   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # /labscript_devices/Camera.py                                      #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of labscript_devices, in the labscript suite    #
   cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
   cbilling: # Simplified BSD License. See the license.txt file in the root of   #
   cbilling: # the project for the full license.                                 #
   cbilling: #                                                                   #
   cbilling: #####################################################################
   cbilling: 
   cbilling: try:
   cbilling:     from labscript_utils import check_version
   cbilling: except ImportError:
   cbilling:     raise ImportError('Require labscript_utils > 2.1.0')
   cbilling:     
   cbilling: check_version('labscript', '2.0.1', '3')
   cbilling: 
   cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker
   spielman: from labscript import TriggerableDevice, LabscriptError, set_passed_properties
   cbilling: import numpy as np
   pstarkey: 
   cbilling: @labscript_device
   cbilling: class Camera(TriggerableDevice):
   spielman:     description = 'Generic Camera'        
   cbilling:     
   cbilling:     # To be set as instantiation arguments:
   cbilling:     trigger_edge_type = None
   cbilling:     minimum_recovery_time = None
   cbilling:     
   spielman:     @set_passed_properties(
   spielman:         property_names = {
   cbilling:             "connection_table_properties": ["BIAS_port"],
    dsbark7:             "device_properties": ["serial_number", "SDK", "effective_pixel_size", "exposure_time", "orientation", "trigger_edge_type", "minimum_recovery_time"]}
   spielman:         )
   spielman:     def __init__(self, name, parent_device, connection,
   spielman:                  BIAS_port = 1027, serial_number = 0x0, SDK='', effective_pixel_size=0.0,
    dsbark7:                  exposure_time=float('nan'), orientation='side', trigger_edge_type='rising', minimum_recovery_time=0,
   spielman:                  **kwargs):
   cbilling:                     
   spielman:         # not a class attribute, so we don't have to have a subclass for each model of camera:
   cbilling:         self.trigger_edge_type = trigger_edge_type
   cbilling:         self.minimum_recovery_time = minimum_recovery_time
   pstarkey:         self.exposure_time = exposure_time
   cbilling:         self.orientation = orientation
   cbilling:         self.BLACS_connection = BIAS_port
   cbilling:         if isinstance(serial_number,str):
   cbilling:             serial_number = int(serial_number,16)
   cbilling:         self.sn = np.uint64(serial_number)
   cbilling:         self.sdk = str(SDK)
   cbilling:         self.effective_pixel_size = effective_pixel_size
   cbilling:         self.exposures = []
   cbilling:         
   pstarkey:         # DEPRECATED: backward compatibility:
   pstarkey:         if 'exposuretime' in kwargs:
   pstarkey:             # We will call self.set_property later to overwrite the non-underscored kwarg's default value.
   pstarkey:             self.exposure_time = kwargs.pop('exposuretime')
   pstarkey:             import sys
   pstarkey:             sys.stderr.write('WARNING: Camera\'s keyword argument \'exposuretime\' deprecated. Use \'exposure_time\' instead.\n')
   pstarkey:         
   cbilling:         TriggerableDevice.__init__(self, name, parent_device, connection, **kwargs)
   cbilling: 
   cbilling:         
   pstarkey:     def expose(self, name, t , frametype, exposure_time=None):
   pstarkey:         if exposure_time is None:
   pstarkey:             duration = self.exposure_time
   cbilling:         else:
   pstarkey:             duration = exposure_time
   cbilling:         if duration is None:
   pstarkey:             raise LabscriptError('Camera %s has not had an exposure_time set as an instantiation argument, '%self.name +
   cbilling:                                  'and one was not specified for this exposure')
   pstarkey:         if not duration > 0:
   pstarkey:             raise LabscriptError("exposure_time must be > 0, not %s"%str(duration))
   cbilling:         # Only ask for a trigger if one has not already been requested by 
   cbilling:         # another camera attached to the same trigger:
   cbilling:         already_requested = False
   cbilling:         for camera in self.trigger_device.child_devices:
   cbilling:             if camera is not self:
   cbilling:                 for _, other_t, _, other_duration in camera.exposures:
   cbilling:                     if t == other_t and duration == other_duration:
   cbilling:                         already_requested = True
   cbilling:         if not already_requested:
   cbilling:             self.trigger_device.trigger(t, duration)
   cbilling:         # Check for exposures too close together (check for overlapping 
   cbilling:         # triggers already performed in self.trigger_device.trigger()):
   cbilling:         start = t
   cbilling:         end = t + duration
   cbilling:         for exposure in self.exposures:
   cbilling:             _, other_t, _, other_duration = exposure
   cbilling:             other_start = other_t
   cbilling:             other_end = other_t + other_duration
   cbilling:             if abs(other_start - end) < self.minimum_recovery_time or abs(other_end - start) < self.minimum_recovery_time:
   cbilling:                 raise LabscriptError('%s %s has two exposures closer together than the minimum recovery time: ' %(self.description, self.name) + \
   cbilling:                                      'one at t = %fs for %fs, and another at t = %fs for %fs. '%(t,duration,start,duration) + \
   cbilling:                                      'The minimum recovery time is %fs.'%self.minimum_recovery_time)
   cbilling:         self.exposures.append((name, t, frametype, duration))
   cbilling:         return duration
   cbilling:     
   cbilling:     def do_checks(self):
   cbilling:         # Check that all Cameras sharing a trigger device have exposures when we have exposures:
   cbilling:         for camera in self.trigger_device.child_devices:
   cbilling:             if camera is not self:
   cbilling:                 for exposure in self.exposures:
   cbilling:                     if exposure not in camera.exposures:
   cbilling:                         _, start, _, duration = exposure
   cbilling:                         raise LabscriptError('Cameras %s and %s share a trigger. ' % (self.name, camera.name) + 
   cbilling:                                              '%s has an exposure at %fs for %fs, ' % (self.name, start, duration) +
   cbilling:                                              'but there is no matching exposure for %s. ' % camera.name +
   cbilling:                                              'Cameras sharing a trigger must have identical exposure times and durations.')
   cbilling:                         
   cbilling:     def generate_code(self, hdf5_file):
   cbilling:         self.do_checks()
   pstarkey:         table_dtypes = [('name','a256'), ('time',float), ('frametype','a256'), ('exposure_time',float)]
   cbilling:         data = np.array(self.exposures,dtype=table_dtypes)
   spielman: 
   spielman:         group = self.init_device_group(hdf5_file)
     rander: 
   cbilling:         if self.exposures:
   cbilling:             group.create_dataset('EXPOSURES', data=data)
   cbilling:             
   pstarkey:         # DEPRECATED backward campatibility for use of exposuretime keyword argument instead of exposure_time:
   pstarkey:         self.set_property('exposure_time', self.exposure_time, location='device_properties', overwrite=True)
   pstarkey:             
    dsbark7:             
   cbilling: 
   cbilling: import os
   shjohnst: 
janwerkmann: from qtutils.qt.QtCore import *
janwerkmann: from qtutils.qt.QtGui import *
   shjohnst: 
   cbilling: from blacs.tab_base_classes import Worker, define_state
   cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
   cbilling: 
   cbilling: from blacs.device_base_class import DeviceTab
   cbilling: 
   cbilling: from qtutils import UiLoader
   shjohnst: import qtutils.icons
   cbilling: 
   cbilling: @BLACS_tab
   cbilling: class CameraTab(DeviceTab):
   cbilling:     def initialise_GUI(self):
   cbilling:         layout = self.get_tab_layout()
   cbilling:         ui_filepath = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'camera.ui')
   cbilling:         self.ui = UiLoader().load(ui_filepath)
   cbilling:         layout.addWidget(self.ui)
   cbilling:         
   cbilling:         port = int(self.settings['connection_table'].find_by_name(self.settings["device_name"]).BLACS_connection)
   cbilling:         self.ui.port_label.setText(str(port)) 
   cbilling:         
   shjohnst:         self.ui.check_connectivity_pushButton.setIcon(QIcon(':/qtutils/fugue/arrow-circle'))
   cbilling:         
   cbilling:         self.ui.host_lineEdit.returnPressed.connect(self.update_settings_and_check_connectivity)
   cbilling:         self.ui.use_zmq_checkBox.toggled.connect(self.update_settings_and_check_connectivity)
   cbilling:         self.ui.check_connectivity_pushButton.clicked.connect(self.update_settings_and_check_connectivity)
   cbilling:         
   cbilling:     def get_save_data(self):
   cbilling:         return {'host': str(self.ui.host_lineEdit.text()), 'use_zmq': self.ui.use_zmq_checkBox.isChecked()}
   cbilling:     
   cbilling:     def restore_save_data(self, save_data):
   cbilling:         print 'restore save data running'
   cbilling:         if save_data:
   cbilling:             host = save_data['host']
   cbilling:             self.ui.host_lineEdit.setText(host)
   cbilling:             if 'use_zmq' in save_data:
   cbilling:                 use_zmq = save_data['use_zmq']
   cbilling:                 self.ui.use_zmq_checkBox.setChecked(use_zmq)
   cbilling:         else:
   cbilling:             self.logger.warning('No previous front panel state to restore')
   cbilling:         
   cbilling:         # call update_settings if primary_worker is set
   cbilling:         # this will be true if you load a front panel from the file menu after the tab has started
   cbilling:         if self.primary_worker:
   cbilling:             self.update_settings_and_check_connectivity()
   cbilling:             
   cbilling:     def initialise_workers(self):
   cbilling:         worker_initialisation_kwargs = {'port': self.ui.port_label.text()}
   cbilling:         self.create_worker("main_worker", CameraWorker, worker_initialisation_kwargs)
   cbilling:         self.primary_worker = "main_worker"
   cbilling:         self.update_settings_and_check_connectivity()
   cbilling:        
   cbilling:     @define_state(MODE_MANUAL, queue_state_indefinitely=True, delete_stale_states=True)
   cbilling:     def update_settings_and_check_connectivity(self, *args):
   shjohnst:         icon = QIcon(':/qtutils/fugue/hourglass')
   shjohnst:         pixmap = icon.pixmap(QSize(16, 16))
   shjohnst:         status_text = 'Checking...'
   shjohnst:         self.ui.status_icon.setPixmap(pixmap)
   shjohnst:         self.ui.server_status.setText(status_text)
   cbilling:         kwargs = self.get_save_data()
   cbilling:         responding = yield(self.queue_work(self.primary_worker, 'update_settings_and_check_connectivity', **kwargs))
   cbilling:         self.update_responding_indicator(responding)
   cbilling:         
   cbilling:     def update_responding_indicator(self, responding):
   cbilling:         if responding:
   shjohnst:             icon = QIcon(':/qtutils/fugue/tick')
   shjohnst:             pixmap = icon.pixmap(QSize(16, 16))
   shjohnst:             status_text = 'Server is responding'
   cbilling:         else:
   shjohnst:             icon = QIcon(':/qtutils/fugue/exclamation')
   shjohnst:             pixmap = icon.pixmap(QSize(16, 16))
   shjohnst:             status_text = 'Server not responding'
   shjohnst:         self.ui.status_icon.setPixmap(pixmap)
   shjohnst:         self.ui.server_status.setText(status_text)
   cbilling: 
   cbilling: @BLACS_worker            
   cbilling: class CameraWorker(Worker):
   cbilling:     def init(self):#, port, host, use_zmq):
   cbilling: #        self.port = port
   cbilling: #        self.host = host
   cbilling: #        self.use_zmq = use_zmq
   cbilling:         global socket; import socket
   cbilling:         global zmq; import zmq
   cbilling:         global zprocess; import zprocess
   cbilling:         global shared_drive; import labscript_utils.shared_drive as shared_drive
   cbilling:         
   cbilling:         self.host = ''
   cbilling:         self.use_zmq = False
   cbilling:         
   cbilling:     def update_settings_and_check_connectivity(self, host, use_zmq):
   cbilling:         self.host = host
   cbilling:         self.use_zmq = use_zmq
   cbilling:         if not self.host:
   cbilling:             return False
   cbilling:         if not self.use_zmq:
   cbilling:             return self.initialise_sockets(self.host, self.port)
   cbilling:         else:
   cbilling:             response = zprocess.zmq_get_raw(self.port, self.host, data='hello')
   cbilling:             if response == 'hello':
   cbilling:                 return True
   cbilling:             else:
   cbilling:                 raise Exception('invalid response from server: ' + str(response))
   cbilling:                 
   cbilling:     def initialise_sockets(self, host, port):
   cbilling:         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   cbilling:         assert port, 'No port number supplied.'
   cbilling:         assert host, 'No hostname supplied.'
   cbilling:         assert str(int(port)) == port, 'Port must be an integer.'
   cbilling:         s.settimeout(10)
   cbilling:         s.connect((host, int(port)))
   cbilling:         s.send('hello\r\n')
   cbilling:         response = s.recv(1024)
   cbilling:         s.close()
   cbilling:         if 'hello' in response:
   cbilling:             return True
   cbilling:         else:
   cbilling:             raise Exception('invalid response from server: ' + response)
   cbilling:     
   cbilling:     def transition_to_buffered(self, device_name, h5file, initial_values, fresh):
   cbilling:         h5file = shared_drive.path_to_agnostic(h5file)
   cbilling:         if not self.use_zmq:
   cbilling:             return self.transition_to_buffered_sockets(h5file,self.host, self.port)
    dsbark7:         response = zprocess.zmq_get_raw(self.port, self.host, data=h5file.encode('utf-8'))
   cbilling:         if response != 'ok':
   cbilling:             raise Exception('invalid response from server: ' + str(response))
   cbilling:         response = zprocess.zmq_get_raw(self.port, self.host, timeout = 10)
   cbilling:         if response != 'done':
   cbilling:             raise Exception('invalid response from server: ' + str(response))
   cbilling:         return {} # indicates final values of buffered run, we have none
   cbilling:         
   cbilling:     def transition_to_buffered_sockets(self, h5file, host, port):
   cbilling:         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   cbilling:         s.settimeout(120)
   cbilling:         s.connect((host, int(port)))
   cbilling:         s.send('%s\r\n'%h5file)
   cbilling:         response = s.recv(1024)
   cbilling:         if not 'ok' in response:
   cbilling:             s.close()
   cbilling:             raise Exception(response)
   cbilling:         response = s.recv(1024)
   cbilling:         if not 'done' in response:
   cbilling:             s.close()
   cbilling:             raise Exception(response)
   cbilling:         return {} # indicates final values of buffered run, we have none
   cbilling:         
   cbilling:     def transition_to_manual(self):
   cbilling:         if not self.use_zmq:
   cbilling:             return self.transition_to_manual_sockets(self.host, self.port)
   cbilling:         response = zprocess.zmq_get_raw(self.port, self.host, 'done')
   cbilling:         if response != 'ok':
   cbilling:             raise Exception('invalid response from server: ' + str(response))
   cbilling:         response = zprocess.zmq_get_raw(self.port, self.host, timeout = 10)
   cbilling:         if response != 'done':
   cbilling:             raise Exception('invalid response from server: ' + str(response))
   cbilling:         return True # indicates success
   cbilling:         
   cbilling:     def transition_to_manual_sockets(self, host, port):
   cbilling:         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   cbilling:         s.settimeout(120)
   cbilling:         s.connect((host, int(port)))
   cbilling:         s.send('done\r\n')
   cbilling:         response = s.recv(1024)
   cbilling:         if response != 'ok\r\n':
   cbilling:             s.close()
   cbilling:             raise Exception(response)
   cbilling:         response = s.recv(1024)
   cbilling:         if not 'done' in response:
   cbilling:             s.close()
   cbilling:             raise Exception(response)
   cbilling:         return True # indicates success
   cbilling:         
   cbilling:     def abort_buffered(self):
   cbilling:         return self.abort()
   cbilling:         
   cbilling:     def abort_transition_to_buffered(self):
   cbilling:         return self.abort()
   cbilling:     
   cbilling:     def abort(self):
   cbilling:         if not self.use_zmq:
   cbilling:             return self.abort_sockets(self.host, self.port)
   cbilling:         response = zprocess.zmq_get_raw(self.port, self.host, 'abort')
   cbilling:         if response != 'done':
   cbilling:             raise Exception('invalid response from server: ' + str(response))
   cbilling:         return True # indicates success 
   cbilling:         
   cbilling:     def abort_sockets(self, host, port):
   cbilling:         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   cbilling:         s.settimeout(120)
   cbilling:         s.connect((host, int(port)))
   cbilling:         s.send('abort\r\n')
   cbilling:         response = s.recv(1024)
   cbilling:         if not 'done' in response:
   cbilling:             s.close()
   cbilling:             raise Exception(response)
   cbilling:         return True # indicates success 
   cbilling:     
   cbilling:     def program_manual(self, values):
   cbilling:         return {}
   cbilling:     
   cbilling:     def shutdown(self):
   cbilling:         return
   cbilling:         
           Chris: #####################################################################
           Chris: #                                                                   #
chrisjbillington: # /labscript_devices/DummyPseudoclock.py                            #
           Chris: #                                                                   #
           Chris: # Copyright 2017, Joint Quantum Institute                           #
           Chris: #                                                                   #
           Chris: # This file is part of labscript_devices, in the labscript suite    #
           Chris: # (see http://labscriptsuite.org), and is licensed under the        #
           Chris: # Simplified BSD License. See the license.txt file in the root of   #
           Chris: # the project for the full license.                                 #
           Chris: #                                                                   #
           Chris: #####################################################################
           Chris: 
           Chris: # This file represents a dummy labscript device for purposes of testing BLACS
           Chris: # and labscript. The device is a PseudoclockDevice, and can be the sole device
           Chris: # in a connection table or experiment.
           Chris: 
           Chris: 
           Chris: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker
chrisjbillington: from labscript import PseudoclockDevice, Pseudoclock, ClockLine
           Chris: 
           Chris: @labscript_device
chrisjbillington: class DummyPseudoclock(PseudoclockDevice):
           Chris: 
chrisjbillington:     description = 'Dummy pseudoclock'
           Chris:     clock_limit = 1e6
chrisjbillington:     clock_resolution = 1e-6
           Chris: 
chrisjbillington:     def __init__(self, name='dummy_pseudoclock', BLACS_connection='dummy_connection', **kwargs):
           Chris:         self.BLACS_connection = BLACS_connection
           Chris:         PseudoclockDevice.__init__(self, name, None, None, **kwargs)
chrisjbillington:         self.pseudoclock = Pseudoclock(self.name + '_pseudoclock', self, 'pseudoclock')
chrisjbillington:         self.clockline = ClockLine(name='clockline', pseudoclock=self.pseudoclock, connection='dummy')
           Chris: 
           Chris:     def generate_code(self, hdf5_file):
           Chris:         group = self.init_device_group(hdf5_file)
           Chris: 
           Chris: 
           Chris: from blacs.device_base_class import DeviceTab, define_state, MODE_BUFFERED
           Chris: from blacs.tab_base_classes import Worker
           Chris: 
           Chris: 
           Chris: @BLACS_tab
chrisjbillington: class DummyPseudoclockTab(DeviceTab):
           Chris:     def initialise_workers(self):
           Chris:         worker_initialisation_kwargs = {}
chrisjbillington:         self.create_worker("main_worker", DummyPseudoclockWorker, worker_initialisation_kwargs)
           Chris:         self.primary_worker = "main_worker"
           Chris: 
           Chris:     @define_state(MODE_BUFFERED, True)  
           Chris:     def start_run(self, notify_queue):
           Chris:         notify_queue.put('done')
           Chris: 
           Chris: @BLACS_worker
chrisjbillington: class DummyPseudoclockWorker(Worker):
           Chris:     def program_manual(self, values):
           Chris:         return {}
           Chris: 
           Chris:     def transition_to_buffered(self, device_name, h5file, initial_values, fresh):
           Chris:         return {}
           Chris:     
           Chris:     def transition_to_manual(self):
           Chris:         return True
           Chris: 
           Chris:     def shutdown(self):
chrisjbillington:         return
cbilling: import numpy as np
cbilling: from labscript_devices import runviewer_parser
cbilling: from labscript import IntermediateDevice, AnalogOut, DigitalOut, AnalogIn, bitfield, config, LabscriptError, set_passed_properties
pstarkey: import labscript_utils.h5_lock, h5py
  rander: import labscript_utils.properties
cbilling: 
cbilling: class NIBoard(IntermediateDevice):
cbilling:     allowed_children = [AnalogOut, DigitalOut, AnalogIn]
cbilling:     n_analogs = 4
cbilling:     n_digitals = 32
cbilling:     digital_dtype = np.uint32
cbilling:     clock_limit = 500e3 # underestimate I think.
cbilling:     description = 'generic_NI_Board'
cbilling:     
spielman:     @set_passed_properties(property_names = {
spielman:         "device_properties":["acquisition_rate", "MAX_name"]}
spielman:         )
pstarkey:     def __init__(self, name, parent_device, clock_terminal, MAX_name=None, acquisition_rate=0):
pstarkey:         IntermediateDevice.__init__(self, name, parent_device)
cbilling:         self.acquisition_rate = acquisition_rate
cbilling:         self.clock_terminal = clock_terminal
cbilling:         self.MAX_name = name if MAX_name is None else MAX_name
cbilling:         self.BLACS_connection = self.MAX_name
cbilling:         
cbilling:     def add_device(self,output):
cbilling:         # TODO: check there are no duplicates, check that connection
cbilling:         # string is formatted correctly.
cbilling:         IntermediateDevice.add_device(self,output)
cbilling:         
cbilling:     def convert_bools_to_bytes(self,digitals):
cbilling:         """converts digital outputs to an array of bitfields stored
cbilling:         as self.digital_dtype"""
cbilling:         outputarray = [0]*self.n_digitals
cbilling:         for output in digitals:
cbilling:             port, line = output.connection.replace('port','').replace('line','').split('/')
cbilling:             port, line  = int(port),int(line)
cbilling:             if port > 0:
cbilling:                 raise LabscriptError('Ports > 0 on NI Boards not implemented. Please use port 0, or file a feature request at redmine.physics.monash.edu.au/labscript.')
cbilling:             outputarray[line] = output.raw_output
cbilling:         bits = bitfield(outputarray,dtype=self.digital_dtype)
cbilling:         return bits
cbilling:             
cbilling:     def generate_code(self, hdf5_file):
cbilling:         IntermediateDevice.generate_code(self, hdf5_file)
cbilling:         analogs = {}
cbilling:         digitals = {}
cbilling:         inputs = {}
cbilling:         for device in self.child_devices:
cbilling:             if isinstance(device,AnalogOut):
cbilling:                 analogs[device.connection] = device
cbilling:             elif isinstance(device,DigitalOut):
cbilling:                 digitals[device.connection] = device
cbilling:             elif isinstance(device,AnalogIn):
cbilling:                 inputs[device.connection] = device
cbilling:             else:
cbilling:                 raise Exception('Got unexpected device.')
pstarkey:         
pstarkey:         clockline = self.parent_device
pstarkey:         pseudoclock = clockline.parent_device
pstarkey:         times = pseudoclock.times[clockline]
pstarkey:                 
pstarkey:         analog_out_table = np.empty((len(times),len(analogs)), dtype=np.float32)
cbilling:         analog_connections = analogs.keys()
cbilling:         analog_connections.sort()
cbilling:         analog_out_attrs = []
cbilling:         for i, connection in enumerate(analog_connections):
cbilling:             output = analogs[connection]
cbilling:             if any(output.raw_output > 10 )  or any(output.raw_output < -10 ):
cbilling:                 # Bounds checking:
cbilling:                 raise LabscriptError('%s %s '%(output.description, output.name) +
cbilling:                                   'can only have values between -10 and 10 Volts, ' + 
cbilling:                                   'the limit imposed by %s.'%self.name)
cbilling:             analog_out_table[:,i] = output.raw_output
cbilling:             analog_out_attrs.append(self.MAX_name +'/'+connection)
cbilling:         input_connections = inputs.keys()
cbilling:         input_connections.sort()
cbilling:         input_attrs = []
cbilling:         acquisitions = []
cbilling:         for connection in input_connections:
cbilling:             input_attrs.append(self.MAX_name+'/'+connection)
cbilling:             for acq in inputs[connection].acquisitions:
cbilling:                 acquisitions.append((connection,acq['label'],acq['start_time'],acq['end_time'],acq['wait_label'],acq['scale_factor'],acq['units']))
cbilling:         # The 'a256' dtype below limits the string fields to 256
cbilling:         # characters. Can't imagine this would be an issue, but to not
cbilling:         # specify the string length (using dtype=str) causes the strings
cbilling:         # to all come out empty.
cbilling:         acquisitions_table_dtypes = [('connection','a256'), ('label','a256'), ('start',float),
cbilling:                                      ('stop',float), ('wait label','a256'),('scale factor',float), ('units','a256')]
cbilling:         acquisition_table= np.empty(len(acquisitions), dtype=acquisitions_table_dtypes)
cbilling:         for i, acq in enumerate(acquisitions):
cbilling:             acquisition_table[i] = acq
cbilling:         digital_out_table = []
cbilling:         if digitals:
cbilling:             digital_out_table = self.convert_bools_to_bytes(digitals.values())
spielman:         grp = self.init_device_group(hdf5_file)
cbilling:         if all(analog_out_table.shape): # Both dimensions must be nonzero
  rander:             grp.create_dataset('ANALOG_OUTS',compression=config.compression,data=analog_out_table)
cbilling:             self.set_property('analog_out_channels', ', '.join(analog_out_attrs), location='device_properties')
cbilling:         if len(digital_out_table): # Table must be non empty
  rander:             grp.create_dataset('DIGITAL_OUTS',compression=config.compression,data=digital_out_table)
cbilling:             self.set_property('digital_lines', '/'.join((self.MAX_name,'port0','line0:%d'%(self.n_digitals-1))), location='device_properties')
cbilling:         if len(acquisition_table): # Table must be non empty
  rander:             grp.create_dataset('ACQUISITIONS',compression=config.compression,data=acquisition_table)
cbilling:             self.set_property('analog_in_channels', ', '.join(input_attrs), location='device_properties')
  rander:         # TODO: move this to decorator (requires ability to set positional args with @set_passed_properties)
  rander:         self.set_property('clock_terminal', self.clock_terminal, location='connection_table_properties')
  rander: 
  rander: 
cbilling: @runviewer_parser
cbilling: class RunviewerClass(object):
cbilling:     num_digitals = 32
cbilling:     
pstarkey:     def __init__(self, path, device):
cbilling:         self.path = path
pstarkey:         self.name = device.name
pstarkey:         self.device = device
cbilling:         
cbilling:         # We create a lookup table for strings to be used later as dictionary keys.
cbilling:         # This saves having to evaluate '%d'%i many many times, and makes the _add_pulse_program_row_to_traces method
cbilling:         # significantly more efficient
cbilling:         self.port_strings = {} 
cbilling:         for i in range(self.num_digitals):
cbilling:             self.port_strings[i] = 'port0/line%d'%i
cbilling:             
pstarkey:     def get_traces(self, add_trace, clock=None):
cbilling:         if clock is None:
cbilling:             # we're the master pseudoclock, software triggered. So we don't have to worry about trigger delays, etc
cbilling:             raise Exception('No clock passed to %s. The NI PCIe 6363 must be clocked by another device.'%self.name)
cbilling:             
cbilling:         # get the pulse program
cbilling:         with h5py.File(self.path, 'r') as f:
cbilling:             if 'ANALOG_OUTS' in f['devices/%s'%self.name]:
cbilling:                 analogs = f['devices/%s/ANALOG_OUTS'%self.name][:]
  rander:                 analog_out_channels = labscript_utils.properties.get(f, self.name, 'device_properties')['analog_out_channels'].split(', ')
cbilling:             else:
cbilling:                 analogs = None
cbilling:                 analog_out_channels = []
cbilling:                 
cbilling:             if 'DIGITAL_OUTS' in f['devices/%s'%self.name]:
cbilling:                 digitals = f['devices/%s/DIGITAL_OUTS'%self.name][:]
cbilling:             else:
cbilling:                 digitals = []
cbilling:             
cbilling:         times, clock_value = clock[0], clock[1]
cbilling:         
cbilling:         clock_indices = np.where((clock_value[1:]-clock_value[:-1])==1)[0]+1
cbilling:         # If initial clock value is 1, then this counts as a rising edge (clock should be 0 before experiment)
cbilling:         # but this is not picked up by the above code. So we insert it!
cbilling:         if clock_value[0] == 1:
cbilling:             clock_indices = np.insert(clock_indices, 0, 0)
cbilling:         clock_ticks = times[clock_indices]
cbilling:         
cbilling:         traces = {}
cbilling:         for i in range(self.num_digitals):
cbilling:             traces['port0/line%d'%i] = []
cbilling:         for row in digitals:
cbilling:             bit_string = np.binary_repr(row,self.num_digitals)[::-1]
cbilling:             for i in range(self.num_digitals):
cbilling:                 traces[self.port_strings[i]].append(int(bit_string[i]))
cbilling:                 
cbilling:         for i in range(self.num_digitals):
cbilling:             traces[self.port_strings[i]] = (clock_ticks, np.array(traces[self.port_strings[i]]))
cbilling:         
cbilling:         for i, channel in enumerate(analog_out_channels):
cbilling:             traces[channel.split('/')[-1]] = (clock_ticks, analogs[:,i])
pstarkey:         
pstarkey:         triggers = {}
pstarkey:         for channel_name, channel in self.device.child_list.items():
pstarkey:             if channel.parent_port in traces:
pstarkey:                 if channel.device_class == 'Trigger':
pstarkey:                     triggers[channel_name] = traces[channel.parent_port]
pstarkey:                 add_trace(channel_name, traces[channel.parent_port], self.name, channel.parent_port)
pstarkey:         
pstarkey:         return triggers
cbilling:     
pstarkey: #####################################################################
pstarkey: #                                                                   #
pstarkey: # /NI_PCI_6733.py                                                   #
pstarkey: #                                                                   #
pstarkey: # Copyright 2013, Monash University                                 #
pstarkey: #                                                                   #
pstarkey: # This file is part of the module labscript_devices, in the         #
pstarkey: # labscript suite (see http://labscriptsuite.org), and is           #
pstarkey: # licensed under the Simplified BSD License. See the license.txt    #
pstarkey: # file in the root of the project for the full license.             #
pstarkey: #                                                                   #
pstarkey: #####################################################################
pstarkey: 
pstarkey: from labscript import LabscriptError, AnalogOut
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: import labscript_devices.NIBoard as parent
pstarkey: 
pstarkey: import numpy as np
pstarkey: import labscript_utils.h5_lock, h5py
  rander: import labscript_utils.properties
pstarkey: 
cbilling: @labscript_device
cbilling: class NI_PCI_6733(parent.NIBoard):
cbilling:     description = 'NI-PCI-6733'
cbilling:     n_analogs = 8
cbilling:     n_digitals = 8
cbilling:     n_analog_ins = 0
cbilling:     clock_limit = 700e3
pstarkey:     digital_dtype = np.uint8
cbilling:     
cbilling:     def generate_code(self, hdf5_file):
cbilling:         parent.NIBoard.generate_code(self, hdf5_file)
pstarkey:         
pstarkey:         # count the number of analog outputs in use
pstarkey:         analog_count = 0
pstarkey:         for child in self.child_devices:
pstarkey:             if isinstance(child,AnalogOut):
pstarkey:                 analog_count += 1
pstarkey:         
pstarkey:         # Check that there is a multiple of two outputs
pstarkey:         if analog_count % 2:
cbilling:             raise LabscriptError('%s %s must have an even numer of analog outputs '%(self.description, self.name) +
cbilling:                              'in order to guarantee an even total number of samples, which is a limitation of the DAQmx library. ' +
pstarkey:                              'Please add a dummy analog output device or remove an output you\'re not using, so that there are an even number of analog outputs. Sorry, this is annoying I know :).')
cbilling:       
cbilling:              
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: from blacs.device_base_class import DeviceTab
cbilling: 
cbilling: 
cbilling: @BLACS_tab
cbilling: class NI_PCI_6733Tab(DeviceTab):
cbilling:     def initialise_GUI(self):
cbilling:         # Capabilities
cbilling:         self.num_AO = 8
cbilling:         self.num_DO = 8
cbilling:         self.base_units = 'V'
cbilling:         self.base_min = -10.0
cbilling:         self.base_max = 10.0
cbilling:         self.base_step = 0.1
cbilling:         self.base_decimals = 3
cbilling:         
cbilling:         # Create the AO output objects
cbilling:         ao_prop = {}
cbilling:         for i in range(self.num_AO):
cbilling:             ao_prop['ao%d'%i] = {'base_unit':self.base_units,
cbilling:                                  'min':self.base_min,
cbilling:                                  'max':self.base_max,
cbilling:                                  'step':self.base_step,
cbilling:                                  'decimals':self.base_decimals
cbilling:                                 }
cbilling:         
cbilling:         do_prop = {}
cbilling:         for i in range(self.num_DO):
cbilling:             do_prop['port0/line%d'%i] = {}
cbilling:             
pstarkey:             
cbilling:         # Create the output objects    
cbilling:         self.create_analog_outputs(ao_prop)        
cbilling:         # Create widgets for analog outputs only
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         
cbilling:         # now create the digital output objects
pstarkey:         self.create_digital_outputs(do_prop)        
pstarkey:         # manually create the digital output widgets so they are grouped separately
cbilling:         do_widgets = self.create_digital_widgets(do_prop)
cbilling:         
cbilling:         def do_sort(channel):
cbilling:             flag = channel.replace('port0/line','')
cbilling:             flag = int(flag)
cbilling:             return '%02d'%(flag)
cbilling:             
pstarkey:             
cbilling:         # and auto place the widgets in the UI
pstarkey:         self.auto_place_widgets(("Analog Outputs",ao_widgets),("Digital Outputs",do_widgets,do_sort))
cbilling:         
cbilling:         # Store the Measurement and Automation Explorer (MAX) name
cbilling:         self.MAX_name = str(self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection)
cbilling:         
cbilling:         # Create and set the primary worker
pstarkey:         self.create_worker("main_worker",NiPCI6733Worker,{'MAX_name':self.MAX_name, 'limits': [self.base_min,self.base_max], 'num_AO':self.num_AO, 'num_DO': self.num_DO})
cbilling:         self.primary_worker = "main_worker"
cbilling: 
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(False)
cbilling:         self.supports_smart_programming(False) 
cbilling:     
cbilling:     
cbilling: @BLACS_worker
cbilling: class NiPCI6733Worker(Worker):
cbilling:     def init(self):
cbilling:         exec 'from PyDAQmx import Task' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global pylab; import pylab
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global numpy; import numpy
cbilling:            
cbilling:         # Create task
cbilling:         self.ao_task = Task()
cbilling:         self.ao_read = int32()
cbilling:         self.ao_data = numpy.zeros((self.num_AO,), dtype=numpy.float64)
cbilling:         
cbilling:         # Create DO task:
cbilling:         self.do_task = Task()
cbilling:         self.do_read = int32()
pstarkey:         self.do_data = numpy.zeros(self.num_DO, dtype=numpy.uint8)
cbilling:         
cbilling:         self.setup_static_channels()
cbilling:         
cbilling:         #DAQmx Start Code        
cbilling:         self.ao_task.StartTask()  
cbilling:         self.do_task.StartTask()  
cbilling:         
cbilling:     def setup_static_channels(self):
cbilling:         #setup AO channels
cbilling:         for i in range(self.num_AO): 
cbilling:             self.ao_task.CreateAOVoltageChan(self.MAX_name+"/ao%d"%i,"",self.limits[0],self.limits[1],DAQmx_Val_Volts,None)
cbilling:         #setup DO ports
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line0:7","",DAQmx_Val_ChanForAllLines)
cbilling:         
cbilling:     def shutdown(self):        
cbilling:         self.ao_task.StopTask()
cbilling:         self.ao_task.ClearTask()
cbilling:         self.do_task.StopTask()
cbilling:         self.do_task.ClearTask()
cbilling:         
cbilling:     def program_manual(self,front_panel_values):
cbilling:         for i in range(self.num_AO):
cbilling:             self.ao_data[i] = front_panel_values['ao%d'%i]
cbilling:         self.ao_task.WriteAnalogF64(1,True,1,DAQmx_Val_GroupByChannel,self.ao_data,byref(self.ao_read),None)
cbilling:         
cbilling:         for i in range(self.num_DO):
cbilling:             self.do_data[i] = front_panel_values['port0/line%d'%i]
cbilling:         self.do_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,self.do_data,byref(self.do_read),None)
cbilling:         # TODO: Return coerced/quantised values
cbilling:         return {}
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # Store the initial values in case we have to abort and restore them:
cbilling:         # TODO: Coerce/quantise these correctly before returning them
cbilling:         self.initial_values = initial_values
cbilling:             
cbilling:         with h5py.File(h5file,'r') as hdf5_file:
cbilling:             group = hdf5_file['devices/'][device_name]
pstarkey:             device_properties = labscript_utils.properties.get(hdf5_file, device_name, 'device_properties')
pstarkey:             connection_table_properties = labscript_utils.properties.get(hdf5_file, device_name, 'connection_table_properties')
pstarkey:             clock_terminal = connection_table_properties['clock_terminal']           
cbilling:             h5_data = group.get('ANALOG_OUTS')
cbilling:             if h5_data:
cbilling:                 self.buffered_using_analog = True
  rander:                 ao_channels = device_properties['analog_out_channels']
cbilling:                 # We use all but the last sample (which is identical to the
cbilling:                 # second last sample) in order to ensure there is one more
cbilling:                 # clock tick than there are samples. The 6733 requires this
cbilling:                 # to determine that the task has completed.
cbilling:                 ao_data = pylab.array(h5_data,dtype=float64)[:-1,:]
cbilling:             else:
cbilling:                 self.buffered_using_analog = False   
cbilling:                 
cbilling:             h5_data = group.get('DIGITAL_OUTS')
cbilling:             if h5_data:
cbilling:                 self.buffered_using_digital = True
  rander:                 do_channels = device_properties['digital_lines']
cbilling:                 do_bitfield = numpy.array(h5_data,dtype=numpy.uint32)
cbilling:             else:
cbilling:                 self.buffered_using_digital = False
cbilling:                 
cbilling:             final_values = {}
cbilling:             # We must do digital first, so as to make sure the manual mode task is stopped, or reprogrammed, by the time we setup the AO task
cbilling:             # this is because the clock_terminal PFI must be freed!
cbilling:             if self.buffered_using_digital:
pstarkey:                 # Expand each bitfield int into self.num_DO
pstarkey:                 # (8) individual ones and zeros:
pstarkey:                 do_write_data = numpy.zeros((do_bitfield.shape[0],self.num_DO),dtype=numpy.uint8)
pstarkey:                 for i in range(self.num_DO):
cbilling:                     do_write_data[:,i] = (do_bitfield & (1 << i)) >> i
cbilling:                     
cbilling:                 self.do_task.StopTask()
cbilling:                 self.do_task.ClearTask()
cbilling:                 self.do_task = Task()
cbilling:                 self.do_read = int32()
cbilling:         
cbilling:                 self.do_task.CreateDOChan(do_channels,"",DAQmx_Val_ChanPerLine)
cbilling:                 self.do_task.CfgSampClkTiming(clock_terminal,1000000,DAQmx_Val_Rising,DAQmx_Val_FiniteSamps,do_bitfield.shape[0])
cbilling:                 self.do_task.WriteDigitalLines(do_bitfield.shape[0],False,10.0,DAQmx_Val_GroupByScanNumber,do_write_data,self.do_read,None)
cbilling:                 self.do_task.StartTask()
cbilling:                 
pstarkey:                 for i in range(self.num_DO):
cbilling:                     final_values['port0/line%d'%i] = do_write_data[-1,i]
cbilling:             else:
cbilling:                 # We still have to stop the task to make the 
cbilling:                 # clock flag available for buffered analog output, or the wait monitor:
cbilling:                 self.do_task.StopTask()
cbilling:                 self.do_task.ClearTask()
cbilling:                 
cbilling:             if self.buffered_using_analog:
cbilling:                 self.ao_task.StopTask()
cbilling:                 self.ao_task.ClearTask()
cbilling:                 self.ao_task = Task()
cbilling:                 ao_read = int32()
cbilling: 
cbilling:                 self.ao_task.CreateAOVoltageChan(ao_channels,"",-10.0,10.0,DAQmx_Val_Volts,None)
cbilling:                 self.ao_task.CfgSampClkTiming(clock_terminal,1000000,DAQmx_Val_Rising,DAQmx_Val_FiniteSamps, ao_data.shape[0])
cbilling:                 
cbilling:                 self.ao_task.WriteAnalogF64(ao_data.shape[0],False,10.0,DAQmx_Val_GroupByScanNumber, ao_data,ao_read,None)
cbilling:                 self.ao_task.StartTask()   
cbilling:                 
cbilling:                 # Final values here are a dictionary of values, keyed by channel:
cbilling:                 channel_list = [channel.split('/')[1] for channel in ao_channels.split(', ')]
cbilling:                 final_values = {channel: value for channel, value in zip(channel_list, ao_data[-1,:])}
pstarkey:                 
cbilling:             else:
cbilling:                 # we should probabaly still stop the task (this makes it easier to setup the task later)
cbilling:                 self.ao_task.StopTask()
cbilling:                 self.ao_task.ClearTask()
pstarkey:         
pstarkey:         return final_values
cbilling:             
cbilling:     def transition_to_manual(self,abort=False):
cbilling:         # if aborting, don't call StopTask since this throws an
cbilling:         # error if the task hasn't actually finished!
cbilling:         if self.buffered_using_analog:
cbilling:             if not abort:
cbilling:                 self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:         if self.buffered_using_digital:
cbilling:             if not abort:
cbilling:                 self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:                 
cbilling:         self.ao_task = Task()
cbilling:         self.do_task = Task()
cbilling:         self.setup_static_channels()
cbilling:         self.ao_task.StartTask()
cbilling:         self.do_task.StartTask()
cbilling:         if abort:
cbilling:             # Reprogram the initial states:
cbilling:             self.program_manual(self.initial_values)
cbilling:             
cbilling:         return True
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)    
cbilling: 
cbilling:              
cbilling: @runviewer_parser
cbilling: class RunviewerClass(parent.RunviewerClass):
pstarkey:     num_digitals = 0
cbilling:     
pstarkey: #####################################################################
pstarkey: #                                                                   #
pstarkey: # /NI_PCIe_6363.py                                                  #
pstarkey: #                                                                   #
pstarkey: # Copyright 2013, Monash University                                 #
pstarkey: #                                                                   #
pstarkey: # This file is part of the module labscript_devices, in the         #
pstarkey: # labscript suite (see http://labscriptsuite.org), and is           #
pstarkey: # licensed under the Simplified BSD License. See the license.txt    #
pstarkey: # file in the root of the project for the full license.             #
pstarkey: #                                                                   #
pstarkey: #####################################################################
pstarkey: 
pstarkey: from labscript import LabscriptError
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: import labscript_devices.NIBoard as parent
pstarkey: 
pstarkey: import numpy as np
pstarkey: import labscript_utils.h5_lock, h5py
  rander: import labscript_utils.properties
  rander: 
pstarkey: 
cbilling: @labscript_device
cbilling: class NI_PCIe_6363(parent.NIBoard):
cbilling:     description = 'NI-PCIe-6363'
cbilling:     n_analogs = 4
cbilling:     n_digitals = 32
cbilling:     n_analog_ins = 32
cbilling:     digital_dtype = np.uint32
cbilling: 
cbilling: 
cbilling: import time
cbilling: 
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: from blacs.device_base_class import DeviceTab
cbilling: 
cbilling: @BLACS_tab
cbilling: class NI_PCIe_6363Tab(DeviceTab):
cbilling:     def initialise_GUI(self):
cbilling:         # Capabilities
cbilling:         num = {'AO':4, 'DO':32, 'PFI':16}
cbilling:         
cbilling:         base_units = {'AO':'V'}
cbilling:         base_min = {'AO':-10.0}
cbilling:         base_max = {'AO':10.0}
cbilling:         base_step = {'AO':0.1}
cbilling:         base_decimals = {'AO':3}
cbilling:         
cbilling:         # Create the AO output objects
cbilling:         ao_prop = {}
cbilling:         for i in range(num['AO']):
cbilling:             ao_prop['ao%d'%i] = {'base_unit':base_units['AO'],
cbilling:                                  'min':base_min['AO'],
cbilling:                                  'max':base_max['AO'],
cbilling:                                  'step':base_step['AO'],
cbilling:                                  'decimals':base_decimals['AO']
cbilling:                                 }
cbilling:         
cbilling:         do_prop = {}
cbilling:         for i in range(num['DO']):
cbilling:             do_prop['port0/line%d'%i] = {}
cbilling:             
cbilling:         pfi_prop = {}
cbilling:         for i in range(num['PFI']):
cbilling:             pfi_prop['PFI %d'%i] = {}
cbilling:         
cbilling:         
cbilling:         # Create the output objects    
cbilling:         self.create_analog_outputs(ao_prop)        
cbilling:         # Create widgets for analog outputs only
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         
cbilling:         # now create the digital output objects
cbilling:         self.create_digital_outputs(do_prop)
cbilling:         self.create_digital_outputs(pfi_prop)
cbilling:         # manually create the digital output widgets so they are grouped separately
cbilling:         do_widgets = self.create_digital_widgets(do_prop)
cbilling:         pfi_widgets = self.create_digital_widgets(pfi_prop)
cbilling:         
cbilling:         def do_sort(channel):
cbilling:             flag = channel.replace('port0/line','')
cbilling:             flag = int(flag)
cbilling:             return '%02d'%(flag)
cbilling:             
cbilling:         def pfi_sort(channel):
cbilling:             flag = channel.replace('PFI ','')
cbilling:             flag = int(flag)
cbilling:             return '%02d'%(flag)
cbilling:         
cbilling:         # and auto place the widgets in the UI
cbilling:         self.auto_place_widgets(("Analog Outputs",ao_widgets),("Digital Outputs",do_widgets,do_sort),("PFI Outputs",pfi_widgets,pfi_sort))
cbilling:         
cbilling:         # Store the Measurement and Automation Explorer (MAX) name
cbilling:         self.MAX_name = str(self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection)
cbilling:         
cbilling:         # Create and set the primary worker
cbilling:         self.create_worker("main_worker",NiPCIe6363Worker,{'MAX_name':self.MAX_name, 'limits': [base_min['AO'],base_max['AO']], 'num':num})
cbilling:         self.primary_worker = "main_worker"
pstarkey:         self.create_worker("wait_monitor_worker",NiPCIe6363WaitMonitorWorker,{'MAX_name':self.MAX_name})
pstarkey:         self.add_secondary_worker("wait_monitor_worker")
cbilling:         self.create_worker("acquisition_worker",NiPCIe6363AcquisitionWorker,{'MAX_name':self.MAX_name})
cbilling:         self.add_secondary_worker("acquisition_worker")
cbilling: 
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(False)
cbilling:         self.supports_smart_programming(False) 
cbilling:     
cbilling: @BLACS_worker
cbilling: class NiPCIe6363Worker(Worker):
cbilling:     def init(self):
pstarkey:         exec 'from PyDAQmx import Task, DAQmxGetSysNIDAQMajorVersion, DAQmxGetSysNIDAQMinorVersion, DAQmxGetSysNIDAQUpdateVersion' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global pylab; import pylab
cbilling:         global numpy; import numpy
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         
pstarkey:         # check version of PyDAQmx
pstarkey:         major = uInt32()
pstarkey:         minor = uInt32()
pstarkey:         patch = uInt32()
pstarkey:         DAQmxGetSysNIDAQMajorVersion(major)
pstarkey:         DAQmxGetSysNIDAQMinorVersion(minor)
pstarkey:         DAQmxGetSysNIDAQUpdateVersion(patch)
pstarkey:         
pstarkey:         if major.value == 14 and minor.value < 2:
pstarkey:             version_exception_message = 'There is a known bug with buffered shots using NI DAQmx v14.0.0. This bug does not exist on v14.2.0. You are currently using v%d.%d.%d. Please ensure you upgrade to v14.2.0 or higher.'%(major.value, minor.value, patch.value)
pstarkey:             raise Exception(version_exception_message)
pstarkey:         
cbilling:         # Create task
cbilling:         self.ao_task = Task()
cbilling:         self.ao_read = int32()
cbilling:         self.ao_data = numpy.zeros((self.num['AO'],), dtype=numpy.float64)
cbilling:         
cbilling:         # Create DO task:
cbilling:         self.do_task = Task()
cbilling:         self.do_read = int32()
cbilling:         self.do_data = numpy.zeros(self.num['DO']+self.num['PFI'],dtype=numpy.uint8)
cbilling:         
cbilling:         self.setup_static_channels()            
cbilling:         
cbilling:         #DAQmx Start Code        
cbilling:         self.ao_task.StartTask() 
cbilling:         self.do_task.StartTask()  
cbilling:         
cbilling:     def setup_static_channels(self):
cbilling:         #setup AO channels
cbilling:         for i in range(self.num['AO']): 
cbilling:             self.ao_task.CreateAOVoltageChan(self.MAX_name+"/ao%d"%i,"",self.limits[0],self.limits[1],DAQmx_Val_Volts,None)
cbilling:         
cbilling:         #setup DO ports
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line0:7","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line8:15","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line16:23","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line24:31","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port1/line0:7","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port2/line0:7","",DAQmx_Val_ChanForAllLines)  
cbilling:                 
cbilling:     def shutdown(self):        
cbilling:         self.ao_task.StopTask()
cbilling:         self.ao_task.ClearTask()
cbilling:         self.do_task.StopTask()
cbilling:         self.do_task.ClearTask()
cbilling:         
cbilling:     def program_manual(self,front_panel_values):
cbilling:         for i in range(self.num['AO']):
cbilling:             self.ao_data[i] = front_panel_values['ao%d'%i]
cbilling:         self.ao_task.WriteAnalogF64(1,True,1,DAQmx_Val_GroupByChannel,self.ao_data,byref(self.ao_read),None)
cbilling:         
cbilling:         for i in range(self.num['DO']):
cbilling:             self.do_data[i] = front_panel_values['port0/line%d'%i]
cbilling:             
cbilling:         for i in range(self.num['PFI']):
cbilling:             self.do_data[i+self.num['DO']] = front_panel_values['PFI %d'%i]
cbilling:         self.do_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,self.do_data,byref(self.do_read),None)
cbilling:      
cbilling:         # TODO: return coerced/quantised values
cbilling:         return {}
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # Store the initial values in case we have to abort and restore them:
cbilling:         self.initial_values = initial_values
cbilling:             
cbilling:         with h5py.File(h5file,'r') as hdf5_file:
cbilling:             group = hdf5_file['devices/'][device_name]
pstarkey:             device_properties = labscript_utils.properties.get(hdf5_file, device_name, 'device_properties')
pstarkey:             connection_table_properties = labscript_utils.properties.get(hdf5_file, device_name, 'connection_table_properties')
pstarkey:             clock_terminal = connection_table_properties['clock_terminal']            
cbilling:             h5_data = group.get('ANALOG_OUTS')
cbilling:             if h5_data:
cbilling:                 self.buffered_using_analog = True
  rander:                 ao_channels = device_properties['analog_out_channels']
cbilling:                 # We use all but the last sample (which is identical to the
cbilling:                 # second last sample) in order to ensure there is one more
cbilling:                 # clock tick than there are samples. The 6733 requires this
cbilling:                 # to determine that the task has completed.
cbilling:                 ao_data = pylab.array(h5_data,dtype=float64)[:-1,:]
cbilling:             else:
cbilling:                 self.buffered_using_analog = False
cbilling:                 
cbilling:             h5_data = group.get('DIGITAL_OUTS')
cbilling:             if h5_data:
cbilling:                 self.buffered_using_digital = True
  rander:                 do_channels = device_properties['digital_lines']
cbilling:                 do_bitfield = numpy.array(h5_data,dtype=numpy.uint32)
cbilling:             else:
cbilling:                 self.buffered_using_digital = False
cbilling:                 
cbilling:                 
cbilling:         
cbilling:         final_values = {} 
cbilling:         # We must do digital first, so as to make sure the manual mode task is stopped, or reprogrammed, by the time we setup the AO task
cbilling:         # this is because the clock_terminal PFI must be freed!
cbilling:         if self.buffered_using_digital:
cbilling:             # Expand each bitfield int into self.num['DO']
cbilling:             # (32) individual ones and zeros:
cbilling:             do_write_data = numpy.zeros((do_bitfield.shape[0],self.num['DO']),dtype=numpy.uint8)
cbilling:             for i in range(self.num['DO']):
cbilling:                 do_write_data[:,i] = (do_bitfield & (1 << i)) >> i
cbilling:                 
cbilling:             self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:             self.do_task = Task()
cbilling:             self.do_read = int32()
cbilling:     
cbilling:             self.do_task.CreateDOChan(do_channels,"",DAQmx_Val_ChanPerLine)
cbilling:             self.do_task.CfgSampClkTiming(clock_terminal,1000000,DAQmx_Val_Rising,DAQmx_Val_FiniteSamps,do_bitfield.shape[0])
cbilling:             self.do_task.WriteDigitalLines(do_bitfield.shape[0],False,10.0,DAQmx_Val_GroupByScanNumber,do_write_data,self.do_read,None)
cbilling:             self.do_task.StartTask()
cbilling:             
cbilling:             for i in range(self.num['DO']):
cbilling:                 final_values['port0/line%d'%i] = do_write_data[-1,i]
cbilling:         else:
cbilling:             # We still have to stop the task to make the 
cbilling:             # clock flag available for buffered analog output, or the wait monitor:
cbilling:             self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:             
cbilling:         if self.buffered_using_analog:
cbilling:             self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:             self.ao_task = Task()
cbilling:             ao_read = int32()
cbilling: 
cbilling:             self.ao_task.CreateAOVoltageChan(ao_channels,"",-10.0,10.0,DAQmx_Val_Volts,None)
cbilling:             self.ao_task.CfgSampClkTiming(clock_terminal,1000000,DAQmx_Val_Rising,DAQmx_Val_FiniteSamps, ao_data.shape[0])
cbilling:             
cbilling:             self.ao_task.WriteAnalogF64(ao_data.shape[0],False,10.0,DAQmx_Val_GroupByScanNumber, ao_data,ao_read,None)
cbilling:             self.ao_task.StartTask()   
cbilling:             
cbilling:             # Final values here are a dictionary of values, keyed by channel:
cbilling:             channel_list = [channel.split('/')[1] for channel in ao_channels.split(', ')]
cbilling:             for channel, value in zip(channel_list, ao_data[-1,:]):
cbilling:                 final_values[channel] = value
cbilling:         else:
cbilling:             # we should probabaly still stop the task (this makes it easier to setup the task later)
cbilling:             self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:                 
cbilling:        
cbilling:             
cbilling:         return final_values
cbilling:         
cbilling:     def transition_to_manual(self,abort=False):
cbilling:         # if aborting, don't call StopTask since this throws an
cbilling:         # error if the task hasn't actually finished!
cbilling:         if self.buffered_using_analog:
cbilling:             if not abort:
cbilling:                 self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:         if self.buffered_using_digital:
cbilling:             if not abort:
cbilling:                 self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:                 
cbilling:         self.ao_task = Task()
cbilling:         self.do_task = Task()
cbilling:         self.setup_static_channels()
cbilling:         self.ao_task.StartTask()
cbilling:         self.do_task.StartTask()
cbilling:         if abort:
cbilling:             # Reprogram the initial states:
cbilling:             self.program_manual(self.initial_values)
cbilling:             
cbilling:         return True
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)    
cbilling: 
cbilling:         
cbilling: class NiPCIe6363AcquisitionWorker(Worker):
cbilling:     def init(self):
cbilling:         #exec 'import traceback' in globals()
cbilling:         exec 'from PyDAQmx import Task' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global numpy; import numpy
cbilling:         global threading; import threading
cbilling:         global zprocess; import zprocess
cbilling:         global logging; import logging
cbilling:         global time; import time
cbilling:         
cbilling:         self.task_running = False
cbilling:         self.daqlock = threading.Condition()
cbilling:         # Channel details
cbilling:         self.channels = []
cbilling:         self.rate = 1000.
cbilling:         self.samples_per_channel = 1000
cbilling:         self.ai_start_delay = 25e-9
cbilling:         self.h5_file = ""
cbilling:         self.buffered_channels = []
cbilling:         self.buffered_rate = 0
cbilling:         self.buffered = False
cbilling:         self.buffered_data = None
cbilling:         self.buffered_data_list = []
cbilling:         
cbilling:         self.task = None
cbilling:         self.abort = False
cbilling:         
cbilling:         # And event for knowing when the wait durations are known, so that we may use them
cbilling:         # to chunk up acquisition data:
cbilling:         self.wait_durations_analysed = zprocess.Event('wait_durations_analysed')
cbilling:         
cbilling:         self.daqmx_read_thread = threading.Thread(target=self.daqmx_read)
cbilling:         self.daqmx_read_thread.daemon = True
cbilling:         self.daqmx_read_thread.start()
cbilling: 
cbilling:     def shutdown(self):
cbilling:         if self.task_running:
cbilling:             self.stop_task()
cbilling:         
cbilling:     def daqmx_read(self):
cbilling:         logger = logging.getLogger('BLACS.%s_%s.acquisition.daqmxread'%(self.device_name,self.worker_name))
cbilling:         logger.info('Starting')
cbilling:         #first_read = True
cbilling:         try:
cbilling:             while True:
cbilling:                 with self.daqlock:
cbilling:                     logger.debug('Got daqlock')
cbilling:                     while not self.task_running:
cbilling:                         logger.debug('Task isn\'t running. Releasing daqlock and waiting to reacquire it.')
cbilling:                         self.daqlock.wait()
pstarkey:                     #logger.debug('Reading data from analogue inputs')
cbilling:                     if self.buffered:
cbilling:                         chnl_list = self.buffered_channels
cbilling:                     else:
cbilling:                         chnl_list = self.channels
cbilling:                     try:
cbilling:                         error = "Task did not return an error, but it should have"
cbilling:                         acquisition_timeout = 5
cbilling:                         error = self.task.ReadAnalogF64(self.samples_per_channel,acquisition_timeout,DAQmx_Val_GroupByChannel,self.ai_data,self.samples_per_channel*len(chnl_list),byref(self.ai_read),None)
pstarkey:                         #logger.debug('Reading complete')
cbilling:                         if error is not None and error != 0:
cbilling:                             if error < 0:
cbilling:                                 raise Exception(error)
cbilling:                             if error > 0:
cbilling:                                 logger.warning(error)
cbilling:                     except Exception as e:
cbilling:                         logger.exception('acquisition error')
cbilling:                         if self.abort:
cbilling:                             # If an abort is in progress, then we expect an exception here. Don't raise it.
cbilling:                             logger.debug('ignoring error since an abort is in progress.')
cbilling:                             # Ensure the next iteration of this while loop
cbilling:                             # doesn't happen until the task is restarted.
cbilling:                             # The thread calling self.stop_task() is
cbilling:                             # also setting self.task_running = False
cbilling:                             # right about now, but we don't want to rely
cbilling:                             # on it doing so in time. Doing it here too
cbilling:                             # avoids a race condition.
cbilling:                             self.task_running = False
cbilling:                             continue
cbilling:                         else:
cbilling:                             # Error was likely a timeout error...some other device might be bing slow 
cbilling:                             # transitioning to buffered, so we haven't got our start trigger yet. 
cbilling:                             # Keep trying until task_running is False:
cbilling:                             continue
cbilling:                 # send the data to the queue
cbilling:                 if self.buffered:
cbilling:                     # rearrange ai_data into correct form
cbilling:                     data = numpy.copy(self.ai_data)
cbilling:                     self.buffered_data_list.append(data)
cbilling:                     
cbilling:                     #if len(chnl_list) > 1:
cbilling:                     #    data.shape = (len(chnl_list),self.ai_read.value)              
cbilling:                     #    data = data.transpose()
cbilling:                     #self.buffered_data = numpy.append(self.buffered_data,data,axis=0)
cbilling:                 else:
cbilling:                     pass
cbilling:                     # Todo: replace this with zmq pub plus a broker somewhere so things can subscribe to channels
cbilling:                     # and get their data without caring what process it came from. For the sake of speed, this
cbilling:                     # should use the numpy buffer interface and raw zmq messages, and not the existing event system
cbilling:                     # that zprocess has.
cbilling:                     # self.result_queue.put([self.t0,self.rate,self.ai_read.value,len(self.channels),self.ai_data])
cbilling:                     # self.t0 = self.t0 + self.samples_per_channel/self.rate
cbilling:         except:
cbilling:             message = traceback.format_exc()
cbilling:             logger.error('An exception happened:\n %s'%message)
cbilling:             #self.to_parent.put(['error', message])
cbilling:             # TODO: Tell the GUI process that this has a problem some how (status check?)
cbilling:             
cbilling:     def setup_task(self):
cbilling:         self.logger.debug('setup_task')
cbilling:         #DAQmx Configure Code
cbilling:         with self.daqlock:
cbilling:             self.logger.debug('setup_task got daqlock')
cbilling:             if self.task:
cbilling:                 self.task.ClearTask()##
cbilling:             if self.buffered:
cbilling:                 chnl_list = self.buffered_channels
cbilling:                 rate = self.buffered_rate
cbilling:             else:
cbilling:                 chnl_list = self.channels
cbilling:                 rate = self.rate
cbilling:                 
cbilling:             if len(chnl_list) < 1:
cbilling:                 return
cbilling:                 
cbilling:             if rate < 1000:
cbilling:                 self.samples_per_channel = int(rate)
cbilling:             else:
cbilling:                 self.samples_per_channel = 1000
cbilling:             try:
cbilling:                 self.task = Task()
cbilling:             except Exception as e:
cbilling:                 self.logger.error(str(e))
cbilling:             self.ai_read = int32()
cbilling:             self.ai_data = numpy.zeros((self.samples_per_channel*len(chnl_list),), dtype=numpy.float64)   
cbilling:             
cbilling:             for chnl in chnl_list:
cbilling:                 self.task.CreateAIVoltageChan(chnl,"",DAQmx_Val_RSE,-10.0,10.0,DAQmx_Val_Volts,None)
cbilling:                 
cbilling:             self.task.CfgSampClkTiming("",rate,DAQmx_Val_Rising,DAQmx_Val_ContSamps,1000)
cbilling:                     
cbilling:             if self.buffered:
cbilling:                 #set up start on digital trigger
cbilling:                 self.task.CfgDigEdgeStartTrig(self.clock_terminal,DAQmx_Val_Rising)
cbilling:             
cbilling:             #DAQmx Start Code
cbilling:             self.task.StartTask()
cbilling:             # TODO: Need to do something about the time for buffered acquisition. Should be related to when it starts (approx)
cbilling:             # How do we detect that?
cbilling:             self.t0 = time.time() - time.timezone
cbilling:             self.task_running = True
cbilling:             self.daqlock.notify()
cbilling:         self.logger.debug('finished setup_task')
cbilling:         
cbilling:     def stop_task(self):
cbilling:         self.logger.debug('stop_task')
cbilling:         with self.daqlock:
cbilling:             self.logger.debug('stop_task got daqlock')
cbilling:             if self.task_running:
cbilling:                 self.task_running = False
cbilling:                 self.task.StopTask()
cbilling:                 self.task.ClearTask()
cbilling:             self.daqlock.notify()
cbilling:         self.logger.debug('finished stop_task')
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # TODO: Do this line better!
cbilling:         self.device_name = device_name
cbilling:         
cbilling:         self.logger.debug('transition_to_buffered')
cbilling:         # stop current task
cbilling:         self.stop_task()
cbilling:         
cbilling:         self.buffered_data_list = []
cbilling:         
cbilling:         # Save h5file path (for storing data later!)
cbilling:         self.h5_file = h5file
cbilling:         # read channels, acquisition rate, etc from H5 file
cbilling:         h5_chnls = []
cbilling:         with h5py.File(h5file,'r') as hdf5_file:
cbilling:             group =  hdf5_file['/devices/'+device_name]
pstarkey:             device_properties = labscript_utils.properties.get(hdf5_file, device_name, 'device_properties')
pstarkey:             connection_table_properties = labscript_utils.properties.get(hdf5_file, device_name, 'connection_table_properties')
pstarkey:             self.clock_terminal = connection_table_properties['clock_terminal']            
  rander:             if 'analog_in_channels' in device_properties:
  rander:                 h5_chnls = device_properties['analog_in_channels'].split(', ')
  rander:                 self.buffered_rate = device_properties['acquisition_rate']
cbilling:             else:
cbilling:                self.logger.debug("no input channels")
cbilling:         # combine static channels with h5 channels (using a set to avoid duplicates)
cbilling:         self.buffered_channels = set(h5_chnls)
cbilling:         self.buffered_channels.update(self.channels)
cbilling:         # Now make it a sorted list:
cbilling:         self.buffered_channels = sorted(list(self.buffered_channels))
cbilling:         
cbilling:         # setup task (rate should be from h5 file)
cbilling:         # Possibly should detect and lower rate if too high, as h5 file doesn't know about other acquisition channels?
cbilling:         
cbilling:         if self.buffered_rate <= 0:
cbilling:             self.buffered_rate = self.rate
cbilling:         
cbilling:         self.buffered = True
cbilling:         if len(self.buffered_channels) == 1:
cbilling:             self.buffered_data = numpy.zeros((1,),dtype=numpy.float64)
cbilling:         else:
cbilling:             self.buffered_data = numpy.zeros((1,len(self.buffered_channels)),dtype=numpy.float64)
cbilling:         
cbilling:         self.setup_task()   
cbilling: 
cbilling:         return {}
cbilling:     
cbilling:     def transition_to_manual(self,abort=False):    
cbilling:         self.logger.debug('transition_to_static')
cbilling:         # Stop acquisition (this should really be done on a digital edge, but that is for later! Maybe use a Counter)
cbilling:         # Set the abort flag so that the acquisition thread knows to expect an exception in the case of an abort:
cbilling:         #
cbilling:         # TODO: This is probably bad because it shortly get's overwritten to False
cbilling:         # However whether it has an effect depends on whether daqmx_read thread holds the daqlock 
cbilling:         # when self.stop_task() is called
cbilling:         self.abort = abort 
cbilling:         self.stop_task()
cbilling:         # Reset the abort flag so that unexpected exceptions are still raised:        
cbilling:         self.abort = False
cbilling:         self.logger.info('transitioning to static, task stopped')
cbilling:         # save the data acquired to the h5 file
cbilling:         if not abort:
cbilling:             with h5py.File(self.h5_file,'a') as hdf5_file:
cbilling:                 data_group = hdf5_file['data']
cbilling:                 data_group.create_group(self.device_name)
cbilling: 
cbilling:             dtypes = [(chan.split('/')[-1],numpy.float32) for chan in sorted(self.buffered_channels)]
cbilling: 
cbilling:             start_time = time.time()
cbilling:             if self.buffered_data_list:
cbilling:                 self.buffered_data = numpy.zeros(len(self.buffered_data_list)*1000,dtype=dtypes)
cbilling:                 for i, data in enumerate(self.buffered_data_list):
cbilling:                     data.shape = (len(self.buffered_channels),self.ai_read.value)              
cbilling:                     for j, (chan, dtype) in enumerate(dtypes):
cbilling:                         self.buffered_data[chan][i*1000:(i*1000)+1000] = data[j,:]
cbilling:                     if i % 100 == 0:
cbilling:                         self.logger.debug( str(i/100) + " time: "+str(time.time()-start_time))
cbilling:                 self.extract_measurements(self.device_name)
cbilling:                 self.logger.info('data written, time taken: %ss' % str(time.time()-start_time))
cbilling:             
cbilling:             self.buffered_data = None
cbilling:             self.buffered_data_list = []
cbilling:             
cbilling:             # Send data to callback functions as requested (in one big chunk!)
cbilling:             #self.result_queue.put([self.t0,self.rate,self.ai_read,len(self.channels),self.ai_data])
cbilling:         
cbilling:         # return to previous acquisition mode
cbilling:         self.buffered = False
cbilling:         self.setup_task()
cbilling:         
cbilling:         return True
cbilling:         
cbilling:     def extract_measurements(self, device_name):
cbilling:         self.logger.debug('extract_measurements')
cbilling:         with h5py.File(self.h5_file,'a') as hdf5_file:
cbilling:             waits_in_use = len(hdf5_file['waits']) > 0
cbilling:         if waits_in_use:
cbilling:             # There were waits in this shot. We need to wait until the other process has
cbilling:             # determined their durations before we proceed:
cbilling:             self.wait_durations_analysed.wait(self.h5_file)
    dihm:             
cbilling:         with h5py.File(self.h5_file,'a') as hdf5_file:
    dihm:             if waits_in_use:
    dihm:                 # get the wait start times and durations
    dihm:                 waits = hdf5_file['/data/waits']
    dihm:                 wait_times = waits['time']
    dihm:                 wait_durations = waits['duration']
cbilling:             try:
cbilling:                 acquisitions = hdf5_file['/devices/'+device_name+'/ACQUISITIONS']
cbilling:             except:
cbilling:                 # No acquisitions!
cbilling:                 return
cbilling:             try:
cbilling:                 measurements = hdf5_file['/data/traces']
cbilling:             except:
cbilling:                 # Group doesn't exist yet, create it:
cbilling:                 measurements = hdf5_file.create_group('/data/traces')
cbilling:             for connection,label,start_time,end_time,wait_label,scale_factor,units in acquisitions:
    dihm:                 if waits_in_use:
    dihm:                     # add durations from all waits that start prior to start_time of acquisition
    dihm:                     start_time += wait_durations[(wait_times < start_time)].sum()
    dihm:                     # compare wait times to end_time to allow for waits during an acquisition
    dihm:                     end_time += wait_durations[(wait_times < end_time)].sum()
  rander:                 start_index = int(numpy.ceil(self.buffered_rate*(start_time-self.ai_start_delay)))
  rander:                 end_index = int(numpy.floor(self.buffered_rate*(end_time-self.ai_start_delay)))
cbilling:                 # numpy.ceil does what we want above, but float errors can miss the equality
cbilling:                 if self.ai_start_delay + (start_index-1)/self.buffered_rate - start_time > -2e-16:
cbilling:                     start_index -= 1
cbilling:                 # We actually want numpy.floor(x) to yield the largest integer < x (not <=) 
cbilling:                 if end_time - self.ai_start_delay - end_index/self.buffered_rate < 2e-16:
cbilling:                     end_index -= 1
cbilling:                 acquisition_start_time = self.ai_start_delay + start_index/self.buffered_rate
cbilling:                 acquisition_end_time = self.ai_start_delay + end_index/self.buffered_rate
cbilling:                 times = numpy.linspace(acquisition_start_time, acquisition_end_time, 
cbilling:                                        end_index-start_index+1,
cbilling:                                        endpoint=True)
cbilling:                 values = self.buffered_data[connection][start_index:end_index+1]
cbilling:                 dtypes = [('t', numpy.float64),('values', numpy.float32)]
cbilling:                 data = numpy.empty(len(values),dtype=dtypes)
cbilling:                 data['t'] = times
cbilling:                 data['values'] = values
cbilling:                 measurements.create_dataset(label, data=data)
cbilling:             
cbilling:     def abort_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)   
cbilling:     
cbilling:     def program_manual(self,values):
cbilling:         return {}
cbilling:     
cbilling: class NiPCIe6363WaitMonitorWorker(Worker):
cbilling:     def init(self):
cbilling:         exec 'import ctypes' in globals()
cbilling:         exec 'from PyDAQmx import Task' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global numpy; import numpy        
cbilling:         global threading; import threading
cbilling:         global zprocess; import zprocess
cbilling:         global logging; import logging
cbilling:         global time; import time
cbilling:     
cbilling:         self.task_running = False
cbilling:         self.daqlock = threading.Lock() # not sure if needed, access should be serialised already
cbilling:         self.h5_file = None
cbilling:         self.task = None
cbilling:         self.abort = False
cbilling:         self.all_waits_finished = zprocess.Event('all_waits_finished',type='post')
cbilling:         self.wait_durations_analysed = zprocess.Event('wait_durations_analysed',type='post')
cbilling:     
cbilling:     def shutdown(self):
cbilling:         self.logger.info('Shutdown requested, stopping task')
cbilling:         if self.task_running:
cbilling:             self.stop_task()    
cbilling:     
cbilling:     #def read_one_half_period(self, timeout, readarray = numpy.empty(1)):
cbilling:     def read_one_half_period(self, timeout): 
cbilling:         readarray = numpy.empty(1)
cbilling:         try:
cbilling:             with self.daqlock:
cbilling:                 self.acquisition_task.ReadCounterF64(1, timeout, readarray, len(readarray), ctypes.c_long(1), None)
cbilling:                 self.half_periods.append(readarray[0])
cbilling:             return readarray[0]
cbilling:         except Exception:
cbilling:             if self.abort:
cbilling:                 raise
cbilling:             # otherwise, it's a timeout:
cbilling:             return None
cbilling:     
cbilling:     def wait_for_edge(self, timeout=None):
cbilling:         if timeout is None:
cbilling:             while True:
cbilling:                 half_period = self.read_one_half_period(1)
cbilling:                 if half_period is not None:
cbilling:                     return half_period
cbilling:         else:
cbilling:             return self.read_one_half_period(timeout)
cbilling:                 
cbilling:     def daqmx_read(self):
cbilling:         logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))
cbilling:         logger.info('Starting')
cbilling:         with self.kill_lock:
cbilling:             try:
cbilling:                 # Wait for the end of the first pulse indicating the start of the experiment:
cbilling:                 current_time = pulse_width = self.wait_for_edge()
cbilling:                 # alright, we're now a short way into the experiment.
cbilling:                 for wait in self.wait_table:
cbilling:                     # How long until this wait should time out?
cbilling:                     timeout = wait['time'] + wait['timeout'] - current_time
cbilling:                     timeout = max(timeout, 0) # ensure non-negative
cbilling:                     # Wait that long for the next pulse:
cbilling:                     half_period = self.wait_for_edge(timeout)
cbilling:                     # Did the wait finish of its own accord?
cbilling:                     if half_period is not None:
cbilling:                         # It did, we are now at the end of that wait:
cbilling:                         current_time = wait['time']
cbilling:                         # Wait for the end of the pulse:
cbilling:                         current_time += self.wait_for_edge()
cbilling:                     else:
cbilling:                         # It timed out. Better trigger the clock to resume!.
cbilling:                         self.send_resume_trigger(pulse_width)
cbilling:                         # Wait for it to respond to that:
cbilling:                         self.wait_for_edge()
cbilling:                         # Alright, *now* we're at the end of the wait.
cbilling:                         current_time = wait['time']
cbilling:                         # And wait for the end of the pulse:
cbilling:                         current_time += self.wait_for_edge()
cbilling: 
cbilling:                 # Inform any interested parties that waits have all finished:
cbilling:                 self.all_waits_finished.post(self.h5_file)
cbilling:             except Exception:
cbilling:                 if self.abort:
cbilling:                     return
cbilling:                 else:
cbilling:                     raise
cbilling:     
cbilling:     def send_resume_trigger(self, pulse_width):
cbilling:         written = int32()
cbilling:         # go high:
cbilling:         self.timeout_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,numpy.ones(1, dtype=numpy.uint8),byref(written),None)
cbilling:         assert written.value == 1
cbilling:         # Wait however long we observed the first pulse of the experiment to be:
cbilling:         time.sleep(pulse_width)
pstarkey:         # go high:
pstarkey:         self.timeout_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,numpy.ones(1, dtype=numpy.uint8),byref(written),None)
cbilling:         assert written.value == 1
cbilling:         
cbilling:     def stop_task(self):
cbilling:         self.logger.debug('stop_task')
cbilling:         with self.daqlock:
cbilling:             self.logger.debug('stop_task got daqlock')
cbilling:             if self.task_running:
cbilling:                 self.task_running = False
cbilling:                 self.acquisition_task.StopTask()
cbilling:                 self.acquisition_task.ClearTask()
cbilling:                 self.timeout_task.StopTask()
cbilling:                 self.timeout_task.ClearTask()
cbilling:         self.logger.debug('finished stop_task')
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         self.logger.debug('transition_to_buffered')
cbilling:         # Save h5file path (for storing data later!)
cbilling:         self.h5_file = h5file
cbilling:         self.is_wait_monitor_device = False # Will be set to true in a moment if necessary
cbilling:         self.logger.debug('setup_task')
cbilling:         with h5py.File(h5file, 'r') as hdf5_file:
cbilling:             dataset = hdf5_file['waits']
cbilling:             if len(dataset) == 0:
cbilling:                 # There are no waits. Do nothing.
cbilling:                 self.logger.debug('There are no waits, not transitioning to buffered')
cbilling:                 self.waits_in_use = False
cbilling:                 self.wait_table = numpy.zeros((0,))
cbilling:                 return {}
cbilling:             self.waits_in_use = True
cbilling:             acquisition_device = dataset.attrs['wait_monitor_acquisition_device']
cbilling:             acquisition_connection = dataset.attrs['wait_monitor_acquisition_connection']
cbilling:             timeout_device = dataset.attrs['wait_monitor_timeout_device']
cbilling:             timeout_connection = dataset.attrs['wait_monitor_timeout_connection']
cbilling:             self.wait_table = dataset[:]
cbilling:         # Only do anything if we are in fact the wait_monitor device:
cbilling:         if timeout_device == device_name or acquisition_device == device_name:
cbilling:             if not timeout_device == device_name and acquisition_device == device_name:
cbilling:                 raise NotImplementedError("ni-PCIe-6363 worker must be both the wait monitor timeout device and acquisition device." +
cbilling:                                           "Being only one could be implemented if there's a need for it, but it isn't at the moment")
cbilling:             
cbilling:             self.is_wait_monitor_device = True
cbilling:             # The counter acquisition task:
cbilling:             self.acquisition_task = Task()
cbilling:             acquisition_chan = '/'.join([self.MAX_name,acquisition_connection])
cbilling:             self.acquisition_task.CreateCISemiPeriodChan(acquisition_chan, '', 100e-9, 200, DAQmx_Val_Seconds, "")    
cbilling:             self.acquisition_task.CfgImplicitTiming(DAQmx_Val_ContSamps, 1000)
cbilling:             self.acquisition_task.StartTask()
cbilling:             # The timeout task:
cbilling:             self.timeout_task = Task()
cbilling:             timeout_chan = '/'.join([self.MAX_name,timeout_connection])
cbilling:             self.timeout_task.CreateDOChan(timeout_chan,"",DAQmx_Val_ChanForAllLines)
cbilling:             self.task_running = True
cbilling:                 
cbilling:             # An array to store the results of counter acquisition:
cbilling:             self.half_periods = []
cbilling:             self.read_thread = threading.Thread(target=self.daqmx_read)
cbilling:             # Not a daemon thread, as it implements wait timeouts - we need it to stay alive if other things die.
cbilling:             self.read_thread.start()
cbilling:             self.logger.debug('finished transition to buffered')
cbilling:             
cbilling:         return {}
cbilling:     
cbilling:     def transition_to_manual(self,abort=False):
cbilling:         self.logger.debug('transition_to_static')
cbilling:         self.abort = abort
cbilling:         self.stop_task()
cbilling:         # Reset the abort flag so that unexpected exceptions are still raised:        
cbilling:         self.abort = False
cbilling:         self.logger.info('transitioning to static, task stopped')
cbilling:         # save the data acquired to the h5 file
cbilling:         if not abort:
pstarkey:             if self.is_wait_monitor_device and self.waits_in_use:
cbilling:                 # Let's work out how long the waits were. The absolute times of each edge on the wait
cbilling:                 # monitor were:
cbilling:                 edge_times = numpy.cumsum(self.half_periods)
cbilling:                 # Now there was also a rising edge at t=0 that we didn't measure:
cbilling:                 edge_times = numpy.insert(edge_times,0,0)
cbilling:                 # Ok, and the even-indexed ones of these were rising edges.
cbilling:                 rising_edge_times = edge_times[::2]
cbilling:                 # Now what were the times between rising edges?
cbilling:                 periods = numpy.diff(rising_edge_times)
cbilling:                 # How does this compare to how long we expected there to be between the start
cbilling:                 # of the experiment and the first wait, and then between each pair of waits?
cbilling:                 # The difference will give us the waits' durations.
cbilling:                 resume_times = self.wait_table['time']
cbilling:                 # Again, include the start of the experiment, t=0:
cbilling:                 resume_times =  numpy.insert(resume_times,0,0)
cbilling:                 run_periods = numpy.diff(resume_times)
cbilling:                 wait_durations = periods - run_periods
cbilling:                 waits_timed_out = wait_durations > self.wait_table['timeout']
cbilling:             with h5py.File(self.h5_file,'a') as hdf5_file:
cbilling:                 # Work out how long the waits were, save em, post an event saying so 
cbilling:                 dtypes = [('label','a256'),('time',float),('timeout',float),('duration',float),('timed_out',bool)]
cbilling:                 data = numpy.empty(len(self.wait_table), dtype=dtypes)
pstarkey:                 if self.is_wait_monitor_device and self.waits_in_use:
cbilling:                     data['label'] = self.wait_table['label']
cbilling:                     data['time'] = self.wait_table['time']
cbilling:                     data['timeout'] = self.wait_table['timeout']
cbilling:                     data['duration'] = wait_durations
cbilling:                     data['timed_out'] = waits_timed_out
cbilling:                 if self.is_wait_monitor_device:
cbilling:                     hdf5_file.create_dataset('/data/waits', data=data)
cbilling:             if self.is_wait_monitor_device:
cbilling:                 self.wait_durations_analysed.post(self.h5_file)
cbilling:         
cbilling:         return True
cbilling:     
cbilling:     def abort_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)   
cbilling:     
cbilling:     def program_manual(self,values):
cbilling:         return {}
cbilling: 
cbilling:  
cbilling:     
cbilling: @runviewer_parser
cbilling: class RunviewerClass(parent.RunviewerClass):
pstarkey:     num_digitals = 32
cbilling:     
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /NI_USB_6343.py                                                  #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of the module labscript_devices, in the         #
cbilling: # labscript suite (see http://labscriptsuite.org), and is           #
cbilling: # licensed under the Simplified BSD License. See the license.txt    #
cbilling: # file in the root of the project for the full license.             #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: from labscript import LabscriptError
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: import labscript_devices.NIBoard as parent
cbilling: 
cbilling: import numpy as np
cbilling: import labscript_utils.h5_lock, h5py
  rander: import labscript_utils.properties
  rander: 
cbilling: 
cbilling: @labscript_device
cbilling: class NI_USB_6343(parent.NIBoard):
cbilling:     description = 'NI-USB-6343'
cbilling:     clock_limit = 700e3
cbilling:     n_analogs = 4
cbilling:     n_digitals = 32
cbilling:     n_analog_ins = 32
cbilling:     digital_dtype = np.uint32
cbilling: 
cbilling: 
cbilling: import time
cbilling: 
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: from blacs.device_base_class import DeviceTab
cbilling: 
cbilling: @BLACS_tab
cbilling: class NI_USB_6343Tab(DeviceTab):
cbilling:     def initialise_GUI(self):
cbilling:         # Capabilities
cbilling:         num_AO = 4
cbilling:         num = {'AO':4, 'DO':32, 'PFI':16}
cbilling:         
cbilling:         base_units = {'AO':'V'}
cbilling:         base_min = {'AO':-10.0}
cbilling:         base_max = {'AO':10.0}
cbilling:         base_step = {'AO':0.1}
cbilling:         base_decimals = {'AO':3}
cbilling:         
cbilling:         # Create the AO output objects
cbilling:         ao_prop = {}
cbilling:         for i in range(num['AO']):
cbilling:             ao_prop['ao%d'%i] = {'base_unit':base_units['AO'],
cbilling:                                  'min':base_min['AO'],
cbilling:                                  'max':base_max['AO'],
cbilling:                                  'step':base_step['AO'],
cbilling:                                  'decimals':base_decimals['AO']
cbilling:                                 }
cbilling:         
cbilling:         do_prop = {}
cbilling:         for i in range(num['DO']):
cbilling:             do_prop['port0/line%d'%i] = {}
cbilling:             
cbilling:         pfi_prop = {}
cbilling:         for i in range(num['PFI']):
cbilling:             pfi_prop['PFI %d'%i] = {}
cbilling:         
cbilling:         
cbilling:         # Create the output objects    
cbilling:         self.create_analog_outputs(ao_prop)        
cbilling:         # Create widgets for analog outputs only
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         
cbilling:         # now create the digital output objects
cbilling:         self.create_digital_outputs(do_prop)
cbilling:         self.create_digital_outputs(pfi_prop)
cbilling:         # manually create the digital output widgets so they are grouped separately
cbilling:         do_widgets = self.create_digital_widgets(do_prop)
cbilling:         pfi_widgets = self.create_digital_widgets(pfi_prop)
cbilling:         
cbilling:         def do_sort(channel):
cbilling:             flag = channel.replace('port0/line','')
cbilling:             flag = int(flag)
cbilling:             return '%02d'%(flag)
cbilling:             
cbilling:         def pfi_sort(channel):
cbilling:             flag = channel.replace('PFI ','')
cbilling:             flag = int(flag)
cbilling:             return '%02d'%(flag)
cbilling:         
cbilling:         # and auto place the widgets in the UI
cbilling:         self.auto_place_widgets(("Analog Outputs",ao_widgets),("Digital Outputs",do_widgets,do_sort),("PFI Outputs",pfi_widgets,pfi_sort))
cbilling:         
cbilling:         # Store the Measurement and Automation Explorer (MAX) name
cbilling:         self.MAX_name = str(self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection)
cbilling:         
cbilling:         # Create and set the primary worker
cbilling:         self.create_worker("main_worker",NI_USB_6343Worker,{'MAX_name':self.MAX_name, 'limits': [base_min['AO'],base_max['AO']], 'num':num})
cbilling:         self.primary_worker = "main_worker"
cbilling:         self.create_worker("wait_monitor_worker",NI_USB_6343WaitMonitorWorker,{'MAX_name':self.MAX_name})
cbilling:         self.add_secondary_worker("wait_monitor_worker")
cbilling:         self.create_worker("acquisition_worker",NI_USB_6343AcquisitionWorker,{'MAX_name':self.MAX_name})
cbilling:         self.add_secondary_worker("acquisition_worker")
cbilling: 
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(False)
cbilling:         self.supports_smart_programming(False) 
cbilling:     
cbilling: @BLACS_worker
cbilling: class NI_USB_6343Worker(Worker):
cbilling:     def init(self):
cbilling:         exec 'from PyDAQmx import Task' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global pylab; import pylab
cbilling:         global numpy; import numpy
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         
cbilling:         # Create task
cbilling:         self.ao_task = Task()
cbilling:         self.ao_read = int32()
cbilling:         self.ao_data = numpy.zeros((self.num['AO'],), dtype=numpy.float64)
cbilling:         
cbilling:         # Create DO task:
cbilling:         self.do_task = Task()
cbilling:         self.do_read = int32()
cbilling:         self.do_data = numpy.zeros(self.num['DO']+self.num['PFI'],dtype=numpy.uint8)
cbilling:         
cbilling:         self.setup_static_channels()            
cbilling:         
cbilling:         #DAQmx Start Code        
cbilling:         self.ao_task.StartTask() 
cbilling:         self.do_task.StartTask()  
cbilling:         
cbilling:     def setup_static_channels(self):
cbilling:         #setup AO channels
cbilling:         for i in range(self.num['AO']): 
cbilling:             self.ao_task.CreateAOVoltageChan(self.MAX_name+"/ao%d"%i,"",self.limits[0],self.limits[1],DAQmx_Val_Volts,None)
cbilling:         
cbilling:         #setup DO ports
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line0:7","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line8:15","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line16:23","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port0/line24:31","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port1/line0:7","",DAQmx_Val_ChanForAllLines)
cbilling:         self.do_task.CreateDOChan(self.MAX_name+"/port2/line0:7","",DAQmx_Val_ChanForAllLines)  
cbilling:                 
cbilling:     def shutdown(self):        
cbilling:         self.ao_task.StopTask()
cbilling:         self.ao_task.ClearTask()
cbilling:         self.do_task.StopTask()
cbilling:         self.do_task.ClearTask()
cbilling:         
cbilling:     def program_manual(self,front_panel_values):
cbilling:         for i in range(self.num['AO']):
cbilling:             self.ao_data[i] = front_panel_values['ao%d'%i]
cbilling:         self.ao_task.WriteAnalogF64(1,True,1,DAQmx_Val_GroupByChannel,self.ao_data,byref(self.ao_read),None)
cbilling:         
cbilling:         for i in range(self.num['DO']):
cbilling:             self.do_data[i] = front_panel_values['port0/line%d'%i]
cbilling:             
cbilling:         for i in range(self.num['PFI']):
cbilling:             self.do_data[i+self.num['DO']] = front_panel_values['PFI %d'%i]
cbilling:         self.do_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,self.do_data,byref(self.do_read),None)
cbilling:      
cbilling:         # TODO: return coerced/quantised values
cbilling:         return {}
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # Store the initial values in case we have to abort and restore them:
cbilling:         self.initial_values = initial_values
cbilling:             
cbilling:         with h5py.File(h5file,'r') as hdf5_file:
cbilling:             group = hdf5_file['devices/'][device_name]
pstarkey:             device_properties = labscript_utils.properties.get(hdf5_file, device_name, 'device_properties')
pstarkey:             connection_table_properties = labscript_utils.properties.get(hdf5_file, device_name, 'connection_table_properties')
  rander:             clock_terminal = connection_table_properties['clock_terminal']
cbilling:             h5_data = group.get('ANALOG_OUTS')
cbilling:             if h5_data:
cbilling:                 self.buffered_using_analog = True
  rander:                 ao_channels = device_properties['analog_out_channels']
cbilling:                 # We use all but the last sample (which is identical to the
cbilling:                 # second last sample) in order to ensure there is one more
cbilling:                 # clock tick than there are samples. The 6733 requires this
cbilling:                 # to determine that the task has completed.
cbilling:                 ao_data = pylab.array(h5_data,dtype=float64)[:-1,:]
cbilling:             else:
cbilling:                 self.buffered_using_analog = False
cbilling:                 
cbilling:             h5_data = group.get('DIGITAL_OUTS')
cbilling:             if h5_data:
cbilling:                 self.buffered_using_digital = True
  rander:                 do_channels = device_properties['digital_lines']
cbilling:                 do_bitfield = numpy.array(h5_data,dtype=numpy.uint32)
cbilling:             else:
cbilling:                 self.buffered_using_digital = False
cbilling:                 
cbilling:                 
cbilling:         
cbilling:         final_values = {} 
cbilling:         # We must do digital first, so as to make sure the manual mode task is stopped, or reprogrammed, by the time we setup the AO task
cbilling:         # this is because the clock_terminal PFI must be freed!
cbilling:         if self.buffered_using_digital:
cbilling:             # Expand each bitfield int into self.num['DO']
cbilling:             # (32) individual ones and zeros:
cbilling:             do_write_data = numpy.zeros((do_bitfield.shape[0],self.num['DO']),dtype=numpy.uint8)
cbilling:             for i in range(self.num['DO']):
cbilling:                 do_write_data[:,i] = (do_bitfield & (1 << i)) >> i
cbilling:                 
cbilling:             self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:             self.do_task = Task()
cbilling:             self.do_read = int32()
cbilling:     
cbilling:             self.do_task.CreateDOChan(do_channels,"",DAQmx_Val_ChanPerLine)
cbilling:             self.do_task.CfgSampClkTiming(clock_terminal,500000,DAQmx_Val_Rising,DAQmx_Val_FiniteSamps,do_bitfield.shape[0])
cbilling:             self.do_task.WriteDigitalLines(do_bitfield.shape[0],False,10.0,DAQmx_Val_GroupByScanNumber,do_write_data,self.do_read,None)
cbilling:             self.do_task.StartTask()
cbilling:             
cbilling:             for i in range(self.num['DO']):
cbilling:                 final_values['port0/line%d'%i] = do_write_data[-1,i]
cbilling:         else:
cbilling:             # We still have to stop the task to make the 
cbilling:             # clock flag available for buffered analog output, or the wait monitor:
cbilling:             self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:             
cbilling:         if self.buffered_using_analog:
cbilling:             self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:             self.ao_task = Task()
cbilling:             ao_read = int32()
cbilling: 
cbilling:             self.ao_task.CreateAOVoltageChan(ao_channels,"",-10.0,10.0,DAQmx_Val_Volts,None)
cbilling:             self.ao_task.CfgSampClkTiming(clock_terminal,500000,DAQmx_Val_Rising,DAQmx_Val_FiniteSamps, ao_data.shape[0])
cbilling:             
cbilling:             self.ao_task.WriteAnalogF64(ao_data.shape[0],False,10.0,DAQmx_Val_GroupByScanNumber, ao_data,ao_read,None)
cbilling:             self.ao_task.StartTask()   
cbilling:             
cbilling:             # Final values here are a dictionary of values, keyed by channel:
cbilling:             channel_list = [channel.split('/')[1] for channel in ao_channels.split(', ')]
cbilling:             for channel, value in zip(channel_list, ao_data[-1,:]):
cbilling:                 final_values[channel] = value
cbilling:         else:
cbilling:             # we should probabaly still stop the task (this makes it easier to setup the task later)
cbilling:             self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:                 
cbilling:        
cbilling:             
cbilling:         return final_values
cbilling:         
cbilling:     def transition_to_manual(self,abort=False):
cbilling:         # if aborting, don't call StopTask since this throws an
cbilling:         # error if the task hasn't actually finished!
cbilling:         if self.buffered_using_analog:
cbilling:             if not abort:
cbilling:                 self.ao_task.StopTask()
cbilling:             self.ao_task.ClearTask()
cbilling:         if self.buffered_using_digital:
cbilling:             if not abort:
cbilling:                 self.do_task.StopTask()
cbilling:             self.do_task.ClearTask()
cbilling:                 
cbilling:         self.ao_task = Task()
cbilling:         self.do_task = Task()
cbilling:         self.setup_static_channels()
cbilling:         self.ao_task.StartTask()
cbilling:         self.do_task.StartTask()
cbilling:         if abort:
cbilling:             # Reprogram the initial states:
cbilling:             self.program_manual(self.initial_values)
cbilling:             
cbilling:         return True
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)    
cbilling: 
cbilling:         
cbilling: class NI_USB_6343AcquisitionWorker(Worker):
cbilling:     def init(self):
cbilling:         #exec 'import traceback' in globals()
cbilling:         exec 'from PyDAQmx import Task' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global numpy; import numpy
cbilling:         global threading; import threading
cbilling:         global zprocess; import zprocess
cbilling:         global logging; import logging
cbilling:         global time; import time
cbilling:         
cbilling:         self.task_running = False
cbilling:         self.daqlock = threading.Condition()
cbilling:         # Channel details
cbilling:         self.channels = []
cbilling:         self.rate = 1000.
cbilling:         self.samples_per_channel = 1000
cbilling:         self.ai_start_delay = 25e-9
cbilling:         self.h5_file = ""
cbilling:         self.buffered_channels = []
cbilling:         self.buffered_rate = 0
cbilling:         self.buffered = False
cbilling:         self.buffered_data = None
cbilling:         self.buffered_data_list = []
cbilling:         
cbilling:         self.task = None
cbilling:         self.abort = False
cbilling:         
cbilling:         # And event for knowing when the wait durations are known, so that we may use them
cbilling:         # to chunk up acquisition data:
cbilling:         self.wait_durations_analysed = zprocess.Event('wait_durations_analysed')
cbilling:         
cbilling:         self.daqmx_read_thread = threading.Thread(target=self.daqmx_read)
cbilling:         self.daqmx_read_thread.daemon = True
cbilling:         self.daqmx_read_thread.start()
cbilling: 
cbilling:     def shutdown(self):
cbilling:         if self.task_running:
cbilling:             self.stop_task()
cbilling:         
cbilling:     def daqmx_read(self):
cbilling:         logger = logging.getLogger('BLACS.%s_%s.acquisition.daqmxread'%(self.device_name,self.worker_name))
cbilling:         logger.info('Starting')
cbilling:         #first_read = True
cbilling:         try:
cbilling:             while True:
cbilling:                 with self.daqlock:
cbilling:                     logger.debug('Got daqlock')
cbilling:                     while not self.task_running:
cbilling:                         logger.debug('Task isn\'t running. Releasing daqlock and waiting to reacquire it.')
cbilling:                         self.daqlock.wait()
cbilling:                     #logger.debug('Reading data from analogue inputs')
cbilling:                     if self.buffered:
cbilling:                         chnl_list = self.buffered_channels
cbilling:                     else:
cbilling:                         chnl_list = self.channels
cbilling:                     try:
cbilling:                         error = "Task did not return an error, but it should have"
cbilling:                         acquisition_timeout = 5
cbilling:                         error = self.task.ReadAnalogF64(self.samples_per_channel,acquisition_timeout,DAQmx_Val_GroupByChannel,self.ai_data,self.samples_per_channel*len(chnl_list),byref(self.ai_read),None)
cbilling:                         #logger.debug('Reading complete')
cbilling:                         if error is not None and error != 0:
cbilling:                             if error < 0:
cbilling:                                 raise Exception(error)
cbilling:                             if error > 0:
cbilling:                                 logger.warning(error)
cbilling:                     except Exception as e:
cbilling:                         logger.exception('acquisition error')
cbilling:                         if self.abort:
cbilling:                             # If an abort is in progress, then we expect an exception here. Don't raise it.
cbilling:                             logger.debug('ignoring error since an abort is in progress.')
cbilling:                             # Ensure the next iteration of this while loop
cbilling:                             # doesn't happen until the task is restarted.
cbilling:                             # The thread calling self.stop_task() is
cbilling:                             # also setting self.task_running = False
cbilling:                             # right about now, but we don't want to rely
cbilling:                             # on it doing so in time. Doing it here too
cbilling:                             # avoids a race condition.
cbilling:                             self.task_running = False
cbilling:                             continue
cbilling:                         else:
cbilling:                             # Error was likely a timeout error...some other device might be bing slow 
cbilling:                             # transitioning to buffered, so we haven't got our start trigger yet. 
cbilling:                             # Keep trying until task_running is False:
cbilling:                             continue
cbilling:                 # send the data to the queue
cbilling:                 if self.buffered:
cbilling:                     # rearrange ai_data into correct form
cbilling:                     data = numpy.copy(self.ai_data)
cbilling:                     self.buffered_data_list.append(data)
cbilling:                     
cbilling:                     #if len(chnl_list) > 1:
cbilling:                     #    data.shape = (len(chnl_list),self.ai_read.value)              
cbilling:                     #    data = data.transpose()
cbilling:                     #self.buffered_data = numpy.append(self.buffered_data,data,axis=0)
cbilling:                 else:
cbilling:                     pass
cbilling:                     # Todo: replace this with zmq pub plus a broker somewhere so things can subscribe to channels
cbilling:                     # and get their data without caring what process it came from. For the sake of speed, this
cbilling:                     # should use the numpy buffer interface and raw zmq messages, and not the existing event system
cbilling:                     # that zprocess has.
cbilling:                     # self.result_queue.put([self.t0,self.rate,self.ai_read.value,len(self.channels),self.ai_data])
cbilling:                     # self.t0 = self.t0 + self.samples_per_channel/self.rate
cbilling:         except:
cbilling:             message = traceback.format_exc()
cbilling:             logger.error('An exception happened:\n %s'%message)
cbilling:             #self.to_parent.put(['error', message])
cbilling:             # TODO: Tell the GUI process that this has a problem some how (status check?)
cbilling:             
cbilling:     def setup_task(self):
cbilling:         self.logger.debug('setup_task')
cbilling:         #DAQmx Configure Code
cbilling:         with self.daqlock:
cbilling:             self.logger.debug('setup_task got daqlock')
cbilling:             if self.task:
cbilling:                 self.task.ClearTask()##
cbilling:             if self.buffered:
cbilling:                 chnl_list = self.buffered_channels
cbilling:                 rate = self.buffered_rate
cbilling:             else:
cbilling:                 chnl_list = self.channels
cbilling:                 rate = self.rate
cbilling:                 
cbilling:             if len(chnl_list) < 1:
cbilling:                 return
cbilling:                 
cbilling:             if rate < 1000:
cbilling:                 self.samples_per_channel = int(rate)
cbilling:             else:
cbilling:                 self.samples_per_channel = 1000
cbilling:             try:
cbilling:                 self.task = Task()
cbilling:             except Exception as e:
cbilling:                 self.logger.error(str(e))
cbilling:             self.ai_read = int32()
cbilling:             self.ai_data = numpy.zeros((self.samples_per_channel*len(chnl_list),), dtype=numpy.float64)   
cbilling:             
cbilling:             for chnl in chnl_list:
cbilling:                 self.task.CreateAIVoltageChan(chnl,"",DAQmx_Val_RSE,-10.0,10.0,DAQmx_Val_Volts,None)
cbilling:                 
cbilling:             self.task.CfgSampClkTiming("",rate,DAQmx_Val_Rising,DAQmx_Val_ContSamps,1000)
cbilling:                     
cbilling:             if self.buffered:
cbilling:                 #set up start on digital trigger
cbilling:                 self.task.CfgDigEdgeStartTrig(self.clock_terminal,DAQmx_Val_Rising)
cbilling:             
cbilling:             #DAQmx Start Code
cbilling:             self.task.StartTask()
cbilling:             # TODO: Need to do something about the time for buffered acquisition. Should be related to when it starts (approx)
cbilling:             # How do we detect that?
cbilling:             self.t0 = time.time() - time.timezone
cbilling:             self.task_running = True
cbilling:             self.daqlock.notify()
cbilling:         self.logger.debug('finished setup_task')
cbilling:         
cbilling:     def stop_task(self):
cbilling:         self.logger.debug('stop_task')
cbilling:         with self.daqlock:
cbilling:             self.logger.debug('stop_task got daqlock')
cbilling:             if self.task_running:
cbilling:                 self.task_running = False
cbilling:                 self.task.StopTask()
cbilling:                 self.task.ClearTask()
cbilling:             self.daqlock.notify()
cbilling:         self.logger.debug('finished stop_task')
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # TODO: Do this line better!
cbilling:         self.device_name = device_name
cbilling:         
cbilling:         self.logger.debug('transition_to_buffered')
cbilling:         # stop current task
cbilling:         self.stop_task()
cbilling:         
cbilling:         self.buffered_data_list = []
cbilling:         
cbilling:         # Save h5file path (for storing data later!)
cbilling:         self.h5_file = h5file
cbilling:         # read channels, acquisition rate, etc from H5 file
cbilling:         h5_chnls = []
cbilling:         with h5py.File(h5file,'r') as hdf5_file:
cbilling:             group =  hdf5_file['/devices/'+device_name]
pstarkey:             device_properties = labscript_utils.properties.get(hdf5_file, device_name, 'device_properties')
pstarkey:             connection_table_properties = labscript_utils.properties.get(hdf5_file, device_name, 'connection_table_properties')
pstarkey:             self.clock_terminal = connection_table_properties['clock_terminal']
  rander:             if 'analog_in_channels' in device_properties:
  rander:                 h5_chnls = device_properties['analog_in_channels'].split(', ')
  rander:                 self.buffered_rate = device_properties['acquisition_rate']
cbilling:             else:
cbilling:                self.logger.debug("no input channels")
cbilling:         # combine static channels with h5 channels (using a set to avoid duplicates)
cbilling:         self.buffered_channels = set(h5_chnls)
cbilling:         self.buffered_channels.update(self.channels)
cbilling:         # Now make it a sorted list:
cbilling:         self.buffered_channels = sorted(list(self.buffered_channels))
cbilling:         
cbilling:         # setup task (rate should be from h5 file)
cbilling:         # Possibly should detect and lower rate if too high, as h5 file doesn't know about other acquisition channels?
cbilling:         
cbilling:         if self.buffered_rate <= 0:
cbilling:             self.buffered_rate = self.rate
cbilling:         
cbilling:         self.buffered = True
cbilling:         if len(self.buffered_channels) == 1:
cbilling:             self.buffered_data = numpy.zeros((1,),dtype=numpy.float64)
cbilling:         else:
cbilling:             self.buffered_data = numpy.zeros((1,len(self.buffered_channels)),dtype=numpy.float64)
cbilling:         
cbilling:         self.setup_task()   
cbilling: 
cbilling:         return {}
cbilling:     
cbilling:     def transition_to_manual(self,abort=False):    
cbilling:         self.logger.debug('transition_to_static')
cbilling:         # Stop acquisition (this should really be done on a digital edge, but that is for later! Maybe use a Counter)
cbilling:         # Set the abort flag so that the acquisition thread knows to expect an exception in the case of an abort:
cbilling:         #
cbilling:         # TODO: This is probably bad because it shortly get's overwritten to False
cbilling:         # However whether it has an effect depends on whether daqmx_read thread holds the daqlock 
cbilling:         # when self.stop_task() is called
cbilling:         self.abort = abort 
cbilling:         self.stop_task()
cbilling:         # Reset the abort flag so that unexpected exceptions are still raised:        
cbilling:         self.abort = False
cbilling:         self.logger.info('transitioning to static, task stopped')
cbilling:         # save the data acquired to the h5 file
cbilling:         if not abort:
cbilling:             with h5py.File(self.h5_file,'a') as hdf5_file:
cbilling:                 data_group = hdf5_file['data']
cbilling:                 data_group.create_group(self.device_name)
cbilling: 
cbilling:             dtypes = [(chan.split('/')[-1],numpy.float32) for chan in sorted(self.buffered_channels)]
cbilling: 
cbilling:             start_time = time.time()
cbilling:             if self.buffered_data_list:
cbilling:                 self.buffered_data = numpy.zeros(len(self.buffered_data_list)*1000,dtype=dtypes)
cbilling:                 for i, data in enumerate(self.buffered_data_list):
cbilling:                     data.shape = (len(self.buffered_channels),self.ai_read.value)              
cbilling:                     for j, (chan, dtype) in enumerate(dtypes):
cbilling:                         self.buffered_data[chan][i*1000:(i*1000)+1000] = data[j,:]
cbilling:                     if i % 100 == 0:
cbilling:                         self.logger.debug( str(i/100) + " time: "+str(time.time()-start_time))
cbilling:                 self.extract_measurements(self.device_name)
cbilling:                 self.logger.info('data written, time taken: %ss' % str(time.time()-start_time))
cbilling:             
cbilling:             self.buffered_data = None
cbilling:             self.buffered_data_list = []
cbilling:             
cbilling:             # Send data to callback functions as requested (in one big chunk!)
cbilling:             #self.result_queue.put([self.t0,self.rate,self.ai_read,len(self.channels),self.ai_data])
cbilling:         
cbilling:         # return to previous acquisition mode
cbilling:         self.buffered = False
cbilling:         self.setup_task()
cbilling:         
cbilling:         return True
cbilling:         
cbilling:     def extract_measurements(self, device_name):
cbilling:         self.logger.debug('extract_measurements')
cbilling:         with h5py.File(self.h5_file,'a') as hdf5_file:
cbilling:             waits_in_use = len(hdf5_file['waits']) > 0
cbilling:         if waits_in_use:
cbilling:             # There were waits in this shot. We need to wait until the other process has
cbilling:             # determined their durations before we proceed:
cbilling:             self.wait_durations_analysed.wait(self.h5_file)
    dihm: 
cbilling:         with h5py.File(self.h5_file,'a') as hdf5_file:
    dihm:             if waits_in_use:
    dihm:                 # get the wait start times and durations
    dihm:                 waits = hdf5_file['/data/waits']
    dihm:                 wait_times = waits['time']
    dihm:                 wait_durations = waits['duration']
cbilling:             try:
cbilling:                 acquisitions = hdf5_file['/devices/'+device_name+'/ACQUISITIONS']
cbilling:             except:
cbilling:                 # No acquisitions!
cbilling:                 return
cbilling:             try:
cbilling:                 measurements = hdf5_file['/data/traces']
cbilling:             except:
cbilling:                 # Group doesn't exist yet, create it:
cbilling:                 measurements = hdf5_file.create_group('/data/traces')
cbilling:             for connection,label,start_time,end_time,wait_label,scale_factor,units in acquisitions:
    dihm:                 if waits_in_use:
    dihm:                     # add durations from all waits that start prior to start_time of acquisition
    dihm:                     start_time += wait_durations[(wait_times < start_time)].sum()
    dihm:                     # compare wait_times to end_time to allow for waits during an acquisition
    dihm:                     end_time += wait_durations[(wait_times < end_time)].sum()
  rander:                 start_index = int(numpy.ceil(self.buffered_rate*(start_time-self.ai_start_delay)))
  rander:                 end_index = int(numpy.floor(self.buffered_rate*(end_time-self.ai_start_delay)))
cbilling:                 # numpy.ceil does what we want above, but float errors can miss the equality
cbilling:                 if self.ai_start_delay + (start_index-1)/self.buffered_rate - start_time > -2e-16:
cbilling:                     start_index -= 1
cbilling:                 # We actually want numpy.floor(x) to yield the largest integer < x (not <=) 
cbilling:                 if end_time - self.ai_start_delay - end_index/self.buffered_rate < 2e-16:
cbilling:                     end_index -= 1
cbilling:                 acquisition_start_time = self.ai_start_delay + start_index/self.buffered_rate
cbilling:                 acquisition_end_time = self.ai_start_delay + end_index/self.buffered_rate
cbilling:                 times = numpy.linspace(acquisition_start_time, acquisition_end_time, 
cbilling:                                        end_index-start_index+1,
cbilling:                                        endpoint=True)
cbilling:                 values = self.buffered_data[connection][start_index:end_index+1]
cbilling:                 dtypes = [('t', numpy.float64),('values', numpy.float32)]
cbilling:                 data = numpy.empty(len(values),dtype=dtypes)
cbilling:                 data['t'] = times
cbilling:                 data['values'] = values
cbilling:                 measurements.create_dataset(label, data=data)
cbilling:             
cbilling:     def abort_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)   
cbilling:     
cbilling:     def program_manual(self,values):
cbilling:         return {}
cbilling:     
cbilling: class NI_USB_6343WaitMonitorWorker(Worker):
cbilling:     def init(self):
cbilling:         exec 'import ctypes' in globals()
cbilling:         exec 'from PyDAQmx import Task' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxConstants import *' in globals()
cbilling:         exec 'from PyDAQmx.DAQmxTypes import *' in globals()
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global numpy; import numpy        
cbilling:         global threading; import threading
cbilling:         global zprocess; import zprocess
cbilling:         global logging; import logging
cbilling:         global time; import time
cbilling:     
cbilling:         self.task_running = False
cbilling:         self.daqlock = threading.Lock() # not sure if needed, access should be serialised already
cbilling:         self.h5_file = None
cbilling:         self.task = None
cbilling:         self.abort = False
cbilling:         self.all_waits_finished = zprocess.Event('all_waits_finished',type='post')
cbilling:         self.wait_durations_analysed = zprocess.Event('wait_durations_analysed',type='post')
cbilling:     
cbilling:     def shutdown(self):
cbilling:         self.logger.info('Shutdown requested, stopping task')
cbilling:         if self.task_running:
cbilling:             self.stop_task()    
cbilling:     
cbilling:     #def read_one_half_period(self, timeout, readarray = numpy.empty(1)):
cbilling:     def read_one_half_period(self, timeout): 
cbilling:         readarray = numpy.empty(1)
cbilling:         try:
cbilling:             with self.daqlock:
cbilling:                 self.acquisition_task.ReadCounterF64(1, timeout, readarray, len(readarray), ctypes.c_long(1), None)
cbilling:                 self.half_periods.append(readarray[0])
cbilling:             return readarray[0]
cbilling:         except Exception:
cbilling:             if self.abort:
cbilling:                 raise
cbilling:             # otherwise, it's a timeout:
cbilling:             return None
cbilling:     
cbilling:     def wait_for_edge(self, timeout=None):
cbilling:         if timeout is None:
cbilling:             while True:
cbilling:                 half_period = self.read_one_half_period(1)
cbilling:                 if half_period is not None:
cbilling:                     return half_period
cbilling:         else:
cbilling:             return self.read_one_half_period(timeout)
cbilling:                 
cbilling:     def daqmx_read(self):
cbilling:         logger = logging.getLogger('BLACS.%s_%s.read_thread'%(self.device_name, self.worker_name))
cbilling:         logger.info('Starting')
cbilling:         with self.kill_lock:
cbilling:             try:
cbilling:                 # Wait for the end of the first pulse indicating the start of the experiment:
cbilling:                 current_time = pulse_width = self.wait_for_edge()
cbilling:                 # alright, we're now a short way into the experiment.
cbilling:                 for wait in self.wait_table:
cbilling:                     # How long until this wait should time out?
cbilling:                     timeout = wait['time'] + wait['timeout'] - current_time
cbilling:                     timeout = max(timeout, 0) # ensure non-negative
cbilling:                     # Wait that long for the next pulse:
cbilling:                     half_period = self.wait_for_edge(timeout)
cbilling:                     # Did the wait finish of its own accord?
cbilling:                     if half_period is not None:
cbilling:                         # It did, we are now at the end of that wait:
cbilling:                         current_time = wait['time']
cbilling:                         # Wait for the end of the pulse:
cbilling:                         current_time += self.wait_for_edge()
cbilling:                     else:
cbilling:                         # It timed out. Better trigger the clock to resume!.
cbilling:                         self.send_resume_trigger(pulse_width)
cbilling:                         # Wait for it to respond to that:
cbilling:                         self.wait_for_edge()
cbilling:                         # Alright, *now* we're at the end of the wait.
cbilling:                         current_time = wait['time']
cbilling:                         # And wait for the end of the pulse:
cbilling:                         current_time += self.wait_for_edge()
cbilling: 
cbilling:                 # Inform any interested parties that waits have all finished:
cbilling:                 self.all_waits_finished.post(self.h5_file)
cbilling:             except Exception:
cbilling:                 if self.abort:
cbilling:                     return
cbilling:                 else:
cbilling:                     raise
cbilling:     
cbilling:     def send_resume_trigger(self, pulse_width):
cbilling:         written = int32()
cbilling:         # go high:
cbilling:         self.timeout_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,numpy.ones(1, dtype=numpy.uint8),byref(written),None)
cbilling:         assert written.value == 1
cbilling:         # Wait however long we observed the first pulse of the experiment to be:
cbilling:         time.sleep(pulse_width)
cbilling:         # go high:
cbilling:         self.timeout_task.WriteDigitalLines(1,True,1,DAQmx_Val_GroupByChannel,numpy.ones(1, dtype=numpy.uint8),byref(written),None)
cbilling:         assert written.value == 1
cbilling:         
cbilling:     def stop_task(self):
cbilling:         self.logger.debug('stop_task')
cbilling:         with self.daqlock:
cbilling:             self.logger.debug('stop_task got daqlock')
cbilling:             if self.task_running:
cbilling:                 self.task_running = False
cbilling:                 self.acquisition_task.StopTask()
cbilling:                 self.acquisition_task.ClearTask()
cbilling:                 self.timeout_task.StopTask()
cbilling:                 self.timeout_task.ClearTask()
cbilling:         self.logger.debug('finished stop_task')
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         self.logger.debug('transition_to_buffered')
cbilling:         # Save h5file path (for storing data later!)
cbilling:         self.h5_file = h5file
cbilling:         self.is_wait_monitor_device = False # Will be set to true in a moment if necessary
cbilling:         self.logger.debug('setup_task')
cbilling:         with h5py.File(h5file, 'r') as hdf5_file:
cbilling:             dataset = hdf5_file['waits']
cbilling:             if len(dataset) == 0:
cbilling:                 # There are no waits. Do nothing.
cbilling:                 self.logger.debug('There are no waits, not transitioning to buffered')
cbilling:                 self.waits_in_use = False
cbilling:                 self.wait_table = numpy.zeros((0,))
cbilling:                 return {}
cbilling:             self.waits_in_use = True
cbilling:             acquisition_device = dataset.attrs['wait_monitor_acquisition_device']
cbilling:             acquisition_connection = dataset.attrs['wait_monitor_acquisition_connection']
cbilling:             timeout_device = dataset.attrs['wait_monitor_timeout_device']
cbilling:             timeout_connection = dataset.attrs['wait_monitor_timeout_connection']
cbilling:             self.wait_table = dataset[:]
cbilling:         # Only do anything if we are in fact the wait_monitor device:
cbilling:         if timeout_device == device_name or acquisition_device == device_name:
cbilling:             if not timeout_device == device_name and acquisition_device == device_name:
cbilling:                 raise NotImplementedError("NI-USB-6343 worker must be both the wait monitor timeout device and acquisition device." +
cbilling:                                           "Being only one could be implemented if there's a need for it, but it isn't at the moment")
cbilling:             self.is_wait_monitor_device = True
cbilling:             # The counter acquisition task:
cbilling:             self.acquisition_task = Task()
cbilling:             acquisition_chan = '/'.join([self.MAX_name,acquisition_connection])
cbilling:             self.acquisition_task.CreateCISemiPeriodChan(acquisition_chan, '', 100e-9, 200, DAQmx_Val_Seconds, "")    
cbilling:             self.acquisition_task.CfgImplicitTiming(DAQmx_Val_ContSamps, 1000)
cbilling:             self.acquisition_task.StartTask()
cbilling:             # The timeout task:
cbilling:             self.timeout_task = Task()
cbilling:             timeout_chan = '/'.join([self.MAX_name,timeout_connection])
cbilling:             self.timeout_task.CreateDOChan(timeout_chan,"",DAQmx_Val_ChanForAllLines)
cbilling:             self.task_running = True
cbilling:                 
cbilling:             # An array to store the results of counter acquisition:
cbilling:             self.half_periods = []
cbilling:             self.read_thread = threading.Thread(target=self.daqmx_read)
cbilling:             # Not a daemon thread, as it implements wait timeouts - we need it to stay alive if other things die.
cbilling:             self.read_thread.start()
cbilling:             self.logger.debug('finished transition to buffered')
cbilling:             
cbilling:         return {}
cbilling:     
cbilling:     def transition_to_manual(self,abort=False):
cbilling:         self.logger.debug('transition_to_static')
cbilling:         self.abort = abort
cbilling:         self.stop_task()
cbilling:         # Reset the abort flag so that unexpected exceptions are still raised:        
cbilling:         self.abort = False
cbilling:         self.logger.info('transitioning to static, task stopped')
cbilling:         # save the data acquired to the h5 file
cbilling:         if not abort:
cbilling:             if self.waits_in_use:
cbilling:                 # Let's work out how long the waits were. The absolute times of each edge on the wait
cbilling:                 # monitor were:
cbilling:                 edge_times = numpy.cumsum(self.half_periods)
cbilling:                 # Now there was also a rising edge at t=0 that we didn't measure:
cbilling:                 edge_times = numpy.insert(edge_times,0,0)
cbilling:                 # Ok, and the even-indexed ones of these were rising edges.
cbilling:                 rising_edge_times = edge_times[::2]
cbilling:                 # Now what were the times between rising edges?
cbilling:                 periods = numpy.diff(rising_edge_times)
cbilling:                 # How does this compare to how long we expected there to be between the start
cbilling:                 # of the experiment and the first wait, and then between each pair of waits?
cbilling:                 # The difference will give us the waits' durations.
cbilling:                 resume_times = self.wait_table['time']
cbilling:                 # Again, include the start of the experiment, t=0:
cbilling:                 resume_times =  numpy.insert(resume_times,0,0)
cbilling:                 run_periods = numpy.diff(resume_times)
cbilling:                 wait_durations = periods - run_periods
cbilling:                 waits_timed_out = wait_durations > self.wait_table['timeout']
cbilling:             with h5py.File(self.h5_file,'a') as hdf5_file:
cbilling:                 # Work out how long the waits were, save em, post an event saying so 
cbilling:                 dtypes = [('label','a256'),('time',float),('timeout',float),('duration',float),('timed_out',bool)]
cbilling:                 data = numpy.empty(len(self.wait_table), dtype=dtypes)
cbilling:                 if self.waits_in_use:
cbilling:                     data['label'] = self.wait_table['label']
cbilling:                     data['time'] = self.wait_table['time']
cbilling:                     data['timeout'] = self.wait_table['timeout']
cbilling:                     data['duration'] = wait_durations
cbilling:                     data['timed_out'] = waits_timed_out
cbilling:                 if self.is_wait_monitor_device:
cbilling:                     hdf5_file.create_dataset('/data/waits', data=data)
cbilling:             if self.is_wait_monitor_device:
cbilling:                 self.wait_durations_analysed.post(self.h5_file)
cbilling:         
cbilling:         return True
cbilling:     
cbilling:     def abort_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         #TODO: test this
cbilling:         return self.transition_to_manual(True)   
cbilling:     
cbilling:     def program_manual(self,values):
cbilling:         return {}
cbilling: 
cbilling:  
cbilling:     
cbilling: @runviewer_parser
cbilling: class RunviewerClass(parent.RunviewerClass):
cbilling:     num_digitals = 32
cbilling:     
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /NovaTechDDS9M.py                                                 #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of the module labscript_devices, in the         #
cbilling: # labscript suite (see http://labscriptsuite.org), and is           #
cbilling: # licensed under the Simplified BSD License. See the license.txt    #
cbilling: # file in the root of the project for the full license.             #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: from labscript_devices import runviewer_parser, labscript_device, BLACS_tab, BLACS_worker
cbilling: 
spielman: from labscript import IntermediateDevice, DDS, StaticDDS, Device, config, LabscriptError, set_passed_properties
cbilling: from labscript_utils.unitconversions import NovaTechDDS9mFreqConversion, NovaTechDDS9mAmpConversion
cbilling: 
cbilling: import numpy as np
cbilling: import labscript_utils.h5_lock, h5py
  rander: import labscript_utils.properties
  rander: 
cbilling:         
cbilling: @labscript_device
cbilling: class NovaTechDDS9M(IntermediateDevice):
cbilling:     description = 'NT-DDS9M'
cbilling:     allowed_children = [DDS, StaticDDS]
pstarkey:     clock_limit = 9990 # This is a realistic estimate of the max clock rate (100us for TS/pin10 processing to load next value into buffer and 100ns pipeline delay on pin 14 edge to update output values)
pstarkey: 
  rander:     @set_passed_properties(
   Chris:         property_names = {'connection_table_properties': ['update_mode', 'synchronous_first_line_repeat']}
  rander:         )
spielman:     def __init__(self, name, parent_device, 
   Chris:                  com_port = "", baud_rate=115200, update_mode='synchronous', synchronous_first_line_repeat=False, **kwargs):
spielman: 
spielman:         IntermediateDevice.__init__(self, name, parent_device, **kwargs)
cbilling:         self.BLACS_connection = '%s,%s'%(com_port, str(baud_rate))
cbilling:         if not update_mode in ['synchronous', 'asynchronous']:
spielman:             raise LabscriptError('update_mode must be \'synchronous\' or \'asynchronous\'')            
spielman:         
spielman:         self.update_mode = update_mode        
   Chris:         self.synchronous_first_line_repeat = synchronous_first_line_repeat
spielman:         
cbilling:     def add_device(self, device):
cbilling:         Device.add_device(self, device)
cbilling:         # The Novatech doesn't support 0Hz output; set the default frequency of the DDS to 0.1 Hz:
cbilling:         device.frequency.default_value = 0.1
cbilling:             
cbilling:     def get_default_unit_conversion_classes(self, device):
cbilling:         """Child devices call this during their __init__ (with themselves
cbilling:         as the argument) to check if there are certain unit calibration
cbilling:         classes that they should apply to their outputs, if the user has
cbilling:         not otherwise specified a calibration class"""
cbilling:         if device.connection in ['channel 0', 'channel 1']:
cbilling:             # Default calibration classes for the non-static channels:
cbilling:             return NovaTechDDS9mFreqConversion, NovaTechDDS9mAmpConversion, None
cbilling:         else:
cbilling:             return None, None, None
cbilling:         
cbilling:         
cbilling:     def quantise_freq(self, data, device):
cbilling:         if not isinstance(data, np.ndarray):
cbilling:             data = np.array(data)
cbilling:         # Ensure that frequencies are within bounds:
cbilling:         if np.any(data > 171e6 )  or np.any(data < 0.1 ):
cbilling:             raise LabscriptError('%s %s '%(device.description, device.name) +
cbilling:                               'can only have frequencies between 0.1Hz and 171MHz, ' + 
cbilling:                               'the limit imposed by %s.'%self.name)
cbilling:         # It's faster to add 0.5 then typecast than to round to integers first:
cbilling:         data = np.array((10*data)+0.5,dtype=np.uint32)
cbilling:         scale_factor = 10
cbilling:         return data, scale_factor
cbilling:         
cbilling:     def quantise_phase(self, data, device):
cbilling:         if not isinstance(data, np.ndarray):
cbilling:             data = np.array(data)
cbilling:         # ensure that phase wraps around:
cbilling:         data %= 360
cbilling:         # It's faster to add 0.5 then typecast than to round to integers first:
cbilling:         data = np.array((45.511111111111113*data)+0.5,dtype=np.uint16)
cbilling:         scale_factor = 45.511111111111113
cbilling:         return data, scale_factor
cbilling:         
cbilling:     def quantise_amp(self,data,device):
cbilling:         if not isinstance(data, np.ndarray):
cbilling:             data = np.array(data)
cbilling:         # ensure that amplitudes are within bounds:
cbilling:         if np.any(data > 1 )  or np.any(data < 0):
cbilling:             raise LabscriptError('%s %s '%(device.description, device.name) +
cbilling:                               'can only have amplitudes between 0 and 1 (Volts peak to peak approx), ' + 
cbilling:                               'the limit imposed by %s.'%self.name)
cbilling:         # It's faster to add 0.5 then typecast than to round to integers first:
cbilling:         data = np.array((1023*data)+0.5,dtype=np.uint16)
cbilling:         scale_factor = 1023
cbilling:         return data, scale_factor
cbilling:         
cbilling:     def generate_code(self, hdf5_file):
cbilling:         DDSs = {}
cbilling:         for output in self.child_devices:
cbilling:             # Check that the instructions will fit into RAM:
cbilling:             if isinstance(output, DDS) and len(output.frequency.raw_output) > 16384 - 2: # -2 to include space for dummy instructions
cbilling:                 raise LabscriptError('%s can only support 16383 instructions. '%self.name +
cbilling:                                      'Please decrease the sample rates of devices on the same clock, ' + 
cbilling:                                      'or connect %s to a different pseudoclock.'%self.name)
cbilling:             try:
cbilling:                 prefix, channel = output.connection.split()
cbilling:                 channel = int(channel)
cbilling:             except:
cbilling:                 raise LabscriptError('%s %s has invalid connection string: \'%s\'. '%(output.description,output.name,str(output.connection)) + 
cbilling:                                      'Format must be \'channel n\' with n from 0 to 4.')
cbilling:             DDSs[channel] = output
cbilling:         for connection in DDSs:
pstarkey:             if connection in range(4):
cbilling:                 # Dynamic DDS
cbilling:                 dds = DDSs[connection]   
cbilling:                 dds.frequency.raw_output, dds.frequency.scale_factor = self.quantise_freq(dds.frequency.raw_output, dds)
cbilling:                 dds.phase.raw_output, dds.phase.scale_factor = self.quantise_phase(dds.phase.raw_output, dds)
cbilling:                 dds.amplitude.raw_output, dds.amplitude.scale_factor = self.quantise_amp(dds.amplitude.raw_output, dds)
pstarkey:             # elif connection in range(2,4):
pstarkey:                 # # StaticDDS:
pstarkey:                 # dds = DDSs[connection]   
pstarkey:                 # dds.frequency.raw_output, dds.frequency.scale_factor = self.quantise_freq(dds.frequency.static_value, dds)
pstarkey:                 # dds.phase.raw_output, dds.phase.scale_factor = self.quantise_phase(dds.phase.static_value, dds)
pstarkey:                 # dds.amplitude.raw_output, dds.amplitude.scale_factor = self.quantise_amp(dds.amplitude.static_value, dds)
cbilling:             else:
cbilling:                 raise LabscriptError('%s %s has invalid connection string: \'%s\'. '%(dds.description,dds.name,str(dds.connection)) + 
cbilling:                                      'Format must be \'channel n\' with n from 0 to 4.')
cbilling:                                 
cbilling:         dtypes = [('freq%d'%i,np.uint32) for i in range(2)] + \
cbilling:                  [('phase%d'%i,np.uint16) for i in range(2)] + \
cbilling:                  [('amp%d'%i,np.uint16) for i in range(2)]
cbilling:                  
cbilling:         static_dtypes = [('freq%d'%i,np.uint32) for i in range(2,4)] + \
cbilling:                         [('phase%d'%i,np.uint16) for i in range(2,4)] + \
cbilling:                         [('amp%d'%i,np.uint16) for i in range(2,4)]
pstarkey:          
pstarkey:         clockline = self.parent_clock_line
pstarkey:         pseudoclock = clockline.parent_device
pstarkey:         times = pseudoclock.times[clockline]
pstarkey:        
cbilling:         out_table = np.zeros(len(times),dtype=dtypes)
cbilling:         out_table['freq0'].fill(1)
cbilling:         out_table['freq1'].fill(1)
cbilling:         
cbilling:         static_table = np.zeros(1, dtype=static_dtypes)
cbilling:         static_table['freq2'].fill(1)
cbilling:         static_table['freq3'].fill(1)
cbilling:         
cbilling:         for connection in range(2):
cbilling:             if not connection in DDSs:
cbilling:                 continue
cbilling:             dds = DDSs[connection]
cbilling:             # The last two instructions are left blank, for BLACS
cbilling:             # to fill in at program time.
cbilling:             out_table['freq%d'%connection][:] = dds.frequency.raw_output
cbilling:             out_table['amp%d'%connection][:] = dds.amplitude.raw_output
cbilling:             out_table['phase%d'%connection][:] = dds.phase.raw_output
cbilling:         for connection in range(2,4):
cbilling:             if not connection in DDSs:
cbilling:                 continue
cbilling:             dds = DDSs[connection]
pstarkey:             static_table['freq%d'%connection] = dds.frequency.raw_output[0]
pstarkey:             static_table['amp%d'%connection] = dds.amplitude.raw_output[0]
pstarkey:             static_table['phase%d'%connection] = dds.phase.raw_output[0]
cbilling:             
   Chris:         if self.update_mode == 'asynchronous' or self.synchronous_first_line_repeat:
   Chris:             # Duplicate the first line of the table. Otherwise, we are one step
   Chris:             # ahead in the table from the start of a run. In asynchronous
   Chris:             # updating mode, this is necessary since the first line of the
   Chris:             # table is already being output before the first trigger from
   Chris:             # the master clock. When using a simple delay line for synchronous
   Chris:             # output, this also seems to be required, in which case
   Chris:             # synchronous_first_line_repeat should be set to True.
   Chris:             # However, when a tristate driver is used as described at
   Chris:             # http://labscriptsuite.org/blog/implementation-of-the-novatech-dds9m/
   Chris:             # then is is not neccesary to duplicate the first line. Use of a
   Chris:             # tristate driver in this way is the correct way to use
   Chris:             # the novatech DDS, as per its instruction manual, and so is likely
   Chris:             # to be the most reliable. However, through trial and error we've
   Chris:             # determined that duplicating the first line like this gives correct
   Chris:             # output in asynchronous mode and in synchronous mode when using a
   Chris:             # simple delay line, at least for the specific device we tested.
   Chris:             # Your milage may vary.
cbilling:             out_table = np.concatenate([out_table[0:1], out_table])
  rander: 
spielman:         grp = self.init_device_group(hdf5_file)
cbilling:         grp.create_dataset('TABLE_DATA',compression=config.compression,data=out_table) 
cbilling:         grp.create_dataset('STATIC_DATA',compression=config.compression,data=static_table) 
cbilling:         self.set_property('frequency_scale_factor', 10, location='device_properties')
cbilling:         self.set_property('amplitude_scale_factor', 1023, location='device_properties')
cbilling:         self.set_property('phase_scale_factor', 45.511111111111113, location='device_properties')
cbilling: 
cbilling: 
cbilling: 
cbilling: import time
cbilling: 
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: 
cbilling: from blacs.device_base_class import DeviceTab
cbilling: 
cbilling: @BLACS_tab
cbilling: class NovatechDDS9MTab(DeviceTab):
cbilling:     def initialise_GUI(self):        
cbilling:         # Capabilities
cbilling:         self.base_units =    {'freq':'Hz',          'amp':'Arb',   'phase':'Degrees'}
cbilling:         self.base_min =      {'freq':0.0,           'amp':0,       'phase':0}
cbilling:         self.base_max =      {'freq':170.0*10.0**6, 'amp':1,       'phase':360}
cbilling:         self.base_step =     {'freq':10**6,         'amp':1/1023., 'phase':1}
cbilling:         self.base_decimals = {'freq':1,             'amp':4,       'phase':3} # TODO: find out what the phase precision is!
cbilling:         self.num_DDS = 4
cbilling:         
cbilling:         # Create DDS Output objects
cbilling:         dds_prop = {}
cbilling:         for i in range(self.num_DDS): # 4 is the number of DDS outputs on this device
cbilling:             dds_prop['channel %d'%i] = {}
cbilling:             for subchnl in ['freq', 'amp', 'phase']:
cbilling:                 dds_prop['channel %d'%i][subchnl] = {'base_unit':self.base_units[subchnl],
cbilling:                                                      'min':self.base_min[subchnl],
cbilling:                                                      'max':self.base_max[subchnl],
cbilling:                                                      'step':self.base_step[subchnl],
cbilling:                                                      'decimals':self.base_decimals[subchnl]
cbilling:                                                     }
cbilling:         # Create the output objects    
cbilling:         self.create_dds_outputs(dds_prop)        
cbilling:         # Create widgets for output objects
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         # and auto place the widgets in the UI
cbilling:         self.auto_place_widgets(("DDS Outputs",dds_widgets))
cbilling:         
cbilling:         connection_object = self.settings['connection_table'].find_by_name(self.device_name)
cbilling:         
cbilling:         # Store the COM port to be used
cbilling:         blacs_connection =  str(connection_object.BLACS_connection)
cbilling:         if ',' in blacs_connection:
cbilling:             self.com_port, baud_rate = blacs_connection.split(',')
cbilling:             self.baud_rate = int(baud_rate)
cbilling:         else:
cbilling:             self.com_port = blacs_connection
cbilling:             self.baud_rate = 115200
cbilling:         
cbilling:         self.update_mode = connection_object.properties.get('update_mode', 'synchronous')
cbilling:         
cbilling:         # Create and set the primary worker
cbilling:         self.create_worker("main_worker",NovatechDDS9mWorker,{'com_port':self.com_port,
cbilling:                                                               'baud_rate': self.baud_rate,
cbilling:                                                               'update_mode': self.update_mode})
cbilling:         self.primary_worker = "main_worker"
cbilling: 
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(True)
cbilling:         self.supports_smart_programming(True) 
cbilling: 
cbilling: @BLACS_worker        
cbilling: class NovatechDDS9mWorker(Worker):
cbilling:     def init(self):
cbilling:         global serial; import serial
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         self.smart_cache = {'STATIC_DATA': None, 'TABLE_DATA': ''}
cbilling:         
cbilling:         self.connection = serial.Serial(self.com_port, baudrate = self.baud_rate, timeout=0.1)
cbilling:         self.connection.readlines()
cbilling:         
cbilling:         self.connection.write('e d\r\n')
cbilling:         response = self.connection.readline()
cbilling:         if response == 'e d\r\n':
cbilling:             # if echo was enabled, then the command to disable it echos back at us!
cbilling:             response = self.connection.readline()
cbilling:         if response != "OK\r\n":
cbilling:             raise Exception('Error: Failed to execute command: "e d". Cannot connect to the device.')
cbilling:         
cbilling:         self.connection.write('I a\r\n')
cbilling:         if self.connection.readline() != "OK\r\n":
cbilling:             raise Exception('Error: Failed to execute command: "I a"')
cbilling:         
cbilling:         self.connection.write('m 0\r\n')
cbilling:         if self.connection.readline() != "OK\r\n":
cbilling:             raise Exception('Error: Failed to execute command: "m 0"')
cbilling:         
cbilling:         #return self.get_current_values()
cbilling:         
cbilling:     def check_remote_values(self):
cbilling:         # Get the currently output values:
cbilling:         self.connection.write('QUE\r\n')
cbilling:         try:
cbilling:             response = [self.connection.readline() for i in range(5)]
cbilling:         except socket.timeout:
cbilling:             raise Exception('Failed to execute command "QUE". Cannot connect to device.')
cbilling:         results = {}
cbilling:         for i, line in enumerate(response[:4]):
cbilling:             results['channel %d'%i] = {}
cbilling:             freq, phase, amp, ignore, ignore, ignore, ignore = line.split()
cbilling:             # Convert hex multiple of 0.1 Hz to MHz:
cbilling:             results['channel %d'%i]['freq'] = float(int(freq,16))/10.0
cbilling:             # Convert hex to int:
cbilling:             results['channel %d'%i]['amp'] = int(amp,16)/1023.0
cbilling:             # Convert hex fraction of 16384 to degrees:
cbilling:             results['channel %d'%i]['phase'] = int(phase,16)*360/16384.0
cbilling:         return results
cbilling:         
cbilling:     def program_manual(self,front_panel_values):
cbilling:         # TODO: Optimise this so that only items that have changed are reprogrammed by storing the last programmed values
cbilling:         # For each DDS channel,
cbilling:         for i in range(4):    
cbilling:             # and for each subchnl in the DDS,
cbilling:             for subchnl in ['freq','amp','phase']:     
cbilling:                 # Program the sub channel
cbilling:                 self.program_static(i,subchnl,front_panel_values['channel %d'%i][subchnl])
cbilling:         return self.check_remote_values()
cbilling: 
cbilling:     def program_static(self,channel,type,value):
cbilling:         if type == 'freq':
cbilling:             command = 'F%d %.7f\r\n'%(channel,value/10.0**6)
cbilling:             self.connection.write(command)
cbilling:             if self.connection.readline() != "OK\r\n":
cbilling:                 raise Exception('Error: Failed to execute command: %s'%command)
cbilling:         elif type == 'amp':
cbilling:             command = 'V%d %u\r\n'%(channel,int(value*1023+0.5))
cbilling:             self.connection.write(command)
cbilling:             if self.connection.readline() != "OK\r\n":
cbilling:                 raise Exception('Error: Failed to execute command: %s'%command)
cbilling:         elif type == 'phase':
cbilling:             command = 'P%d %u\r\n'%(channel,value*16384/360)
cbilling:             self.connection.write(command)
cbilling:             if self.connection.readline() != "OK\r\n":
cbilling:                 raise Exception('Error: Failed to execute command: %s'%command)
cbilling:         else:
cbilling:             raise TypeError(type)
cbilling:         # Now that a static update has been done, we'd better invalidate the saved STATIC_DATA:
cbilling:         self.smart_cache['STATIC_DATA'] = None
cbilling:      
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # Store the initial values in case we have to abort and restore them:
cbilling:         self.initial_values = initial_values
cbilling:         # Store the final values to for use during transition_to_static:
cbilling:         self.final_values = {}
cbilling:         static_data = None
cbilling:         table_data = None
cbilling:         with h5py.File(h5file) as hdf5_file:
cbilling:             group = hdf5_file['/devices/'+device_name]
cbilling:             # If there are values to set the unbuffered outputs to, set them now:
cbilling:             if 'STATIC_DATA' in group:
cbilling:                 static_data = group['STATIC_DATA'][:][0]
cbilling:             # Now program the buffered outputs:
cbilling:             if 'TABLE_DATA' in group:
cbilling:                 table_data = group['TABLE_DATA'][:]
cbilling:         
cbilling:         if static_data is not None:
cbilling:             data = static_data
cbilling:             if fresh or data != self.smart_cache['STATIC_DATA']:
cbilling:                 self.logger.debug('Static data has changed, reprogramming.')
cbilling:                 self.smart_cache['STATIC_DATA'] = data
cbilling:                 self.connection.write('F2 %.7f\r\n'%(data['freq2']/10.0**7))
cbilling:                 self.connection.readline()
cbilling:                 self.connection.write('V2 %u\r\n'%(data['amp2']))
cbilling:                 self.connection.readline()
cbilling:                 self.connection.write('P2 %u\r\n'%(data['phase2']))
cbilling:                 self.connection.readline()
cbilling:                 self.connection.write('F3 %.7f\r\n'%(data['freq3']/10.0**7))
cbilling:                 self.connection.readline()
cbilling:                 self.connection.write('V3 %u\r\n'%data['amp3'])
cbilling:                 self.connection.readline()
cbilling:                 self.connection.write('P3 %u\r\n'%data['phase3'])
cbilling:                 self.connection.readline()
cbilling:                 
cbilling:                 # Save these values into final_values so the GUI can
cbilling:                 # be updated at the end of the run to reflect them:
cbilling:                 self.final_values['channel 2'] = {}
cbilling:                 self.final_values['channel 3'] = {}
cbilling:                 self.final_values['channel 2']['freq'] = data['freq2']/10.0
cbilling:                 self.final_values['channel 3']['freq'] = data['freq3']/10.0
cbilling:                 self.final_values['channel 2']['amp'] = data['amp2']/1023.0
cbilling:                 self.final_values['channel 3']['amp'] = data['amp3']/1023.0
cbilling:                 self.final_values['channel 2']['phase'] = data['phase2']*360/16384.0
cbilling:                 self.final_values['channel 3']['phase'] = data['phase3']*360/16384.0
cbilling:                     
cbilling:         # Now program the buffered outputs:
cbilling:         if table_data is not None:
cbilling:             data = table_data
cbilling:             for i, line in enumerate(data):
cbilling:                 st = time.time()
cbilling:                 oldtable = self.smart_cache['TABLE_DATA']
cbilling:                 for ddsno in range(2):
cbilling:                     if fresh or i >= len(oldtable) or (line['freq%d'%ddsno],line['phase%d'%ddsno],line['amp%d'%ddsno]) != (oldtable[i]['freq%d'%ddsno],oldtable[i]['phase%d'%ddsno],oldtable[i]['amp%d'%ddsno]):
cbilling:                         self.connection.write('t%d %04x %08x,%04x,%04x,ff\r\n'%(ddsno, i,line['freq%d'%ddsno],line['phase%d'%ddsno],line['amp%d'%ddsno]))
cbilling:                         self.connection.readline()
cbilling:                 et = time.time()
cbilling:                 tt=et-st
cbilling:                 self.logger.debug('Time spent on line %s: %s'%(i,tt))
cbilling:             # Store the table for future smart programming comparisons:
cbilling:             try:
cbilling:                 self.smart_cache['TABLE_DATA'][:len(data)] = data
cbilling:                 self.logger.debug('Stored new table as subset of old table')
cbilling:             except: # new table is longer than old table
cbilling:                 self.smart_cache['TABLE_DATA'] = data
cbilling:                 self.logger.debug('New table is longer than old table and has replaced it.')
cbilling:                 
cbilling:             # Get the final values of table mode so that the GUI can
cbilling:             # reflect them after the run:
cbilling:             self.final_values['channel 0'] = {}
cbilling:             self.final_values['channel 1'] = {}
cbilling:             self.final_values['channel 0']['freq'] = data[-1]['freq0']/10.0
cbilling:             self.final_values['channel 1']['freq'] = data[-1]['freq1']/10.0
cbilling:             self.final_values['channel 0']['amp'] = data[-1]['amp0']/1023.0
cbilling:             self.final_values['channel 1']['amp'] = data[-1]['amp1']/1023.0
cbilling:             self.final_values['channel 0']['phase'] = data[-1]['phase0']*360/16384.0
cbilling:             self.final_values['channel 1']['phase'] = data[-1]['phase1']*360/16384.0
cbilling:             
cbilling:             # Transition to table mode:
cbilling:             self.connection.write('m t\r\n')
cbilling:             self.connection.readline()
cbilling:             if self.update_mode == 'synchronous':
cbilling:                 # Transition to hardware synchronous updates:
cbilling:                 self.connection.write('I e\r\n')
cbilling:                 self.connection.readline()
cbilling:                 # We are now waiting for a rising edge to trigger the output
cbilling:                 # of the second table pair (first of the experiment)
cbilling:             elif self.update_mode == 'asynchronous':
cbilling:                 # Output will now be updated on falling edges.
cbilling:                 pass
cbilling:             else:
cbilling:                 raise ValueError('invalid update mode %s'%str(self.update_mode))
cbilling:                 
cbilling:             
cbilling:         return self.final_values
cbilling:     
cbilling:     def abort_transition_to_buffered(self):
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_buffered(self):
cbilling:         # TODO: untested
cbilling:         return self.transition_to_manual(True)
cbilling:     
cbilling:     def transition_to_manual(self,abort = False):
cbilling:         self.connection.write('m 0\r\n')
cbilling:         if self.connection.readline() != "OK\r\n":
cbilling:             raise Exception('Error: Failed to execute command: "m 0"')
cbilling:         self.connection.write('I a\r\n')
cbilling:         if self.connection.readline() != "OK\r\n":
cbilling:             raise Exception('Error: Failed to execute command: "I a"')
cbilling:         if abort:
cbilling:             # If we're aborting the run, then we need to reset DDSs 2 and 3 to their initial values.
cbilling:             # 0 and 1 will already be in their initial values. We also need to invalidate the smart
cbilling:             # programming cache for them.
cbilling:             values = self.initial_values
cbilling:             DDSs = [2,3]
cbilling:             self.smart_cache['STATIC_DATA'] = None
cbilling:         else:
cbilling:             # If we're not aborting the run, then we need to set DDSs 0 and 1 to their final values.
cbilling:             # 2 and 3 will already be in their final values.
cbilling:             values = self.final_values
cbilling:             DDSs = [0,1]
cbilling:             
cbilling:         # only program the channels that we need to
cbilling:         for ddsnumber in DDSs:
cbilling:             channel_values = values['channel %d'%ddsnumber]
cbilling:             for subchnl in ['freq','amp','phase']:            
cbilling:                 self.program_static(ddsnumber,subchnl,channel_values[subchnl])
cbilling:             
cbilling:         # return True to indicate we successfully transitioned back to manual mode
cbilling:         return True
cbilling:                      
cbilling:     def shutdown(self):
cbilling:         self.connection.close()
cbilling:         
cbilling:         
cbilling:         
cbilling: @runviewer_parser
cbilling: class RunviewerClass(object):    
pstarkey:     def __init__(self, path, device):
cbilling:         self.path = path
pstarkey:         self.name = device.name
pstarkey:         self.device = device
cbilling:             
pstarkey:     def get_traces(self, add_trace, clock=None):
cbilling:         if clock is None:
cbilling:             # we're the master pseudoclock, software triggered. So we don't have to worry about trigger delays, etc
cbilling:             raise Exception('No clock passed to %s. The NovaTechDDS9M must be clocked by another device.'%self.name)
cbilling:         
cbilling:         times, clock_value = clock[0], clock[1]
cbilling:         
cbilling:         clock_indices = np.where((clock_value[1:]-clock_value[:-1])==1)[0]+1
cbilling:         # If initial clock value is 1, then this counts as a rising edge (clock should be 0 before experiment)
cbilling:         # but this is not picked up by the above code. So we insert it!
cbilling:         if clock_value[0] == 1:
cbilling:             clock_indices = np.insert(clock_indices, 0, 0)
cbilling:         clock_ticks = times[clock_indices]
cbilling:         
cbilling:         # get the data out of the H5 file
cbilling:         data = {}
  rander:         with h5py.File(self.path, 'r') as hdf5_file:
  rander:             if 'TABLE_DATA' in hdf5_file['devices/%s' % self.name]:
  rander:                 table_data = hdf5_file['devices/%s/TABLE_DATA' % self.name][:]
  rander:                 connection_table_properties = labscript_utils.properties.get(hdf5_file, self.name, 'connection_table_properties')
  rander:                 update_mode = getattr(connection_table_properties, 'update_mode', 'synchronous')
  rander:                 synchronous_first_line_repeat = getattr(connection_table_properties, 'synchronous_first_line_repeat', False)
  rander:                 if update_mode == 'asynchronous' or synchronous_first_line_repeat:
  rander:                     table_data = table_data[1:]
cbilling:                 for i in range(2):
  rander:                     for sub_chnl in ['freq', 'amp', 'phase']:
cbilling:                         data['channel %d_%s'%(i,sub_chnl)] = table_data['%s%d'%(sub_chnl,i)][:]
cbilling:                                 
  rander:             if 'STATIC_DATA' in hdf5_file['devices/%s'%self.name]:
  rander:                 static_data = hdf5_file['devices/%s/STATIC_DATA'%self.name][:]
cbilling:                 for i in range(2,4):
  rander:                     for sub_chnl in ['freq', 'amp', 'phase']:
cbilling:                         data['channel %d_%s'%(i,sub_chnl)] = np.empty((len(clock_ticks),))
cbilling:                         data['channel %d_%s'%(i,sub_chnl)].fill(static_data['%s%d'%(sub_chnl,i)][0])
cbilling:             
cbilling:         
cbilling:         for channel, channel_data in data.items():
cbilling:             data[channel] = (clock_ticks, channel_data)
cbilling:         
pstarkey:         for channel_name, channel in self.device.child_list.items():
pstarkey:             for subchnl_name, subchnl in channel.child_list.items():
pstarkey:                 connection = '%s_%s'%(channel.parent_port, subchnl.parent_port)
pstarkey:                 if connection in data:
pstarkey:                     add_trace(subchnl.name, data[connection], self.name, connection)
pstarkey:         
pstarkey:         return {}
cbilling:     
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /phasematrixquicksyn.py                                           #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of labscript_devices, in the labscript suite    #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
  rander: import numpy as np
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: 
spielman: from labscript import Device, StaticDDS, StaticAnalogQuantity, StaticDigitalOut, config, LabscriptError, set_passed_properties
  rander: import labscript_utils.properties
cbilling: 
cbilling: class QuickSynDDS(StaticDDS):
cbilling:     """A StaticDDS that supports only frequency control, with no phase or amplitude control."""
cbilling:     description = 'PhaseMatrix QuickSyn DDS'
cbilling:     allowed_children = [StaticAnalogQuantity,StaticDigitalOut]
cbilling:     generation = 2
spielman:     
spielman:     @set_passed_properties()    
cbilling:     def __init__(self, name, parent_device, connection, freq_limits = None, freq_conv_class = None,freq_conv_params = {}):
cbilling:         Device.__init__(self,name,parent_device,connection)
cbilling:         self.frequency = StaticAnalogQuantity(self.name+'_freq',self,'freq',freq_limits,freq_conv_class,freq_conv_params)
cbilling:         self.frequency.default_value = 0.5e9
cbilling:         self.gate = StaticDigitalOut(self.name+'_gate',self,'gate')
cbilling:             
cbilling:     def setamp(self,value,units=None):
cbilling:         raise LabscriptError('QuickSyn does not support amplitude control')
cbilling:         
cbilling:     def setphase(self,value,units=None):
cbilling:         raise LabscriptError('QuickSyn does not support phase control')
cbilling:             
cbilling:     def enable(self):       
cbilling:         """overridden from StaticDDS so as not to provide time resolution -
cbilling:         output can be enabled or disabled only at the start of the shot"""
cbilling:         self.gate.go_high()
cbilling:                             
cbilling:     def disable(self):
cbilling:         """overridden from StaticDDS so as not to provide time resolution -
cbilling:         output can be enabled or disabled only at the start of the shot"""
cbilling:         self.gate.go_low()
cbilling:         
cbilling: @labscript_device              
cbilling: class PhaseMatrixQuickSyn(Device):
cbilling:     description = 'QuickSyn Frequency Synthesiser'
pstarkey:     allowed_children = [QuickSynDDS]
cbilling:     generation = 0
spielman: 
  rander:     @set_passed_properties()
cbilling:     def __init__(self, name,com_port):
cbilling:         Device.__init__(self, name, None, None)
cbilling:         self.BLACS_connection = com_port
cbilling:         
cbilling:     def quantise_freq(self,data, device):
cbilling:         # Ensure that frequencies are within bounds:
cbilling:         if any(data > 10e9 )  or any(data < 0.5e9 ):
cbilling:             raise LabscriptError('%s %s '%(device.description, device.name) +
cbilling:                               'can only have frequencies between 0.5GHz and 10GHz, ' + 
cbilling:                               'the limit imposed by %s.'%self.name)
cbilling:         # It's faster to add 0.5 then typecast than to round to integers first (device is programmed in mHz):
cbilling:         data = np.array((1000*data)+0.5, dtype=np.uint64)
cbilling:         scale_factor = 1000
cbilling:         return data, scale_factor
cbilling:     
cbilling:     def generate_code(self, hdf5_file):
cbilling:         for output in self.child_devices:
cbilling:             try:
cbilling:                 prefix, channel = output.connection.split()
cbilling:                 channel = int(channel)
cbilling:             except:
cbilling:                 raise LabscriptError('%s %s has invalid connection string: \'%s\'. '%(output.description,output.name,str(output.connection)) + 
cbilling:                                      'Format must be \'channel n\' with n equal 0.')
cbilling:             if channel != 0:
cbilling:                 raise LabscriptError('%s %s has invalid connection string: \'%s\'. '%(output.description,output.name,str(output.connection)) + 
cbilling:                                      'Format must be \'channel n\' with n equal 0.')
cbilling:             dds = output
cbilling:         # Call these functions to finalise stuff:
cbilling:         ignore = dds.frequency.get_change_times()
cbilling:         dds.frequency.make_timeseries([])
cbilling:         dds.frequency.expand_timeseries()
cbilling:         
cbilling:         ignore = dds.gate.get_change_times()
cbilling:         dds.gate.make_timeseries([])
cbilling:         dds.gate.expand_timeseries()
cbilling:         
cbilling:         dds.frequency.raw_output, dds.frequency.scale_factor = self.quantise_freq(dds.frequency.raw_output, dds)
cbilling:         static_dtypes = [('freq0', np.uint64)] + \
cbilling:                         [('gate0', np.uint16)]
cbilling:         static_table = np.zeros(1, dtype=static_dtypes)   
cbilling:         static_table['freq0'].fill(1)
cbilling:         static_table['freq0'] = dds.frequency.raw_output[0]
cbilling:         static_table['gate0'] = dds.gate.raw_output[0]
cbilling:         grp = hdf5_file.create_group('/devices/'+self.name)
cbilling:         grp.create_dataset('STATIC_DATA',compression=config.compression,data=static_table) 
pstarkey:         self.set_property('frequency_scale_factor', 1000, location='device_properties')
cbilling:         
cbilling:         
cbilling:         
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: from blacs.device_base_class import DeviceTab
cbilling: from qtutils import UiLoader
cbilling: import os
cbilling: 
cbilling: @BLACS_tab
cbilling: class PhaseMatrixQuickSynTab(DeviceTab):
cbilling:     def initialise_GUI(self):
cbilling:         # Create DDS Output objects
cbilling:         dds_prop = {'dds 0':{'freq':{'base_unit':   'Hz',
cbilling:                                      'min':         0.5e9,
cbilling:                                      'max':         10e9,
cbilling:                                      'step':        1e6,
cbilling:                                      'decimals':    3},
cbilling:                              'gate':{}
cbilling:                                  }
cbilling:                                  }
cbilling: 
cbilling:        
cbilling:         # Create the output objects    
cbilling:         self.create_dds_outputs(dds_prop)        
cbilling:         # Create widgets for output objects
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         # and auto place the widgets in the UI
cbilling:         self.auto_place_widgets(("DDS Outputs",dds_widgets))
cbilling:         
cbilling:         self.status_ui = UiLoader().load(os.path.join(os.path.dirname(os.path.realpath(__file__)),'phasematrixquicksyn.ui'))
cbilling:         self.get_tab_layout().addWidget(self.status_ui)
cbilling:         self.status_ui.ref_button.clicked.connect(self.update_reference_out)
cbilling:         self.status_ui.blanking_button.clicked.connect(self.update_blanking)
cbilling:         self.status_ui.lock_recovery_button.clicked.connect(self.update_lock_recovery)
cbilling:         
cbilling:         
cbilling:         # Store the COM port to be used
cbilling:         self.address = str(self.settings['connection_table'].find_by_name(self.settings["device_name"]).BLACS_connection)
cbilling:         
cbilling:         # Create and set the primary worker
cbilling:         self.create_worker("main_worker",QuickSynWorker,{'address':self.address})
cbilling:         self.primary_worker = "main_worker"
cbilling: 
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(True)
cbilling:         self.supports_smart_programming(False) 
cbilling:         self.statemachine_timeout_add(2000, self.status_monitor)
cbilling:         
cbilling:         
cbilling:         
cbilling: 
cbilling:     
cbilling:     # This function gets the status of the phasematrix,
cbilling:     # and updates the front panel widgets!
cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
cbilling:     def status_monitor(self):
cbilling:         # When called with a queue, this function writes to the queue
cbilling:         # when the pulseblaster is waiting. This indicates the end of
cbilling:         # an experimental run.
cbilling:         self.status = yield(self.queue_work(self._primary_worker,'check_status'))
cbilling:         #TODO: update some widgets to reflect the current state
cbilling:         self.status_ui.temperature_label.setText(str(self.status['temperature']))
cbilling:         
cbilling:         if self.status['freqlock']:
cbilling:             self.status_ui.freq_lock_label.setText('locked')
cbilling:         else:
cbilling:             self.status_ui.freq_lock_label.setText('unlocked')
cbilling:             
cbilling:         if self.status['reflock'] and self.status['ref']:
cbilling:             self.status_ui.ref_lock_label.setText('locked')
cbilling:         elif self.status['ref']:
cbilling:             self.status_ui.ref_lock_label.setText('unlocked')
cbilling:         else:
cbilling:             self.status_ui.ref_lock_label.setText('disconnected')
cbilling:             
cbilling:             
cbilling:         self.status_ui.ref_button.setChecked(self.status['ref_output'])
cbilling:         self.status_ui.blanking_button.setChecked(self.status['blanking'])
cbilling:         self.status_ui.lock_recovery_button.setChecked(self.status['lock_recovery'])
cbilling:         
cbilling:         
cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True,True)
cbilling:     def update_reference_out(self):
cbilling:         value = self.status_ui.ref_button.isChecked()
cbilling:         yield(self.queue_work(self._primary_worker,'update_reference_out',value))
cbilling:         
cbilling:     
cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True,True)
cbilling:     def update_blanking(self):
cbilling:         value = self.status_ui.blanking_button.isChecked()
cbilling:         yield(self.queue_work(self._primary_worker,'update_blanking',value))
cbilling:         
cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True,True)
cbilling:     def update_lock_recovery(self):
cbilling:         value = self.status_ui.lock_recovery_button.isChecked()
cbilling:         print value
cbilling:         yield(self.queue_work(self._primary_worker,'update_lock_recovery',value))
cbilling:        
cbilling: 
cbilling: @BLACS_worker
cbilling: class QuickSynWorker(Worker):
cbilling:     def init(self):
cbilling:         global serial; import serial
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global time; import time
cbilling:     
cbilling:         baud_rate=115200
cbilling:         port = self.address
cbilling:         self.connection = serial.Serial(port, baudrate = baud_rate, timeout=0.1)
cbilling:         self.connection.readlines()
cbilling:         
cbilling:         #check to see if the reference is set to external. If not, make it so! (should we ask the user about this?)
cbilling:         self.connection.write('ROSC:SOUR?\r')
cbilling:         response = self.connection.readline()
cbilling:         if response == 'INT\n':
cbilling:             #ref was set to internal, let's change it to ext
cbilling:             self.connection.write('ROSC:SOUR EXT\r')
cbilling:     
cbilling:     def check_remote_values(self):
cbilling:         # Get the currently output values:
cbilling: 
cbilling:         results = {'dds 0':{}}
cbilling:         line = ''
cbilling:         count = 0
cbilling: 
cbilling: 
cbilling:         self.connection.write('FREQ?\r')
cbilling:         line = self.connection.readline()
cbilling: 
cbilling:         if line == '':
cbilling:             #try again
cbilling:             line = self.connection.readline()
cbilling:             if line == '':
cbilling:                 raise Exception("Device didn't say what its frequncy was :(")
cbilling:             
cbilling:         # Convert mHz to Hz:
cbilling:         results['dds 0']['freq'] = float(line)/1000
cbilling: 
cbilling:         # wait a little while first, it doesn't like being asked things too quickly!
cbilling:         time.sleep(0.05)
cbilling:         self.connection.write('OUTP:STAT?\r')
cbilling:         line = self.connection.readline()
cbilling:         if line == '':
cbilling:             raise Exception("Device didn't say what its status was :(")
cbilling:         time.sleep(0.05)    
cbilling:             
cbilling: 
cbilling:         #get the gate status
cbilling:         results['dds 0']['gate'] = 0 if line == 'OFF\n' else 1
cbilling: 
cbilling: 
cbilling:         return results
cbilling:     
cbilling:     def check_status(self):
cbilling:         results = {}
cbilling:         line = ''
cbilling:         self.connection.write('STAT?\r')
cbilling:         line = self.connection.readline()
cbilling:         if line == '':
cbilling:             raise Exception("Device didn't say what its status was :(")
cbilling:         time.sleep(0.05)    
cbilling:             
cbilling:         
cbilling:         #get the status and convert to binary, and take off the '0b' header:
cbilling:         status = bin(int(line,16))[2:]
cbilling:         # if the status is less than 8 bits long, pad the start with zeros!
cbilling:         while len(status)<8:
cbilling:             status = '0'+status
cbilling:         # byte 0 is the 1 for an external ref, 0 for no external ref
cbilling:         results['ref'] = int(status[-1])
cbilling:         # byte 1 is high for rf unlocked, low for rf locked. This is silly, let's reverse it!
cbilling:         results['freqlock'] = int(not int(status[-2]))
cbilling:         # byte 2 is the high for ref unlocked, low for ref locked. Again, let's swap this!
cbilling:         results['reflock'] = int(not int(status[-3]))
cbilling:         # byte 3 tells us if the output is on or off,  we don't care since the check values function deals with this
cbilling:         
cbilling:         
cbilling:         # byte 4 will go high if there is a voltage error.
cbilling:         #In this case, we probably just want to raise an exception to get the user's attention
cbilling:         if int(status[-5]):
cbilling:             self.logger.critical('Device is reporting voltage error')
cbilling:             raise Exception('Voltage error')
cbilling:         # byte 5 tells us if the internal reference is being output
cbilling:         results['ref_output'] = int(status[-6])
cbilling:         # byte 6 tells us if blanking is on (i.e. turning off output while it changes frequency)
cbilling:         results['blanking'] = int(status[-7])
cbilling:         # byte 7 tells us if lock recovery is on,
cbilling:         
cbilling:         results['lock_recovery'] = int(status[-8])
cbilling:         
cbilling:         # now let's check it's temperature!
cbilling:         self.connection.write('DIAG:MEAS? 21\r')
cbilling:         results['temperature'] = float(self.connection.readline())
cbilling:         
cbilling:         # check if the temperature is bad, if it is, raise an exception. Hopefully one day this will be sent to syslog,
cbilling:         #at which point we'll add some extra magic to segregate into warning and critical temperatures.
cbilling:         
cbilling:         if results['temperature'] > 50.0:
cbilling:             raise Exception('WARNING: Temperature is too high! Temperature is %s'%results['temperature'])
cbilling:             return results
cbilling:         
cbilling:         return results
cbilling:     
cbilling:     def program_manual(self,front_panel_values):
cbilling:         freq = front_panel_values['dds 0']['freq']
cbilling:         #program in millihertz:
cbilling:         freq*=1e3
cbilling:         command = 'FREQ %i\r'%freq
cbilling:         self.connection.write(command)
cbilling:         
cbilling:         # add some sleep time here since the phasematrix gets grumpy
cbilling:         time.sleep(0.05)
cbilling:         
cbilling:         
cbilling:         gate = front_panel_values['dds 0']['gate']
cbilling:         command = 'OUTP:STAT %i\r'%gate
cbilling:         self.connection.write(command)
cbilling:         
cbilling:         return self.check_remote_values()
cbilling:         
cbilling:         
cbilling:     def update_reference_out(self,value):
cbilling:         pass
cbilling:         
cbilling:     def update_blanking(self,value):
cbilling:         pass
cbilling:         
cbilling:     def update_lock_recovery(self,value):
cbilling:         pass
cbilling:     
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         # Store the initial values in case we have to abort and restore them:
cbilling:         self.initial_values = initial_values
cbilling:         # Store the final values to for use during transition_to_static:
cbilling:         self.final_values = {}
cbilling:         with h5py.File(h5file) as hdf5_file:
cbilling:             group = hdf5_file['/devices/'+device_name]
cbilling:             # If there are values to set the unbuffered outputs to, set them now:
cbilling:             if 'STATIC_DATA' in group:
cbilling:                 data = group['STATIC_DATA'][:][0]
cbilling:                 
cbilling:         self.connection.write('FREQ %i\r'%(data['freq0']))
cbilling:         time.sleep(0.05)
cbilling:         self.connection.write('OUTP:STAT 1')#%i'%(data['gate0']))
cbilling:         
cbilling:         
cbilling:         # Save these values into final_values so the GUI can
cbilling:         # be updated at the end of the run to reflect them:
cbilling:         final_values = {'dds 0':{}}
cbilling:         
cbilling:         final_values['dds 0']['freq'] = data['freq0']/1e3
cbilling:         final_values['dds 0']['gate'] = 1#data['gate0']
cbilling:                 
cbilling:         return final_values
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         return self.transition_to_manual(True)
cbilling:         
cbilling:     def abort_buffered(self):
cbilling:         return self.transition_to_manual(True)
cbilling:     
cbilling: 
cbilling:     
cbilling:     def transition_to_manual(self,abort = False):
cbilling:         if abort:
cbilling:             # If we're aborting the run, reset to original value
cbilling:             self.program_manual(self.initial_values)
cbilling:         # If we're not aborting the run, stick with buffered value. Nothing to do really!
cbilling:         # return the current values in the device
cbilling:         return True
cbilling:         
cbilling:     def shutdown(self):
cbilling:         self.connection.close()
cbilling: 
pstarkey: #####################################################################
pstarkey: #                                                                   #
pstarkey: # /PineBlaster.py                                                   #
pstarkey: #                                                                   #
pstarkey: # Copyright 2013, Monash University                                 #
pstarkey: #                                                                   #
pstarkey: # This file is part of the module labscript_devices, in the         #
pstarkey: # labscript suite (see http://labscriptsuite.org), and is           #
pstarkey: # licensed under the Simplified BSD License. See the license.txt    #
pstarkey: # file in the root of the project for the full license.             #
pstarkey: #                                                                   #
pstarkey: #####################################################################
pstarkey: 
pstarkey: from labscript import PseudoclockDevice, Pseudoclock, ClockLine, config, LabscriptError, set_passed_properties
pstarkey: from labscript_devices import runviewer_parser, BLACS_tab, BLACS_worker, labscript_device
pstarkey: 
pstarkey: import numpy as np
pstarkey: import labscript_utils.h5_lock, h5py
  rander: import labscript_utils.properties
  rander: 
pstarkey: 
pstarkey: 
pstarkey: # Define a PineBlasterPseudoClock that only accepts one child clockline
pstarkey: class PineBlasterPseudoclock(Pseudoclock):    
pstarkey:     def add_device(self, device):
pstarkey:         if isinstance(device, ClockLine):
pstarkey:             # only allow one child
pstarkey:             if self.child_devices:
pstarkey:                 raise LabscriptError('The pseudoclock of the PineBlaster %s only supports 1 clockline, which is automatically created. Please use the clockline located at %s.clockline'%(self.parent_device.name, self.parent_device.name))
pstarkey:             Pseudoclock.add_device(self, device)
pstarkey:         else:
pstarkey:             raise LabscriptError('You have connected %s to %s (the Pseudoclock of %s), but %s only supports children that are ClockLines. Please connect your device to %s.clockline instead.'%(device.name, self.name, self.parent_device.name, self.name, self.parent_device.name))
pstarkey:  
pstarkey: @labscript_device     
pstarkey: class PineBlaster(PseudoclockDevice):
cbilling:     description = 'PineBlaster'
cbilling:     clock_limit = 10e6
cbilling:     clock_resolution = 25e-9
cbilling:     clock_type = 'fast clock'
  philip:     # Measured by Phil Starkey on 2015/9/24
  philip:     trigger_delay = 350e-9
cbilling:     # Todo: find out what this actually is:
cbilling:     wait_delay = 2.5e-6
pstarkey:     allowed_children = [PineBlasterPseudoclock]
cbilling:     
cbilling:     max_instructions = 15000
cbilling:     
spielman:     @set_passed_properties(property_names = {
cbilling:         "connection_table_properties": ["usbport"]}
spielman:         )    
cbilling:     def __init__(self, name, trigger_device=None, trigger_connection=None, usbport='COM1'):
pstarkey:         PseudoclockDevice.__init__(self, name, trigger_device, trigger_connection)
cbilling:         self.BLACS_connection = usbport
pstarkey:         
pstarkey:         # create Pseudoclock and clockline
pstarkey:         self._pseudoclock = PineBlasterPseudoclock('%s_pseudoclock'%name, self, 'clock') # possibly a better connection name than 'clock'?
pstarkey:         # Create the internal direct output clock_line
pstarkey:         self._clock_line = ClockLine('%s_clock_line'%name, self.pseudoclock, 'internal')
pstarkey:     
pstarkey:     @property
pstarkey:     def pseudoclock(self):
pstarkey:         return self._pseudoclock
pstarkey:     
pstarkey:     # Note, not to be confused with Device.parent_clock_line which returns the parent ClockLine
pstarkey:     # This one gives the automatically created ClockLine object
pstarkey:     @property
pstarkey:     def clockline(self):
pstarkey:         return self._clock_line
pstarkey:     
pstarkey:     def add_device(self, device):
pstarkey:         if not self.child_devices and isinstance(device, Pseudoclock):
pstarkey:             PseudoclockDevice.add_device(self, device)            
pstarkey:         elif isinstance(device, Pseudoclock):
pstarkey:             raise LabscriptError('The %s %s automatically creates a Pseudoclock because it only supports one. '%(self.description, self.name) +
pstarkey:                                  'Instead of instantiating your own Pseudoclock object, please use the internal' +
pstarkey:                                  ' one stored in %s.pseudoclock'%self.name)
pstarkey:         else:
pstarkey:             raise LabscriptError('You have connected %s (class %s) to %s, but %s does not support children with that class.'%(device.name, device.__class__, self.name, self.name))
cbilling:     
cbilling:     def generate_code(self, hdf5_file):
pstarkey:         PseudoclockDevice.generate_code(self, hdf5_file)
pstarkey:         group = hdf5_file['devices'].create_group(self.name)   
pstarkey:         
cbilling:         # compress clock instructions with the same period: This will
cbilling:         # halve the number of instructions roughly, since the PineBlaster
cbilling:         # does not have a 'slow clock':
cbilling:         reduced_instructions = []
pstarkey:         for instruction in self.pseudoclock.clock:
cbilling:             if instruction == 'WAIT':
cbilling:                 # The following period and reps indicates a wait instruction
cbilling:                 reduced_instructions.append({'period': 0, 'reps': 1})
cbilling:                 continue
cbilling:             reps = instruction['reps']
cbilling:             # period is in quantised units:
cbilling:             period = int(round(instruction['step']/self.clock_resolution))
cbilling:             if reduced_instructions and reduced_instructions[-1]['period'] == period:
cbilling:                 reduced_instructions[-1]['reps'] += reps
cbilling:             else:
cbilling:                 reduced_instructions.append({'period': period, 'reps': reps})
cbilling:         # The following period and reps indicates a stop instruction:
cbilling:         reduced_instructions.append({'period': 0, 'reps': 0})
cbilling:         if len(reduced_instructions) > self.max_instructions:
cbilling:             raise LabscriptError("%s %s has too many instructions. It has %d and can only support %d"%(self.description, self.name, len(reduced_instructions), self.max_instructions))
cbilling:         # Store these instructions to the h5 file:
cbilling:         dtypes = [('period',int),('reps',int)]
cbilling:         pulse_program = np.zeros(len(reduced_instructions),dtype=dtypes)
cbilling:         for i, instruction in enumerate(reduced_instructions):
cbilling:             pulse_program[i]['period'] = instruction['period']
cbilling:             pulse_program[i]['reps'] = instruction['reps']
cbilling:         group.create_dataset('PULSE_PROGRAM', compression = config.compression, data=pulse_program)
pstarkey:         # TODO: is this needed, the PulseBlasters don't save it... 
  rander:         self.set_property('is_master_pseudoclock', self.is_master_pseudoclock, location='device_properties')
cbilling:         self.set_property('stop_time', self.stop_time, location='device_properties')
pstarkey:  
pstarkey: 
cbilling: @runviewer_parser
pstarkey: class RunviewerClass(object):
pstarkey:     clock_resolution = 25e-9
pstarkey:     clock_type = 'fast clock'
pstarkey:     # Todo: find out what this actually is:
pstarkey:     trigger_delay = 1e-6
pstarkey:     # Todo: find out what this actually is:
pstarkey:     wait_delay = 2.5e-6
pstarkey:     
pstarkey:     def __init__(self, path, device):
pstarkey:         self.path = path
pstarkey:         self.name = device.name
pstarkey:         self.device = device
pstarkey:         
pstarkey:             
pstarkey:     def get_traces(self, add_trace, clock=None):
pstarkey:         if clock is not None:
pstarkey:             times, clock_value = clock[0], clock[1]
pstarkey:             clock_indices = np.where((clock_value[1:]-clock_value[:-1])==1)[0]+1
pstarkey:             # If initial clock value is 1, then this counts as a rising edge (clock should be 0 before experiment)
pstarkey:             # but this is not picked up by the above code. So we insert it!
pstarkey:             if clock_value[0] == 1:
pstarkey:                 clock_indices = np.insert(clock_indices, 0, 0)
pstarkey:             clock_ticks = times[clock_indices]
pstarkey: 
pstarkey:         
pstarkey:             
pstarkey:         # get the pulse program
pstarkey:         with h5py.File(self.path, 'r') as f:
pstarkey:             pulse_program = f['devices/%s/PULSE_PROGRAM'%self.name][:]
pstarkey:             
pstarkey:         time = []
pstarkey:         states = []
pstarkey:         trigger_index = 0
pstarkey:         t = 0 if clock is None else clock_ticks[trigger_index]+self.trigger_delay
pstarkey:         trigger_index += 1
pstarkey:         
pstarkey:         clock_factor = self.clock_resolution/2.
pstarkey:         
pstarkey:         for row in pulse_program:
pstarkey:             if row['period'] == 0:
pstarkey:                 #special case
pstarkey:                 if row['reps'] == 1: # WAIT
pstarkey:                     if clock is not None:
pstarkey:                         t = clock_ticks[trigger_index]+self.trigger_delay
pstarkey:                         trigger_index += 1
pstarkey:                     else:
pstarkey:                         t += self.wait_delay
pstarkey:             else:    
pstarkey:                 for i in range(row['reps']):
pstarkey:                     for j in range(1, -1, -1):
pstarkey:                         time.append(t)
pstarkey:                         states.append(j)
pstarkey:                         t += row['period']*clock_factor
pstarkey:         
pstarkey:         clock = (np.array(time), np.array(states))
pstarkey:         
pstarkey:         clocklines_and_triggers = {}
pstarkey:         for pseudoclock_name, pseudoclock in self.device.child_list.items():
pstarkey:             for clock_line_name, clock_line in pseudoclock.child_list.items():
pstarkey:                 if clock_line.parent_port == 'internal':
pstarkey:                     clocklines_and_triggers[clock_line_name] = clock
pstarkey:                     add_trace(clock_line_name, clock, self.name, clock_line.parent_port)
pstarkey:             
pstarkey:         return clocklines_and_triggers
pstarkey: 
pstarkey: from blacs.tab_base_classes import Worker, define_state
pstarkey: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
pstarkey: 
pstarkey: from blacs.device_base_class import DeviceTab
pstarkey: 
pstarkey: @BLACS_tab
pstarkey: class PineblasterTab(DeviceTab):
cbilling:     
pstarkey:     def initialise_GUI(self):
pstarkey:         # Create a single digital output     
pstarkey:         self.create_digital_outputs({'internal':{}})        
pstarkey:         # Create widgets for output objects
pstarkey:         _,_,do_widgets = self.auto_create_widgets()
pstarkey:         # and auto place the widgets in the UI
pstarkey:         self.auto_place_widgets(("Flags", do_widgets))
pstarkey:         
pstarkey:         # Store the board number to be used
pstarkey:         self.usb_port = str(self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection)
pstarkey:         # Create and set the primary worker
pstarkey:         self.create_worker("main_worker", PineblasterWorker, {'usbport':self.usb_port})
pstarkey:         self.primary_worker = "main_worker"
pstarkey:         
pstarkey:         # Set the capabilities of this device
pstarkey:         self.supports_smart_programming(True) 
pstarkey:      
pstarkey:     def get_child_from_connection_table(self, parent_device_name, port):
pstarkey:         # This is a direct output, let's search for it on the internal Pseudoclock
pstarkey:         if parent_device_name == self.device_name:
pstarkey:             device = self.connection_table.find_by_name(self.device_name)
pstarkey:             pseudoclock = device.child_list[device.child_list.keys()[0]] # there should always be one (and only one) child, the Pseudoclock
pstarkey:             clockline = None
pstarkey:             for child_name, child in pseudoclock.child_list.items():
pstarkey:                 # store a reference to the internal clockline
pstarkey:                 if child.parent_port == port:                
pstarkey:                     return DeviceTab.get_child_from_connection_table(self, pseudoclock.name, port)
pstarkey:             
pstarkey:         return '-'
pstarkey:         
pstarkey:      
pstarkey:     @define_state(MODE_BUFFERED,True)  
pstarkey:     def status_monitor(self, notify_queue):
pstarkey:         status = yield(self.queue_work(self.primary_worker, 'status_monitor'))        
pstarkey:         if status:
pstarkey:             # Experiment is over. Tell the queue manager about it
pstarkey:             notify_queue.put('done')
pstarkey:             self.statemachine_timeout_remove(self.status_monitor)
pstarkey:         
pstarkey:     @define_state(MODE_BUFFERED,True)  
pstarkey:     def start_run(self, notify_queue):
pstarkey:         """Starts the Pineblaster, notifying the queue manager when
pstarkey:         the run is over"""
pstarkey:         self.statemachine_timeout_add(100, self.status_monitor, notify_queue)
pstarkey:         yield(self.queue_work(self.primary_worker, 'start_run'))
pstarkey: 
pstarkey: 
pstarkey: @BLACS_worker        
pstarkey: class PineblasterWorker(Worker):
pstarkey:     def init(self):
pstarkey:         global h5py; import labscript_utils.h5_lock, h5py
pstarkey:         global serial; import serial
pstarkey:         global time; import time
pstarkey:         self.smart_cache = []
pstarkey:     
pstarkey:         self.pineblaster = serial.Serial(self.usbport, 115200, timeout=1)
pstarkey:         # Device has a finite startup time:
pstarkey:         time.sleep(5)
pstarkey:         self.pineblaster.write('hello\r\n')
pstarkey:         response = self.pineblaster.readline()
pstarkey:         
pstarkey:         if response == 'hello\r\n':
pstarkey:             return
pstarkey:         elif response:
pstarkey:             raise Exception('PineBlaster is confused: saying %s instead of hello'%(repr(response)))
pstarkey:         else:
pstarkey:             raise Exception('PineBlaster is not saying hello back when greeted politely. How rude. Maybe it needs a reboot.')
pstarkey:             
pstarkey:             
pstarkey:     def shutdown(self):
pstarkey:         self.pineblaster.close()
pstarkey:         
pstarkey:     def program_manual(self, values):    
pstarkey:         value = values['internal'] # there is only one value
pstarkey:         self.pineblaster.write('go high\r\n' if value else 'go low\r\n')
pstarkey:         response = self.pineblaster.readline()
pstarkey:         assert response == 'ok\r\n', 'PineBlaster said \'%s\', expected \'ok\''%repr(response)
pstarkey:         return {}
pstarkey:         
pstarkey:     def transition_to_buffered(self, device_name, h5file, initial_values, fresh):
pstarkey:         if fresh:
pstarkey:             self.smart_cache = []
pstarkey:         self.program_manual({'internal':0})
pstarkey:         
pstarkey:         with h5py.File(h5file,'r') as hdf5_file:
pstarkey:             group = hdf5_file['devices/%s'%device_name]
pstarkey:             pulse_program = group['PULSE_PROGRAM'][:]
  philip:             device_properties = labscript_utils.properties.get(hdf5_file, device_name, 'device_properties')
  rander:             self.is_master_pseudoclock = device_properties['is_master_pseudoclock']
pstarkey:             
pstarkey:         for i, instruction in enumerate(pulse_program):
pstarkey:             if i == len(self.smart_cache):
pstarkey:                 # Pad the smart cache out to be as long as the program:
pstarkey:                 self.smart_cache.append(None)
pstarkey:                 
pstarkey:             # Only program instructions that differ from what's in the smart cache:
pstarkey:             if self.smart_cache[i] != instruction:
pstarkey:                 self.pineblaster.write('set %d %d %d\r\n'%(i, instruction['period'], instruction['reps']))
pstarkey:                 response = self.pineblaster.readline()
pstarkey:                 assert response == 'ok\r\n', 'PineBlaster said \'%s\', expected \'ok\''%repr(response)
pstarkey:                 self.smart_cache[i] = instruction
pstarkey:                 
pstarkey:         if not self.is_master_pseudoclock:
pstarkey:             # Get ready for a hardware trigger:
pstarkey:             self.pineblaster.write('hwstart\r\n')
pstarkey:             response = self.pineblaster.readline()
pstarkey:             assert response == 'ok\r\n', 'PineBlaster said \'%s\', expected \'ok\''%repr(response)
pstarkey:             
pstarkey:         return {'internal':0} # always finish on 0
pstarkey:             
pstarkey:     def start_run(self):
pstarkey:         # Start in software:
pstarkey:         self.pineblaster.write('start\r\n')
pstarkey:         response = self.pineblaster.readline()
pstarkey:         assert response == 'ok\r\n', 'PineBlaster said \'%s\', expected \'ok\''%repr(response)
pstarkey:     
pstarkey:     def status_monitor(self):
pstarkey:         # Wait to see if it's done within the timeout:
pstarkey:         response = self.pineblaster.readline()
pstarkey:         if response:
pstarkey:             assert response == 'done\r\n'
pstarkey:             return True
pstarkey:         return False
pstarkey:         
pstarkey:     def transition_to_manual(self):
pstarkey:         # Wait until the pineblaster says it's done:
pstarkey:         if not self.is_master_pseudoclock:
pstarkey:             # If we're the master pseudoclock then this already happened
pstarkey:             # in status_monitor, so we don't need to do it again
pstarkey:             response = self.pineblaster.readline()
pstarkey:             assert response == 'done\r\n', 'PineBlaster said \'%s\', expected \'ok\''%repr(response)
pstarkey:             # print 'done!'
pstarkey:         return True
pstarkey:     
pstarkey:     def abort_buffered(self):
pstarkey:         return self.abort()
pstarkey:     
pstarkey:     def abort_transition_to_buffered(self):
pstarkey:         return self.abort()
pstarkey:     
pstarkey:     def abort(self):
pstarkey:         self.pineblaster.write('restart\r\n')
pstarkey:         time.sleep(5)
pstarkey:         self.shutdown()
pstarkey:         self.init()
pstarkey:         return True
pstarkey: 
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /PulseBlaster.py                                                  #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the module labscript_devices, in the         #
        pstarkey: # labscript suite (see http://labscriptsuite.org), and is           #
        pstarkey: # licensed under the Simplified BSD License. See the license.txt    #
        pstarkey: # file in the root of the project for the full license.             #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
        cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
        pstarkey: 
        spielman: from labscript import Device, PseudoclockDevice, Pseudoclock, ClockLine, IntermediateDevice, DigitalQuantity, DigitalOut, DDS, config, LabscriptError, set_passed_properties
        cbilling: 
        pstarkey: import numpy as np
        pstarkey: 
        pstarkey: import labscript_utils.h5_lock, h5py
        pstarkey: 
        pstarkey: class x(object):
        pstarkey:     pass
        pstarkey: 
        pstarkey: import time
        pstarkey: 
        pstarkey: profiles = {}
        pstarkey: def profile(funct):
        pstarkey:     func = funct.__name__
        pstarkey:     if func not in profiles:
        pstarkey:         profiles[func] = {'total_time':0, 'min':None, 'max':0, 'num_calls':0, 'average_time_per_call':0}
        pstarkey:     
        pstarkey:     def new_func(*args,**kwargs):
        pstarkey:         start_time = time.time()
        pstarkey:         ret = funct(*args,**kwargs)
        pstarkey:         runtime = time.time()-start_time
        pstarkey:         profiles[func]['total_time'] += runtime
        pstarkey:         profiles[func]['num_calls'] += 1
        pstarkey:         profiles[func]['min'] = profiles[func]['min'] if profiles[func]['min'] is not None and profiles[func]['min'] < runtime else runtime
        pstarkey:         profiles[func]['max'] = profiles[func]['max'] if profiles[func]['max'] > runtime else runtime
        pstarkey:         profiles[func]['average_time_per_call'] = profiles[func]['total_time']/profiles[func]['num_calls']
        pstarkey:         
        pstarkey:         return ret
        pstarkey:     # return new_func
        pstarkey:     return funct
        pstarkey:     
        pstarkey: def start_profile(name):
        pstarkey:     if name not in profiles:
        pstarkey:         profiles[name] = {'total_time':0, 'min':None, 'max':0, 'num_calls':0, 'average_time_per_call':0}
        pstarkey:         
        pstarkey:     if 'start_time' in profiles[name]:
        pstarkey:         raise Exception('You cannot call start_profile for %s without first calling stop_profile'%name)
        pstarkey:         
        pstarkey:     profiles[name]['start_time'] = time.time()
        pstarkey:     
        pstarkey: def stop_profile(name):
        pstarkey:     if name not in profiles or 'start_time' not in profiles[name]:
        pstarkey:         raise Exception('You must first call start_profile for %s before calling stop_profile')
        pstarkey:         
        pstarkey:     runtime = time.time()-profiles[name]['start_time']
        pstarkey:     del profiles[name]['start_time']
        pstarkey:     profiles[name]['total_time'] += runtime
        pstarkey:     profiles[name]['num_calls'] += 1
        pstarkey:     profiles[name]['min'] = profiles[name]['min'] if profiles[name]['min'] is not None and profiles[name]['min'] < runtime else runtime
        pstarkey:     profiles[name]['max'] = profiles[name]['max'] if profiles[name]['max'] > runtime else runtime
        pstarkey:     profiles[name]['average_time_per_call'] = profiles[name]['total_time']/profiles[name]['num_calls']
        pstarkey:           
        cbilling: @labscript_device          
        pstarkey: class PulseBlaster(PseudoclockDevice):
        pstarkey:     
        cbilling:     pb_instructions = {'CONTINUE':   0,
        cbilling:                        'STOP':       1, 
        cbilling:                        'LOOP':       2, 
        cbilling:                        'END_LOOP':   3,
        cbilling:                        'BRANCH':     6,
        cbilling:                        'LONG_DELAY': 7,
        cbilling:                        'WAIT':       8}
        cbilling:                        
        cbilling:     description = 'PB-DDSII-300'
        cbilling:     clock_limit = 8.3e6 # Slight underestimate I think.
        cbilling:     clock_resolution = 26.6666666666666666e-9
        pstarkey:     # TODO: Add n_dds and generalise code
        cbilling:     n_flags = 12
        cbilling:     
        cbilling:     # This value is coupled to a value in the PulseBlaster worker process of BLACS
        cbilling:     # This number was found experimentally but is determined theoretically by the
        cbilling:     # instruction lengths in BLACS, and a finite delay in the PulseBlaster
        cbilling:     #
        cbilling:     # IF YOU CHANGE ONE, YOU MUST CHANGE THE OTHER!
        cbilling:     trigger_delay = 250e-9 
        cbilling:     wait_delay = 100e-9
        cbilling:     trigger_edge_type = 'falling'
        cbilling:     
        pstarkey:     # This device can only have Pseudoclock children (digital outs and DDS outputs should be connected to a child device)
        pstarkey:     allowed_children = [Pseudoclock]
        pstarkey:     
        spielman:     @set_passed_properties(
        cbilling:         property_names = {"connection_table_properties": ["firmware",  "programming_scheme"],
chrisjbillington:                           "device_properties": ["pulse_width", "max_instructions",
chrisjbillington:                                                 "time_based_stop_workaround",
chrisjbillington:                                                 "time_based_stop_workaround_extra_time"]}
        spielman:         )
chrisjbillington:     def __init__(self, name, trigger_device=None, trigger_connection=None, board_number=0, firmware = '',
chrisjbillington:                  programming_scheme='pb_start/BRANCH', pulse_width=None, max_instructions=4000,
chrisjbillington:                  time_based_stop_workaround=False, time_based_stop_workaround_extra_time=0.5, **kwargs):
        spielman:         PseudoclockDevice.__init__(self, name, trigger_device, trigger_connection, **kwargs)
        cbilling:         self.BLACS_connection = board_number
        cbilling:         # TODO: Implement capability checks based on firmware revision of PulseBlaster
        cbilling:         self.firmware_version = firmware
chrisjbillington:         
chrisjbillington:         # time_based_stop_workaround is for old pulseblaster models which do
chrisjbillington:         # not respond correctly to status checks. These models provide no way
chrisjbillington:         # to know when the shot has completed. So if
chrisjbillington:         # time_based_stop_workaround=True, we fall back to simply waiting
chrisjbillington:         # until stop_time (plus the timeout of all waits) and assuming in the
chrisjbillington:         # BLACS worker that the end of the shot occurs at this time.
chrisjbillington:         # time_based_stop_workaround_extra_time is a configurable duration for
chrisjbillington:         # how much longer than stop_time we should wait, to allow for software
chrisjbillington:         # timing variation. Note that since the maximum duration of all waits
chrisjbillington:         # is included in the calculation of the time at which the experiemnt
chrisjbillington:         # should be stopped, attention should be paid to the timeout argument
chrisjbillington:         # of all waits, since if it is larger than necessary, this will
chrisjbillington:         # increase the duration of your shots even if the waits are actually
chrisjbillington:         # short in duration.
chrisjbillington:         
chrisjbillington:         
        cbilling:         # If we are the master pseudoclock, there are two ways we can start and stop the PulseBlaster.
        cbilling:         #
        cbilling:         # 'pb_start/BRANCH':
        cbilling:         # Call pb_start(), to start us in software time. At the end of the program BRANCH to
        cbilling:         # a WAIT instruction at the beginning, ready to start again.
        cbilling:         #
        cbilling:         # 'pb_stop_programming/STOP'
        cbilling:         # Defer calling pb_stop_programming() until everything is ready to start.
        cbilling:         # Then, the next hardware trigger to the PulseBlaster will start it.
        cbilling:         # It is important not to call pb_stop_programming() too soon, because if the PulseBlaster is receiving
        cbilling:         # repeated triggers (such as from a 50/60-Hz line trigger), then we do not want it to start running
        cbilling:         # before everything is ready. Not calling pb_stop_programming() until we are ready ensures triggers are
        cbilling:         # ignored until then. In this case, we end with a STOP instruction, ensuring further triggers do not cause
        cbilling:         # the PulseBlaster to run repeatedly until start_programming()/stop_programming() are called once more.
        cbilling:         # The programming scheme is saved as a property in the connection table and read out by BLACS.
        cbilling:         possible_programming_schemes = ['pb_start/BRANCH', 'pb_stop_programming/STOP']
        cbilling:         if programming_scheme not in possible_programming_schemes:
        cbilling:             raise LabscriptError('programming_scheme must be one of %s'%str(possible_programming_schemes))
        cbilling:         if trigger_device is not None and programming_scheme != 'pb_start/BRANCH':
        cbilling:             raise LabscriptError('only the master pseudoclock can use a programming scheme other than \'pb_start/BRANCH\'')
        cbilling:         self.programming_scheme = programming_scheme
        cbilling: 
        pstarkey:         if pulse_width is not None:            
        pstarkey:             if pulse_width < 0.5/self.clock_limit:
        pstarkey:                 message = ('pulse_width cannot be less than 0.5/%s.clock_limit '%self.__class__.__name__ +
        pstarkey:                            '( = %s seconds)'%str(0.5/self.clock_limit))
        pstarkey:                 raise LabscriptError(message)
        pstarkey:             # Round pulse width up to the nearest multiple of clock resolution:
        pstarkey:             quantised_pulse_width = 2*pulse_width/self.clock_resolution
        pstarkey:             quantised_pulse_width = int(quantised_pulse_width) + 1 # ceil(quantised_pulse_width)
        pstarkey:             # This will be used as the high time of clock ticks:
        pstarkey:             self.pulse_width = quantised_pulse_width*self.clock_resolution/2
        pstarkey:             # This pulse width, if larger than the minimum, may limit how fast we can tick.
        pstarkey:             # Update self.clock_limit accordingly.
        pstarkey:             minimum_low_time = 0.5/self.clock_limit
        pstarkey:             if self.pulse_width > minimum_low_time:
        pstarkey:                 self.clock_limit = 1/(self.pulse_width + minimum_low_time)
        pstarkey:         else:
        pstarkey:             pulse_width = 'symmetric'
        pstarkey:             self.pulse_width = None
        cbilling: 
            rene:         self.max_instructions = max_instructions
        cbilling: 
        pstarkey:         # Create the internal pseudoclock
        pstarkey:         self._pseudoclock = Pseudoclock('%s_pseudoclock'%name, self, 'clock') # possibly a better connection name than 'clock'?
        pstarkey:         # Create the internal direct output clock_line
        pstarkey:         self._direct_output_clock_line = ClockLine('%s_direct_output_clock_line'%name, self.pseudoclock, 'internal', ramping_allowed = False)
        pstarkey:         # Create the internal intermediate device connected to the above clock line
        pstarkey:         # This will have the direct DigitalOuts of DDSs of the PulseBlaster connected to it
        pstarkey:         self._direct_output_device = PulseBlasterDirectOutputs('%s_direct_output_device'%name, self._direct_output_clock_line)
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def pseudoclock(self):
        pstarkey:         return self._pseudoclock
        cbilling:         
        pstarkey:     @property
        pstarkey:     def direct_outputs(self):
        pstarkey:         return self._direct_output_device
        cbilling:     
        cbilling:     def add_device(self, device):
        pstarkey:         if not self.child_devices and isinstance(device, Pseudoclock):
        pstarkey:             PseudoclockDevice.add_device(self, device)
        pstarkey:             
        pstarkey:         elif isinstance(device, Pseudoclock):
        pstarkey:             raise LabscriptError('The %s %s automatically creates a Pseudoclock because it only supports one. '%(self.description, self.name) +
        pstarkey:                                  'Instead of instantiating your own Pseudoclock object, please use the internal' +
        pstarkey:                                  ' one stored in %s.pseudoclock'%self.name)
        pstarkey:         elif isinstance(device, DDS) or isinstance(device, DigitalOut):
        pstarkey:             #TODO: Defensive programming: device.name may not exist!
        pstarkey:             raise LabscriptError('You have connected %s directly to %s, which is not allowed. You should instead specify the parent_device of %s as %s.direct_outputs'%(device.name, self.name, device.name, self.name))
        pstarkey:         else:
        pstarkey:             raise LabscriptError('You have connected %s (class %s) to %s, but %s does not support children with that class.'%(device.name, device.__class__, self.name, self.name))
        cbilling:                 
        cbilling:     def flag_valid(self, flag):
        cbilling:         if -1 < flag < self.n_flags:
        cbilling:             return True
        pstarkey:         return False     
        cbilling:         
        cbilling:     def flag_is_clock(self, flag):
        pstarkey:         for clock_line in self.pseudoclock.child_devices:
        pstarkey:             if clock_line.connection == 'internal': #ignore internal clockline
        pstarkey:                 continue
        pstarkey:             if flag == self.get_flag_number(clock_line.connection):
        pstarkey:                 return True
        pstarkey:         return False
        pstarkey:             
        pstarkey:     def get_flag_number(self, connection):
        pstarkey:         # TODO: Error checking
        pstarkey:         prefix, connection = connection.split()
        pstarkey:         return int(connection)
        cbilling:     
        cbilling:     def get_direct_outputs(self):
        cbilling:         """Finds out which outputs are directly attached to the PulseBlaster"""
        cbilling:         dig_outputs = []
        cbilling:         dds_outputs = []
        pstarkey:         for output in self.direct_outputs.get_all_outputs():
        pstarkey:             # If we are a child of a DDS
        pstarkey:             if isinstance(output.parent_device, DDS):
        pstarkey:                 # and that DDS has not been processed yet
        pstarkey:                 if output.parent_device not in dds_outputs:
        pstarkey:                     # process the DDS instead of the child
        pstarkey:                     output = output.parent_device
        pstarkey:                 else:
        pstarkey:                     # ignore the child
        pstarkey:                     continue
        pstarkey:             
        pstarkey:             # only check DDS and DigitalOuts (so ignore the children of the DDS)
        pstarkey:             if isinstance(output,DDS) or isinstance(output, DigitalOut):
        pstarkey:                 # get connection number and prefix
        cbilling:                 try:
        cbilling:                     prefix, connection = output.connection.split()
        cbilling:                     assert prefix == 'flag' or prefix == 'dds'
        cbilling:                     connection = int(connection)
        cbilling:                 except:
        cbilling:                     raise LabscriptError('%s %s has invalid connection string: \'%s\'. '%(output.description,output.name,str(output.connection)) + 
        cbilling:                                          'Format must be \'flag n\' with n an integer less than %d, or \'dds n\' with n less than 2.'%self.n_flags)
        pstarkey:                 # run checks on the connection string to make sure it is valid
        pstarkey:                 # TODO: Most of this should be done in add_device() No?
        pstarkey:                 if prefix == 'flag' and not self.flag_valid(connection):
        pstarkey:                     raise LabscriptError('%s is set as connected to flag %d of %s. '%(output.name, connection, self.name) +
        pstarkey:                                          'Output flag number must be a integer from 0 to %d.'%(self.n_flags-1))
        pstarkey:                 if prefix == 'flag' and self.flag_is_clock(connection):
        pstarkey:                     raise LabscriptError('%s is set as connected to flag %d of %s.'%(output.name, connection, self.name) +
        pstarkey:                                          ' This flag is already in use as one of the PulseBlaster\'s clock flags.')                         
        cbilling:                 if prefix == 'dds' and not connection < 2:
        cbilling:                     raise LabscriptError('%s is set as connected to output connection %d of %s. '%(output.name, connection, self.name) +
        cbilling:                                          'DDS output connection number must be a integer less than 2.')
        pstarkey:                 
        pstarkey:                 # Check that the connection string doesn't conflict with another output
        cbilling:                 for other_output in dig_outputs + dds_outputs:
        cbilling:                     if output.connection == other_output.connection:
        cbilling:                         raise LabscriptError('%s and %s are both set as connected to %s of %s.'%(output.name, other_output.name, output.connection, self.name))
        pstarkey:                 
        pstarkey:                 # store a reference to the output
        pstarkey:                 if isinstance(output, DigitalOut):
        cbilling:                 	dig_outputs.append(output)
        cbilling:                 elif isinstance(output, DDS):
        cbilling:                 	dds_outputs.append(output)
        cbilling:                 
        cbilling:         return dig_outputs, dds_outputs
        cbilling: 
        cbilling:     def generate_registers(self, hdf5_file, dds_outputs):
        cbilling:         ampdicts = {}
        cbilling:         phasedicts = {}
        cbilling:         freqdicts = {}
        cbilling:         group = hdf5_file['/devices/'+self.name]
        cbilling:         dds_dict = {}
        cbilling:         for output in dds_outputs:
        cbilling:             num = int(output.connection.split()[1])
        cbilling:             dds_dict[num] = output
        cbilling:         for num in [0,1]:
        cbilling:             
        cbilling:             if num in dds_dict:
        cbilling:                 output = dds_dict[num]
        cbilling:             
        cbilling:                 # Ensure that amplitudes are within bounds:
        cbilling:                 if any(output.amplitude.raw_output > 1)  or any(output.amplitude.raw_output < 0):
        cbilling:                     raise LabscriptError('%s %s '%(output.amplitude.description, output.amplitude.name) +
        cbilling:                                       'can only have values between 0 and 1, ' + 
        cbilling:                                       'the limit imposed by %s.'%output.name)
        cbilling:                                       
        cbilling:                 # Ensure that frequencies are within bounds:
        cbilling:                 if any(output.frequency.raw_output > 150e6 )  or any(output.frequency.raw_output < 0):
        cbilling:                     raise LabscriptError('%s %s '%(output.frequency.description, output.frequency.name) +
        cbilling:                                       'can only have values between 0Hz and and 150MHz, ' + 
        cbilling:                                       'the limit imposed by %s.'%output.name)
        cbilling:                                       
        cbilling:                 # Ensure that phase wraps around:
        cbilling:                 output.phase.raw_output %= 360
        cbilling:                 
        cbilling:                 amps = set(output.amplitude.raw_output)
        cbilling:                 phases = set(output.phase.raw_output)
        cbilling:                 freqs = set(output.frequency.raw_output)
        cbilling:             else:
        cbilling:                 # If the DDS is unused, it will use the following values
        cbilling:                 # for the whole experimental run:
        cbilling:                 amps = set([0])
        cbilling:                 phases = set([0])
        cbilling:                 freqs = set([0])
        cbilling:                                   
        cbilling:             if len(amps) > 1024:
        cbilling:                 raise LabscriptError('%s dds%d can only support 1024 amplitude registers, and %s have been requested.'%(self.name, num, str(len(amps))))
        cbilling:             if len(phases) > 128:
        cbilling:                 raise LabscriptError('%s dds%d can only support 128 phase registers, and %s have been requested.'%(self.name, num, str(len(phases))))
        cbilling:             if len(freqs) > 1024:
        cbilling:                 raise LabscriptError('%s dds%d can only support 1024 frequency registers, and %s have been requested.'%(self.name, num, str(len(freqs))))
        cbilling:                                 
        cbilling:             # start counting at 1 to leave room for the dummy instruction,
        cbilling:             # which BLACS will fill in with the state of the front
        cbilling:             # panel:
        cbilling:             ampregs = range(1,len(amps)+1)
        cbilling:             freqregs = range(1,len(freqs)+1)
        cbilling:             phaseregs = range(1,len(phases)+1)
        cbilling:             
        cbilling:             ampdicts[num] = dict(zip(amps,ampregs))
        cbilling:             freqdicts[num] = dict(zip(freqs,freqregs))
        cbilling:             phasedicts[num] = dict(zip(phases,phaseregs))
        cbilling:             
        cbilling:             # The zeros are the dummy instructions:
        cbilling:             freq_table = np.array([0] + list(freqs), dtype = np.float64) / 1e6 # convert to MHz
        cbilling:             amp_table = np.array([0] + list(amps), dtype = np.float32)
        cbilling:             phase_table = np.array([0] + list(phases), dtype = np.float64)
        cbilling:             
        cbilling:             subgroup = group.create_group('DDS%d'%num)
        cbilling:             subgroup.create_dataset('FREQ_REGS', compression=config.compression, data = freq_table)
        cbilling:             subgroup.create_dataset('AMP_REGS', compression=config.compression, data = amp_table)
        cbilling:             subgroup.create_dataset('PHASE_REGS', compression=config.compression, data = phase_table)
        cbilling:             
        cbilling:         return freqdicts, ampdicts, phasedicts
        cbilling:         
        cbilling:     def convert_to_pb_inst(self, dig_outputs, dds_outputs, freqs, amps, phases):
        cbilling:         pb_inst = []
        pstarkey:         
        cbilling:         # index to keep track of where in output.raw_output the
        cbilling:         # pulseblaster flags are coming from
        pstarkey:         # starts at -1 because the internal flag should always tick on the first instruction and be 
        pstarkey:         # incremented (to 0) before it is used to index any arrays
        pstarkey:         i = -1 
        cbilling:         # index to record what line number of the pulseblaster hardware
        cbilling:         # instructions we're up to:
        cbilling:         j = 0
        cbilling:         # We've delegated the initial two instructions off to BLACS, which
        cbilling:         # can ensure continuity with the state of the front panel. Thus
        cbilling:         # these two instructions don't actually do anything:
        cbilling:         flags = [0]*self.n_flags
        cbilling:         freqregs = [0]*2
        cbilling:         ampregs = [0]*2
        cbilling:         phaseregs = [0]*2
        cbilling:         dds_enables = [0]*2
        cbilling:             
        cbilling:         pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                         'flags': ''.join([str(flag) for flag in flags]), 'instruction': 'STOP',
        cbilling:                         'data': 0, 'delay': 10.0/self.clock_limit*1e9})
        cbilling:         pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                         'flags': ''.join([str(flag) for flag in flags]), 'instruction': 'STOP',
        cbilling:                         'data': 0, 'delay': 10.0/self.clock_limit*1e9})    
        cbilling:         j += 2
        pstarkey:         
        cbilling:         flagstring = '0'*self.n_flags # So that this variable is still defined if the for loop has no iterations
        pstarkey:         for k, instruction in enumerate(self.pseudoclock.clock):
        cbilling:             if instruction == 'WAIT':
        cbilling:                 # This is a wait instruction. Repeat the last instruction but with a 100ns delay and a WAIT op code:
        cbilling:                 wait_instruction = pb_inst[-1].copy()
        cbilling:                 wait_instruction['delay'] = 100
        cbilling:                 wait_instruction['instruction'] = 'WAIT'
        cbilling:                 wait_instruction['data'] = 0
        cbilling:                 pb_inst.append(wait_instruction)
        cbilling:                 j += 1
        cbilling:                 continue
        pstarkey:                 
        cbilling:             flags = [0]*self.n_flags
        cbilling:             # The registers below are ones, not zeros, so that we don't
        cbilling:             # use the BLACS-inserted initial instructions. Instead
        cbilling:             # unused DDSs have a 'zero' in register one for freq, amp
        cbilling:             # and phase.
        cbilling:             freqregs = [1]*2
        cbilling:             ampregs = [1]*2
        cbilling:             phaseregs = [1]*2
        cbilling:             dds_enables = [0]*2
        pstarkey:             
        pstarkey:             # This flag indicates whether we need a full clock tick, or are just updating an internal output
        pstarkey:             only_internal = True
        pstarkey:             # find out which clock flags are ticking during this instruction
        pstarkey:             for clock_line in instruction['enabled_clocks']:
        pstarkey:                 if clock_line == self._direct_output_clock_line: 
        pstarkey:                     # advance i (the index keeping track of internal clockline output)
        pstarkey:                     i += 1
        pstarkey:                 else:
        pstarkey:                     flag_index = int(clock_line.connection.split()[1])
        pstarkey:                     flags[flag_index] = 1
        pstarkey:                     # We are not just using the internal clock line
        pstarkey:                     only_internal = False
        pstarkey:                     
        pstarkey:             if only_internal and self.pulse_width is not None:
        pstarkey:                 raise LabscriptError('You cannot set a pulse_width for %s (%s) if it is not used as a pseudoclock for another device'%(self.name, self.description))
        pstarkey:                     
        pstarkey:             
        cbilling:             for output in dig_outputs:
        cbilling:                 flagindex = int(output.connection.split()[1])
        cbilling:                 flags[flagindex] = int(output.raw_output[i])
        cbilling:             for output in dds_outputs:
        cbilling:                 ddsnumber = int(output.connection.split()[1])
        cbilling:                 freqregs[ddsnumber] = freqs[ddsnumber][output.frequency.raw_output[i]]
        cbilling:                 ampregs[ddsnumber] = amps[ddsnumber][output.amplitude.raw_output[i]]
        cbilling:                 phaseregs[ddsnumber] = phases[ddsnumber][output.phase.raw_output[i]]
        cbilling:                 dds_enables[ddsnumber] = output.gate.raw_output[i]
        pstarkey:                 
        pstarkey:             # if self.fast_clock_flag is not None:
        pstarkey:                 # for fast_flag in self.fast_clock_flag:
        pstarkey:                     # if (type(instruction['fast_clock']) == list and 'flag %d'%fast_flag in instruction['fast_clock']) or instruction['fast_clock'] == 'all':
        pstarkey:                         # flags[fast_flag] = 1
        pstarkey:                     # else:
        pstarkey:                         # flags[fast_flag] = 1 if instruction['slow_clock_tick'] else 0
        pstarkey:             # if self.slow_clock_flag is not None:
        pstarkey:                 # for slow_flag in self.slow_clock_flag:
        pstarkey:                     # flags[slow_flag] = 1 if instruction['slow_clock_tick'] else 0
        pstarkey:                     
        pstarkey:             # if instruction['slow_clock_tick']:
        pstarkey:                 # slow_clock_indices.append(j)
        pstarkey:                 
        cbilling:             flagstring = ''.join([str(flag) for flag in flags])
        pstarkey:             
        cbilling:             if instruction['reps'] > 1048576:
        cbilling:                 raise LabscriptError('Pulseblaster cannot support more than 1048576 loop iterations. ' +
        cbilling:                                       str(instruction['reps']) +' were requested at t = ' + str(instruction['start']) + '. '+
        cbilling:                                      'This can be fixed easily enough by using nested loops. If it is needed, ' +
        cbilling:                                      'please file a feature request at' +
        cbilling:                                      'http://redmine.physics.monash.edu.au/projects/labscript.')
        cbilling:                 
        cbilling:             # Instruction delays > 55 secs will require a LONG_DELAY
        cbilling:             # to be inserted. How many times does the delay of the
        cbilling:             # loop/endloop instructions go into 55 secs?
        pstarkey:             if not only_internal:
        pstarkey:                 if self.pulse_width is not None:
        pstarkey:                     quotient, remainder = divmod(instruction['step'],55.0)
        pstarkey:                 else:
        pstarkey:                     quotient, remainder = divmod(instruction['step']/2.0,55.0)
        cbilling:             else:
        cbilling:                 quotient, remainder = divmod(instruction['step'],55.0)
        pstarkey:                 
        cbilling:             if quotient and remainder < 100e-9:
        cbilling:                 # The remainder will be used for the total duration of the LOOP and END_LOOP instructions. 
        cbilling:                 # It must not be too short for this, if it is, take one LONG_DELAY iteration and give 
        cbilling:                 # its duration to the loop instructions:
        cbilling:                 quotient, remainder = quotient - 1, remainder + 55.0
        pstarkey:                 
        pstarkey:             if not only_internal:
        pstarkey:                 if self.pulse_width is not None:
        pstarkey:                     delay = self.pulse_width
        pstarkey:                 else:
        pstarkey:                     delay = remainder
        pstarkey:             
        cbilling:                 # The loop and endloop instructions will only use the remainder:
        cbilling:                 pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                                 'flags': flagstring, 'instruction': 'LOOP',
        pstarkey:                                 'data': instruction['reps'], 'delay': delay*1e9})
        pstarkey:                 
        pstarkey:                 for clock_line in instruction['enabled_clocks']:
        pstarkey:                     if clock_line != self._direct_output_clock_line:
        pstarkey:                         flag_index = int(clock_line.connection.split()[1])
        pstarkey:                         flags[flag_index] = 0
        pstarkey:                         
        cbilling:                 flagstring = ''.join([str(flag) for flag in flags])
        cbilling:             
        cbilling:                 # If there was a nonzero quotient, let's wait twice that
        cbilling:                 # many multiples of 55 seconds (one multiple of 55 seconds
        cbilling:                 # for each of the other two loop and endloop instructions):
        cbilling:                 if quotient:
        pstarkey:                     if self.pulse_width is not None:
        pstarkey:                         delay = 55/2.0
        pstarkey:                     else:
        pstarkey:                         delay = 55
        pstarkey:                     
        cbilling:                     pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                                 'flags': flagstring, 'instruction': 'LONG_DELAY',
        pstarkey:                                 'data': int(2*quotient), 'delay': delay*1e9}) 
        cbilling:                                 
        pstarkey:                 if self.pulse_width is not None:
        pstarkey:                     delay = 2*remainder-self.pulse_width
        pstarkey:                 else:
        pstarkey:                     delay = remainder
        cbilling:                 pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                                 'flags': flagstring, 'instruction': 'END_LOOP',
        pstarkey:                                 'data': j, 'delay': delay*1e9})
        cbilling:                                 
        cbilling:                 # Two instructions were used in the case of there being no LONG_DELAY, 
        cbilling:                 # otherwise three. This increment is done here so that the j referred
        cbilling:                 # to in the previous line still refers to the LOOP instruction.
        cbilling:                 j += 3 if quotient else 2
        cbilling:             else:
        pstarkey:                 # We only need to update a direct output, so no need to tick the clocks
        pstarkey:                 
        cbilling:                 # The loop and endloop instructions will only use the remainder:
        cbilling:                 pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                                 'flags': flagstring, 'instruction': 'CONTINUE',
        cbilling:                                 'data': 0, 'delay': remainder*1e9})
        cbilling:                 # If there was a nonzero quotient, let's wait that many multiples of 55 seconds:
        cbilling:                 if quotient:
        cbilling:                     pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                                 'flags': flagstring, 'instruction': 'LONG_DELAY',
        pstarkey:                                 'data': int(2*quotient), 'delay': 55/2.0*1e9}) 
        cbilling:                 j += 2 if quotient else 1
        cbilling:                 
        pstarkey: 
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             # This is how we stop the pulse program. We branch from the last
        cbilling:             # instruction to the zeroth, which BLACS has programmed in with
        cbilling:             # the same values and a WAIT instruction. The PulseBlaster then
        cbilling:             # waits on instuction zero, which is a state ready for either
        cbilling:             # further static updates or buffered mode.
        cbilling:             pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                             'flags': flagstring, 'instruction': 'BRANCH',
        cbilling:                             'data': 0, 'delay': 10.0/self.clock_limit*1e9})
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             # An ordinary stop instruction. This has the downside that the PulseBlaster might
        cbilling:             # (on some models) reset its output to zero momentarily until BLACS calls program_manual, which
        cbilling:             # it will for this programming scheme. However it is necessary when the PulseBlaster has
        cbilling:             # repeated triggers coming to it, such as a 50Hz/60Hz line trigger. We can't have it sit
        cbilling:             # on a WAIT instruction as above, or it will trigger and run repeatedly when that's not what
        cbilling:             # we wanted.
        cbilling:             pb_inst.append({'freqs': freqregs, 'amps': ampregs, 'phases': phaseregs, 'enables':dds_enables,
        cbilling:                             'flags': flagstring, 'instruction': 'STOP',
        cbilling:                             'data': 0, 'delay': 10.0/self.clock_limit*1e9})
        cbilling:         else:
        cbilling:             raise AssertionError('Invalid programming scheme %s'%str(self.programming_scheme))
            rene:             
            rene:         if len(pb_inst) > self.max_instructions:
            rene:             raise LabscriptError("The Pulseblaster memory cannot store more than {:d} instuctions, but the PulseProgram contains {:d} instructions.".format(self.max_instructions, len(pb_inst))) 
            rene:             
        pstarkey:         return pb_inst
        cbilling:         
        pstarkey:     def write_pb_inst_to_h5(self, pb_inst, hdf5_file):
        cbilling:         # OK now we squeeze the instructions into a numpy array ready for writing to hdf5:
        cbilling:         pb_dtype = [('freq0', np.int32), ('phase0', np.int32), ('amp0', np.int32), 
        cbilling:                     ('dds_en0', np.int32), ('phase_reset0', np.int32),
        cbilling:                     ('freq1', np.int32), ('phase1', np.int32), ('amp1', np.int32),
        cbilling:                     ('dds_en1', np.int32), ('phase_reset1', np.int32),
        cbilling:                     ('flags', np.int32), ('inst', np.int32),
        cbilling:                     ('inst_data', np.int32), ('length', np.float64)]
        cbilling:         pb_inst_table = np.empty(len(pb_inst),dtype = pb_dtype)
        cbilling:         for i,inst in enumerate(pb_inst):
        cbilling:             flagint = int(inst['flags'][::-1],2)
        cbilling:             instructionint = self.pb_instructions[inst['instruction']]
        cbilling:             dataint = inst['data']
        cbilling:             delaydouble = inst['delay']
        cbilling:             freq0 = inst['freqs'][0]
        cbilling:             freq1 = inst['freqs'][1]
        cbilling:             phase0 = inst['phases'][0]
        cbilling:             phase1 = inst['phases'][1]
        cbilling:             amp0 = inst['amps'][0]
        cbilling:             amp1 = inst['amps'][1]
        cbilling:             en0 = inst['enables'][0]
        cbilling:             en1 = inst['enables'][1]
        cbilling:             pb_inst_table[i] = (freq0,phase0,amp0,en0,0,freq1,phase1,amp1,en1,0, flagint, 
        pstarkey:                                 instructionint, dataint, delaydouble)     
        pstarkey:                                 
        pstarkey:         # Okay now write it to the file: 
        cbilling:         group = hdf5_file['/devices/'+self.name]  
        cbilling:         group.create_dataset('PULSE_PROGRAM', compression=config.compression,data = pb_inst_table)   
        cbilling:         self.set_property('stop_time', self.stop_time, location='device_properties')
          rander: 
        cbilling:         
        cbilling:     def generate_code(self, hdf5_file):
        cbilling:         # Generate the hardware instructions
        cbilling:         hdf5_file.create_group('/devices/'+self.name)
        pstarkey:         PseudoclockDevice.generate_code(self, hdf5_file)
        cbilling:         dig_outputs, dds_outputs = self.get_direct_outputs()
        cbilling:         freqs, amps, phases = self.generate_registers(hdf5_file, dds_outputs)
        pstarkey:         pb_inst = self.convert_to_pb_inst(dig_outputs, dds_outputs, freqs, amps, phases)
        pstarkey:         self.write_pb_inst_to_h5(pb_inst, hdf5_file)
        cbilling:         
        pstarkey: 
        pstarkey: class PulseBlasterDirectOutputs(IntermediateDevice):
        pstarkey:     allowed_children = [DDS, DigitalOut]
        pstarkey:     clock_limit = PulseBlaster.clock_limit
        pstarkey:     description = 'PB-DDSII-300 Direct Outputs'
        pstarkey:   
        pstarkey:     def add_device(self, device):
        pstarkey:         IntermediateDevice.add_device(self, device)
        pstarkey:         if isinstance(device, DDS):
        pstarkey:             # Check that the user has not specified another digital line as the gate for this DDS, that doesn't make sense.
        pstarkey:             # Then instantiate a DigitalQuantity to keep track of gating.
        pstarkey:             if device.gate is None:
        pstarkey:                 device.gate = DigitalQuantity(device.name + '_gate', device, 'gate')
        pstarkey:             else:
        pstarkey:                 raise LabscriptError('You cannot specify a digital gate ' +
        pstarkey:                                      'for a DDS connected to %s. '% (self.name) + 
        pstarkey:                                      'The digital gate is always internal to the Pulseblaster.')
        pstarkey:             
        cbilling: 
        cbilling: from blacs.tab_base_classes import Worker, define_state
        cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
        cbilling: 
        cbilling: from blacs.device_base_class import DeviceTab
        cbilling: 
        pstarkey: from qtutils import UiLoader
        shjohnst: import qtutils.icons
        pstarkey: import os
        shjohnst: 
        shjohnst: # We can't import * from QtCore & QtGui, as one of them has a function called bin() which overrides the builtin, which is used in the pulseblaster worker
     janwerkmann: from qtutils.qt import QtCore
     janwerkmann: from qtutils.qt import QtGui
        shjohnst: 
        shjohnst:     
        pstarkey: 
        cbilling: @BLACS_tab
        cbilling: class PulseBlasterTab(DeviceTab):
        cbilling:     
        cbilling:     def initialise_GUI(self):
        cbilling:         # Capabilities
        cbilling:         self.base_units     = {'freq':'Hz',        'amp':'Vpp', 'phase':'Degrees'}
        cbilling:         self.base_min       = {'freq':0.3,         'amp':0.0,   'phase':0}
        cbilling:         self.base_max       = {'freq':150000000.0, 'amp':1.0,   'phase':360}
        cbilling:         self.base_step      = {'freq':1000000,     'amp':0.01,  'phase':1}
        cbilling:         self.base_decimals  = {'freq':1,           'amp':3,     'phase':3}
        cbilling:         self.num_DDS = 2
        cbilling:         self.num_DO = 12
        cbilling:         
        cbilling:         dds_prop = {}
        cbilling:         for i in range(self.num_DDS): # 2 is the number of DDS outputs on this device
        cbilling:             dds_prop['dds %d'%i] = {}
        cbilling:             for subchnl in ['freq', 'amp', 'phase']:
        cbilling:                 dds_prop['dds %d'%i][subchnl] = {'base_unit':self.base_units[subchnl],
        cbilling:                                                  'min':self.base_min[subchnl],
        cbilling:                                                  'max':self.base_max[subchnl],
        cbilling:                                                  'step':self.base_step[subchnl],
        cbilling:                                                  'decimals':self.base_decimals[subchnl]
        cbilling:                                                 }
        cbilling:             dds_prop['dds %d'%i]['gate'] = {}
        cbilling:         
        cbilling:         do_prop = {}
        cbilling:         for i in range(self.num_DO): # 12 is the maximum number of flags on this device (some only have 4 though)
        cbilling:             do_prop['flag %d'%i] = {}
        cbilling:         
        cbilling:         # Create the output objects    
        cbilling:         self.create_dds_outputs(dds_prop)        
        cbilling:         self.create_digital_outputs(do_prop)        
        cbilling:         # Create widgets for output objects
        cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
        cbilling:         
        cbilling:         # Define the sort function for the digital outputs
        cbilling:         def sort(channel):
        cbilling:             flag = channel.replace('flag ','')
        cbilling:             flag = int(flag)
        cbilling:             return '%02d'%(flag)
        cbilling:         
        cbilling:         # and auto place the widgets in the UI
        cbilling:         self.auto_place_widgets(("DDS Outputs",dds_widgets),("Flags",do_widgets,sort))
        cbilling:         
        cbilling:         # Store the board number to be used
        cbilling:         connection_object = self.settings['connection_table'].find_by_name(self.device_name)
        cbilling:         self.board_number = int(connection_object.BLACS_connection)
        cbilling:         
        cbilling:         # And which scheme we're using for buffered output programming and triggering:
        cbilling:         # (default values for backward compat with old connection tables)
        cbilling:         self.programming_scheme = connection_object.properties.get('programming_scheme', 'pb_start/BRANCH')
        cbilling:             
        cbilling:         # Create and set the primary worker
        cbilling:         self.create_worker("main_worker",PulseblasterWorker,{'board_number':self.board_number,
        cbilling:                                                              'programming_scheme': self.programming_scheme})
        cbilling:         self.primary_worker = "main_worker"
        cbilling:         
        cbilling:         # Set the capabilities of this device
        cbilling:         self.supports_smart_programming(True) 
        cbilling:         
        pstarkey:         # Load status monitor (and start/stop/reset buttons) UI
        pstarkey:         ui = UiLoader().load(os.path.join(os.path.dirname(os.path.realpath(__file__)),'pulseblaster.ui'))        
        pstarkey:         self.get_tab_layout().addWidget(ui)
        pstarkey:         # Connect signals for buttons
        pstarkey:         ui.start_button.clicked.connect(self.start)
        pstarkey:         ui.stop_button.clicked.connect(self.stop)
        pstarkey:         ui.reset_button.clicked.connect(self.reset)
        shjohnst:         # Add icons
        shjohnst:         ui.start_button.setIcon(QtGui.QIcon(':/qtutils/fugue/control'))
        shjohnst:         ui.start_button.setToolTip('Start')
        shjohnst:         ui.stop_button.setIcon(QtGui.QIcon(':/qtutils/fugue/control-stop-square'))
        shjohnst:         ui.stop_button.setToolTip('Stop')
        shjohnst:         ui.reset_button.setIcon(QtGui.QIcon(':/qtutils/fugue/arrow-circle'))
        shjohnst:         ui.reset_button.setToolTip('Reset')
        cbilling:         
        pstarkey:         # initialise dictionaries of data to display and get references to the QLabels
        pstarkey:         self.status_states = ['stopped', 'reset', 'running', 'waiting']
        pstarkey:         self.status = {}
        pstarkey:         self.status_widgets = {}
        pstarkey:         for state in self.status_states:
        pstarkey:             self.status[state] = False
        pstarkey:             self.status_widgets[state] = getattr(ui,'%s_label'%state)        
        cbilling:         
        pstarkey:         # Create status monitor timout
        pstarkey:         self.statemachine_timeout_add(2000, self.status_monitor)
        cbilling:         
        pstarkey:     def get_child_from_connection_table(self, parent_device_name, port):
        pstarkey:         # This is a direct output, let's search for it on the internal intermediate device called 
        pstarkey:         # PulseBlasterDirectOutputs
        pstarkey:         if parent_device_name == self.device_name:
        pstarkey:             device = self.connection_table.find_by_name(self.device_name)
        pstarkey:             pseudoclock = device.child_list[device.child_list.keys()[0]] # there should always be one (and only one) child, the Pseudoclock
        pstarkey:             clockline = None
        pstarkey:             for child_name, child in pseudoclock.child_list.items():
        pstarkey:                 # store a reference to the internal clockline
        pstarkey:                 if child.parent_port == 'internal':
        pstarkey:                     clockline = child
        pstarkey:                 # if the port is in use by a clockline, return the clockline
        pstarkey:                 elif child.parent_port == port:
        pstarkey:                     return child
        pstarkey:                 
        pstarkey:             if clockline is not None:
        pstarkey:                 # There should only be one child of this clock line, the direct outputs
        pstarkey:                 direct_outputs = clockline.child_list[clockline.child_list.keys()[0]] 
        pstarkey:                 # look to see if the port is used by a child of the direct outputs
        pstarkey:                 return DeviceTab.get_child_from_connection_table(self, direct_outputs.name, port)
        pstarkey:             else:
        pstarkey:                 return ''
        pstarkey:         else:
        pstarkey:             # else it's a child of a DDS, so we can use the default behaviour to find the device
        pstarkey:             return DeviceTab.get_child_from_connection_table(self, parent_device_name, port)
        pstarkey:     
        cbilling:     # This function gets the status of the Pulseblaster from the spinapi,
        cbilling:     # and updates the front panel widgets!
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def status_monitor(self,notify_queue=None):
        cbilling:         # When called with a queue, this function writes to the queue
        cbilling:         # when the pulseblaster is waiting. This indicates the end of
        cbilling:         # an experimental run.
chrisjbillington:         self.status, waits_pending, time_based_shot_over = yield(self.queue_work(self._primary_worker,'check_status'))
        cbilling:         
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             done_condition = self.status['waiting']
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             done_condition = self.status['stopped']
        cbilling:             
chrisjbillington:         if time_based_shot_over is not None:
chrisjbillington:             done_condition = time_based_shot_over
chrisjbillington:             
        cbilling:         if notify_queue is not None and done_condition and not waits_pending:
        cbilling:             # Experiment is over. Tell the queue manager about it, then
        cbilling:             # set the status checking timeout back to every 2 seconds
        cbilling:             # with no queue.
        cbilling:             notify_queue.put('done')
        cbilling:             self.statemachine_timeout_remove(self.status_monitor)
        cbilling:             self.statemachine_timeout_add(2000,self.status_monitor)
        cbilling:             if self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:                 # Not clear that on all models the outputs will be correct after being
        cbilling:                 # stopped this way, so we do program_manual with current values to be sure:
        cbilling:                 self.program_device()
        cbilling:                 
        pstarkey:         # Update widgets with new status
        pstarkey:         for state in self.status_states:
        shjohnst:             if self.status[state]:
        shjohnst:                 icon = QtGui.QIcon(':/qtutils/fugue/tick')
        shjohnst:             else:
        shjohnst:                 icon = QtGui.QIcon(':/qtutils/fugue/cross')
        shjohnst:             
        shjohnst:             pixmap = icon.pixmap(QtCore.QSize(16, 16))
        shjohnst:             self.status_widgets[state].setPixmap(pixmap)
        pstarkey:                         
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def start(self,widget=None):
        cbilling:         yield(self.queue_work(self._primary_worker,'start_run'))
        cbilling:         self.status_monitor()
        cbilling:         
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def stop(self,widget=None):
        cbilling:         yield(self.queue_work(self._primary_worker,'pb_stop'))
        cbilling:         self.status_monitor()
        cbilling:         
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def reset(self,widget=None):
        cbilling:         yield(self.queue_work(self._primary_worker,'pb_reset'))
        cbilling:         self.status_monitor()
        cbilling:     
        cbilling:     @define_state(MODE_BUFFERED,True)  
        cbilling:     def start_run(self, notify_queue):
        cbilling:         """Starts the Pulseblaster, notifying the queue manager when
        cbilling:         the run is over"""
        cbilling:         self.statemachine_timeout_remove(self.status_monitor)
        cbilling:         self.start()
        cbilling:         self.statemachine_timeout_add(100,self.status_monitor,notify_queue)
        cbilling: 
        cbilling: 
        cbilling: @BLACS_worker        
        cbilling: class PulseblasterWorker(Worker):
        cbilling:     def init(self):
        cbilling:         from labscript_utils import check_version
        cbilling:         check_version('spinapi', '3.1.1', '4')
        cbilling:         exec 'from spinapi import *' in globals()
        cbilling:         global h5py; import labscript_utils.h5_lock, h5py
        cbilling:         global zprocess; import zprocess
        cbilling:         
        cbilling:         self.pb_start = pb_start
        cbilling:         self.pb_stop = pb_stop
        cbilling:         self.pb_reset = pb_reset
        cbilling:         self.pb_close = pb_close
        cbilling:         self.pb_read_status = pb_read_status
        cbilling:         self.smart_cache = {'amps0':None,'freqs0':None,'phases0':None,
        cbilling:                             'amps1':None,'freqs1':None,'phases1':None,
        cbilling:                             'pulse_program':None,'ready_to_go':False,
        cbilling:                             'initial_values':None}
        cbilling:                             
        cbilling:         # An event for checking when all waits (if any) have completed, so that
        cbilling:         # we can tell the difference between a wait and the end of an experiment.
        cbilling:         # The wait monitor device is expected to post such events, which we'll wait on:
        cbilling:         self.all_waits_finished = zprocess.Event('all_waits_finished')
        cbilling:         self.waits_pending = False
        cbilling:     
        cbilling:         pb_select_board(self.board_number)
        cbilling:         pb_init()
        cbilling:         pb_core_clock(75)
chrisjbillington:         
chrisjbillington:         # This is only set to True on a per-shot basis, so set it to False
chrisjbillington:         # for manual mode
chrisjbillington:         self.time_based_stop_workaround = False
        cbilling: 
        cbilling:     def program_manual(self,values):
        cbilling:     
        cbilling:         if self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             # Need to ensure device is stopped before programming - or we won't know what line it's on.
        cbilling:             pb_stop()
        cbilling:             
        cbilling:         # Program the DDS registers:
        cbilling:         for i in range(2):
        cbilling:             pb_select_dds(i)
        cbilling:             # Program the frequency, amplitude and phase into their
        cbilling:             # zeroth registers:
        cbilling:             program_amp_regs(values['dds %d'%i]['amp']) # Does not call pb_stop_programming anyway, so no kwarg needed
        cbilling:             program_freq_regs(values['dds %d'%i]['freq']/10.0**6, call_stop_programming=False) # method expects MHz
        cbilling:             program_phase_regs(values['dds %d'%i]['phase'], call_stop_programming=False)
        cbilling: 
        cbilling:         # create flags string
        cbilling:         # NOTE: The spinapi can take a string or integer for flags.
        cbilling:                 # If it is a string: 
        cbilling:                 #     flag: 0          12
        cbilling:                 #          '101100011111'
        cbilling:                 #
        cbilling:                 # If it is a binary number:
        cbilling:                 #     flag:12          0
        cbilling:                 #         0b111110001101
        cbilling:                 #
        cbilling:                 # Be warned!
        cbilling:         flags = ''
        cbilling:         for i in range(12):
        cbilling:             if values['flag %d'%i]:
        cbilling:                 flags += '1'
        cbilling:             else:
        cbilling:                 flags += '0'
        cbilling:         
        cbilling:         # Write the first two lines of the pulse program:
        cbilling:         pb_start_programming(PULSE_PROGRAM)
        cbilling:         # Line zero is a wait:
        cbilling:         pb_inst_dds2(0,0,0,values['dds 0']['gate'],0,0,0,0,values['dds 1']['gate'],0,flags, WAIT, 0, 100)
        cbilling:         # Line one is a brach to line 0:
        cbilling:         pb_inst_dds2(0,0,0,values['dds 0']['gate'],0,0,0,0,values['dds 1']['gate'],0,flags, BRANCH, 0, 100)
        cbilling:         pb_stop_programming()
        cbilling:         
        cbilling:         # Now we're waiting on line zero, so when we start() we'll go to
        cbilling:         # line one, then brach back to zero, completing the static update:
        cbilling:         pb_start()
        cbilling:         
        cbilling:         # The pulse program now has a branch in line one, and so can't proceed to the pulse program
        cbilling:         # without a reprogramming of the first two lines:
        cbilling:         self.smart_cache['ready_to_go'] = False
        cbilling:         
        cbilling:         # TODO: return coerced/quantised values
        cbilling:         return {}
        cbilling:         
        cbilling:     def start_run(self):
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             pb_start()
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             pb_stop_programming()
        cbilling:             pb_start()
        cbilling:         else:
        cbilling:             raise ValueError('invalid programming_scheme: %s'%str(self.programming_scheme))
chrisjbillington:         if self.time_based_stop_workaround:
chrisjbillington:             import time
chrisjbillington:             self.time_based_shot_end_time = time.time() + self.time_based_shot_duration
        cbilling:     
        cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
        cbilling:         self.h5file = h5file
        cbilling:         if self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             # Need to ensure device is stopped before programming - or we wont know what line it's on.
        cbilling:             pb_stop()
        cbilling:         with h5py.File(h5file,'r') as hdf5_file:
        cbilling:             group = hdf5_file['devices/%s'%device_name]
chrisjbillington:             
chrisjbillington:             # Is this shot using the fixed-duration workaround instead of checking the PulseBlaster's status?
chrisjbillington:             self.time_based_stop_workaround = group.attrs.get('time_based_stop_workaround', False)
chrisjbillington:             if self.time_based_stop_workaround:
chrisjbillington:                 self.time_based_shot_duration = (group.attrs['stop_time']
chrisjbillington:                                                  + hdf5_file['waits'][:]['timeout'].sum()
chrisjbillington:                                                  + group.attrs['time_based_stop_workaround_extra_time'])
chrisjbillington:             
        cbilling:             # Program the DDS registers:
        cbilling:             ampregs = []
        cbilling:             freqregs = []
        cbilling:             phaseregs = []
        cbilling:             for i in range(2):
        cbilling:                 amps = group['DDS%d/AMP_REGS'%i][:]
        cbilling:                 freqs = group['DDS%d/FREQ_REGS'%i][:]
        cbilling:                 phases = group['DDS%d/PHASE_REGS'%i][:]
        cbilling:                 
        cbilling:                 amps[0] = initial_values['dds %d'%i]['amp']
        cbilling:                 freqs[0] = initial_values['dds %d'%i]['freq']/10.0**6 # had better be in MHz!
        cbilling:                 phases[0] = initial_values['dds %d'%i]['phase']
        cbilling:                 
        cbilling:                 pb_select_dds(i)
        cbilling:                 # Only reprogram each thing if there's been a change:
        cbilling:                 if fresh or len(amps) != len(self.smart_cache['amps%d'%i]) or (amps != self.smart_cache['amps%d'%i]).any():   
        cbilling:                     self.smart_cache['amps%d'%i] = amps
        cbilling:                     program_amp_regs(*amps)
        cbilling:                 if fresh or len(freqs) != len(self.smart_cache['freqs%d'%i]) or (freqs != self.smart_cache['freqs%d'%i]).any():
        cbilling:                     self.smart_cache['freqs%d'%i] = freqs
        cbilling:                     # We must be careful not to call stop_programming() until the end,
        cbilling:                     # lest the pulseblaster become responsive to triggers before we are done programming.
        cbilling:                     # This is not an issue for program_amp_regs above, only for freq and phase regs.
        cbilling:                     program_freq_regs(*freqs, call_stop_programming=False)
        cbilling:                 if fresh or len(phases) != len(self.smart_cache['phases%d'%i]) or (phases != self.smart_cache['phases%d'%i]).any():      
        cbilling:                     self.smart_cache['phases%d'%i] = phases
        cbilling:                     # See above comment - we must not call pb_stop_programming here:
        cbilling:                     program_phase_regs(*phases, call_stop_programming=False)
        cbilling:                 
        cbilling:                 ampregs.append(amps)
        cbilling:                 freqregs.append(freqs)
        cbilling:                 phaseregs.append(phases)
        cbilling:                 
        cbilling:             # Now for the pulse program:
        cbilling:             pulse_program = group['PULSE_PROGRAM'][2:]
        cbilling:             
        cbilling:             #Let's get the final state of the pulseblaster. z's are the args we don't need:
        cbilling:             freqreg0,phasereg0,ampreg0,en0,z,freqreg1,phasereg1,ampreg1,en1,z,flags,z,z,z = pulse_program[-1]
        cbilling:             finalfreq0 = freqregs[0][freqreg0]*10.0**6 # Front panel expects frequency in Hz
        cbilling:             finalfreq1 = freqregs[1][freqreg1]*10.0**6 # Front panel expects frequency in Hz
        cbilling:             finalamp0 = ampregs[0][ampreg0]
        cbilling:             finalamp1 = ampregs[1][ampreg1]
        cbilling:             finalphase0 = phaseregs[0][phasereg0]
        cbilling:             finalphase1 = phaseregs[1][phasereg1]
        cbilling:             
        cbilling:             # Always call start_programming regardless of whether we are going to do any
        cbilling:             # programming or not. This is so that is the programming_scheme is 'pb_stop_programming/STOP'
        cbilling:             # we are ready to be triggered by a call to pb_stop_programming() even if no programming
        cbilling:             # occurred due to smart programming:
        cbilling:             pb_start_programming(PULSE_PROGRAM)
        cbilling:             
        cbilling:             if fresh or (self.smart_cache['initial_values'] != initial_values) or \
        cbilling:                 (len(self.smart_cache['pulse_program']) != len(pulse_program)) or \
        cbilling:                 (self.smart_cache['pulse_program'] != pulse_program).any() or \
        cbilling:                 not self.smart_cache['ready_to_go']:
        cbilling:             
        cbilling:                 self.smart_cache['ready_to_go'] = True
        cbilling:                 self.smart_cache['initial_values'] = initial_values
        cbilling:                 # Line zero is a wait on the final state of the program:
        cbilling:                 pb_inst_dds2(freqreg0,phasereg0,ampreg0,en0,0,freqreg1,phasereg1,ampreg1,en1,0,flags,WAIT,0,100)
        cbilling:                 
        cbilling:                 # create initial flags string
        cbilling:                 # NOTE: The spinapi can take a string or integer for flags.
        cbilling:                 # If it is a string: 
        cbilling:                 #     flag: 0          12
        cbilling:                 #          '101100011111'
        cbilling:                 #
        cbilling:                 # If it is a binary number:
        cbilling:                 #     flag:12          0
        cbilling:                 #         0b111110001101
        cbilling:                 #
        cbilling:                 # Be warned!
        cbilling:                 initial_flags = ''
        cbilling:                 for i in range(12):
        cbilling:                     if initial_values['flag %d'%i]:
        cbilling:                         initial_flags += '1'
        cbilling:                     else:
        cbilling:                         initial_flags += '0'
        cbilling:                 # Line one is a continue with the current front panel values:
        cbilling:                 pb_inst_dds2(0,0,0,initial_values['dds 0']['gate'],0,0,0,0,initial_values['dds 1']['gate'],0,initial_flags, CONTINUE, 0, 100)
        cbilling:                 # Now the rest of the program:
        cbilling:                 if fresh or len(self.smart_cache['pulse_program']) != len(pulse_program) or \
        cbilling:                 (self.smart_cache['pulse_program'] != pulse_program).any():
        cbilling:                     self.smart_cache['pulse_program'] = pulse_program
        cbilling:                     for args in pulse_program:
        cbilling:                         pb_inst_dds2(*args)
        cbilling:             
        cbilling:             if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:                 # We will be triggered by pb_start() if we are are the master pseudoclock or a single hardware trigger
        cbilling:                 # from the master if we are not:
        cbilling:                 pb_stop_programming()
        cbilling:             elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:                 # Don't call pb_stop_programming(). We don't want to pulseblaster to respond to hardware
        cbilling:                 # triggers (such as 50/60Hz line triggers) until we are ready to run.
        cbilling:                 # Our start_method will call pb_stop_programming() when we are ready
        cbilling:                 pass
        cbilling:             else:
        cbilling:                 raise ValueError('invalid programming_scheme %s'%str(self.programming_scheme))
        cbilling:             
        cbilling:             # Are there waits in use in this experiment? The monitor waiting for the end of
        cbilling:             # the experiment will need to know:
        cbilling:             self.waits_pending =  bool(len(hdf5_file['waits']))
        cbilling:             
        cbilling:             # Now we build a dictionary of the final state to send back to the GUI:
        cbilling:             return_values = {'dds 0':{'freq':finalfreq0, 'amp':finalamp0, 'phase':finalphase0, 'gate':en0},
        cbilling:                              'dds 1':{'freq':finalfreq1, 'amp':finalamp1, 'phase':finalphase1, 'gate':en1},
        cbilling:                             }
        cbilling:             # Since we are converting from an integer to a binary string, we need to reverse the string! (see notes above when we create flags variables)
        cbilling:             return_flags = bin(flags)[2:].rjust(12,'0')[::-1]
        cbilling:             for i in range(12):
        cbilling:                 return_values['flag %d'%i] = return_flags[i]
        cbilling:                 
        cbilling:             return return_values
        cbilling:             
        cbilling:     def check_status(self):
        cbilling:         if self.waits_pending:
        cbilling:             try:
        cbilling:                 self.all_waits_finished.wait(self.h5file, timeout=0)
        cbilling:                 self.waits_pending = False
        cbilling:             except zprocess.TimeoutError:
        cbilling:                 pass
chrisjbillington:         if self.time_based_stop_workaround:
chrisjbillington:             import time
chrisjbillington:             time_based_shot_over = time.time() > self.time_based_shot_end_time
chrisjbillington:         else:
chrisjbillington:             time_based_shot_over = None
chrisjbillington:         return pb_read_status(), self.waits_pending, time_based_shot_over
        cbilling: 
        cbilling:     def transition_to_manual(self):
chrisjbillington:         status, waits_pending, time_based_shot_over = self.check_status()
        cbilling:         
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             done_condition = status['waiting']
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             done_condition = True # status['stopped']
        cbilling:             
chrisjbillington:         if time_based_shot_over is not None:
chrisjbillington:             done_condition = time_based_shot_over
chrisjbillington:             
chrisjbillington:         # This is only set to True on a per-shot basis, so reset it to False
chrisjbillington:         # for manual mode
chrisjbillington:         self.time_based_stop_workaround = False
chrisjbillington:         
        cbilling:         if done_condition and not waits_pending:
        cbilling:             return True
        cbilling:         else:
        cbilling:             return False
        cbilling:      
        cbilling:     def abort_buffered(self):
        cbilling:         # Stop the execution
        cbilling:         self.pb_stop()
        cbilling:         # Reset to the beginning of the pulse sequence
        cbilling:         self.pb_reset()
        cbilling:                 
        cbilling:         # abort_buffered in the GUI process queues up a program_device state
        cbilling:         # which will reprogram the device and call pb_start()
        cbilling:         # This ensures the device isn't accidentally retriggered by another device
        cbilling:         # while it is running it's abort function
        cbilling:         return True
        cbilling:         
        cbilling:     def abort_transition_to_buffered(self):
        cbilling:         return True
        cbilling:         
        cbilling:     def shutdown(self):
        cbilling:         #TODO: implement this
        cbilling:         pass
        cbilling:       
        cbilling: 
        cbilling:             
        cbilling: @runviewer_parser
        cbilling: class PulseBlasterParser(object):
        pstarkey:     num_dds = 2
        pstarkey:     num_flags = 12
        pstarkey:     
        pstarkey:     def __init__(self, path, device):
        pstarkey:         self.path = path
        pstarkey:         self.name = device.name
        pstarkey:         self.device = device
        pstarkey:         
        pstarkey:         # We create a lookup table for strings to be used later as dictionary keys.
        pstarkey:         # This saves having to evaluate '%d'%i many many times, and makes the _add_pulse_program_row_to_traces method
        pstarkey:         # significantly more efficient
        pstarkey:         self.dds_strings = {}
        pstarkey:         for i in range(self.num_dds):
        pstarkey:             self.dds_strings[i] = {}
        pstarkey:             self.dds_strings[i]['ddsfreq'] = 'dds %d_freq'%i
        pstarkey:             self.dds_strings[i]['ddsamp'] = 'dds %d_amp'%i
        pstarkey:             self.dds_strings[i]['ddsphase'] = 'dds %d_phase'%i
        pstarkey:             self.dds_strings[i]['freq'] = 'freq%d'%i
        pstarkey:             self.dds_strings[i]['amp'] = 'amp%d'%i
        pstarkey:             self.dds_strings[i]['phase'] = 'phase%d'%i
        pstarkey:             self.dds_strings[i]['dds_en'] = 'dds_en%d'%i
        pstarkey:             
        pstarkey:         self.flag_strings = {}
        pstarkey:         self.flag_powers = {}
        pstarkey:         
        pstarkey:         for i in range(self.num_flags):
        pstarkey:             self.flag_strings[i] = 'flag %d'%i
        pstarkey:             self.flag_powers[i] = 2**i
        pstarkey:         
        pstarkey:             
        pstarkey:         
        pstarkey:     def get_traces(self, add_trace, parent=None):
        pstarkey:         if parent is None:
        pstarkey:             # we're the master pseudoclock, software triggered. So we don't have to worry about trigger delays, etc
        pstarkey:             pass
        pstarkey:             
        pstarkey:         # get the pulse program
        pstarkey:         with h5py.File(self.path, 'r') as f:
        pstarkey:             pulse_program = f['devices/%s/PULSE_PROGRAM'%self.name][:]
        pstarkey:             # slow_clock_flag = eval(f['devices/%s'%self.name].attrs['slow_clock'])
        pstarkey:             dds = {}
        pstarkey:             for i in range(self.num_dds):
        pstarkey:                 dds[i] = {}
        pstarkey:                 for reg in ['FREQ', 'AMP', 'PHASE']:
        pstarkey:                     dds[i][reg] = f['devices/%s/DDS%d/%s_REGS'%(self.name, i, reg)][:]
        pstarkey:         
        pstarkey:         clock = []
        pstarkey:         traces = {}
        pstarkey:         for i in range(self.num_flags):
        pstarkey:             traces['flag %d'%i] = []
        pstarkey:         for i in range(self.num_dds):
        pstarkey:             for sub_chnl in ['freq', 'amp', 'phase']:
        pstarkey:                 traces['dds %d_%s'%(i,sub_chnl)] = []   
        pstarkey:         
        pstarkey:         # now build the traces
        pstarkey:         t = 0. if parent is None else PulseBlaster.trigger_delay # Offset by initial trigger of parent
        pstarkey:         i = 0
        pstarkey:         while i < len(pulse_program):
        pstarkey:             # ignore the first 2 instructions, they are dummy instructions for BLACS
        pstarkey:             if i < 2:
        pstarkey:                 i += 1
        pstarkey:                 continue
        pstarkey:             
        pstarkey:             row = pulse_program[i]
        pstarkey:             
        pstarkey:             if row['inst'] == 2: # Loop
        pstarkey:                 loops = int(row['inst_data'])
        pstarkey:                 
        pstarkey:                 buffer = {}
        pstarkey:                 j = i
        pstarkey:                 while loops > 0:
        pstarkey:                     looping = True
        pstarkey:                     while looping:
        pstarkey:                         row = pulse_program[j]
        pstarkey:                         # buffer the index of traces used for this instruction
        pstarkey:                         # Cuts the runtime down by ~60%
        pstarkey:                         # start_profile('loop_contents')
        pstarkey:                         if j not in buffer:
        pstarkey:                             clock.append(t)
        pstarkey:                             self._add_pulse_program_row_to_traces(traces, row, dds)
        pstarkey:                             buffer[j] = len(clock)-1
        pstarkey:                         else:                            
        pstarkey:                             clock.append(t)
        pstarkey:                             self._add_pulse_program_row_from_buffer(traces, buffer[j])
        pstarkey:                         # stop_profile('loop_contents')
        pstarkey:                             
        pstarkey:                         # start_profile('end_of_loop')
        pstarkey:                         t+= row['length']*1.0e-9
        pstarkey:                         
        pstarkey:                         if row['inst'] == 3: # END_LOOP
        pstarkey:                             looping = False
        pstarkey:                             # print 'end loop. j=%d, t=%.7f'%(j,t)
        pstarkey:                             j = int(row['inst_data']) if loops > 1 else j
        pstarkey:                             # print 'setting j=%d'%j
        pstarkey:                         else:
        pstarkey:                             # print 'in loop. j=%d, t=%.7f'%(j,t)
        pstarkey:                             j+=1
        pstarkey:                         # stop_profile('end_of_loop')
        pstarkey:                     loops -= 1
        pstarkey:                     
        pstarkey:                 i = j
        pstarkey:                 # print 'i now %d'%i
        pstarkey:                     
        pstarkey:             else: # Continue
        pstarkey:                 if row['inst'] == 8: #WAIT
        pstarkey:                     print 'Wait at %.9f'%t
        pstarkey:                     pass
        pstarkey:                 clock.append(t)
        pstarkey:                 self._add_pulse_program_row_to_traces(traces,row,dds)
        pstarkey:                 t+= row['length']*1.0e-9
        pstarkey:             
        pstarkey:                 if row['inst'] == 8 and parent is not None: #WAIT
        pstarkey:                     #TODO: Offset next time by trigger delay is not master pseudoclock
        pstarkey:                     t+= PulseBlaster.trigger_delay
        pstarkey:                     
        pstarkey:             
        pstarkey:             i += 1            
        pstarkey:                 
        pstarkey:         print 'Stop time: %.9f'%t 
        pstarkey:         # now put together the traces
        pstarkey:         to_return = {}
        pstarkey:         clock = np.array(clock, dtype=np.float64)
        pstarkey:         for name, data in traces.items():
        pstarkey:             to_return[name] = (clock, np.array(data))
        pstarkey:             
        pstarkey:         
        pstarkey:         # if slow_clock_flag is not None:
        pstarkey:             # to_return['slow clock'] = to_return['flag %d'%slow_clock_flag[0]]
        pstarkey:             
        pstarkey:         clocklines_and_triggers = {}
        pstarkey:         for pseudoclock_name, pseudoclock in self.device.child_list.items():
        pstarkey:             for clock_line_name, clock_line in pseudoclock.child_list.items():
        pstarkey:                 if clock_line.parent_port == 'internal':
        pstarkey:                     parent_device_name = '%s.direct_outputs'%self.name
        pstarkey:                     for internal_device_name, internal_device in clock_line.child_list.items():
        pstarkey:                         for channel_name, channel in internal_device.child_list.items():
        pstarkey:                             if channel.device_class == 'Trigger':
        pstarkey:                                 clocklines_and_triggers[channel_name] = to_return[channel.parent_port]
        pstarkey:                                 add_trace(channel_name, to_return[channel.parent_port], parent_device_name, channel.parent_port)
        pstarkey:                             else:
        pstarkey:                                 if channel.device_class == 'DDS':
        pstarkey:                                     for subchnl_name, subchnl in channel.child_list.items():
        pstarkey:                                         connection = '%s_%s'%(channel.parent_port, subchnl.parent_port)
        pstarkey:                                         if connection in to_return:
        pstarkey:                                             add_trace(subchnl.name, to_return[connection], parent_device_name, connection)
        pstarkey:                                 else:
        pstarkey:                                     add_trace(channel_name, to_return[channel.parent_port], parent_device_name, channel.parent_port)
        pstarkey:                 else:
        pstarkey:                     clocklines_and_triggers[clock_line_name] = to_return[clock_line.parent_port]
        pstarkey:                     add_trace(clock_line_name, to_return[clock_line.parent_port], self.name, clock_line.parent_port)
        pstarkey:             
        pstarkey:         return clocklines_and_triggers
        pstarkey:     
        pstarkey:     @profile
        pstarkey:     def _add_pulse_program_row_from_buffer(self, traces, index):
        pstarkey:         for i in range(self.num_flags):
        pstarkey:             traces[self.flag_strings[i]].append(traces[self.flag_strings[i]][index])
        pstarkey:             
        pstarkey:         for i in range(self.num_dds):
        pstarkey:             current_strings = self.dds_strings[i]
        pstarkey:             traces[current_strings['ddsfreq']].append(traces[current_strings['ddsfreq']][index])
        pstarkey:             traces[current_strings['ddsphase']].append(traces[current_strings['ddsphase']][index])
        pstarkey:             traces[current_strings['ddsamp']].append(traces[current_strings['ddsamp']][index])
        pstarkey:             
        pstarkey:     @profile            
        pstarkey:     def _add_pulse_program_row_to_traces(self, traces, row, dds, flags = None):
        pstarkey:         # add flags
        pstarkey:         if flags is None:
        pstarkey:             flags = np.binary_repr(row['flags'],self.num_flags)[::-1]
        pstarkey:         for i in range(self.num_flags):
        pstarkey:             traces[self.flag_strings[i]].append(int(flags[i]))
        pstarkey:         
        pstarkey:         # Below block saved for history. This is much slower compared to what is below!
        pstarkey:         # for i in range(self.num_dds):
        pstarkey:             # traces['dds %d_freq'%i].append(dds[i]['FREQ'][row['freq%d'%i]])
        pstarkey:             # traces['dds %d_phase'%i].append(dds[i]['PHASE'][row['phase%d'%i]])
        pstarkey:             # amp = dds[i]['AMP'][row['amp%d'%i]] if row['dds_en%d'%i] else 0
        pstarkey:             # traces['dds %d_amp'%i].append(amp)
        pstarkey:             
        pstarkey:        
        pstarkey:         # note that we are looking up keys for the traces dictionary and row array in self.dds_strings
        pstarkey:         # Doing this reduces the runtime (of the below block) by 25%
        pstarkey:         for i in range(self.num_dds):
        pstarkey:             # Note: This is done to reduce runtime (about 10%)
        pstarkey:             current_strings = self.dds_strings[i]
        pstarkey:             current_dds = dds[i]
        pstarkey:             
        pstarkey:             traces[current_strings['ddsfreq']].append(current_dds['FREQ'][row[current_strings['freq']]])
        pstarkey:             traces[current_strings['ddsphase']].append(current_dds['PHASE'][row[current_strings['phase']]])
        pstarkey:             # Note: Using the inline if statement reduces the runtime (of this for loop) by 50%
        pstarkey:             amp = current_dds['AMP'][row[current_strings['amp']]] if row[current_strings['dds_en']] else 0
        pstarkey:             traces[current_strings['ddsamp']].append(amp)
        pstarkey:             
        cbilling:             
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /PulseblasterESRpro500.py                                         #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of labscript_devices, in the labscript suite    #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: from labscript_devices.PulseBlaster_No_DDS import PulseBlaster_No_DDS, Pulseblaster_No_DDS_Tab, PulseblasterNoDDSWorker
cbilling: 
cbilling: 
cbilling: @labscript_device
cbilling: class PulseBlasterESRPro500(PulseBlaster_No_DDS):
cbilling:     description = 'SpinCore PulseBlaster ESR-PRO-500'
cbilling:     clock_limit = 50.0e6 # can probably go faster
cbilling:     clock_resolution = 4e-9
cbilling:     n_flags = 21
cbilling: 
cbilling: 
cbilling: @BLACS_tab    
cbilling: class pulseblasteresrpro500(Pulseblaster_No_DDS_Tab):
cbilling:     # Capabilities
cbilling:     num_DO = 21
cbilling:     def __init__(self,*args,**kwargs):
cbilling:         self.device_worker_class = PulseblasterESRPro500Worker 
cbilling:         Pulseblaster_No_DDS_Tab.__init__(self,*args,**kwargs)
cbilling:     
cbilling:     
cbilling: @BLACS_worker
cbilling: class PulseblasterESRPro500Worker(PulseblasterNoDDSWorker):
cbilling:     core_clock_freq = 500.0
cbilling:     
cbilling:      
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /pulseblasterUSB.py                                               #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of labscript_devices, in the labscript suite    #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: from labscript_devices.PulseBlaster_No_DDS import PulseBlaster_No_DDS, Pulseblaster_No_DDS_Tab, PulseblasterNoDDSWorker
cbilling: 
cbilling: @labscript_device
cbilling: class PulseBlasterUSB(PulseBlaster_No_DDS):
cbilling:     description = 'SpinCore PulseBlasterUSB'        
cbilling:     clock_limit = 8.3e6 # can probably go faster
cbilling:     clock_resolution = 20e-9
cbilling:     n_flags = 24
cbilling:     
cbilling: @BLACS_tab
cbilling: class PulseblasterUSBTab(Pulseblaster_No_DDS_Tab):
cbilling:     # Capabilities
cbilling:     num_DO = 24
cbilling:     def __init__(self,*args,**kwargs):
cbilling:         self.device_worker_class = PulseblasterUSBWorker 
cbilling:         pulseblaster_no_dds.__init__(self,*args,**kwargs)
cbilling:     
cbilling: @BLACS_worker   
cbilling: class PulseblasterUSBWorker(PulseblasterNoDDSWorker):
cbilling:     core_clock_freq = 100.0
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # /Pulseblaster_No_DDS.py                                           #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of labscript_devices, in the labscript suite    #
        cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
        cbilling: # Simplified BSD License. See the license.txt file in the root of   #
        cbilling: # the project for the full license.                                 #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
        cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
            dihm: from labscript_devices.PulseBlaster import PulseBlaster, PulseBlasterParser
        cbilling: from labscript import PseudoclockDevice, config
        cbilling: 
        cbilling: import numpy as np
        cbilling: 
        cbilling: import time
        cbilling: 
        cbilling: def check_version(module_name, at_least, less_than, version=None):
        cbilling: 
        cbilling:     class VersionException(Exception):
        cbilling:         pass
        cbilling: 
        cbilling:     def get_version_tuple(version_string):
        cbilling:         version_tuple = [int(v.replace('+', '-').split('-')[0]) for v in version_string.split('.')]
        cbilling:         while len(version_tuple) < 3:
        cbilling:             version_tuple += (0,)
        cbilling:         return version_tuple
        cbilling: 
        cbilling:     if version is None:
        cbilling:         version = __import__(module_name).__version__
        cbilling:     at_least_tuple, less_than_tuple, version_tuple = [get_version_tuple(v) for v in [at_least, less_than, version]]
        cbilling:     if not at_least_tuple <= version_tuple < less_than_tuple:
        cbilling:         raise VersionException(
        cbilling:             '{module_name} {version} found. {at_least} <= {module_name} < {less_than} required.'.format(**locals()))
        cbilling:             
        cbilling:             
        cbilling: @labscript_device
        cbilling: class PulseBlaster_No_DDS(PulseBlaster):
        cbilling: 
        cbilling:     description = 'generic DO only Pulseblaster'
        cbilling:     clock_limit = 8.3e6 # can probably go faster
        cbilling:     clock_resolution = 20e-9
        cbilling:     n_flags = 24
        cbilling:     
        pstarkey:     def write_pb_inst_to_h5(self, pb_inst, hdf5_file):
        cbilling:         # OK now we squeeze the instructions into a numpy array ready for writing to hdf5:
        cbilling:         pb_dtype = [('flags',np.int32), ('inst',np.int32),
        cbilling:                     ('inst_data',np.int32), ('length',np.float64)]
        cbilling:         pb_inst_table = np.empty(len(pb_inst),dtype = pb_dtype)
        cbilling:         for i,inst in enumerate(pb_inst):
        cbilling:             flagint = int(inst['flags'][::-1],2)
        cbilling:             instructionint = self.pb_instructions[inst['instruction']]
        cbilling:             dataint = inst['data']
        cbilling:             delaydouble = inst['delay']
        cbilling:             pb_inst_table[i] = (flagint, instructionint, dataint, delaydouble)
        pstarkey:         
        pstarkey:         # Okay now write it to the file: 
        cbilling:         group = hdf5_file['/devices/'+self.name]  
        cbilling:         group.create_dataset('PULSE_PROGRAM', compression=config.compression,data = pb_inst_table)         
        cbilling:         self.set_property('stop_time', self.stop_time, location='device_properties')
        cbilling:         
        cbilling:     def generate_code(self, hdf5_file):
        cbilling:         # Generate the hardware instructions
        spielman:         self.init_device_group(hdf5_file)
        cbilling:         PseudoclockDevice.generate_code(self, hdf5_file)
        cbilling:         dig_outputs, ignore = self.get_direct_outputs()
        pstarkey:         pb_inst = self.convert_to_pb_inst(dig_outputs, [], {}, {}, {})
        pstarkey:         self.write_pb_inst_to_h5(pb_inst, hdf5_file) 
        cbilling:         
        cbilling: 
        cbilling: from blacs.tab_base_classes import Worker, define_state
        cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
        cbilling: 
        cbilling: from blacs.device_base_class import DeviceTab
        cbilling: 
            dihm: from qtutils import UiLoader
        shjohnst: import qtutils.icons
            dihm: import os
        shjohnst: 
        shjohnst: # We can't import * from QtCore & QtGui, as one of them has a function called bin() which overrides the builtin, which is used in the pulseblaster worker
     janwerkmann: from qtutils.qt import QtCore
     janwerkmann: from qtutils.qt import QtGui
     janwerkmann: from qtutils.qt import QtWidgets
            dihm: 
        cbilling: @BLACS_tab
        cbilling: class Pulseblaster_No_DDS_Tab(DeviceTab):
        cbilling:     # Capabilities
        cbilling:     num_DO = 24
        cbilling:     def __init__(self,*args,**kwargs):
        cbilling:         if not hasattr(self,'device_worker_class'):
        cbilling:             self.device_worker_class = PulseblasterNoDDSWorker
        cbilling:         DeviceTab.__init__(self,*args,**kwargs)
        cbilling:         
        cbilling:     def initialise_GUI(self):
        cbilling:         do_prop = {}
        cbilling:         for i in range(self.num_DO): # 12 is the maximum number of flags on this device (some only have 4 though)
        cbilling:             do_prop['flag %d'%i] = {}
        cbilling:         
        cbilling:         # Create the output objects         
        cbilling:         self.create_digital_outputs(do_prop)        
        cbilling:         # Create widgets for output objects
        cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
        cbilling:         
        cbilling:         # Define the sort function for the digital outputs
        cbilling:         def sort(channel):
        cbilling:             flag = channel.replace('flag ','')
        cbilling:             flag = int(flag)
        cbilling:             return '%02d'%(flag)
        cbilling:         
        cbilling:         # and auto place the widgets in the UI
        cbilling:         self.auto_place_widgets(("Flags",do_widgets,sort))
        cbilling:         
        cbilling:         # Store the board number to be used
        cbilling:         connection_object = self.settings['connection_table'].find_by_name(self.device_name)
        cbilling:         self.board_number = int(connection_object.BLACS_connection)
        cbilling:         
        cbilling:         # And which scheme we're using for buffered output programming and triggering:
        cbilling:         # (default values for backward compat with old connection tables)
        cbilling:         self.programming_scheme = connection_object.properties.get('programming_scheme', 'pb_start/BRANCH')
        cbilling:         
        cbilling:         # Create and set the primary worker
        cbilling:         self.create_worker("main_worker",self.device_worker_class,{'board_number':self.board_number,
        cbilling:                                                                    'num_DO': self.num_DO,
        cbilling:                                                                    'programming_scheme': self.programming_scheme})
        cbilling:         self.primary_worker = "main_worker"
        cbilling:         
        cbilling:         # Set the capabilities of this device
        cbilling:         self.supports_smart_programming(True) 
        cbilling:         
            dihm:         #### adding status widgets from PulseBlaster.py
            dihm:         
            dihm:         # Load status monitor (and start/stop/reset buttons) UI
            dihm:         ui = UiLoader().load(os.path.join(os.path.dirname(os.path.realpath(__file__)),'pulseblaster.ui'))        
            dihm:         self.get_tab_layout().addWidget(ui)
            dihm:         # Connect signals for buttons
            dihm:         ui.start_button.clicked.connect(self.start)
            dihm:         ui.stop_button.clicked.connect(self.stop)
            dihm:         ui.reset_button.clicked.connect(self.reset)
        shjohnst:         # Add icons
        shjohnst:         ui.start_button.setIcon(QtGui.QIcon(':/qtutils/fugue/control'))
        shjohnst:         ui.start_button.setToolTip('Start')
        shjohnst:         ui.stop_button.setIcon(QtGui.QIcon(':/qtutils/fugue/control-stop-square'))
        shjohnst:         ui.stop_button.setToolTip('Stop')
        shjohnst:         ui.reset_button.setIcon(QtGui.QIcon(':/qtutils/fugue/arrow-circle'))
        shjohnst:         ui.reset_button.setToolTip('Reset')
            dihm:         
            dihm:         # initialise dictionaries of data to display and get references to the QLabels
            dihm:         self.status_states = ['stopped', 'reset', 'running', 'waiting']
            dihm:         self.status = {}
            dihm:         self.status_widgets = {}
            dihm:         for state in self.status_states:
            dihm:             self.status[state] = False
            dihm:             self.status_widgets[state] = getattr(ui,'%s_label'%state) 
            dihm:         
        cbilling:         # Status monitor timout
        cbilling:         self.statemachine_timeout_add(2000, self.status_monitor)
        cbilling:         
          philip:     def get_child_from_connection_table(self, parent_device_name, port):
          philip:         # This is a direct output, let's search for it on the internal intermediate device called 
          philip:         # PulseBlasterDirectOutputs
          philip:         if parent_device_name == self.device_name:
          philip:             device = self.connection_table.find_by_name(self.device_name)
          philip:             pseudoclock = device.child_list[device.child_list.keys()[0]] # there should always be one (and only one) child, the Pseudoclock
          philip:             clockline = None
          philip:             for child_name, child in pseudoclock.child_list.items():
          philip:                 # store a reference to the internal clockline
          philip:                 if child.parent_port == 'internal':
          philip:                     clockline = child
          philip:                 # if the port is in use by a clockline, return the clockline
          philip:                 elif child.parent_port == port:
          philip:                     return child
          philip:                 
          philip:             if clockline is not None:
          philip:                 # There should only be one child of this clock line, the direct outputs
          philip:                 direct_outputs = clockline.child_list[clockline.child_list.keys()[0]] 
          philip:                 # look to see if the port is used by a child of the direct outputs
          philip:                 return DeviceTab.get_child_from_connection_table(self, direct_outputs.name, port)
          philip:             else:
          philip:                 return ''
          philip:         else:
          philip:             # else it's a child of a DDS, so we can use the default behaviour to find the device
          philip:             return DeviceTab.get_child_from_connection_table(self, parent_device_name, port)
        cbilling:     
        cbilling:     # This function gets the status of the Pulseblaster from the spinapi,
        cbilling:     # and updates the front panel widgets!
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def status_monitor(self,notify_queue=None):
        cbilling:         # When called with a queue, this function writes to the queue
        cbilling:         # when the pulseblaster is waiting. This indicates the end of
        cbilling:         # an experimental run.
chrisjbillington:         self.status, waits_pending, time_based_shot_over = yield(self.queue_work(self._primary_worker,'check_status'))
        cbilling:         
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             done_condition = self.status['waiting']
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             done_condition = self.status['stopped']
        cbilling:             
chrisjbillington:         if time_based_shot_over is not None:
chrisjbillington:             done_condition = time_based_shot_over
chrisjbillington:             
        cbilling:         if notify_queue is not None and done_condition and not waits_pending:
        cbilling:             # Experiment is over. Tell the queue manager about it, then
        cbilling:             # set the status checking timeout back to every 2 seconds
        cbilling:             # with no queue.
        cbilling:             notify_queue.put('done')
        cbilling:             self.statemachine_timeout_remove(self.status_monitor)
        cbilling:             self.statemachine_timeout_add(2000,self.status_monitor)
        cbilling:             if self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:                 # Not clear that on all models the outputs will be correct after being
        cbilling:                 # stopped this way, so we do program_manual with current values to be sure:
        cbilling:                 self.program_device()
            dihm:         # Update widgets with new status
            dihm:         for state in self.status_states:
        shjohnst:             if self.status[state]:
        shjohnst:                 icon = QtGui.QIcon(':/qtutils/fugue/tick')
        shjohnst:             else:
        shjohnst:                 icon = QtGui.QIcon(':/qtutils/fugue/cross')
        shjohnst:             
        shjohnst:             pixmap = icon.pixmap(QtCore.QSize(16, 16))
        shjohnst:             self.status_widgets[state].setPixmap(pixmap)
        cbilling:         
        cbilling:     
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def start(self,widget=None):
        cbilling:         yield(self.queue_work(self._primary_worker,'start_run'))
        cbilling:         self.status_monitor()
        cbilling:         
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def stop(self,widget=None):
        cbilling:         yield(self.queue_work(self._primary_worker,'pb_stop'))
        cbilling:         self.status_monitor()
        cbilling:         
        cbilling:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        cbilling:     def reset(self,widget=None):
        cbilling:         yield(self.queue_work(self._primary_worker,'pb_reset'))
        cbilling:         self.status_monitor()
        cbilling:     
        cbilling:     @define_state(MODE_BUFFERED,True)  
        cbilling:     def start_run(self, notify_queue):
        cbilling:         """Starts the Pulseblaster, notifying the queue manager when
        cbilling:         the run is over"""
        cbilling:         self.statemachine_timeout_remove(self.status_monitor)
        cbilling:         self.start()
        cbilling:         self.statemachine_timeout_add(100,self.status_monitor,notify_queue)
        cbilling: 
        cbilling: @BLACS_worker        
        cbilling: class PulseblasterNoDDSWorker(Worker):
        cbilling:     core_clock_freq = 100
        cbilling:     def init(self):
        cbilling:         from labscript_utils import check_version
        cbilling:         check_version('spinapi', '3.1.1', '4')
        cbilling:         exec 'from spinapi import *' in globals()
        cbilling:         global h5py; import labscript_utils.h5_lock, h5py
        cbilling:         global zprocess; import zprocess
        cbilling:         
        cbilling:         self.pb_start = pb_start
        cbilling:         self.pb_stop = pb_stop
        cbilling:         self.pb_reset = pb_reset
        cbilling:         self.pb_close = pb_close
        cbilling:         self.pb_read_status = pb_read_status
        cbilling:         self.smart_cache = {'pulse_program':None,'ready_to_go':False,
        cbilling:                             'initial_values':None}
        cbilling:                             
        cbilling:         # An event for checking when all waits (if any) have completed, so that
        cbilling:         # we can tell the difference between a wait and the end of an experiment.
        cbilling:         # The wait monitor device is expected to post such events, which we'll wait on:
        cbilling:         self.all_waits_finished = zprocess.Event('all_waits_finished')
        cbilling:         self.waits_pending = False
        cbilling:     
        cbilling:         pb_select_board(self.board_number)
        cbilling:         pb_init()
        cbilling:         pb_core_clock(self.core_clock_freq)
chrisjbillington:         
chrisjbillington:         # This is only set to True on a per-shot basis, so set it to False
chrisjbillington:         # for manual mode
chrisjbillington:         self.time_based_stop_workaround = False
        cbilling: 
        cbilling:     def program_manual(self,values):
        cbilling:         # Program the DDS registers:
        cbilling:         
        cbilling:         # create flags string
        cbilling:         # NOTE: The spinapi can take a string or integer for flags.
        cbilling:                 # If it is a string: 
        cbilling:                 #     flag: 0          12
        cbilling:                 #          '101100011111'
        cbilling:                 #
        cbilling:                 # If it is a binary number:
        cbilling:                 #     flag:12          0
        cbilling:                 #         0b111110001101
        cbilling:                 #
        cbilling:                 # Be warned!
        cbilling:         flags = ''
        cbilling:         for i in range(self.num_DO):
        cbilling:             if values['flag %d'%i]:
        cbilling:                 flags += '1'
        cbilling:             else:
        cbilling:                 flags += '0'
        cbilling:         
        cbilling:         if self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             # Need to ensure device is stopped before programming - or we won't know what line it's on.
        cbilling:             pb_stop()
        cbilling:             
        cbilling:         # Write the first two lines of the pulse program:
        cbilling:         pb_start_programming(PULSE_PROGRAM)
        cbilling:         # Line zero is a wait:
        cbilling:         pb_inst_pbonly(flags, WAIT, 0, 100)
        cbilling:         # Line one is a brach to line 0:
        cbilling:         pb_inst_pbonly(flags, BRANCH, 0, 100)
        cbilling:         pb_stop_programming()
        cbilling:         
        cbilling:         # Now we're waiting on line zero, so when we start() we'll go to
        cbilling:         # line one, then brach back to zero, completing the static update:
        cbilling:         pb_start()
        cbilling:         
        cbilling:         # The pulse program now has a branch in line one, and so can't proceed to the pulse program
        cbilling:         # without a reprogramming of the first two lines:
        cbilling:         self.smart_cache['ready_to_go'] = False
        cbilling:         
        cbilling:         # TODO: return coerced/quantised values
        cbilling:         return {}
        cbilling:         
        cbilling:     def start_run(self):
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             pb_start()
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             pb_stop_programming()
        cbilling:             pb_start()
        cbilling:         else:
        cbilling:             raise ValueError('invalid programming_scheme: %s'%str(self.programming_scheme))
chrisjbillington:         if self.time_based_stop_workaround:
chrisjbillington:             import time
chrisjbillington:             self.time_based_shot_end_time = time.time() + self.time_based_shot_duration
        cbilling:             
        cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
        cbilling:         self.h5file = h5file
        cbilling:         if self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             # Need to ensure device is stopped before programming - or we wont know what line it's on.
        cbilling:             pb_stop()
        cbilling:         with h5py.File(h5file,'r') as hdf5_file:
        cbilling:             group = hdf5_file['devices/%s'%device_name]
chrisjbillington:                           
chrisjbillington:             # Is this shot using the fixed-duration workaround instead of checking the PulseBlaster's status?
chrisjbillington:             self.time_based_stop_workaround = group.attrs.get('time_based_stop_workaround', False)
chrisjbillington:             if self.time_based_stop_workaround:
chrisjbillington:                 self.time_based_shot_duration = (group.attrs['stop_time']
chrisjbillington:                                                  + hdf5_file['waits'][:]['timeout'].sum()
chrisjbillington:                                                  + group.attrs['time_based_stop_workaround_extra_time'])
chrisjbillington:             
        cbilling:             # Now for the pulse program:
        cbilling:             pulse_program = group['PULSE_PROGRAM'][2:]
        cbilling:             
        cbilling:             #Let's get the final state of the pulseblaster. z's are the args we don't need:
        cbilling:             flags,z,z,z = pulse_program[-1]
        cbilling:             
        cbilling:             # Always call start_programming regardless of whether we are going to do any
        cbilling:             # programming or not. This is so that is the programming_scheme is 'pb_stop_programming/STOP'
        cbilling:             # we are ready to be triggered by a call to pb_stop_programming() even if no programming
        cbilling:             # occurred due to smart programming:
        cbilling:             pb_start_programming(PULSE_PROGRAM)
        cbilling:             
        cbilling:             if fresh or (self.smart_cache['initial_values'] != initial_values) or \
        cbilling:                 (len(self.smart_cache['pulse_program']) != len(pulse_program)) or \
        cbilling:                 (self.smart_cache['pulse_program'] != pulse_program).any() or \
        cbilling:                 not self.smart_cache['ready_to_go']:
        cbilling:             
        cbilling:                 self.smart_cache['ready_to_go'] = True
        cbilling:                 self.smart_cache['initial_values'] = initial_values
        cbilling:                 # Line zero is a wait on the final state of the program:
        cbilling:                 pb_inst_pbonly(flags,WAIT,0,100)
        cbilling:                 
        cbilling:                 # create initial flags string
        cbilling:                 # NOTE: The spinapi can take a string or integer for flags.
        cbilling:                 # If it is a string: 
        cbilling:                 #     flag: 0          12
        cbilling:                 #          '101100011111'
        cbilling:                 #
        cbilling:                 # If it is a binary number:
        cbilling:                 #     flag:12          0
        cbilling:                 #         0b111110001101
        cbilling:                 #
        cbilling:                 # Be warned!
        cbilling:                 initial_flags = ''
        cbilling:                 for i in range(self.num_DO):
        cbilling:                     if initial_values['flag %d'%i]:
        cbilling:                         initial_flags += '1'
        cbilling:                     else:
        cbilling:                         initial_flags += '0'
        cbilling:                 # Line one is a continue with the current front panel values:
        cbilling:                 pb_inst_pbonly(initial_flags, CONTINUE, 0, 100)
        cbilling:                 # Now the rest of the program:
        cbilling:                 if fresh or len(self.smart_cache['pulse_program']) != len(pulse_program) or \
        cbilling:                 (self.smart_cache['pulse_program'] != pulse_program).any():
        cbilling:                     self.smart_cache['pulse_program'] = pulse_program
        cbilling:                     for args in pulse_program:
        cbilling:                         pb_inst_pbonly(*args)
        cbilling:                         
        cbilling:             if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:                 # We will be triggered by pb_start() if we are are the master pseudoclock or a single hardware trigger
        cbilling:                 # from the master if we are not:
        cbilling:                 pb_stop_programming()
        cbilling:             elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:                 # Don't call pb_stop_programming(). We don't want to pulseblaster to respond to hardware
        cbilling:                 # triggers (such as 50/60Hz line triggers) until we are ready to run.
        cbilling:                 # Our start_method will call pb_stop_programming() when we are ready
        cbilling:                 pass
        cbilling:             else:
        cbilling:                 raise ValueError('invalid programming_scheme %s'%str(self.programming_scheme))
        cbilling:             
        cbilling:             # Are there waits in use in this experiment? The monitor waiting for the end of
        cbilling:             # the experiment will need to know:
        cbilling:             self.waits_pending =  bool(len(hdf5_file['waits']))
        cbilling:             
        cbilling:             # Now we build a dictionary of the final state to send back to the GUI:
        cbilling:             return_values = {}
        cbilling:             # Since we are converting from an integer to a binary string, we need to reverse the string! (see notes above when we create flags variables)
        cbilling:             return_flags = bin(flags)[2:].rjust(self.num_DO,'0')[::-1]
        cbilling:             for i in range(self.num_DO):
        cbilling:                 return_values['flag %d'%i] = return_flags[i]
        cbilling:                 
        cbilling:             return return_values
        cbilling:             
        cbilling:     def check_status(self):
        cbilling:         if self.waits_pending:
        cbilling:             try:
        cbilling:                 self.all_waits_finished.wait(self.h5file, timeout=0)
        cbilling:                 self.waits_pending = False
        cbilling:             except zprocess.TimeoutError:
        cbilling:                 pass
chrisjbillington:         if self.time_based_stop_workaround:
chrisjbillington:             import time
chrisjbillington:             time_based_shot_over = time.time() > self.time_based_shot_end_time
chrisjbillington:         else:
chrisjbillington:             time_based_shot_over = None
chrisjbillington:         return pb_read_status(), self.waits_pending, time_based_shot_over
chrisjbillington:         
        cbilling:     def transition_to_manual(self):
chrisjbillington:         status, waits_pending, time_based_shot_over = self.check_status()
        cbilling:         
        cbilling:         if self.programming_scheme == 'pb_start/BRANCH':
        cbilling:             done_condition = status['waiting']
        cbilling:         elif self.programming_scheme == 'pb_stop_programming/STOP':
        cbilling:             done_condition = True # status['stopped']
        cbilling:             
chrisjbillington:         if time_based_shot_over is not None:
chrisjbillington:             done_condition = time_based_shot_over
chrisjbillington:         
chrisjbillington:         # This is only set to True on a per-shot basis, so reset it to False
chrisjbillington:         # for manual mode
chrisjbillington:         self.time_based_stop_workaround = False
chrisjbillington:         
        cbilling:         if done_condition and not waits_pending:
        cbilling:             return True
        cbilling:         else:
        cbilling:             return False
        cbilling:      
        cbilling:     def abort_buffered(self):
        cbilling:         # Stop the execution
        cbilling:         self.pb_stop()
        cbilling:         # Reset to the beginning of the pulse sequence
        cbilling:         self.pb_reset()
        cbilling:                 
        cbilling:         # abort_buffered in the GUI process queues up a program_device state
        cbilling:         # which will reprogram the device and call pb_start()
        cbilling:         # This ensures the device isn't accidentally retriggered by another device
        cbilling:         # while it is running it's abort function
        cbilling:         return True
        cbilling:         
        cbilling:     def abort_transition_to_buffered(self):
        cbilling:         return True
        cbilling:         
        cbilling:     def shutdown(self):
        cbilling:         #TODO: implement this
        cbilling:         pass
        cbilling:         
            dihm: @runviewer_parser
            dihm: class PulseBlaster_No_DDS_Parser(PulseBlasterParser):
            dihm:     num_dds = 0
           Chris:     num_flags = 24
        cbilling: 
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /PulseblasterESRpro500.py                                         #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of labscript_devices, in the labscript suite    #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: from labscript_devices.PulseBlaster_No_DDS import PulseBlaster_No_DDS, Pulseblaster_No_DDS_Tab, PulseblasterNoDDSWorker
cbilling: from labscript_devices.PulseBlaster import PulseBlasterParser
cbilling: 
cbilling: @labscript_device
cbilling: class PulseBlaster_SP2_24_100_32k(PulseBlaster_No_DDS):
cbilling:     description = 'SpinCore PulseBlaster-SP2-24-100-32k'
cbilling:     clock_limit = 5.0e6
cbilling:     clock_resolution = 10e-9
cbilling:     n_flags = 24
    rene:     
    rene:     def __init__(self, *args, **kwargs):
    rene:         if 'max_instructions' not in kwargs:
    rene:             kwargs['max_instructions'] = 32000
    rene:         PulseBlaster_No_DDS.__init__(self, *args, **kwargs)
cbilling: 
cbilling: 
cbilling: @BLACS_tab    
cbilling: class PulseBlaster_SP2_24_100_32k_Tab(Pulseblaster_No_DDS_Tab):
cbilling:     num_DO = 24
cbilling:     def __init__(self,*args,**kwargs):
cbilling:         self.device_worker_class = PulseBlaster_SP2_24_100_32k_Worker 
cbilling:         Pulseblaster_No_DDS_Tab.__init__(self,*args,**kwargs)
cbilling:     
cbilling:     
cbilling: @BLACS_worker
cbilling: class PulseBlaster_SP2_24_100_32k_Worker(PulseblasterNoDDSWorker):
cbilling:     core_clock_freq = 100.0
cbilling:     
cbilling:      
cbilling: @runviewer_parser
cbilling: class PulseBlaster_SP2_24_100_32k_Parser(PulseBlasterParser):
cbilling:     num_dds = 0
cbilling:     num_flags = 24
         dsbark7: #####################################################################
         dsbark7: #                                                                   #
chrisjbillington: # /labscript_devices/PythonCamera.py                                #
         dsbark7: #                                                                   #
         dsbark7: # Copyright 2013, Monash University                                 #
         dsbark7: #                                                                   #
         dsbark7: # This file is part of labscript_devices, in the labscript suite    #
         dsbark7: # (see http://labscriptsuite.org), and is licensed under the        #
         dsbark7: # Simplified BSD License. See the license.txt file in the root of   #
         dsbark7: # the project for the full license.                                 #
         dsbark7: #                                                                   #
         dsbark7: #####################################################################
chrisjbillington: from __future__ import print_function, unicode_literals, absolute_import, division
         dsbark7: 
         dsbark7: try:
         dsbark7:     from labscript_utils import check_version
         dsbark7: except ImportError:
         dsbark7:     raise ImportError('Require labscript_utils > 2.1.0')
         dsbark7:     
         dsbark7: check_version('labscript', '2.0.1', '3')
         dsbark7: 
         dsbark7: from labscript_devices import labscript_device, BLACS_tab
         dsbark7: from labscript_devices.Camera import Camera, CameraTab
         dsbark7: from labscript import set_passed_properties
         dsbark7: 
chrisjbillington: 
         dsbark7: @labscript_device
chrisjbillington: class PythonCamera(Camera):
chrisjbillington:     """A class for new features not compatible with the legacy Camera class"""
chrisjbillington:     description = 'Python camera'        
         dsbark7:     
         dsbark7:     @set_passed_properties(
         dsbark7:         property_names = {
         dsbark7:             "device_properties": ["acquisition_ROI"]}
         dsbark7:         )
chrisjbillington:     def __init__(self, *args, **kwargs):
chrisjbillington:         self.acquisition_ROI = kwargs.pop('acquisition_ROI', None)
         dsbark7:         Camera.__init__(self, *args, **kwargs)
         dsbark7:     
chrisjbillington:     def set_acquisition_ROI(self, acquisition_ROI):
chrisjbillington:         # acq_ROI is a tuple of form (width, height, offset_X, offset_Y) This
chrisjbillington:         # method can be used in a script to overwrite a camera's acquisition_ROI
chrisjbillington:         # after instantiation, so that BlACS does not detect a connection table
chrisjbillington:         # change on disk when the same file is being imported by experiment scripts
chrisjbillington:         # and used as the lab connection table.
chrisjbillington:         self.set_property('acquisition_ROI', acquisition_ROI,
chrisjbillington:                           location='device_properties', overwrite=True)
chrisjbillington: 
         dsbark7: 
         dsbark7: @BLACS_tab
chrisjbillington: class PythonCameraTab(CameraTab):
         dsbark7:     pass
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # RFblaster.py                                                      #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of labscript_devices, in the labscript suite    #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: import os
spielman: from labscript import PseudoclockDevice, Pseudoclock, ClockLine, IntermediateDevice, DDS, config, startupinfo, LabscriptError, set_passed_properties
cbilling: import numpy as np
pstarkey: 
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser
cbilling: 
pstarkey: # Define a RFBlasterPseudoclock that only accepts one child clockline
pstarkey: class RFBlasterPseudoclock(Pseudoclock):    
pstarkey:     def add_device(self, device):
pstarkey:         if isinstance(device, ClockLine):
pstarkey:             # only allow one child
pstarkey:             if self.child_devices:
pstarkey:                 raise LabscriptError('The pseudoclock of the RFBlaster %s only supports 1 clockline, which is automatically created. Please use the clockline located at %s.clockline'%(self.parent_device.name, self.parent_device.name))
pstarkey:             Pseudoclock.add_device(self, device)
pstarkey:         else:
pstarkey:             raise LabscriptError('You have connected %s to %s (the Pseudoclock of %s), but %s only supports children that are ClockLines. Please connect your device to %s.clockline instead.'%(device.name, self.name, self.parent_device.name, self.name, self.parent_device.name))
pstarkey: 
cbilling: @labscript_device
pstarkey: class RFBlaster(PseudoclockDevice):
cbilling:     description = 'RF Blaster Rev1.1'
cbilling:     clock_limit = 500e3
cbilling:     clock_resolution = 13.33333333333333333333e-9
pstarkey:     allowed_children = [RFBlasterPseudoclock]
cbilling:     
cbilling:     # TODO: find out what these actually are!
cbilling:     trigger_delay = 873.75e-6
cbilling:     wait_day = trigger_delay
cbilling:     
spielman:     @set_passed_properties()
cbilling:     def __init__(self, name, ip_address, trigger_device=None, trigger_connection=None):
pstarkey:         PseudoclockDevice.__init__(self, name, trigger_device, trigger_connection)
cbilling:         self.BLACS_connection = ip_address
pstarkey:         
pstarkey:         # create Pseudoclock and clockline
pstarkey:         self._pseudoclock = RFBlasterPseudoclock('%s_pseudoclock'%name, self, 'clock') # possibly a better connection name than 'clock'?
pstarkey:         # Create the internal direct output clock_line
pstarkey:         self._clock_line = ClockLine('%s_clock_line'%name, self.pseudoclock, 'internal')
pstarkey:         # Create the internal intermediate device connected to the above clock line
pstarkey:         # This will have the DDSs of the RFBlaster connected to it
pstarkey:         self._direct_output_device = RFBlasterDirectOutputs('%s_direct_output_device'%name, self._clock_line)
pstarkey:     
pstarkey:     @property
pstarkey:     def pseudoclock(self):
pstarkey:         return self._pseudoclock
pstarkey:     
pstarkey:     @property
pstarkey:     def direct_outputs(self):
pstarkey:         return self._direct_output_device
cbilling:     
cbilling:     def add_device(self, device):
pstarkey:         if not self.child_devices and isinstance(device, Pseudoclock):
pstarkey:             PseudoclockDevice.add_device(self, device)
pstarkey:         elif isinstance(device, Pseudoclock):
pstarkey:             raise LabscriptError('The %s %s automatically creates a Pseudoclock because it only supports one. '%(self.description, self.name) +
pstarkey:                                  'Instead of instantiating your own Pseudoclock object, please use the internal' +
pstarkey:                                  ' one stored in %s.pseudoclock'%self.name)
pstarkey:         elif isinstance(device, DDS):
pstarkey:             #TODO: Defensive programming: device.name may not exist!
pstarkey:             raise LabscriptError('You have connected %s directly to %s, which is not allowed. You should instead specify the parent_device of %s as %s.direct_outputs'%(device.name, self.name, device.name, self.name))
pstarkey:         else:
pstarkey:             raise LabscriptError('You have connected %s (class %s) to %s, but %s does not support children with that class.'%(device.name, device.__class__, self.name, self.name))
pstarkey:         
cbilling:         
cbilling:     def generate_code(self, hdf5_file):
cbilling:         from rfblaster import caspr
cbilling:         import rfblaster.rfjuice
cbilling:         rfjuice_folder = os.path.dirname(rfblaster.rfjuice.__file__)
cbilling:         
cbilling:         import rfblaster.rfjuice.const as c
cbilling:         from rfblaster.rfjuice.cython.make_diff_table import make_diff_table
cbilling:         from rfblaster.rfjuice.cython.compile import compileD
cbilling:         # from rfblaster.rfjuice.compile import compileD
cbilling:         import tempfile
cbilling:         from subprocess import Popen, PIPE
cbilling:         
cbilling:         # Generate clock and save raw instructions to the h5 file:
pstarkey:         PseudoclockDevice.generate_code(self, hdf5_file)
cbilling:         dtypes = [('time',float),('amp0',float),('freq0',float),('phase0',float),('amp1',float),('freq1',float),('phase1',float)]
pstarkey:         
pstarkey:         times = self.pseudoclock.times[self._clock_line]
pstarkey:         
pstarkey:         data = np.zeros(len(times),dtype=dtypes)
pstarkey:         data['time'] = times
pstarkey:         for dds in self.direct_outputs.child_devices:
cbilling:             prefix, connection = dds.connection.split()
cbilling:             data['freq%s'%connection] = dds.frequency.raw_output
cbilling:             data['amp%s'%connection] = dds.amplitude.raw_output
cbilling:             data['phase%s'%connection] = dds.phase.raw_output
cbilling:         group = hdf5_file['devices'].create_group(self.name)
cbilling:         group.create_dataset('TABLE_DATA',compression=config.compression, data=data)
cbilling:         
cbilling:         # Quantise the data and save it to the h5 file:
cbilling:         quantised_dtypes = [('time',np.int64),
cbilling:                             ('amp0',np.int32), ('freq0',np.int32), ('phase0',np.int32),
cbilling:                             ('amp1',np.int32), ('freq1',np.int32), ('phase1',np.int32)]
pstarkey:         quantised_data = np.zeros(len(times),dtype=quantised_dtypes)
cbilling:         quantised_data['time'] = np.array(c.tT*1e6*data['time']+0.5)
cbilling:         for dds in range(2):
cbilling:             # TODO: bounds checking
cbilling:             # Adding 0.5 to each so that casting to integer rounds:
cbilling:             quantised_data['freq%d'%dds] = np.array(c.fF*1e-6*data['freq%d'%dds] + 0.5)
cbilling:             quantised_data['amp%d'%dds]  = np.array((2**c.bitsA - 1)*data['amp%d'%dds] + 0.5)
cbilling:             quantised_data['phase%d'%dds] = np.array(c.pP*data['phase%d'%dds] + 0.5)
cbilling:         group.create_dataset('QUANTISED_DATA',compression=config.compression, data=quantised_data)
cbilling:         # Generate some assembly code and compile it to machine code:
cbilling:         assembly_group = group.create_group('ASSEMBLY_CODE')
cbilling:         binary_group = group.create_group('BINARY_CODE')
cbilling:         diff_group = group.create_group('DIFF_TABLES')
cbilling:         # When should the RFBlaster wait for a trigger?
cbilling:         quantised_trigger_times = np.array([c.tT*1e6*t + 0.5 for t in self.trigger_times], dtype=np.int64)
cbilling:         for dds in range(2):
pstarkey:             abs_table = np.zeros((len(times), 4),dtype=np.int64)
cbilling:             abs_table[:,0] = quantised_data['time']
cbilling:             abs_table[:,1] = quantised_data['amp%d'%dds]
cbilling:             abs_table[:,2] = quantised_data['freq%d'%dds]
cbilling:             abs_table[:,3] = quantised_data['phase%d'%dds]
cbilling:             
cbilling:             # split up the table into chunks delimited by trigger times:
cbilling:             abs_tables = []
cbilling:             for i, t in enumerate(quantised_trigger_times):
cbilling:                 subtable = abs_table[abs_table[:,0] >= t]
cbilling:                 try:
cbilling:                     next_trigger_time = quantised_trigger_times[i+1]
cbilling:                 except IndexError:
cbilling:                     # No next trigger time
cbilling:                     pass
cbilling:                 else:
cbilling:                     subtable = subtable[subtable[:,0] < next_trigger_time]
cbilling:                 subtable[:,0] -= t
cbilling:                 abs_tables.append(subtable)
cbilling: 
cbilling:             # convert to diff tables:
cbilling:             diff_tables = [make_diff_table(tab) for tab in abs_tables]
cbilling:             # Create temporary files, get their paths, and close them:
cbilling:             with tempfile.NamedTemporaryFile(delete=False) as f:
cbilling:                 temp_assembly_filepath = f.name
cbilling:             with tempfile.NamedTemporaryFile(delete=False) as f:
cbilling:                 temp_binary_filepath = f.name
cbilling:                 
cbilling:             try:
cbilling:                 # Compile to assembly:
cbilling:                 with open(temp_assembly_filepath,'w') as assembly_file:
cbilling:                     for i, dtab in enumerate(diff_tables):
cbilling:                         compileD(dtab, assembly_file, init=(i == 0),
cbilling:                                  jump_to_start=(i == 0),
cbilling:                                  jump_from_end=False,
cbilling:                                  close_end=(i == len(diff_tables) - 1),
cbilling:                                  local_loop_pre = str(i),
cbilling:                                  set_defaults = (i==0))
cbilling:                 # Save the assembly to the h5 file:
cbilling:                 with open(temp_assembly_filepath,) as assembly_file:
cbilling:                     assembly_code = assembly_file.read()
cbilling:                     assembly_group.create_dataset('DDS%d'%dds, data=assembly_code)
cbilling:                     for i, diff_table in enumerate(diff_tables):
cbilling:                         diff_group.create_dataset('DDS%d_difftable%d'%(dds,i), compression=config.compression, data=diff_table)
cbilling:                 # compile to binary:
cbilling:                 compilation = Popen([caspr,temp_assembly_filepath,temp_binary_filepath],
cbilling:                                      stdout=PIPE, stderr=PIPE, cwd=rfjuice_folder,startupinfo=startupinfo)
cbilling:                 stdout, stderr = compilation.communicate()
cbilling:                 if compilation.returncode:
cbilling:                     print stdout
cbilling:                     raise LabscriptError('RFBlaster compilation exited with code %d\n\n'%compilation.returncode + 
cbilling:                                          'Stdout was:\n %s\n'%stdout + 'Stderr was:\n%s\n'%stderr)
cbilling:                 # Save the binary to the h5 file:
cbilling:                 with open(temp_binary_filepath,'rb') as binary_file:
cbilling:                     binary_data = binary_file.read()
cbilling:                 # has to be numpy.string_ (string_ in this namespace,
cbilling:                 # imported from pylab) as python strings get stored
cbilling:                 # as h5py as 'variable length' strings, which 'cannot
cbilling:                 # contain embedded nulls'. Presumably our binary data
cbilling:                 # must contain nulls sometimes. So this crashes if we
cbilling:                 # don't convert to a numpy 'fixes length' string:
cbilling:                 binary_group.create_dataset('DDS%d'%dds, data=np.string_(binary_data))
cbilling:             finally:
cbilling:                 # Delete the temporary files:
cbilling:                 os.remove(temp_assembly_filepath)
cbilling:                 os.remove(temp_binary_filepath)
cbilling:                 # print 'assembly:', temp_assembly_filepath
cbilling:                 # print 'binary for dds %d on %s:'%(dds,self.name), temp_binary_filepath
pstarkey: 
pstarkey:                 
pstarkey: class RFBlasterDirectOutputs(IntermediateDevice):
pstarkey:     allowed_children = [DDS]
pstarkey:     clock_limit = RFBlaster.clock_limit
pstarkey:     description = 'RFBlaster Direct Outputs'
pstarkey:   
pstarkey:     def add_device(self, device):
pstarkey:         try:
pstarkey:             prefix, number = device.connection.split()
pstarkey:             assert int(number) in range(2)
pstarkey:             assert prefix == 'dds'
pstarkey:         except Exception:
pstarkey:             raise LabscriptError('invalid connection string. Please use the format \'dds n\' with n 0 or 1')
pstarkey:        
pstarkey:         if isinstance(device, DDS):
pstarkey:             # Check that the user has not specified another digital line as the gate for this DDS, that doesn't make sense.
pstarkey:             if device.gate is not None:
pstarkey:                 raise LabscriptError('You cannot specify a digital gate ' +
pstarkey:                                      'for a DDS connected to %s. '% (self.name))
pstarkey:                                      
pstarkey:         IntermediateDevice.add_device(self, device)
cbilling:         
cbilling:         
cbilling:         
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: from blacs.device_base_class import DeviceTab
cbilling: 
cbilling: 
cbilling: @BLACS_tab
cbilling: class RFBlasterTab(DeviceTab):
cbilling:     def initialise_GUI(self):
cbilling:         # Capabilities 
cbilling:         self.base_units =     {'freq':'Hz',        'amp':'%',         'phase':'Degrees'}
cbilling:         self.base_min =       {'freq':500000,      'amp':0.0,         'phase':0}
cbilling:         self.base_max =       {'freq':350000000.0, 'amp':99.99389648, 'phase':360}
cbilling:         self.base_step =      {'freq':1000000,     'amp':1.0,         'phase':1}
cbilling:         #TODO: Find out what the amp and phase precision is
cbilling:         self.base_decimals =  {'freq':1,           'amp':3,           'phase':3}
cbilling:         self.num_DDS = 2  
cbilling: 
cbilling:         # Create DDS Output objects
cbilling:         dds_prop = {}
cbilling:         for i in range(self.num_DDS): # 2 is the number of DDS outputs on this device
cbilling:             dds_prop['dds %d'%i] = {}
cbilling:             for subchnl in ['freq', 'amp', 'phase']:
cbilling:                 dds_prop['dds %d'%i][subchnl] = {'base_unit':self.base_units[subchnl],
cbilling:                                                  'min':self.base_min[subchnl],
cbilling:                                                  'max':self.base_max[subchnl],
cbilling:                                                  'step':self.base_step[subchnl],
cbilling:                                                  'decimals':self.base_decimals[subchnl]
cbilling:                                                 }
cbilling:             dds_prop['dds %d'%i]['gate'] = {}
cbilling:                 
cbilling:         # Create the output objects    
cbilling:         self.create_dds_outputs(dds_prop)        
cbilling:         # Create widgets for output objects
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         # and auto place the widgets in the UI
cbilling:         self.auto_place_widgets(("DDS Outputs",dds_widgets))
cbilling:         
cbilling:         # Store the COM port to be used
cbilling:         self.address = "http://" + str(self.BLACS_connection) + ":8080"
cbilling:         
cbilling:         # Create and set the primary worker
cbilling:         self.create_worker("main_worker",RFBlasterWorker,{'address':self.address, 'num_DDS':self.num_DDS})
cbilling:         self.primary_worker = "main_worker"
cbilling: 
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(True)
cbilling:         self.supports_smart_programming(False) 
cbilling:     
pstarkey:     def get_child_from_connection_table(self, parent_device_name, port):
pstarkey:         # This is a direct output, let's search for it on the internal intermediate device called 
pstarkey:         # RFBlasterDirectOutputs
pstarkey:         if parent_device_name == self.device_name:
pstarkey:             device = self.connection_table.find_by_name(self.device_name)
pstarkey:             pseudoclock = device.child_list[device.child_list.keys()[0]] # there should always be one (and only one) child, the Pseudoclock
pstarkey:             clockline = pseudoclock.child_list[pseudoclock.child_list.keys()[0]] # there should always be one (and only one) child, the clockline
pstarkey:             direct_outputs = clockline.child_list[clockline.child_list.keys()[0]] # There should only be one child of this clock line, the direct outputs
pstarkey:             # look to see if the port is used by a child of the direct outputs
pstarkey:             return DeviceTab.get_child_from_connection_table(self, direct_outputs.name, port)
pstarkey:         else:
pstarkey:             # else it's a child of a DDS, so we can use the default behaviour to find the device
pstarkey:             return DeviceTab.get_child_from_connection_table(self, parent_device_name, port)
pstarkey:     
cbilling:     # We override this because the RFBlaster doesn't really support remote_value_checking properly
cbilling:     # Here we specifically do not program the device (it's slow!) nor do we update the last programmed value to the current
cbilling:     # front panel state. This is because the remote value returned from the RFBlaster is always the last *manual* values programmed.
cbilling:     @define_state(MODE_BUFFERED,False)
cbilling:     def transition_to_manual(self,notify_queue,program=False):
cbilling:         self.mode = MODE_TRANSITION_TO_MANUAL
cbilling:         
cbilling:         success = yield(self.queue_work(self._primary_worker,'transition_to_manual'))
cbilling:         for worker in self._secondary_workers:
cbilling:             transition_success = yield(self.queue_work(worker,'transition_to_manual'))
cbilling:             if not transition_success:
cbilling:                 success = False
cbilling:                 # don't break here, so that as much of the device is returned to normal
cbilling:         
cbilling:         # Update the GUI with the final values of the run:
cbilling:         for channel, value in self._final_values.items():
cbilling:             if channel in self._AO:
cbilling:                 self._AO[channel].set_value(value,program=False)
cbilling:             elif channel in self._DO:
cbilling:                 self._DO[channel].set_value(value,program=False)
cbilling:             elif channel in self._DDS:
cbilling:                 self._DDS[channel].set_value(value,program=False)
cbilling:         
cbilling:         if success:
cbilling:             notify_queue.put([self.device_name,'success'])
cbilling:             self.mode = MODE_MANUAL
cbilling:         else:
cbilling:             notify_queue.put([self.device_name,'fail'])
cbilling:             raise Exception('Could not transition to manual. You must restart this device to continue')
cbilling:             
cbilling:     
cbilling: @BLACS_worker
cbilling: class RFBlasterWorker(Worker):
cbilling:     def init(self):
cbilling:         exec 'from multipart_form import *' in globals()
cbilling:         exec 'from numpy import *' in globals()
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global urllib2; import urllib2
cbilling:         global re; import re
cbilling:         self.timeout = 30 #How long do we wait until we assume that the RFBlaster is dead? (in seconds)
cbilling:     
cbilling:         # See if the RFBlaster answers
cbilling:         urllib2.urlopen(self.address,timeout=self.timeout)
cbilling:         
cbilling:         self._last_program_manual_values = {}
cbilling:         
cbilling:     def program_manual(self,values):
cbilling:         self._last_program_manual_values = values
cbilling:         
cbilling:         form = MultiPartForm()
cbilling:         for i in range(self.num_DDS):
cbilling:             # Program the frequency, amplitude and phase
cbilling:             form.add_field("a_ch%d_in"%i,str(values['dds %d'%i]['amp']*values['dds %d'%i]['gate']))
cbilling:             form.add_field("f_ch%d_in"%i,str(values['dds %d'%i]['freq']*1e-6)) # method expects MHz
cbilling:             form.add_field("p_ch%d_in"%i,str(values['dds %d'%i]['phase']))
cbilling:             
cbilling:         form.add_field("set_dds","Set device")
cbilling:         # Build the request
cbilling:         req = urllib2.Request(self.address)
cbilling:         #raise Exception(form_values)
cbilling:         body = str(form)
cbilling:         req.add_header('Content-type', form.get_content_type())
cbilling:         req.add_header('Content-length', len(body))
cbilling:         req.add_data(body)
cbilling:         response = str(urllib2.urlopen(req,timeout=self.timeout).readlines())
cbilling:         return_vals = self.get_web_values(response)
cbilling:             
cbilling:         return return_vals
cbilling:         
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         with h5py.File(h5file,'r') as hdf5_file:
cbilling:             group = hdf5_file['devices'][device_name]
cbilling:             #Strip out the binary files and submit to the webserver
cbilling:             form = MultiPartForm()
cbilling:             self.final_values = {}
cbilling:             finalfreq = zeros(self.num_DDS)
cbilling:             finalamp = zeros(self.num_DDS)
cbilling:             finalphase = zeros(self.num_DDS)
cbilling:             for i in range(self.num_DDS):
cbilling:                 #Find the final value from the human-readable part of the h5 file to use for
cbilling:                 #the front panel values at the end
cbilling:                 self.final_values['dds %d'%i] = {'freq':group['TABLE_DATA']["freq%d"%i][-1],
cbilling:                                                  'amp':group['TABLE_DATA']["amp%d"%i][-1]*100,
cbilling:                                                  'phase':group['TABLE_DATA']["phase%d"%i][-1],
cbilling:                                                  'gate':True
cbilling:                                                 }
cbilling:                 data = group['BINARY_CODE/DDS%d'%i].value
cbilling:                 form.add_file_content("pulse_ch%d"%i,"output_ch%d.bin"%i,data)
cbilling:                 
cbilling:         form.add_field("upload_and_run","Upload and start")
cbilling:         req = urllib2.Request(self.address)
cbilling: 
cbilling:         body = str(form)
cbilling:         req.add_header('Content-type', form.get_content_type())
cbilling:         req.add_header('Content-length', len(body))
cbilling:         req.add_data(body)
cbilling:         post_buffered_web_vals = self.get_web_values(str(urllib2.urlopen(req,timeout = self.timeout).readlines()))
cbilling: 
cbilling:         return self.final_values
cbilling:                  
cbilling:     def abort_transition_to_buffered(self):
cbilling:         # TODO: untested (this is probably wrong...)
cbilling:         form = MultiPartForm()
cbilling:         #tell the rfblaster to stop
cbilling:         form.add_field("halt","Halt execution")
cbilling:         req = urllib2.Request(self.address)
cbilling:         body = str(form)
cbilling:         req.add_header('Content-type', form.get_content_type())
cbilling:         req.add_header('Content-length', len(body))
cbilling:         req.add_data(body)
cbilling:         urllib2.urlopen(req,timeout=self.timeout)
cbilling:         return True
cbilling:     
cbilling:     def abort_buffered(self):
cbilling:         form = MultiPartForm()
cbilling:         #tell the rfblaster to stop
cbilling:         form.add_field("halt","Halt execution")
cbilling:         req = urllib2.Request(self.address)
cbilling:         body = str(form)
cbilling:         req.add_header('Content-type', form.get_content_type())
cbilling:         req.add_header('Content-length', len(body))
cbilling:         req.add_data(body)
cbilling:         urllib2.urlopen(req,timeout=self.timeout)
cbilling:         return True
cbilling:      
cbilling:     def transition_to_manual(self):
cbilling:         # TODO: check that the RF blaster program is finished?
cbilling:         return True
cbilling:      
cbilling:     def get_web_values(self,page): 
cbilling:         #prepare regular expressions for finding the values:
cbilling:         search = re.compile(r'name="([fap])_ch(\d+?)_in"\s*?value="([0-9.]+?)"')
cbilling:         webvalues = re.findall(search,page)
cbilling:         
cbilling:         register_name_map = {'f':'freq','a':'amp','p':'phase'}
cbilling:         newvals = {}
cbilling:         for i in range(self.num_DDS):
cbilling:             newvals['dds %d'%i] = {}
cbilling:         for register,channel,value in webvalues:
cbilling:             newvals['dds %d'%int(channel)][register_name_map[register]] = float(value)
cbilling:         for i in range(self.num_DDS):
cbilling:             if 'dds %d'%i in self._last_program_manual_values and newvals['dds %d'%i]['amp'] == 0:
cbilling:                 newvals['dds %d'%i]['gate'] = self._last_program_manual_values['dds %d'%i]['gate']
cbilling:             else:
cbilling:                 newvals['dds %d'%i]['gate'] = True
cbilling:                 
cbilling:             newvals['dds %d'%i]['freq'] *= 1e6 # BLACS expects it in the base unit (Hz)
cbilling:             
cbilling:             # if the gate is off, keep the front panel amplitude
cbilling:             if not newvals['dds %d'%i]['gate']:
cbilling:                 newvals['dds %d'%i]['amp'] = self._last_program_manual_values['dds %d'%i]['amp']
cbilling:             
cbilling:         return newvals
cbilling:     
cbilling:     def check_remote_values(self):
cbilling:         #read the webserver page to see what values it puts in the form
cbilling:         page = str(urllib2.urlopen(self.address,timeout=self.timeout).readlines())
cbilling:         return self.get_web_values(page)
cbilling:         
cbilling:     def shutdown(self):
cbilling:         # TODO: implement this?
cbilling:         pass
cbilling: 
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # labscript_devices/ZaberStageController.py                         #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of labscript_devices, in the labscript suite    #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker
spielman: from labscript import StaticAnalogQuantity, Device, LabscriptError, set_passed_properties
pstarkey: import numpy as np
cbilling: 
cbilling: class ZaberStageTLSR150D(StaticAnalogQuantity):
cbilling:     minval=0
cbilling:     maxval=76346
cbilling:     description = 'Zaber Stage T-LSR150D'
cbilling:     
cbilling: class ZaberStageTLSR300D(StaticAnalogQuantity):
cbilling:     minval=0
cbilling:     maxval=151937
cbilling:     description = 'Zaber Stage T-LSR300D'
cbilling:     
cbilling: class ZaberStageTLS28M(StaticAnalogQuantity):
cbilling:     minval=0
cbilling:     maxval=282879
cbilling:     description = 'Zaber Stage T-LS28-M'
cbilling: 
cbilling: @labscript_device
cbilling: class ZaberStageController(Device):
cbilling:     allowed_children = [ZaberStageTLSR150D,ZaberStageTLSR300D,ZaberStageTLS28M]
cbilling:     generation = 0
spielman:     
cbilling:     @set_passed_properties(property_names = {"connection_table_properties" : ["com_port"]})
spielman:     def __init__(self, name, com_port = ""):
cbilling:         Device.__init__(self, name, None, None)
cbilling:         self.BLACS_connection = com_port
cbilling:         
cbilling:     def generate_code(self, hdf5_file):
cbilling:         data_dict = {}
cbilling:         for stage in self.child_devices:
cbilling:             # Call these functions to finalise the stage, they are standard functions of all subclasses of Output:
cbilling:             ignore = stage.get_change_times()
cbilling:             stage.make_timeseries([])
cbilling:             stage.expand_timeseries()
cbilling:             connection = [int(s) for s in stage.connection.split() if s.isdigit()][0]
cbilling:             value = stage.raw_output[0]
cbilling:             if not stage.minval <= value <= stage.maxval:
cbilling:                 # error, out of bounds
cbilling:                 raise LabscriptError('%s %s has value out of bounds. Set value: %s Allowed range: %s to %s.'%(stage.description,stage.name,str(value),str(stage.minval),str(stage.maxval)))
cbilling:             if not connection > 0:
cbilling:                 # error, invalid connection number
cbilling:                 raise LabscriptError('%s %s has invalid connection number: %s'%(stage.description,stage.name,str(stage.connection)))
cbilling:             data_dict[str(stage.connection)] = value
cbilling:         dtypes = [(conn, int) for conn in data_dict]
pstarkey:         data_array = np.zeros(1, dtype=dtypes)
cbilling:         for conn in data_dict:
cbilling:             data_array[0][conn] = data_dict[conn] 
cbilling:         grp = hdf5_file.create_group('/devices/'+self.name)
cbilling:         grp.create_dataset('static_values', data=data_array)
cbilling:         
cbilling: 
cbilling: import time
cbilling: 
cbilling: from blacs.tab_base_classes import Worker, define_state
cbilling: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
cbilling: 
cbilling: from blacs.device_base_class import DeviceTab
cbilling: 
cbilling: @BLACS_tab
cbilling: class ZaberstageControllerTab(DeviceTab):
cbilling:     def initialise_GUI(self):
cbilling:         # Capabilities
cbilling:         self.base_units = 'steps'
cbilling:         self.base_min = 0
cbilling:         self.base_step = 100
cbilling:         self.base_decimals = 0
cbilling:         
cbilling:         self.device = self.settings['connection_table'].find_by_name(self.device_name)
cbilling:         self.num_stages = len(self.device.child_list)
cbilling:         
cbilling:         # Create the AO output objects
cbilling:         ao_prop = {}
cbilling:         for child_name in self.device.child_list:
cbilling:             stage_type = self.device.child_list[child_name].device_class
cbilling:             connection = self.device.child_list[child_name].parent_port
cbilling:             if stage_type == "ZaberStageTLSR150D":
cbilling:                 base_max = 76346
cbilling:             elif stage_type == "ZaberStageTLSR300D":
cbilling:                 base_max = 151937
cbilling:             else:
cbilling:                 base_max = 282879
cbilling:             
cbilling:             ao_prop[connection] = {'base_unit':self.base_units,
cbilling:                                    'min':self.base_min,
cbilling:                                    'max':base_max,
cbilling:                                    'step':self.base_step,
cbilling:                                    'decimals':self.base_decimals
cbilling:                                   }
cbilling:                                 
cbilling:         # Create the output objects    
cbilling:         self.create_analog_outputs(ao_prop)        
cbilling:         # Create widgets for output objects
cbilling:         dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
cbilling:         # and auto place the widgets in the UI
cbilling:         self.auto_place_widgets(("Zaber Stages",ao_widgets))
cbilling:         
cbilling:         # Store the Measurement and Automation Explorer (MAX) name
cbilling:         self.com_port = str(self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection)
cbilling:         
cbilling:         # Set the capabilities of this device
cbilling:         self.supports_remote_value_check(False)
cbilling:         self.supports_smart_programming(False) 
cbilling:     
cbilling:     def initialise_workers(self):
cbilling:         # Create and set the primary worker
cbilling:         self.create_worker("main_worker",ZaberWorker,{'com_port':self.com_port})
cbilling:         self.primary_worker = "main_worker"
cbilling: 
cbilling: @BLACS_worker    
cbilling: class ZaberWorker(Worker):
cbilling:     def init(self):
cbilling:         # TODO: Make this configurable
cbilling:         self.response_timeout = 45 #seconds
cbilling: 
cbilling:         global serial; import serial
cbilling:         global h5py; import labscript_utils.h5_lock, h5py
cbilling:         global zaberapi; import zaberapi
cbilling:         
cbilling:         self.connection = serial.Serial(port = self.com_port, timeout = 0.1)
cbilling:         response = True
cbilling:         while response is not None:
cbilling:             response = zaberapi.read(self.connection)
cbilling:             
cbilling:     def program_manual(self,values):
cbilling:         #print "***************programming static*******************"
cbilling:         #self.stages.move_absolute(settings)
cbilling:         for stage in values:
cbilling:             port = [int(s) for s in stage.split() if s.isdigit()][0]
cbilling:             zaberapi.move(self.connection,port,data=values[stage])
cbilling:         t0 = time.time()
cbilling:         ret = []
cbilling:         while len(ret)<len(values):
cbilling:             if time.time()-t0 > self.response_timeout:                
cbilling:                 raise Exception('Not all stages responded within %d seconds'%self.response_timeout)
cbilling:             line = zaberapi.read(self.connection)
cbilling:             if line is not None:
cbilling:                 ret.append(line)
cbilling:         
cbilling:         #TODO: return actual position of the zaber stage
cbilling:         return values
cbilling:     
cbilling:     # Apparently this is not used?
cbilling:     # def home_stage(self,stage):
cbilling:         # zaberapi.command(self.connection,stage,'home',0)
cbilling:         # t0 = time.time()
cbilling:         # ret = []
cbilling:         # while len(ret)<1:
cbilling:             # if time.time()-t0 > self.response_timeout:                
cbilling:                 # raise Exception('Not all stages responded within %d seconds'%self.response_timeout)
cbilling:             
cbilling:             # line = zaberapi.read(self.connection)
cbilling:             # if line is not None:
cbilling:                 # ret.append(line)
cbilling:     
cbilling:     def transition_to_buffered(self,device_name,h5file,initial_values,fresh):
cbilling:         return_data = {}
cbilling:         with h5py.File(h5file) as hdf5_file:
cbilling:             group = hdf5_file['/devices/'+device_name]
cbilling:             if 'static_values' in group:
cbilling:                 data = group['static_values'][:][0]
cbilling:         
cbilling:         for stage in data.dtype.names:
cbilling:             return_data[stage] = data[stage]
cbilling:             port = [int(s) for s in stage.split() if s.isdigit()][0]
cbilling:             zaberapi.move(self.connection,port,data=data[stage])
cbilling:         t0 = time.time()
cbilling:         ret = []
cbilling:         while len(ret) < len(data):
cbilling:             if time.time()-t0 > self.response_timeout:                
cbilling:                 raise Exception('Not all stages responded within %d seconds'%self.response_timeout)
cbilling:     
cbilling:             line = zaberapi.read(self.connection)
cbilling:             if line is not None:
cbilling:                 ret.append(line)
cbilling:                         
cbilling:         return return_data
cbilling:     
cbilling:     def transition_to_manual(self):
cbilling:         return True
cbilling:     
cbilling:     def abort_buffered(self):
cbilling:         return True
cbilling:         
cbilling:     def abort_transition_to_buffered(self):
cbilling:         return True
cbilling:     
cbilling:     def shutdown(self):
cbilling:         self.connection.close()
cbilling:             
cbilling:     
        cbilling: import os
        cbilling: import sys
        cbilling: import importlib
        pstarkey: 
           Chris: __version__ = '2.1.0'
        cbilling: 
        cbilling: from labscript_utils import check_version
        cbilling: 
chrisjbillington: check_version('qtutils', '2.0.0', '3.0.0')
        cbilling: check_version('labscript_utils', '2.2', '3')
        pstarkey: check_version('labscript', '2.1', '3')
        pstarkey: check_version('blacs', '2.1', '3')
        cbilling: 
        cbilling: 
        cbilling: class ClassRegister(object):
        cbilling:     """A register for looking up classes by module name.  Provides a
        cbilling:      decorator and a method for looking up classes decorated with it,
        cbilling:      importing as necessary."""
        cbilling:     def __init__(self, instancename):
        cbilling:         self.registered_classes = {}
        cbilling:         # The name given to the instance in this namespace, so we can use it in error messages:
        cbilling:         self.instancename = instancename
        cbilling: 
        cbilling:     def __call__(self, cls):
        cbilling:         """Adds the class to the register so that it can be looked up later
        cbilling:         by module name"""
        cbilling:         # Add an attribute to the class so it knows its own name in case
        cbilling:         # it needs to look up other classes in the same module:
        cbilling:         cls.labscript_device_class_name = cls.__module__.split('.')[-1]
        cbilling:         if cls.labscript_device_class_name == '__main__':
        cbilling:             # User is running the module as __main__. Use the filename instead:
        cbilling:             import __main__
        cbilling:             try:
        cbilling:                 cls.labscript_device_class_name = os.path.splitext(os.path.basename(__main__.__file__))[0]
        cbilling:             except AttributeError:
        cbilling:                 # Maybe they're running interactively? Or some other funky environment. Either way, we can't proceed.
        cbilling:                 raise RuntimeError('Can\'t figure out what the file or module this class is being defined in. ' +
        cbilling:                                    'If you are testing, please test from a more standard environment, such as ' +
        cbilling:                                    'executing a script from the command line, or if you are using an interactive session, ' +
        cbilling:                                    'writing your code in a separate module and importing it.')
        cbilling: 
        cbilling:         # Add it to the register:
        cbilling:         self.registered_classes[cls.labscript_device_class_name] = cls
        cbilling:         return cls
        cbilling: 
        cbilling:     def __getitem__(self, name):
        cbilling:         try:
        cbilling:             # Ensure the module's code has run (this does not re-import it if it is already in sys.modules)
        cbilling:             importlib.import_module('.' + name, __name__)
        cbilling:             print 'imported', name, 'ok!'
        cbilling:         except ImportError:
        cbilling:             sys.stderr.write('Error importing module %s.%s whilst looking for classes for device %s. '%(__name__, name, name) +
        cbilling:                              'Check that the module exists, is named correctly, and can be imported with no errors. ' +
        cbilling:                              'Full traceback follows:\n')
        cbilling:             raise
        cbilling:         # Class definitions in that module have executed now, check to see if class is in our register:
        cbilling:         try:
        cbilling:             return self.registered_classes[name]
        cbilling:         except KeyError:
        cbilling:             # No? No such class is defined then, or maybe the user forgot to decorate it.
        cbilling:             raise ValueError('No class decorated as a %s found in module %s, '%(self.instancename, __name__ + '.' + name) +
        cbilling:                              'Did you forget to decorate the class definition with @%s?'%(self.instancename))
        pstarkey: 
        cbilling: class SameNameClassRegister(ClassRegister):
        cbilling:     """Subclass of ClassRegister that also checks that the
        cbilling:     class has the same name as the file it is in."""
        cbilling:     def __call__(self, cls):
        cbilling:         ClassRegister.__call__(self, cls)
        cbilling:         if cls.labscript_device_class_name != cls.__name__:
        cbilling:             raise ValueError('The class decorated as a @labscript_device must have the same name as the file it is in. ' +
        cbilling:                              'For example NI_PCI_6733.py: class NI_PCI_6733(IntermediateDevice). ' +
        cbilling:                              'Otherwise labscript suite programs looking for it won\'t know what file to look in!')
        cbilling:         return cls
        cbilling: 
        cbilling: # The decorators the user should apply to their classes so that the
        cbilling: # respective programs can look them up:
        cbilling: labscript_device = SameNameClassRegister('labscript_device')
        cbilling: BLACS_tab = ClassRegister('BLACS_tab')
        cbilling: BLACS_worker = ClassRegister('BLACS_worker')
        cbilling: runviewer_parser = ClassRegister('runviewer_parser')
        cbilling: 
        cbilling: # Wrapper functions to get devices out of the class registers.
        cbilling: def get_labscript_device(name):
        cbilling:     return labscript_device[name]
        cbilling: 
        cbilling: def get_BLACS_tab(name):
        cbilling:     return BLACS_tab[name]
        cbilling: 
        cbilling: def get_BLACS_worker(name):
        cbilling:     return BLACS_worker[name]
        cbilling: 
        cbilling: def get_runviewer_parser(name):
        cbilling:     return runviewer_parser[name]
        cbilling: 
        cbilling: 
cbilling: import sys
cbilling: from labscript_devices import labscript_device, BLACS_tab, BLACS_worker, runviewer_parser 
spielman: from labscript import Device, LabscriptError, set_passed_properties
cbilling: 
cbilling: @labscript_device
spielman: class test_device(Device):
spielman:     description = 'test device'
spielman:     
spielman:     @set_passed_properties(
spielman:         property_names = {
cbilling:                  "connection_table_properties": ["name"],
spielman:                  "device_properties": ["DoSomething"]}
spielman:         )
spielman:     def __init__(self, name, DoSomething = False, **kwargs):
spielman:         if DoSomething is not False:
spielman:             raise LabscriptError('test_device does nothing, but kwarg DoSomething was not passed False')
spielman: 
spielman: 
spielman:         Device.__init(self, name, None, None, **kwargs)
cbilling: 
cbilling: @BLACS_tab
cbilling: class Tab(object):
cbilling:     pass
cbilling:     
cbilling: @BLACS_worker
cbilling: class Worker(object):
cbilling:     pass
cbilling:     
cbilling: @runviewer_parser
cbilling: class Parser(object):
cbilling:     pass
