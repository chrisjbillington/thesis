   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /__init__.py                                                      #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program labscript, in the labscript      #
   pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript.labscript import *
   pstarkey: 
   pstarkey: try:
   pstarkey:     from labscript_utils import check_version
   pstarkey: except ImportError:
   pstarkey:     raise ImportError('Require labscript_utils > 2.1.0')
   pstarkey: 
   cbilling: check_version('labscript_utils', '2.2', '3')
   cbilling: 
   cbilling: 
   pstarkey: # Initialisation, runs at import. Can be suppressed by setting
   pstarkey: # labscript_auto_init = False in the locals of the importing scope
   pstarkey: # before importing labscript. If you do this, you'll need to call
   pstarkey: # labscript_init() yourself:
   pstarkey: 
   cbilling: #import inspect
   cbilling: #importing_frame = inspect.currentframe()
   cbilling: #importing_locals = importing_frame.f_back.f_locals
   cbilling: #if not 'labscript_auto_init' in importing_locals or importing_locals['labscript_auto_init']:
   cbilling: #    overwrite = False
   cbilling: #    if '-f' in sys.argv:
   cbilling: #        overwrite = True
   cbilling: #        sys.argv.remove('-f')
   cbilling: #    if len(sys.argv) > 1:
   cbilling: #        labscript_init(sys.argv[1],labscript_file=sys.argv[0])
   cbilling: #    elif sys.argv[0]:
   cbilling: #        labscript_init(sys.argv[0].replace('.py','.h5'), labscript_file=sys.argv[0], new=True, overwrite=overwrite)
   cbilling: 
   pstarkey: __version__ = '2.4.0'
pstarkey: #####################################################################
pstarkey: #                                                                   #
pstarkey: # /devices/__init__.py                                              #
pstarkey: #                                                                   #
pstarkey: # Copyright 2013, Monash University                                 #
pstarkey: #                                                                   #
pstarkey: # This file is part of the program labscript, in the labscript      #
pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
pstarkey: # the project for the full license.                                 #
pstarkey: #                                                                   #
pstarkey: #####################################################################
pstarkey: 
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /devices/adwin.py                                                 #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program labscript, in the labscript      #
   pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript import Device, Pseudoclock, IntermediateDevice, AnalogOut, DigitalOut, bitfield
   pstarkey: from pylab import *
   pstarkey: default_cycle_time = 2500/300e6 # 8.333us
   pstarkey: 
   pstarkey: # Notes:
   pstarkey: # The ADWin runs at 300MHz. The cycle time should be specified in hardware programming in units of this clock speed.
   pstarkey: # Subsequently, instruction timing must be specified in units of cycles.
   pstarkey: 
   pstarkey: # Voltages are specified with a 16 bit unsigned integer, mapping the range [-10,10) volts.
   pstarkey: # There are 32 digital outputs on a card
   pstarkey: # There are 8 analog outs on a card
   pstarkey: 
   pstarkey: from IPython import embed
   pstarkey: 
   pstarkey: class Instruction(dict):
   pstarkey:     """A dictionary-like class that provides the interface to instructions
   pstarkey:     that the rest of labscript expects, (ie, a dictionary). This is a
   pstarkey:     temporary measure until labscript is updated to use objects for all
   pstarkey:     instructions, rather than dictionarys."""
   pstarkey:     
   pstarkey:     def __getitem__(self, key):
   pstarkey:         if key == 'initial time':
   pstarkey:             return self.initial_time
   pstarkey:         elif key == 'description':
   pstarkey:             return self.__class__.__name__
   pstarkey:         elif key == 'duration':
   pstarkey:             return self.duration
   pstarkey:         elif key == 'function':
   pstarkey:             return self.evaluate
   pstarkey:         elif key == 'clock rate':
   pstarkey:             return self.clock_rate
   pstarkey:         elif key == 'end time':
   pstarkey:             return self.end_time
   pstarkey:         elif key == 'units':
   pstarkey:             return self.units
   pstarkey:         else:
   pstarkey:             import IPython
   pstarkey:             IPython.embed()
   pstarkey:             raise KeyError(key)
   pstarkey: 
   pstarkey:     def __setitem__(self, key, value):
   pstarkey:         if key == 'initial time':
   pstarkey:             self.initial_time = value
   pstarkey:         elif key == 'duration':
   pstarkey:             self.duration = value
   pstarkey:         elif key == 'clock rate':
   pstarkey:             self.clock_rate = value
   pstarkey:         elif key == 'end time':
   pstarkey:             self.end_time = value
   pstarkey:         else:
   pstarkey:             raise KeyError(key)
   pstarkey: 
   pstarkey: class RampInstruction(Instruction):
   pstarkey:     def __init__(self, t, duration, A, B, C, clock_rate, units=None):
   pstarkey:         self.initial_time = t
   pstarkey:         self.duration = duration
   pstarkey:         self.end_time = self.initial_time + duration
   pstarkey:         self.A = A
   pstarkey:         self.B = B
   pstarkey:         self.C = C
   pstarkey:         self.clock_rate = clock_rate
   pstarkey:         self.units = units
   pstarkey:     
   pstarkey:     def copy(self):
   pstarkey:         # Override dict.copy() so we get the same class back when
   pstarkey:         # labscript copies an instruction. We can't call __init__, as
   pstarkey:         # we don't know the call signature of subclasses. We have to
   pstarkey:         # call __new__ and then manually set attributes.
   pstarkey:         new_instruction = self.__class__.__new__(self.__class__)
   pstarkey:         new_instruction.initial_time = self.initial_time
   pstarkey:         new_instruction.duration = self.duration
   pstarkey:         new_instruction.end_time = self.end_time
   pstarkey:         new_instruction.A = self.A
   pstarkey:         new_instruction.B = self.B
   pstarkey:         new_instruction.C = self.C
   pstarkey:         new_instruction.clock_rate = self.clock_rate
   pstarkey:         new_instruction.units = self.units
   pstarkey:         return new_instruction
   pstarkey:         
   pstarkey:     def __repr__(self):
   pstarkey:         return object.__repr__(self)
   pstarkey:         
   pstarkey:     def evaluate(self,t):
   pstarkey:         # To be overridden by subclasses
   pstarkey:         raise NotImplementedError
   pstarkey:         
   pstarkey: class LinearRamp(RampInstruction):
   pstarkey:     def __init__(self, t, duration, initial_value, final_value, clock_rate):
   pstarkey:         RampInstruction.__init__(self, t, duration, A=final_value, B=0, C=initial_value, clock_rate=clock_rate)
   pstarkey: 
   pstarkey:     def evaluate(self, t):
   pstarkey:         return (self.A - self.C)/self.duration * t  + self.C
   pstarkey:         
   pstarkey: class SinRamp(RampInstruction):
   pstarkey:     def __init__(self, t, duration, amplitude, offset, angular_period, clock_rate):
   pstarkey:         RampInstruction.__init__(self, t, duration, A=amplitude, B=angular_period, C=offset, clock_rate=clock_rate)
   pstarkey: 
   pstarkey:     def evaluate(self, t):
   pstarkey:         return self.A*sin(t/self.B) + self.C
   pstarkey:         
   pstarkey: class CosRamp(RampInstruction):
   pstarkey:     def __init__(self, t, duration, amplitude, offset, angular_period, clock_rate):
   pstarkey:         RampInstruction.__init__(self, t, duration, A=amplitude, B=angular_period, C=offset, clock_rate=clock_rate)
   pstarkey: 
   pstarkey:     def evaluate(self, t):
   pstarkey:         return self.A*cos(t/self.B) + self.C
   pstarkey:         
   pstarkey: class ExpRamp(RampInstruction):
   pstarkey:     def __init__(self, t, duration, amplitude, offset, time_constant, clock_rate):
   pstarkey:         RampInstruction.__init__(self, t, duration, A=amplitude, B=time_constant, C=offset, clock_rate=clock_rate)
   pstarkey: 
   pstarkey:     def evaluate(self, t):
   pstarkey:         return self.A*exp(t/self.B) + self.C
   pstarkey:         
   pstarkey:         
   pstarkey: class ADWinAnalogOut(AnalogOut):
   pstarkey:     def linear_ramp(self, t, duration, initial, final):
   pstarkey:         instruction = LinearRamp(t, duration, initial, final, self.parent_device.clock_limit)
   pstarkey:         self.add_instruction(t, instruction)
   pstarkey:         return instruction.duration
   pstarkey:         
   pstarkey:     def sin_ramp(self, t, duration, amplitude, offset, angular_period):
   pstarkey:         instruction = SinRamp(t, duration, amplitude, offset, angular_period, self.parent_device.clock_limit)
   pstarkey:         self.add_instruction(t, instruction)
   pstarkey:         return instruction.duration
   pstarkey:         
   pstarkey:     def cos_ramp(self, t, duration, amplitude, offset, angular_period):
   pstarkey:         instruction = CosRamp(t, duration, amplitude, offset, angular_period, self.parent_device.clock_limit)
   pstarkey:         self.add_instruction(t, instruction)
   pstarkey:         return instruction.duration
   pstarkey:         
   pstarkey:     def exp_ramp(self, t, duration, amplitude, offset, time_constant):
   pstarkey:         instruction = ExpRamp(t, duration, amplitude, offset, time_constant, self.parent_device.clock_limit)
   pstarkey:         self.add_instruction(t, instruction)
   pstarkey:         return instruction.duration
   pstarkey:         
   pstarkey: class ADWinDigitalOut(DigitalOut):
   pstarkey:     pass
janwerkmann: 
janwerkmann: class ADWinCard(Pseudoclock):
   pstarkey:     clock_type = 'fast clock'
   pstarkey:     def __init__(self, name, parent_device, card_number):
   pstarkey:         self.clock_limit = parent_device.clock_limit
   pstarkey:         self.clock_resolution = parent_device.clock_resolution
   pstarkey:         
   pstarkey:         # Device must be accessed via the parent ADWin, so we must store
   pstarkey:         # the parent's device_no as well as the card number:
   pstarkey:         self.card_number = card_number
   pstarkey:         self.BLACS_connection = parent_device.BLACS_connection, card_number
   pstarkey:         # We won't call IntermediateDevice.__init__(), as we don't care
   pstarkey:         # about the checks it does for clocking, we don't actually have
   pstarkey:         # a clock:
   pstarkey:         Device.__init__(self, name, parent_device, card_number)
   pstarkey:         self.trigger_times = []
   pstarkey:         self.wait_times = []
   pstarkey:         self.initial_trigger_time = 0
   pstarkey: 
   pstarkey:     def trigger(self, t, *args):
   pstarkey:         if t == 'initial':
   pstarkey:             t = self.initial_trigger_time
   pstarkey:             self.trigger_times.append(t)
   pstarkey:         else:
   pstarkey:             raise NotImplementedError("AdWins do not have waits implemented in labscript or the current firmware.")
   pstarkey:         # Adwin cards are coordinated internally without the need for
   pstarkey:         # triggering devices.  We split them up into pseudoclocks in
   pstarkey:         # labscript because they are modular in nature, and it helps us
   pstarkey:         # be compatible with AdWins that have different card setups. But
   pstarkey:         # half of this pseudoclock stuff isn't relevant to this, so we
   pstarkey:         # override some methods to do nothing.
   pstarkey:         
   pstarkey: #    def generate_code(self, hdf5_file):
   pstarkey: #        # We don't actually need to expand out ramps and construct a pseudoclock or anything
   pstarkey: #        # but we will anyway so that we have something to plot in runviewer
   pstarkey: #        expanded_change_times
   pstarkey: #        for output in self.get_all_outputs():
   pstarkey:     
   pstarkey: class ADWin_AO_Card(ADWinCard):
   pstarkey:     description = 'ADWin analog output card'
   pstarkey:     allowed_children = [AnalogOut]
   pstarkey:     
   pstarkey:     def generate_code(self, hdf5_file):
   pstarkey:         Device.generate_code(self, hdf5_file)
   pstarkey:         # This group must exist in order for BLACS to know that this
   pstarkey:         # device is part of the experiment:
   pstarkey:         group = hdf5_file.create_group('/devices/%s'%self.name)
   pstarkey:         # OK, let's collect up all the analog instructions!
   pstarkey:         self.formatted_instructions = []
   pstarkey:         for output in self.get_all_outputs():
   pstarkey:             for t, instruction in output.instructions.items():
   pstarkey:                 card_number = self.card_number
   pstarkey:                 channel_number = output.connection
   pstarkey:                 if isinstance(instruction, RampInstruction):
   pstarkey:                     duration = instruction.duration
   pstarkey:                     if isinstance(instruction, LinearRamp):
   pstarkey:                         ramp_type = 0
   pstarkey:                     elif isinstance(instruction, SinRamp):
   pstarkey:                         ramp_type = 1
   pstarkey:                     elif isinstance(instruction, CosRamp):
   pstarkey:                         ramp_type = 2
   pstarkey:                     elif isinstance(instruction, ExpRamp):
   pstarkey:                         ramp_type = 3
   pstarkey:                     else:
   pstarkey:                         raise ValueError(instruction)
   pstarkey:                     A = instruction.A
   pstarkey:                     B = instruction.B
   pstarkey:                     C = instruction.C
   pstarkey:                 else:
   pstarkey:                     # Let's construct a ramp out of the single value instruction:
   pstarkey:                     duration = self.clock_resolution
   pstarkey:                     ramp_type = 0
   pstarkey:                     A = instruction
   pstarkey:                     B = 0
   pstarkey:                     C = instruction
   pstarkey:                 formatted_instruction = {'t':t,
   pstarkey:                                          'duration': duration,
   pstarkey:                                          'card': card_number,
   pstarkey:                                          'channel': channel_number,
   pstarkey:                                          'ramp_type': ramp_type,
   pstarkey:                                          'A': A, 'B': B, 'C': C}
   pstarkey:                 self.formatted_instructions.append(formatted_instruction)
   pstarkey: 
   pstarkey:                         
   pstarkey: class ADWin_DO_Card(ADWinCard):
   pstarkey:     description = 'ADWin digital output card'
   pstarkey:     allowed_children = [DigitalOut]
   pstarkey:     digital_dtype = uint32
   pstarkey:     n_digitals = 32
   pstarkey:     
   pstarkey:     def generate_code(self, hdf5_file):
   pstarkey:         Device.generate_code(self, hdf5_file)
   pstarkey:         # This group must exist in order for BLACS to know that this
   pstarkey:         # device is part of the experiment:
   pstarkey:         group = hdf5_file.create_group('/devices/%s'%self.name)
   pstarkey:         outputs = self.get_all_outputs() 
   pstarkey:         change_times = self.collect_change_times(outputs)
   pstarkey:         for output in outputs:
   pstarkey:             output.make_timeseries(change_times)
   pstarkey:         for time in change_times:
   pstarkey:             outputarray = [0]*self.n_digitals
   pstarkey:             for output in outputs:
   pstarkey:                 channel = output.connection
   pstarkey:                 # We have to subtract one from the channel number to get
   pstarkey:                 # the correct index, as ADWin is one-indexed, curse it.
   pstarkey:                 outputarray[channel - 1] = array(output.timeseries)
   pstarkey:         bits = bitfield(outputarray, dtype=self.digital_dtype)
   pstarkey:         self.formatted_instructions = []
   pstarkey:         for t, value in zip(change_times, bits):
   pstarkey:             formatted_instruction = {'t': t, 'card': self.card_number,'bitfield': value} 
   pstarkey:             self.formatted_instructions.append(formatted_instruction)
   pstarkey:             
   pstarkey: class ADWin(PseudoClock):
   pstarkey:     description = 'ADWin'
   pstarkey:     allowed_children = [ADWin_AO_Card, ADWin_DO_Card]
   pstarkey:     def __init__(self, name, device_no=1, cycle_time = default_cycle_time):
   pstarkey:         self.BLACS_connection = device_no
   pstarkey:         # round cycle time to the nearest multiple of 3.3333ns
   pstarkey:         quantised_cycle_time = round(cycle_time/3.333333333333e-9)
   pstarkey:         cycle_time = quantised_cycle_time*3.333333333333e-9
   pstarkey:         self.clock_limit = 1./cycle_time
   pstarkey:         self.clock_resolution = cycle_time
   pstarkey:         Device.__init__(self, name, parent_device=None, connection=None)
   pstarkey:         self.trigger_times = []
   pstarkey:         self.wait_times = []
   pstarkey:         self.initial_trigger_time = 0
   pstarkey:     
   pstarkey:     def do_checks(self, outputs):
   pstarkey:         if self.trigger_times != [0]:
   pstarkey:             raise LabscriptError('ADWin does not support retriggering or waiting.')
   pstarkey:         for output in outputs:
   pstarkey:             output.do_checks(self.trigger_times)
   pstarkey: 
   pstarkey:     def collect_card_instructions(self, hdf5_file):
   pstarkey:         group = hdf5_file.create_group('/devices/%s'%self.name)
   pstarkey:         all_analog_instructions = []
   pstarkey:         all_digital_instructions = []
   pstarkey:         for device in self.child_devices:
   pstarkey:             if isinstance(device, ADWin_AO_Card):
   pstarkey:                 all_analog_instructions.extend(device.formatted_instructions)
   pstarkey:             elif isinstance(device, ADWin_DO_Card):
   pstarkey:                 all_digital_instructions.extend(device.formatted_instructions)
   pstarkey:             else:
   pstarkey:                 raise AssertionError("Invalid child device, shouldn't be possible")
   pstarkey:         # Make the analog output table:
   pstarkey:         analog_dtypes = [('t',uint), ('duration',int), ('card',int), ('channel',int),
   pstarkey:                          ('ramp_type',int), ('A',int), ('B',int), ('C',int)]
   pstarkey:         # sort by time:
   pstarkey:         all_analog_instructions.sort(key=lambda instruction: instruction['t'])
   pstarkey:         analog_data = zeros(len(all_analog_instructions)+1, dtype=analog_dtypes)
   pstarkey:         for i, instruction in enumerate(all_analog_instructions):
   pstarkey:             analog_data[i]['t'] = round(instruction['t']/self.clock_resolution)
   pstarkey:             analog_data[i]['duration'] = round(instruction['duration']/self.clock_resolution)
   pstarkey:             analog_data[i]['card'] = instruction['card']
   pstarkey:             analog_data[i]['channel'] = instruction['channel']
   pstarkey:             analog_data[i]['ramp_type'] = instruction['ramp_type']
   pstarkey:             if instruction['ramp_type'] in [0]:
   pstarkey:                 # If it's a linear ramp, map the voltages for parameter A from the range [-10,10] to a uint16:
   pstarkey:                 analog_data[i]['A'] = int((instruction['A']+10)/20.*(2**16-1))
   pstarkey:             elif instruction['ramp_type'] in [1,2,3]:
   pstarkey:                 # For an exp,  sine or cos ramp, map A from [-10,10] to a signed int16:
   pstarkey:                 analog_data[i]['A'] = int(instruction['A']/10.*(2**15-1))
   pstarkey:             else:
   pstarkey:                 raise RuntimeError('Sanity check failed: Invalid ramp type! Something has gone wrong.')
   pstarkey:             analog_data[i]['B'] = round(instruction['B']/self.clock_resolution) # B has units of time
   pstarkey:             analog_data[i]['C'] = int((instruction['C']+10)/20.*(2**16-1))
   pstarkey:         # Add the 'end of data' instruction to the end:
   pstarkey:         analog_data[-1]['t'] = 2**32-1
   pstarkey:         # Save to the HDF5 file:
   pstarkey:         group.create_dataset('ANALOG_OUTS', data=analog_data)
   pstarkey:         
   pstarkey:         # Make the digital output table:
   pstarkey:         digital_dtypes = [('t',uint), ('card',int), ('bitfield',int)]
   pstarkey:         # sort by time:
   pstarkey:         all_digital_instructions.sort(key=lambda instruction: instruction['t'])
   pstarkey:         digital_data = zeros(len(all_digital_instructions)+1, dtype=digital_dtypes)
   pstarkey:         for i, instruction in enumerate(all_digital_instructions):
   pstarkey:             digital_data[i]['t'] = round(instruction['t']/self.clock_resolution)
   pstarkey:             digital_data[i]['card'] = instruction['card']
   pstarkey:             digital_data[i]['bitfield'] = instruction['bitfield']
   pstarkey:         # Add the 'end of data' instruction to the end:
   pstarkey:         digital_data[-1]['t'] = 2**32-1
   pstarkey:         # Save to the HDF5 file:
   pstarkey:         group.create_dataset('DIGITAL_OUTS', data=digital_data)
   pstarkey:         group.attrs['stop_time'] = self.stop_time/self.clock_resolution
   pstarkey:         group.attrs['cycle_time'] = self.clock_resolution
   pstarkey:         
   pstarkey:     def generate_code(self, hdf5_file):
   pstarkey:         outputs = self.get_all_outputs()
   pstarkey:         # We call the following to do the error checking it includes,
   pstarkey:         # but we're not actually interested in the set of change times.
   pstarkey:         # Each card will handle its own timebase issues.
   pstarkey:         ignore = self.collect_change_times(outputs)
   pstarkey:         self.do_checks(outputs)
   pstarkey:         # This causes the cards to have their generate_code() methods
   pstarkey:         # called. They collect up the instructions of their outputs,
   pstarkey:         # and then we will collate them together into one big instruction
   pstarkey:         # table.
   pstarkey:         Device.generate_code(self, hdf5_file)
   pstarkey:         self.collect_card_instructions(hdf5_file)
   pstarkey:         
   pstarkey:         # We don't actually care about these other things that pseudoclock
   pstarkey:         # classes normally do, but they still do some error checking
   pstarkey:         # that we want:
   pstarkey:         change_times = self.collect_change_times(outputs)
   pstarkey:         for output in outputs:
   pstarkey:             output.make_timeseries(change_times)
   pstarkey:         all_times, clock = self.expand_change_times(change_times, outputs)
   pstarkey:         
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /devices/sr400photoncounter.py                                    #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program labscript, in the labscript      #
   pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   pstarkey: from labscript import DigitalOut, LabscriptError
   pstarkey: 
   pstarkey: class SR400PhotonCounter(DigitalOut):
   pstarkey:     description = 'SRS400 Gated Photon Counter'
   pstarkey:     def __init__(self, name, parent_device, connection, com_port):
   pstarkey:         DigitalOut.__init__(self, name, parent_device, connection)
   pstarkey:         self.BLACS_connection = com_port
   pstarkey:         self.duration = None
   pstarkey:         
   pstarkey:     def acquire(self, t, bin_size, n_periods, dwell_time=2e-3):
   pstarkey:         if self.duration is not None:
   pstarkey:             raise LabscriptError('already triggered')
   pstarkey:         self.t = t
   pstarkey:         self.bin_size_10MHz = bin_size*1e7
   pstarkey:         self.n_periods = int(n_periods)
   pstarkey:         assert dwell_time >= 2e-3
   pstarkey:         self.dwell_time = dwell_time
   pstarkey:         self.go_high(t)
   pstarkey:         # A short pulse. Potential problems, feel free to change length:
   pstarkey:         self.go_low(t+1e-3)
   pstarkey:         duration = (bin_size + dwell_time)*n_periods
   pstarkey:         self.duration = duration
   pstarkey:         return duration
   pstarkey:         
   pstarkey:     def generate_code(self, hdf5_file):
   pstarkey:         if self.duration is None:
   pstarkey:             return
   pstarkey:         if self.t + self.duration > self.pseudoclock.stop_time:
   pstarkey:             raise LabscriptError('%s acquires past the end of the experiment!'%self.name)
   pstarkey:             
   pstarkey:         group = hdf5_file.create_group('/devices/%s'%self.name)
   pstarkey:         group.attrs['bin_size_10MHz'] = self.bin_size_10MHz
   pstarkey:         group.attrs['n_periods'] = self.n_periods
   pstarkey:         group.attrs['dwell_time'] = self.dwell_time
   pstarkey: 
cbilling: self.clock = [{'start': 0,        'reps': 1,   'step': 1e-3, 'slow_clock_tick':True},
cbilling:                'WAIT',
cbilling:               {'start': 1e-3,     'reps': 1,   'step': 1e-6, 'slow_clock_tick':True},
cbilling:               {'start': 1.001e-3, 'reps': 999, 'step': 1e-6, 'slow_clock_tick':False},
cbilling:               {'start': 2e-3,     'reps': 1,   'step': 1e-3, 'slow_clock_tick':True}]
cbilling: from labscript import *
cbilling: 
cbilling: class NIBoard(IntermediateDevice):
cbilling:     # Set what types of child devices this IntermediateDevice can have:
cbilling:     allowed_children = [AnalogOut, DigitalOut, AnalogIn]
cbilling:     
cbilling:     # Some device specific parameters:
cbilling:     n_analogs = 4
cbilling:     n_digitals = 32
cbilling:     digital_dtype = uint32
cbilling:     
cbilling:     # The maximum rate that the outputs can update:
cbilling:     clock_limit = 500e3
cbilling:     
cbilling:     # A name for the device:
cbilling:     description = 'generic_NI_Board'
cbilling:     
cbilling:     def __init__(self, name, parent_device, clock_type, clock_terminal, MAX_name=None, acquisition_rate=0):
cbilling:         # We pass the relevant parameters to the parent class's __init__ function:
cbilling:         IntermediateDevice.__init__(self, name, parent_device,clock_type)
cbilling:         
cbilling:         # This implementation only allows analog aquisitions at a constant rate
cbilling:         self.acquisition_rate = acquisition_rate
cbilling:         self.clock_terminal = clock_terminal
cbilling:         self.MAX_name = name if MAX_name is None else MAX_name
cbilling:         self.BLACS_connection = self.MAX_name
cbilling:         
cbilling:     def convert_bools_to_bytes(self, digitals):
cbilling:         """converts digital outputs to an array of bitfields stored
cbilling:         as self.digital_dtype"""
cbilling:         outputarray = [0]*self.n_digitals
cbilling:         for output in digitals:
cbilling:             # output.connection is the string that the user provided at
cbilling:             # instantiation of the output object.  It is, by convention
cbilling:             # here, port0/line<n>, where <n> is an integer from 0 to 31
cbilling:             # indicating which digital output it is:
cbilling:             port, line = output.connection.replace('port','').replace('line','').split('/')
cbilling:             port, line  = int(port),int(line)
cbilling:             if port > 0:
cbilling:                 raise LabscriptError('Ports > 0 on NI Boards not implemented. ' + 
cbilling:                                      'Please use port 0, or file a feature request ' + 
cbilling:                                      'at redmine.physics.monash.edu.au/labscript.')
cbilling:             # Pack all the 1d arrays of digital output values into their appropriate spot in a list:
cbilling:             outputarray[line] = output.raw_output
cbilling:         # Convert this list of arrays of digital values into
cbilling:         # integer bitfields (the bitfield function is located in
cbilling:         # labscript.labscript)
cbilling:         bits = bitfield(outputarray,dtype=self.digital_dtype)
cbilling:         return bits
cbilling:             
cbilling:     def generate_code(self, hdf5_file):
cbilling:         # By the time this function is called during compilation, most
cbilling:         # of the work has already been done.  Calling the parent class's
cbilling:         # generate_code method actually does nothing at the moment,
cbilling:         # but this may change in the future, so you should call it anyway.
cbilling:         Device.generate_code(self, hdf5_file)
cbilling:         
cbilling:         # Now we collect up all the output and input objects from self.child_devices:
cbilling:         analogs = {}
cbilling:         digitals = {}
cbilling:         inputs = {}
cbilling:         for device in self.child_devices:
cbilling:             if isinstance(device,AnalogOut):
cbilling:                 analogs[device.connection] = device
cbilling:             elif isinstance(device,DigitalOut):
cbilling:                 digitals[device.connection] = device
cbilling:             elif isinstance(device,AnalogIn):
cbilling:                 inputs[device.connection] = device
cbilling:             else:
cbilling:                 raise Exception('Got unexpected device.')
cbilling:                 
cbilling:         # Now we collect up all the output.raw_output arrays from the
cbilling:         # analog outputs, and load them into a numpy recarray:
cbilling:         analog_out_table = empty((len(self.parent_device.times),len(analogs)), dtype=float32)
cbilling:         analog_connections = analogs.keys()
cbilling:         analog_connections.sort()
cbilling:         analog_out_attrs = []
cbilling:         for i, connection in enumerate(analog_connections):
cbilling:             output = analogs[connection]
cbilling:             # A bit of error checking:
cbilling:             if any(output.raw_output > 10 )  or any(output.raw_output < -10 ):
cbilling:                 # Bounds checking:
cbilling:                 raise LabscriptError('%s %s '%(output.description, output.name) +
cbilling:                                   'can only have values between -10 and 10 Volts, ' + 
cbilling:                                   'the limit imposed by %s.'%self.name)
cbilling:             # Put the 1D array of voltages into the table: 
cbilling:             analog_out_table[:,i] = output.raw_output
cbilling:             # Record the output terminal name to an attribute, so that
cbilling:             # BLACS knows which ones to program:
cbilling:             analog_out_attrs.append(self.MAX_name +'/'+connection)
cbilling:             
cbilling:         # Now we make a numpy recarray of all the analog input requests:
cbilling:         input_connections = inputs.keys()
cbilling:         input_connections.sort()
cbilling:         input_attrs = []
cbilling:         acquisitions = []
cbilling:         for connection in input_connections:
cbilling:             input_attrs.append(self.MAX_name+'/'+connection)
cbilling:             for acq in inputs[connection].acquisitions:
cbilling:                 # Each acquisition request is a dictionary with the
cbilling:                 # following data, we're just putting them all in a list
cbilling:                 # along with the input channel they correspond to:
cbilling:                 acquisitions.append((connection,acq['label'],acq['start_time'],acq['end_time'],
cbilling:                                      acq['wait_label'],acq['scale_factor'],acq['units']))
cbilling:         # The 'a256' dtype below limits the string fields to 256
cbilling:         # characters. Can't imagine this would be an issue, but to not
cbilling:         # specify the string length (using dtype=str) causes the strings
cbilling:         # to all come out empty.
cbilling:         acquisitions_table_dtypes = [('connection','a256'), ('label','a256'), ('start',float),
cbilling:                                      ('stop',float), ('wait label','a256'),('scale factor',float), ('units','a256')]
cbilling:         acquisition_table= empty(len(acquisitions), dtype=acquisitions_table_dtypes)
cbilling:         # OK, now we're putting them all into the numpy array:
cbilling:         for i, acq in enumerate(acquisitions):
cbilling:             acquisition_table[i] = acq
cbilling:             
cbilling:         # And finally for digital output:
cbilling:         digital_out_table = []
cbilling:         if digitals:
cbilling:             # We convert the arrays of boolean values to a single
cbilling:             # array of bitfield integers. This is how many devices need
cbilling:             # their digital values programmed, though as it happens,
cbilling:             # the National Instruments cards we use do not. So actually
cbilling:             # this is just for storage in the HDF5 file and this process
cbilling:             # is reversed when BLACS reads the data later.
cbilling:             digital_out_table = self.convert_bools_to_bytes(digitals.values())
cbilling:             
cbilling:         # Create the required group for this device in the HDF5 file:
cbilling:         grp = hdf5_file.create_group('/devices/'+self.name)
cbilling:         
cbilling:         # Save the analog output table, if it exists (subclasses may have zero outputs and hence an empty table):
cbilling:         if all(analog_out_table.shape): # Both dimensions must be nonzero
cbilling:             analog_dataset = grp.create_dataset('ANALOG_OUTS',compression=config.compression,data=analog_out_table)
cbilling:             # Save the corresponding list of channels:
cbilling:             grp.attrs['analog_out_channels'] = ', '.join(analog_out_attrs)
cbilling:         # Save the digital output table, if it exists:
cbilling:         if len(digital_out_table): # Table must be non empty
cbilling:             digital_dataset = grp.create_dataset('DIGITAL_OUTS',compression=config.compression,data=digital_out_table)
cbilling:             # Save the corresponding list of channels:
cbilling:             grp.attrs['digital_lines'] = '/'.join((self.MAX_name,'port0','line0:%d'%(self.n_digitals-1)))
cbilling:         # Save the table of acquisitions, if it exists:
cbilling:         if len(acquisition_table): # Table must be non empty
cbilling:             input_dataset = grp.create_dataset('ACQUISITIONS',compression=config.compression,data=acquisition_table)
cbilling:             # Save the channels for analog input:
cbilling:             grp.attrs['analog_in_channels'] = ', '.join(input_attrs)
cbilling:             # Save the acquisition rate for analog input:
cbilling:             grp.attrs['acquisition_rate'] = self.acquisition_rate
cbilling:         # Save the setting for which terminal this card should expect
cbilling:         # a clock input on, provided by its parent pseudoclock. BLACS
cbilling:         # needs this in order to configure the device to respond to the
cbilling:         # clock ticks:
cbilling:         grp.attrs['clock_terminal'] = self.clock_terminal
cbilling:         
pstarkey: # -*- coding: utf-8 -*-
pstarkey: #
pstarkey: # labscript documentation build configuration file, created by
pstarkey: # sphinx-quickstart on Mon Dec 08 14:26:41 2014.
pstarkey: #
pstarkey: # This file is execfile()d with the current directory set to its
pstarkey: # containing dir.
pstarkey: #
pstarkey: # Note that not all possible configuration values are present in this
pstarkey: # autogenerated file.
pstarkey: #
pstarkey: # All configuration values have a default; values that are commented out
pstarkey: # serve to show the default.
pstarkey: 
pstarkey: import sys
pstarkey: import os
pstarkey: 
pstarkey: # If extensions (or modules to document with autodoc) are in another directory,
pstarkey: # add these directories to sys.path here. If the directory is relative to the
pstarkey: # documentation root, use os.path.abspath to make it absolute, like shown here.
pstarkey: #sys.path.insert(0, os.path.abspath('.'))
pstarkey: 
pstarkey: # -- General configuration ------------------------------------------------
pstarkey: 
pstarkey: # If your documentation needs a minimal Sphinx version, state it here.
pstarkey: #needs_sphinx = '1.0'
pstarkey: 
pstarkey: # Add any Sphinx extension module names here, as strings. They can be
pstarkey: # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
pstarkey: # ones.
pstarkey: extensions = [
pstarkey:     'sphinx.ext.autodoc',
pstarkey:     'sphinx.ext.intersphinx',
pstarkey:     'sphinx.ext.todo',
pstarkey:     'sphinx.ext.coverage',
pstarkey:     'sphinx.ext.mathjax',
pstarkey:     'sphinx.ext.ifconfig',
pstarkey:     'sphinx.ext.viewcode',
pstarkey:     # 'sphinx.ext.linkcode',
pstarkey: ]
pstarkey: 
pstarkey: # def linkcode_resolve(domain, info):
pstarkey:     # if domain != 'py':
pstarkey:         # return None
pstarkey:     # if not info['module']:
pstarkey:         # return None
pstarkey:     # elif info['module'] == 'labscript':
pstarkey:         # return "https://bitbucket.org/labscript_suite/labscript/src/tip/labscript.py?at=default"
pstarkey:     # else:
pstarkey:         # return None
pstarkey: 
pstarkey: # Add any paths that contain templates here, relative to this directory.
pstarkey: templates_path = ['labscript_templates']
pstarkey: 
pstarkey: # The suffix of source filenames.
pstarkey: source_suffix = '.rst'
pstarkey: 
pstarkey: # The encoding of source files.
pstarkey: #source_encoding = 'utf-8-sig'
pstarkey: 
pstarkey: # The master toctree document.
pstarkey: master_doc = 'index'
pstarkey: 
pstarkey: # General information about the project.
pstarkey: project = u'labscript'
pstarkey: copyright = u'2014, Monash University'
pstarkey: 
pstarkey: # The version info for the project you're documenting, acts as replacement for
pstarkey: # |version| and |release|, also used in various other places throughout the
pstarkey: # built documents.
pstarkey: #
pstarkey: # The short X.Y version.
pstarkey: version = '2.0'
pstarkey: # The full version, including alpha/beta/rc tags.
pstarkey: release = '2.0.1'
pstarkey: 
pstarkey: # The language for content autogenerated by Sphinx. Refer to documentation
pstarkey: # for a list of supported languages.
pstarkey: #
pstarkey: # This is also used if you do content translation via gettext catalogs.
pstarkey: # Usually you set "language" from the command line for these cases.
pstarkey: language = None
pstarkey: 
pstarkey: # There are two options for replacing |today|: either, you set today to some
pstarkey: # non-false value, then it is used:
pstarkey: #today = ''
pstarkey: # Else, today_fmt is used as the format for a strftime call.
pstarkey: #today_fmt = '%B %d, %Y'
pstarkey: 
pstarkey: # List of patterns, relative to source directory, that match files and
pstarkey: # directories to ignore when looking for source files.
pstarkey: exclude_patterns = []
pstarkey: 
pstarkey: # The reST default role (used for this markup: `text`) to use for all
pstarkey: # documents.
pstarkey: #default_role = None
pstarkey: 
pstarkey: # If true, '()' will be appended to :func: etc. cross-reference text.
pstarkey: #add_function_parentheses = True
pstarkey: 
pstarkey: # If true, the current module name will be prepended to all description
pstarkey: # unit titles (such as .. function::).
pstarkey: #add_module_names = True
pstarkey: 
pstarkey: # If true, sectionauthor and moduleauthor directives will be shown in the
pstarkey: # output. They are ignored by default.
pstarkey: #show_authors = False
pstarkey: 
pstarkey: # The name of the Pygments (syntax highlighting) style to use.
pstarkey: pygments_style = 'sphinx'
pstarkey: highlight_language = 'python'
pstarkey: # A list of ignored prefixes for module index sorting.
pstarkey: #modindex_common_prefix = []
pstarkey: 
pstarkey: # If true, keep warnings as "system message" paragraphs in the built documents.
pstarkey: #keep_warnings = False
pstarkey: 
pstarkey: 
pstarkey: # -- Options for HTML output ----------------------------------------------
pstarkey: 
pstarkey: # The theme to use for HTML and HTML Help pages.  See the documentation for
pstarkey: # a list of builtin themes.
pstarkey: html_theme = 'default'
pstarkey: 
pstarkey: # Theme options are theme-specific and customize the look and feel of a theme
pstarkey: # further.  For a list of options available for each theme, see the
pstarkey: # documentation.
pstarkey: #html_theme_options = {}
pstarkey: 
pstarkey: # Add any paths that contain custom themes here, relative to this directory.
pstarkey: #html_theme_path = []
pstarkey: 
pstarkey: # The name for this set of Sphinx documents.  If None, it defaults to
pstarkey: # "<project> v<release> documentation".
pstarkey: #html_title = None
pstarkey: 
pstarkey: # A shorter title for the navigation bar.  Default is the same as html_title.
pstarkey: #html_short_title = None
pstarkey: 
pstarkey: # The name of an image file (relative to this directory) to place at the top
pstarkey: # of the sidebar.
pstarkey: #html_logo = None
pstarkey: 
pstarkey: # The name of an image file (within the static path) to use as favicon of the
pstarkey: # docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
pstarkey: # pixels large.
pstarkey: #html_favicon = None
pstarkey: 
pstarkey: # Add any paths that contain custom static files (such as style sheets) here,
pstarkey: # relative to this directory. They are copied after the builtin static files,
pstarkey: # so a file named "default.css" will overwrite the builtin "default.css".
pstarkey: html_static_path = ['labscript_static']
pstarkey: 
pstarkey: # Add any extra paths that contain custom files (such as robots.txt or
pstarkey: # .htaccess) here, relative to this directory. These files are copied
pstarkey: # directly to the root of the documentation.
pstarkey: #html_extra_path = []
pstarkey: 
pstarkey: # If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
pstarkey: # using the given strftime format.
pstarkey: #html_last_updated_fmt = '%b %d, %Y'
pstarkey: 
pstarkey: # If true, SmartyPants will be used to convert quotes and dashes to
pstarkey: # typographically correct entities.
pstarkey: #html_use_smartypants = True
pstarkey: 
pstarkey: # Custom sidebar templates, maps document names to template names.
pstarkey: #html_sidebars = {}
pstarkey: 
pstarkey: # Additional templates that should be rendered to pages, maps page names to
pstarkey: # template names.
pstarkey: #html_additional_pages = {}
pstarkey: 
pstarkey: # If false, no module index is generated.
pstarkey: #html_domain_indices = True
pstarkey: 
pstarkey: # If false, no index is generated.
pstarkey: #html_use_index = True
pstarkey: 
pstarkey: # If true, the index is split into individual pages for each letter.
pstarkey: #html_split_index = False
pstarkey: 
pstarkey: # If true, links to the reST sources are added to the pages.
pstarkey: #html_show_sourcelink = True
pstarkey: 
pstarkey: # If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
pstarkey: #html_show_sphinx = True
pstarkey: 
pstarkey: # If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
pstarkey: #html_show_copyright = True
pstarkey: 
pstarkey: # If true, an OpenSearch description file will be output, and all pages will
pstarkey: # contain a <link> tag referring to it.  The value of this option must be the
pstarkey: # base URL from which the finished HTML is served.
pstarkey: #html_use_opensearch = ''
pstarkey: 
pstarkey: # This is the file name suffix for HTML files (e.g. ".xhtml").
pstarkey: #html_file_suffix = None
pstarkey: 
pstarkey: # Language to be used for generating the HTML full-text search index.
pstarkey: # Sphinx supports the following languages:
pstarkey: #   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'
pstarkey: #   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'
pstarkey: #html_search_language = 'en'
pstarkey: 
pstarkey: # A dictionary with options for the search language support, empty by default.
pstarkey: # Now only 'ja' uses this config value
pstarkey: #html_search_options = {'type': 'default'}
pstarkey: 
pstarkey: # The name of a javascript file (relative to the configuration directory) that
pstarkey: # implements a search results scorer. If empty, the default will be used.
pstarkey: #html_search_scorer = 'scorer.js'
pstarkey: 
pstarkey: # Output file base name for HTML help builder.
pstarkey: htmlhelp_basename = 'labscriptdoc'
pstarkey: 
pstarkey: # -- Options for LaTeX output ---------------------------------------------
pstarkey: 
pstarkey: latex_elements = {
pstarkey: # The paper size ('letterpaper' or 'a4paper').
pstarkey: #'papersize': 'letterpaper',
pstarkey: 
pstarkey: # The font size ('10pt', '11pt' or '12pt').
pstarkey: #'pointsize': '10pt',
pstarkey: 
pstarkey: # Additional stuff for the LaTeX preamble.
pstarkey: #'preamble': '',
pstarkey: 
pstarkey: # Latex figure (float) alignment
pstarkey: #'figure_align': 'htbp',
pstarkey: }
pstarkey: 
pstarkey: # Grouping the document tree into LaTeX files. List of tuples
pstarkey: # (source start file, target name, title,
pstarkey: #  author, documentclass [howto, manual, or own class]).
pstarkey: latex_documents = [
pstarkey:   ('index', 'labscript.tex', u'labscript Documentation',
pstarkey:    u'Monash University', 'manual'),
pstarkey: ]
pstarkey: 
pstarkey: # The name of an image file (relative to this directory) to place at the top of
pstarkey: # the title page.
pstarkey: #latex_logo = None
pstarkey: 
pstarkey: # For "manual" documents, if this is true, then toplevel headings are parts,
pstarkey: # not chapters.
pstarkey: #latex_use_parts = False
pstarkey: 
pstarkey: # If true, show page references after internal links.
pstarkey: #latex_show_pagerefs = False
pstarkey: 
pstarkey: # If true, show URL addresses after external links.
pstarkey: #latex_show_urls = False
pstarkey: 
pstarkey: # Documents to append as an appendix to all manuals.
pstarkey: #latex_appendices = []
pstarkey: 
pstarkey: # If false, no module index is generated.
pstarkey: #latex_domain_indices = True
pstarkey: 
pstarkey: 
pstarkey: # -- Options for manual page output ---------------------------------------
pstarkey: 
pstarkey: # One entry per manual page. List of tuples
pstarkey: # (source start file, name, description, authors, manual section).
pstarkey: man_pages = [
pstarkey:     ('index', 'labscript', u'labscript Documentation',
pstarkey:      [u'Monash University'], 1)
pstarkey: ]
pstarkey: 
pstarkey: # If true, show URL addresses after external links.
pstarkey: #man_show_urls = False
pstarkey: 
pstarkey: 
pstarkey: # -- Options for Texinfo output -------------------------------------------
pstarkey: 
pstarkey: # Grouping the document tree into Texinfo files. List of tuples
pstarkey: # (source start file, target name, title, author,
pstarkey: #  dir menu entry, description, category)
pstarkey: texinfo_documents = [
pstarkey:   ('index', 'labscript', u'labscript Documentation',
pstarkey:    u'Monash University', 'labscript', 'One line description of project.',
pstarkey:    'Miscellaneous'),
pstarkey: ]
pstarkey: 
pstarkey: # Documents to append as an appendix to all manuals.
pstarkey: #texinfo_appendices = []
pstarkey: 
pstarkey: # If false, no module index is generated.
pstarkey: #texinfo_domain_indices = True
pstarkey: 
pstarkey: # How to display URL addresses: 'footnote', 'no', or 'inline'.
pstarkey: #texinfo_show_urls = 'footnote'
pstarkey: 
pstarkey: # If true, do not generate a @detailmenu in the "Top" node's menu.
pstarkey: #texinfo_no_detailmenu = False
pstarkey: 
pstarkey: 
pstarkey: # Example configuration for intersphinx: refer to the Python standard library.
pstarkey: intersphinx_mapping = {'http://docs.python.org/': None}
pstarkey: #####################################################################
pstarkey: #                                                                   #
pstarkey: # /example.py                                                       #
pstarkey: #                                                                   #
pstarkey: # Copyright 2013, Monash University                                 #
pstarkey: #                                                                   #
pstarkey: # This file is part of the program labscript, in the labscript      #
pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
pstarkey: # the project for the full license.                                 #
pstarkey: #                                                                   #
pstarkey: #####################################################################
pstarkey: 
pstarkey: import __init__ # only have to do this because we're inside the labscript directory
pstarkey: from labscript import *
pstarkey: from labscript_devices.PulseBlaster import PulseBlaster
pstarkey: from labscript_devices.NI_PCIe_6363 import NI_PCIe_6363
pstarkey: from labscript_devices.NovaTechDDS9M import NovaTechDDS9M
pstarkey: from labscript_devices.Camera import Camera
pstarkey: from labscript_devices.PineBlaster import PineBlaster
pstarkey: from labscript_devices.NI_PCI_6733 import NI_PCI_6733
pstarkey: from labscript_utils.unitconversions import *
pstarkey: 
pstarkey: PulseBlaster(name='pulseblaster_0', board_number=0)
pstarkey: ClockLine(name='pulseblaster_0_clockline_fast', pseudoclock=pulseblaster_0.pseudoclock, connection='flag 0')
pstarkey: ClockLine(name='pulseblaster_0_clockline_slow', pseudoclock=pulseblaster_0.pseudoclock, connection='flag 1')
  rander: NI_PCIe_6363(name='ni_card_0', parent_device=pulseblaster_0_clockline_fast, clock_terminal='ni_pcie_6363_0/PFI0', MAX_name='ni_pcie_6363_0', acquisition_rate=100e3)
pstarkey: NovaTechDDS9M(name='novatechdds9m_0', parent_device=pulseblaster_0_clockline_slow, com_port="com10")
pstarkey: 
pstarkey: # Create a BIAS Camera, tirggered to take photos with flag 3 of pulseblaster_0
  rander: Camera('andor_ixon_0', pulseblaster_0.direct_outputs, 'flag 3', BIAS_port = 42520, serial_number="0000", SDK="IMAQdx", effective_pixel_size=4.6e-6, exposure_time=.1, orientation='top')
pstarkey: 
pstarkey: # A second pseudoclock to just clock a NI_PCI_6733 Card
pstarkey: PineBlaster(name='pineblaster_0', trigger_device=ni_card_0, trigger_connection='port0/line15', usbport='COM7')
  rander: NI_PCI_6733(name='ni_card_1', parent_device=pineblaster_0.clockline, clock_terminal='ni_pcie_6733_0/PFI0', MAX_name='ni_pci_6733_0')
pstarkey: 
pstarkey: # Create the output/input channels on the above devices
  rander: AnalogOut( 'analog0', ni_card_1, 'ao0', unit_conversion_class=example1) # use the example1 conversion class located in pythonlib/unitconversions/example.py with default paremeters
pstarkey: 
pstarkey: # same as above, but we are changing some parameters used in the conversion and specifying a prefix to be used with units. You can now program in mA, uA, mGauss, uGauss
  rander: AnalogOut( 'analog1', ni_card_1, 'ao1', unit_conversion_class=example1, unit_conversion_parameters={'a':5, 'b':1, 'magnitudes':['m','u']}) 
  rander: AnalogOut( 'analog2', ni_card_0, 'ao2')
  rander: AnalogIn(   'input1', ni_card_0, 'ai0')
  rander: Shutter(  'shutter1', ni_card_0, 'port0/line1', delay=(0,0))
  rander: Shutter(  'shutter2', pulseblaster_0.direct_outputs, 'flag 2', delay=(0,0))
  rander: DigitalOut( 'switch', pulseblaster_0.direct_outputs, 'flag 4')
pstarkey: 
  rander: DDS(          'dds1', novatechdds9m_0, 'channel 0')
  rander: DDS(          'dds2', novatechdds9m_0, 'channel 1')
  rander: StaticDDS(    'dds5', novatechdds9m_0, 'channel 2')
pstarkey: # The next DDS is special because it has the frequency and amplitude calibrated using example2 and example3 classes from pythonlib/unitconversions/example.py
  rander: DDS(          'dds3', pulseblaster_0.direct_outputs, 'dds 0', freq_conv_class=example2, freq_conv_params={'a':4, 'b':6}, amp_conv_class=example3, amp_conv_params={'a':2, 'b':22, 'magnitudes':['m']})
  rander: DDS(          'dds4', pulseblaster_0.direct_outputs, 'dds 1')
pstarkey: 
pstarkey: # This sets up the inputs/counters/etc that will monitor
pstarkey: # The first paremeter is the name for the WaitMonitor device
pstarkey: # The second and third paremeters are the device and channel respectively that goes high when a wait begins and low when it ends. This output should be   
pstarkey: # physically connected to a counter specified in the next two paremeters.
pstarkey: # The final two paremeters specify the device/channel that is to trigger the pseudoclock if the WAIT instruction hits the specified timeout. The output of 
pstarkey: # this channel should be physicaly connect to the external trigger of the master pseudoclock.
pstarkey: WaitMonitor('wait_monitor', ni_card_0, 'port0/line0', ni_card_0, 'ctr0', ni_card_0, 'pfi1')
pstarkey: 
pstarkey: # A variable to define the acquisition rate used for the analog outputs below.
pstarkey: # This is just here to show you that you can use variables instead of typing in numbers!
pstarkey: # Furthermore, these variables could be defined within runmanager (rather than in the code like this one is)
pstarkey: # for easy manipulation via a graphical interface.
pstarkey: rate = 1e4
pstarkey: 
  rander: # The time (in seconds) we wish the pineblaster pseudoclock to start after
  rander: # the master pseudoclock (the pulseblaster)
pstarkey: pineblaster_0.set_initial_trigger_time(1)
pstarkey: 
pstarkey: # Start the experiment!
pstarkey: start()
pstarkey: 
pstarkey: # A variable to keep track of time
pstarkey: t = 0
pstarkey: 
pstarkey: # Analog Acquisitions are acquired at the sample rate specified when the *device* is instantiated (eg NI_PCIE_6363() above)
pstarkey: # Acquire an analog trace on this channel from t=0s to t=1s
  rander: input1.acquire('measurement1', 0, 1)
pstarkey: # Acquire an analog trace on this channel from t=3s to t=5s
  rander: input1.acquire('measurement2', 3, 5)
pstarkey: # Acquire an analog trace on this channel from t=7s to t=9s
  rander: input1.acquire('measurement3', 7, 9)
pstarkey: 
pstarkey: # Set some initial values (t=0) for DDS 1
  rander: dds1.setamp(t, 0.5)
  rander: dds1.setfreq(t, 0.6)
  rander: dds1.setphase(t, 0.7)
pstarkey: 
  rander: # Set some values for dds2 at t=1s. They will have value '0' before this
  rander: # time unless otherwise set
  rander: dds2.setamp(t+1, 0.9)
  rander: dds2.setfreq(t+1, 1.0)
  rander: dds2.setphase(t+1, 1.1)
pstarkey: 
  rander: # dds5 is a "static" DDS. This means its value can only be set once, and
  rander: # will be set just before the experiment begins
pstarkey: dds5.setfreq(90*MHz)
pstarkey: dds5.setamp(1)
pstarkey: dds5.setphase(0)
pstarkey: 
pstarkey: # Have the shutters start in the closed state (t=0)
pstarkey: shutter1.close(t)
pstarkey: shutter2.close(t)
pstarkey: 
pstarkey: # Analog0 is attached to ni_card_1, which is an NI-pci_6733 card (MAX name ni_pcie_6733_0) clocked by a pineblaster
pstarkey: # The pineblaster is being triggered to start by a pulseblaster, which introduces a delay into the start of output from the NI card
pstarkey: # This is all handled by labscript, and you still specify times from the beginning of the experiment (when the master pseudoclock is started)
pstarkey: # YOU DO NOT HAVE TO TAKE INTO ACCOUNT THE DELAY YOURSELF!!
pstarkey: # You do however need to make sure you do not command output from this device before the device has actually started.
  rander: # To do so, make sure no commands happen on this channel before analog0.t0
  rander: # (this variable contains the delay time!)
  rander: analog0.constant(analog0.t0, 2)
pstarkey: 
pstarkey: # Set this channel to a constant value
  rander: # As this channel is clocked by the master pseudoclock, you can command
  rander: # output from t=0
  rander: analog2.constant(t, 3)
pstarkey: 
pstarkey: # Again, this must not start until analog1.t0 or later!
  rander: analog1.sine(analog1.t0, duration=6, amplitude=5, angfreq=2*pi,
  rander:              phase=0, dc_offset=0.0, samplerate=rate)
pstarkey: 
pstarkey: # Let's increment our time variable!
  rander: t += max(1, analog0.t0)
pstarkey: 
pstarkey: # Open the shutter, enable the DDS, ramp an analog output!
pstarkey: shutter2.open(t)
pstarkey: dds3.enable(t)
pstarkey: analog0.ramp(t, duration=2, initial=2, final=3, samplerate=rate)
pstarkey: 
pstarkey: # Take a picture
  rander: andor_ixon_0.expose('exposure_1', t, 'flat')
  rander: andor_ixon_0.expose('exposure_1', t+1, 'atoms')
pstarkey: 
pstarkey: # Do some more things at various times!
pstarkey: # (these are ignoring the t variable)
  rander: def my_ramp(t, *args, **kwargs):
  rander:     lambda_func = functions.sine_ramp(*args, **kwargs)
  rander:     return lambda_func(t)
  rander: analog2.sine_ramp(t=2.25, duration=3, initial=3, final=4,
  rander:                   samplerate=rate, truncation=0.7)
pstarkey: shutter1.open(t=5.89)
  rander: analog2.constant(t=5.9, value=5)
  rander: analog2.constant(t=7, value=4)
  rander: analog2.constant(t=8, value=5)
pstarkey: 
pstarkey: 
  rander: t += 9  # set t=10 seconds
pstarkey: # Wait for an external trigger on the master pseudoclock
pstarkey: # Waits must be names
pstarkey: # The timeout defaults to 5s, unless otherwise specified.
  rander: # The timeout specifies how long to wait without seeing the external
  rander: # trigger before continuing the experiment
pstarkey: t += wait('my_first_wait', t=t, timeout=2)
pstarkey: # Waits take very little time as far as labscript is concerned. They only add on the retirggering time needed to start devices up and get them all in sync again.
  rander: # After a wait, labscript time (the t variable here) and execution time (when the hardware instructions are executed on the hardware) will not be the same
  rander: # as the wait instruction may take anywhere from 0 to "timeout" seconds,
  rander: # and this number is only determined during execution time.
pstarkey: 
  rander: t += 1
pstarkey: # Do something 1s after the wait!
pstarkey: switch.go_high(t)
pstarkey: 
  rander: # Examples programming in different units as specified in the
  rander: # unitconversion classes passed as parameters to the channel definition
pstarkey: analog0.constant(t, value=5, units='A')
pstarkey: analog1.constant(t, value=1000, units='mGauss')
  rander: dds3.setfreq(t, value=50, units='detuned_MHz')
  rander: dds3.setamp(t, value=1.9, units='W')
  rander: t += 2
  rander: analog0.ramp(t, duration=1, initial=5, final=7, samplerate=rate, units='Gauss')
pstarkey: analog1.constant(t, value=3e6, units='uA')
  rander: dds3.setfreq(t, value=60, units='detuned_MHz')
  rander: dds3.setamp(t, value=500, units='mW')
  rander: t += 2
  rander: # Stop at t=15 seconds, note that because of the wait timeout, this might
  rander: # be as late as 17s (Plus a little bit of retriggering time) in execution
  rander: # time
pstarkey: stop(t)
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /functions.py                                                     #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program labscript, in the labscript      #
   pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   pstarkey: from pylab import *
janwerkmann: import numpy as np
   pstarkey: 
   shjohnst: def print_time(t, description):
   shjohnst:     print('t = {0:.9f} s:'.format(t),description)
   shjohnst: 
   pstarkey: def ramp(duration, initial, final):
   pstarkey:     m = (final - initial)/duration
   pstarkey:     return lambda t: m*t + initial
   pstarkey: 
   pstarkey: def sine(duration, amplitude, angfreq, phase, dc_offset):
   pstarkey:     return lambda t: amplitude*sin(angfreq*(t) + phase) + dc_offset
   pstarkey:     
   pstarkey: def sine_ramp(duration, initial, final):
   pstarkey:     return lambda t: (final-initial)*(sin(pi*(t)/(2*duration)))**2 + initial
   pstarkey:     
   pstarkey: def sine4_ramp(duration, initial, final):
   pstarkey:     return lambda t: (final-initial)*(sin(pi*(t)/(2*duration)))**4 + initial
   pstarkey:     
   pstarkey: def sine4_reverse_ramp(duration, initial, final):
   pstarkey:     return lambda t: (final-initial)*(sin(pi/2+pi*(t)/(2*duration)))**4 + initial
   pstarkey:     
   pstarkey: def exp_ramp(duration,initial,final,zero):
   pstarkey:     rate = 1/duration * log((initial-zero)/(final-zero))
   pstarkey:     return lambda t: (initial-zero)*exp(-rate*(t)) + zero
   pstarkey:     
   pstarkey: def exp_ramp_t(duration,initial,final,time_constant):
   pstarkey:     zero = (final-initial*exp(-duration/time_constant)) / (1-exp(-duration/time_constant))
   pstarkey:     return lambda t: (initial-zero)*exp(-(t)/time_constant) + zero
   pstarkey: 
   pstarkey: def piecewise_accel(duration,initial,final):
   pstarkey:     a = (final-initial)
   pstarkey:     return lambda t: initial + a * (
   pstarkey:     (9./2 * t**3/duration**3) * (t<duration/3)
   pstarkey:     + (-9*t**3/duration**3 + 27./2*t**2/duration**2 - 9./2*t/duration + 1./2) * (t<2*duration/3)*(t>=duration/3)
   pstarkey:     + (9./2*t**3/duration**3 - 27./2 * t**2/duration**2 + 27./2*t/duration - 7./2) * (t>= 2*duration/3))
janwerkmann: 
janwerkmann: def pulse_sequence(pulse_sequence,period):
janwerkmann:     pulse_sequence = np.asarray(sorted(pulse_sequence, key=lambda x: x[0], reverse=True))
janwerkmann:     pulse_sequence_times = pulse_sequence[:, 0]
janwerkmann:     pulse_sequence_states = pulse_sequence[:, 1]
janwerkmann: 
   pstarkey:     def pulse_function(t):
janwerkmann:         try:
janwerkmann:             len(t)
janwerkmann:             is_array = True
janwerkmann:         except TypeError:
janwerkmann:             t = array([t])
janwerkmann:             is_array = False
janwerkmann: 
janwerkmann:         times = t % period
janwerkmann:         indices = np.digitize(times, pulse_sequence_times, right=False)
janwerkmann:         states = pulse_sequence_states[indices]
janwerkmann: 
janwerkmann:         if is_array:
janwerkmann:             return states
janwerkmann:         else:
janwerkmann:             return states[0]
janwerkmann: 
   pstarkey:     return pulse_function
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /labscript.py                                                     #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program labscript, in the labscript      #
        pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
        pstarkey: 
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
             jan: from labscript_utils.numpy_dtype_workaround import dtype_workaround
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann:     import __builtin__ as builtins
     janwerkmann: else:
     janwerkmann:     import builtins
        pstarkey: import os
        pstarkey: import sys
        pstarkey: import subprocess
        pstarkey: import keyword
        spielman: from inspect import getargspec
        spielman: from functools import wraps
        pstarkey: 
        pstarkey: # Notes for v3
        pstarkey: #
        pstarkey: # Anything commented with TO_DELETE:runmanager-batchompiler-agnostic 
        pstarkey: # can be removed with a major version bump of labscript (aka v3+)
        pstarkey: # We leave it in now to maintain backwards compatibility between new labscript
        pstarkey: # and old runmanager.
        pstarkey: # The code to be removed relates to the move of the globals loading code from
        pstarkey: # labscript to runmanager batch compiler.
        pstarkey: 
        pstarkey: 
        pstarkey: import labscript_utils.h5_lock, h5py
        cbilling: import labscript_utils.properties
chrisjbillington: 
chrisjbillington: from labscript_utils import check_version
chrisjbillington: 
chrisjbillington: # This imports the default Qt library that other labscript suite code will
chrisjbillington: # import as well, since it all uses qtutils. By having a Qt library already
chrisjbillington: # imported, we ensure matplotlib (imported by pylab) will notice this and use
chrisjbillington: # the same Qt library and API version, and therefore not conflict with any
chrisjbillington: # other code is using:
chrisjbillington: check_version('qtutils', '2.0.0', '3.0.0')
        pstarkey: from pylab import *
        pstarkey: 
     janwerkmann: import labscript.functions as functions
        pstarkey: try:
        pstarkey:     from labscript_utils.unitconversions import *
        cbilling: except ImportError:
        cbilling:     sys.stderr.write('Warning: Failed to import unit conversion classes\n')
        pstarkey: 
        pstarkey: ns = 1e-9
        pstarkey: us = 1e-6
        pstarkey: ms = 1e-3
        pstarkey: s = 1
        pstarkey: Hz = 1
        pstarkey: kHz = 1e3
        pstarkey: MHz = 1e6
        pstarkey: GHz = 1e9
        pstarkey: 
        pstarkey: # Create a reference to the builtins dict 
             jan: # update this if accessing builtins ever changes
     janwerkmann: _builtins_dict = builtins.__dict__
        pstarkey:     
        pstarkey: # Startupinfo, for ensuring subprocesses don't launch with a visible command window:
        pstarkey: if os.name=='nt':
        pstarkey:     startupinfo = subprocess.STARTUPINFO()
        pstarkey:     startupinfo.dwFlags |= 1 #subprocess.STARTF_USESHOWWINDOW # This variable isn't defined, but apparently it's equal to one.
        pstarkey: else:
        pstarkey:     startupinfo = None
        pstarkey:         
        pstarkey:         
     janwerkmann: class config(object):
        pstarkey:     suppress_mild_warnings = True
        pstarkey:     suppress_all_warnings = False
        spielman:     compression = 'gzip'  # set to 'gzip' for compression 
        pstarkey:    
        pstarkey:     
        pstarkey: class NoWarnings(object):
        pstarkey:     """A context manager which sets config.suppress_mild_warnings to True
        pstarkey:     whilst in use.  Allows the user to suppress warnings for specific
        pstarkey:     lines when they know that the warning does not indicate a problem."""
        pstarkey:     def __enter__(self):
        pstarkey:         self.existing_warning_setting = config.suppress_all_warnings
        pstarkey:         config.suppress_all_warnings = True
        pstarkey:     def __exit__(self, *args):
        pstarkey:         config.suppress_all_warnings = self.existing_warning_setting
        pstarkey:     
        pstarkey: no_warnings = NoWarnings() # This is the object that should be used, not the class above
        pstarkey: 
        pstarkey: def max_or_zero(*args, **kwargs):
        pstarkey:     """returns max(*args) or zero if given an empty sequence (in which case max() would throw an error)"""
        pstarkey:     if not args:
        pstarkey:         return 0
        pstarkey:     if not args[0]:
        pstarkey:         return 0
        pstarkey:     else:
        pstarkey:         return max(*args, **kwargs)
        pstarkey:     
        pstarkey: def bitfield(arrays,dtype):
        pstarkey:     """converts a list of arrays of ones and zeros into a single
        pstarkey:     array of unsigned ints of the given datatype."""
        pstarkey:     n = {uint8:8,uint16:16,uint32:32}
        pstarkey:     if arrays[0] is 0:
        pstarkey:         y = zeros(max([len(arr) if iterable(arr) else 1 for arr in arrays]),dtype=dtype)
        pstarkey:     else:
        pstarkey:         y = array(arrays[0],dtype=dtype)
        pstarkey:     for i in range(1,n[dtype]):
        pstarkey:         if iterable(arrays[i]):
        pstarkey:             y |= arrays[i]<<i
        pstarkey:     return y
        pstarkey: 
        pstarkey: def fastflatten(inarray, dtype):
        pstarkey:     """A faster way of flattening our arrays than pylab.flatten.
        pstarkey:     pylab.flatten returns a generator which takes a lot of time and memory
        pstarkey:     to convert into a numpy array via array(list(generator)).  The problem
        pstarkey:     is that generators don't know how many values they'll return until
        pstarkey:     they're done. This algorithm produces a numpy array directly by
        pstarkey:     first calculating what the length will be. It is several orders of
        pstarkey:     magnitude faster. Note that we can't use numpy.ndarray.flatten here
        pstarkey:     since our inarray is really a list of 1D arrays of varying length
        pstarkey:     and/or single values, not a N-dimenional block of homogeneous data
        pstarkey:     like a numpy array."""
        pstarkey:     total_points = sum([len(element) if iterable(element) else 1 for element in inarray])
        pstarkey:     flat = empty(total_points,dtype=dtype)
        pstarkey:     i = 0
        pstarkey:     for val in inarray:
        pstarkey:         if iterable(val):
        pstarkey:             flat[i:i+len(val)] = val[:]
        pstarkey:             i += len(val)
        pstarkey:         else:
        pstarkey:             flat[i] = val
        pstarkey:             i += 1
        pstarkey:     return flat
        spielman: 
        spielman: def set_passed_properties(property_names = {}):
        spielman:     """
        spielman:     This decorator is intended to wrap the __init__ functions and to
        spielman:     write any selected kwargs into the properties.  
        spielman:     
        spielman:     names is a dictionary {key:val}, where each val
        spielman:         is a list [var1, var2, ...] of variables to be pulled from
        cbilling:         properties_dict and added to the property with name key (it's location)
        spielman:         
        spielman:     internally they are all accessed by calling self.get_property()
        spielman:     """
        spielman:     def decorator(func):
        spielman:         @wraps(func)
        spielman:         def new_function(inst, *args, **kwargs):
        spielman: 
        cbilling:             return_value = func(inst, *args, **kwargs)
        cbilling: 
        spielman:             # Introspect arguments and named arguments functions.  in python 3 this is
        spielman:             # a pair of func.__something__ calls and no import from argspec is needed
        spielman:             a = getargspec(func)
        spielman:             
        spielman:             if a.defaults is not None:
        spielman:                 args_dict = {key:val for key,val in zip(a.args[-len(a.defaults):],a.defaults)}
        spielman:             else:
        spielman:                 args_dict = {}
        spielman:                 
        cbilling:             # Update this list with the values from the passed keywords
        spielman:             args_dict.update(kwargs)
        cbilling: 
        spielman:             # print args_dict
        spielman:             # print property_names
        spielman:             inst.set_properties(args_dict, property_names)
        cbilling: 
        cbilling:             return return_value
        cbilling: 
        spielman:         return new_function
        spielman:     
        spielman:     return decorator
        spielman: 
        spielman: 
        pstarkey: class Device(object):
        pstarkey:     description = 'Generic Device'
        pstarkey:     allowed_children = None
        spielman:     
        spielman:     @set_passed_properties(
           Chris:         property_names = {"device_properties": ["added_properties"]}
        spielman:         )
           Chris:     def __init__(self,name,parent_device,connection, call_parents_add_device=True, 
        pstarkey:                  added_properties = {}, gui=None, worker=None, **kwargs):
        spielman:         # Verify that no invalid kwargs were passed and the set properties
        spielman:         if len(kwargs) != 0:        
        spielman:             raise LabscriptError('Invalid keyword arguments: %s.'%kwargs)
        spielman: 
        pstarkey:         if self.allowed_children is None:
        cbilling:             self.allowed_children = [Device]
        pstarkey:         self.name = name
        pstarkey:         self.parent_device = parent_device
        pstarkey:         self.connection = connection
        pstarkey:         self.child_devices = []
        spielman:         
        spielman:         # self._properties may be instantiated already
        spielman:         if not hasattr(self, "_properties"):
        cbilling:             self._properties = {}
        cbilling:         for location in labscript_utils.properties.VALID_PROPERTY_LOCATIONS:
        cbilling:             if location not in self._properties:
        cbilling:                 self._properties[location] = {}
        spielman: 
        cbilling:         if parent_device and call_parents_add_device:
        cbilling:             # This is optional by keyword argument, so that subclasses
        cbilling:             # overriding __init__ can call call Device.__init__ early
        cbilling:             # on and only call self.parent_device.add_device(self)
        cbilling:             # a bit later, allowing for additional code in
        cbilling:             # between. If setting call_parents_add_device=False,
        cbilling:             # self.parent_device.add_device(self) *must* be called later
        cbilling:             # on, it is not optional.
        pstarkey:             parent_device.add_device(self)
        spielman:             
        pstarkey:         # Check that the name doesn't already exist in the python namespace
        pstarkey:         if name in locals() or name in globals() or name in _builtins_dict:
        pstarkey:             raise LabscriptError('The device name %s already exists in the Python namespace. Please choose another.'%name)
        pstarkey:         if name in keyword.kwlist:
        pstarkey:             raise LabscriptError('%s is a reserved Python keyword.'%name +
        pstarkey:                                  ' Please choose a different device name.')
        pstarkey:                                      
        pstarkey:         try:
        pstarkey:             # Test that name is a valid Python variable name:
     janwerkmann:             exec('%s = None'%name)
        pstarkey:             assert '.' not in name
        pstarkey:         except:
        pstarkey:             raise ValueError('%s is not a valid Python variable name.'%name)
        pstarkey:         
        pstarkey:         # Put self into the global namespace:
        pstarkey:         _builtins_dict[name] = self
        pstarkey:         
        pstarkey:         # Add self to the compiler's device inventory
        pstarkey:         compiler.inventory.append(self)
        pstarkey:         
        pstarkey:         # handle remote workers/gui interface
        pstarkey:         if gui is not None or worker is not None:
        pstarkey:             # remote GUI and worker
        pstarkey:             if gui is not None:
        pstarkey:                 # if no worker is specified, assume it is the same as the gui
        pstarkey:                 if worker is None:
        pstarkey:                     worker = gui
        pstarkey:                     
        pstarkey:                 # check that worker and gui are appropriately typed
        pstarkey:                 if not isinstance(gui, _RemoteConnection):
        pstarkey:                     raise LabscriptError('the "gui" argument for %s must be specified as a subclass of _RemoteConnection'%(self.name))
        pstarkey:             else:
        pstarkey:                 # just remote worker
        pstarkey:                 gui = compiler._PrimaryBLACS
        pstarkey:             
        pstarkey:             if not isinstance(worker, _RemoteConnection):
        pstarkey:                 raise LabscriptError('the "worker" argument for %s must be specified as a subclass of _RemoteConnection'%(self.name))
        pstarkey:             
        pstarkey:             # check that worker is equal to, or a child of, gui
        pstarkey:             if worker != gui and worker not in gui.get_all_children():
             jan:                 print(gui.get_all_children())
        pstarkey:                 raise LabscriptError('The remote worker (%s) for %s must be a child of the specified gui (%s) '%(worker.name, self.name, gui.name))
        pstarkey:                 
        pstarkey:             # store worker and gui as properties of the connection table
        pstarkey:             self.set_property('gui', gui.name, 'connection_table_properties')
        pstarkey:             self.set_property('worker', worker.name, 'connection_table_properties')
        spielman:             
        pstarkey:     
        pstarkey:     # Method to set a property for this device. 
        pstarkey:     #
        pstarkey:     # The property will be stored in the connection table and be used 
        pstarkey:     # during connection table comparisons.
        pstarkey:     #
        pstarkey:     # The value must satisfy eval(repr(value)) == value
        pstarkey:     #
        pstarkey:     # You cannot overwrite an existing property unless you set the 
        pstarkey:     # overwrite flag to True on subsequent calls to this method
        spielman:     # 
        cbilling:     # you can specify a location = "device_properties" or "connection_table_properties"
        spielman:     # to set where these are stored.
        pstarkey:     def set_property(self, name, value, location=None, overwrite=False):
        cbilling:         if location is None or location not in labscript_utils.properties.VALID_PROPERTY_LOCATIONS:
        cbilling:             raise LabscriptError('Device %s requests invalid property assignment %s for property %s'%(self.name, location, name))
        spielman:             
        pstarkey:         # if this try fails then self."location" may not be instantiated
        spielman:         if not hasattr(self, "_properties"):
        spielman:             self._properties = {}
        spielman: 
        cbilling:         if location not in self._properties:
        cbilling:             self._properties[location] = {}
        spielman: 
        cbilling:         selected_properties = self._properties[location]
        spielman:         
        spielman:         if name in selected_properties and not overwrite:
        pstarkey:             raise LabscriptError('Device %s has had the property %s set more than once. This is not allowed unless the overwrite flag is explicitly set'%(self.name, name))
        spielman: 
        spielman:         selected_properties[name] = value
        spielman: 
        spielman:     def set_properties(self, properties_dict, property_names, overwrite = False):
        spielman:         """
        spielman:         Add one or a bunch of properties packed into properties_dict
        spielman: 
        cbilling:         property_names is a dictionary {key:val, ...} where each val
        spielman:             is a list [var1, var2, ...] of variables to be pulled from
        cbilling:             properties_dict and added to the property with name key (it's location)
        spielman:         """
        cbilling:         for location, names in property_names.items():
        cbilling:             if not isinstance(names, list) and not isinstance(names, tuple):
        cbilling:                 raise TypeError('%s names (%s) must be list or tuple, not %s'%(location, repr(names), str(type(names))))
        spielman:             temp_dict = {key:val for key, val in properties_dict.items() if key in names}                  
        spielman:             for (name, value) in temp_dict.items():
        spielman:                 self.set_property(name, value, 
        spielman:                                   overwrite = overwrite, 
        cbilling:                                   location = location)
        pstarkey:     
        pstarkey:     # Method to get a property of this device already set using Device.set_property
        pstarkey:     #
        pstarkey:     # If the property is not already set, a default value will be returned 
        pstarkey:     # if specified as the argument after 'name' if there is only one argument
        pstarkey:     # after 'name' and the argument is either not a keyword argument or is a 
        pstarkey:     # keyword argument with the name 'default'
        pstarkey:     #
        pstarkey:     # If the property is not already set, or one of the above conventions is
        pstarkey:     # violated, a LabscriptError will be raised
        pstarkey:     #
        pstarkey:     # Example acceptable signatures:
        pstarkey:     #
        pstarkey:     # get_property('example')            # 'example will be returned if set, or an exception will be raised
        pstarkey:     # get_property('example', 7)         # 7 will be returned if 'example' is not set
        pstarkey:     # get_property('example', default=7) # 7 will be returned is 'example' is not set
        pstarkey:     #
        pstarkey:     #
        pstarkey:     # Example signatures that WILL ALWAYS RAISE AN EXCEPTION:
        pstarkey:     # get_property('example', 7, 8)
        pstarkey:     # get_property('example', 7, default=9)
        pstarkey:     # get_property('example', default=7, x=9)
        spielman:     #
        cbilling:     # the named argument location, if passed, requests the keyword be searched
        cbilling:     # from only that location
        cbilling:     def get_property(self, name, location = None, *args, **kwargs):#default = None):
        pstarkey:         if len(kwargs) == 1 and 'default' not in kwargs:
        pstarkey:             raise LabscriptError('A call to %s.get_property had a keyword argument that was not name or default'%self.name)
        pstarkey:         if len(args) + len(kwargs) > 1:
        pstarkey:             raise LabscriptError('A call to %s.get_property has too many arguments and/or keyword arguments'%self.name)
        spielman: 
        cbilling:         if (location is not None) and (location not in labscript_utils.properties.VALID_PROPERTY_LOCATIONS):
        cbilling:             raise LabscriptError('Device %s requests invalid property read location %s'%(self.name, location))
        spielman:             
        spielman:         # self._properties may not be instantiated
        spielman:         if not hasattr(self, "_properties"):
        spielman:             self._properties =  {}
        spielman:         
        spielman:         # Run through all keys of interest
        spielman:         for key, val in self._properties.items():
        cbilling:             if (location is None or key == location) and (name in val):
        spielman:                return val[name]
        pstarkey:             
        pstarkey:         if 'default' in kwargs:
        pstarkey:             return kwargs['default']
        pstarkey:         elif len(args) == 1:
        pstarkey:             return args[0]
        pstarkey:         else:
        pstarkey:             raise LabscriptError('The property %s has not been set for device %s'%(name, self.name))
        spielman: 
        cbilling:     def get_properties(self, location = None):
        spielman:         """
        cbilling:         Get all properties in location
        spielman:         
        cbilling:         If location is None we return all keys
        spielman:         """
        spielman:     
        spielman:         # self._properties may not be instantiated
        spielman:         if not hasattr(self, "_properties"):
        spielman:             self._properties =  {}
        spielman: 
        cbilling:         if location is not None:
        cbilling:             temp_dict = self._properties.get(location, {})
        spielman:         else:
        spielman:             temp_dict = {}
        spielman:             for key,val in self._properties.items(): temp_dict.update(val)
        spielman:                 
        spielman:         return temp_dict
        spielman: 
        cbilling:     def add_device(self, device):
        pstarkey:         if any([isinstance(device,DeviceClass) for DeviceClass in self.allowed_children]):
        pstarkey:             self.child_devices.append(device)
        pstarkey:         else:
        pstarkey:             raise LabscriptError('Devices of type %s cannot be attached to devices of type %s.'%(device.description,self.description))
        pstarkey:     
        pstarkey:     @property    
        pstarkey:     def pseudoclock_device(self):
        pstarkey:         if isinstance(self, PseudoclockDevice):
        pstarkey:             return self 
        pstarkey:         parent = self.parent_device
        pstarkey:         try:
        pstarkey:             while not isinstance(parent,PseudoclockDevice):
        pstarkey:                 parent = parent.parent_device
        pstarkey:             return parent
        pstarkey:         except Exception as e:
        pstarkey:             raise LabscriptError('Couldn\'t find parent pseudoclock device of %s, what\'s going on? Original error was %s.'%(self.name, str(e)))
        pstarkey:     
        pstarkey:     def quantise_to_pseudoclock(self, times):
        pstarkey:         convert_back_to = None 
        pstarkey:         if not isinstance(times, ndarray):
        pstarkey:             if isinstance(times, list):
        pstarkey:                 convert_back_to = list
        pstarkey:             elif isinstance(times, set):
        pstarkey:                 convert_back_to = set
        pstarkey:             else:
        pstarkey:                 convert_back_to = float
        pstarkey:             times = array(times)
        pstarkey:         # quantise the times to the pseudoclock clock resolution
        pstarkey:         times = (times/self.pseudoclock_device.clock_resolution).round()*self.pseudoclock_device.clock_resolution
        pstarkey:         
        pstarkey:         if convert_back_to is not None:
        pstarkey:             times = convert_back_to(times)
        pstarkey:         
        pstarkey:         return times
        pstarkey:     
        pstarkey:     @property 
        pstarkey:     def parent_clock_line(self):
        pstarkey:         if isinstance(self, ClockLine):
        pstarkey:             return self
        pstarkey:         parent = self.parent_device
        pstarkey:         try:
        pstarkey:             while not isinstance(parent,ClockLine):
        pstarkey:                 parent = parent.parent_device
        pstarkey:             return parent
        pstarkey:         except Exception as e:
        pstarkey:             raise LabscriptError('Couldn\'t find parent ClockLine of %s, what\'s going on? Original error was %s.'%(self.name, str(e)))
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def t0(self):
        pstarkey:         """The earliest time output can be commanded from this device at the start of the experiment.
        pstarkey:         This is nonzeo on secondary pseudoclock devices due to triggering delays."""
        pstarkey:         parent = self.pseudoclock_device
        pstarkey:         if parent.is_master_pseudoclock:
        pstarkey:             return 0
        pstarkey:         else:
        cbilling:             return round(parent.trigger_times[0] + parent.trigger_delay, 10)
        pstarkey:                             
        pstarkey:     def get_all_outputs(self):
        pstarkey:         all_outputs = []
        pstarkey:         for device in self.child_devices:
        pstarkey:             if isinstance(device,Output):
        pstarkey:                 all_outputs.append(device)
        pstarkey:             else:
        pstarkey:                 all_outputs.extend(device.get_all_outputs())
        pstarkey:         return all_outputs
        pstarkey:     
        pstarkey:     def get_all_children(self):
        pstarkey:         all_children = []
        pstarkey:         for device in self.child_devices:
        pstarkey:               all_children.append(device)
        pstarkey:               all_children.extend(device.get_all_children())
        pstarkey:         return all_children
        pstarkey: 
        pstarkey:     def generate_code(self, hdf5_file):
        spielman:         
        pstarkey:         for device in self.child_devices:
        pstarkey:             device.generate_code(hdf5_file)
        spielman: 
        spielman:     def init_device_group(self, hdf5_file):
        spielman:         group = hdf5_file['/devices'].create_group(self.name)
        spielman:         return group
        pstarkey: 
        cbilling: 
        pstarkey: class _PrimaryBLACS(Device):
        pstarkey:     pass
        pstarkey:     
        pstarkey: class _RemoteConnection(Device):
        pstarkey:     @set_passed_properties(
        pstarkey:         property_names = {}
        pstarkey:     )
        pstarkey:     def __init__(self, name, parent=None, connection=None):
        pstarkey:         if parent is None:
        pstarkey:             # define a hidden parent of top level remote connections so that
        pstarkey:             # "connection" is stored correctly in the connection table
        pstarkey:             if compiler._PrimaryBLACS is None:
        pstarkey:                 compiler._PrimaryBLACS = _PrimaryBLACS('__PrimaryBLACS', None, None)
        pstarkey:             parent = compiler._PrimaryBLACS
        pstarkey:         Device.__init__(self, name, parent, connection)
        pstarkey:         
        pstarkey:         
        pstarkey: class RemoteBLACS(_RemoteConnection):
        pstarkey:     def __init__(self, name, host, port=7340, parent=None):
        pstarkey:         _RemoteConnection.__init__(self, name, parent, "%s:%s"%(host, port))
        pstarkey:         
        pstarkey:         
        pstarkey: class SecondaryControlSystem(_RemoteConnection):
        pstarkey:     def __init__(self, name, host, port, parent=None):
        pstarkey:         _RemoteConnection.__init__(self, name, parent, "%s:%s"%(host, port))
        pstarkey:         
          philip: 
        pstarkey: class IntermediateDevice(Device):
        pstarkey:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, parent_device, **kwargs):
        spielman: 
        pstarkey:         self.name = name
        pstarkey:         # this should be checked here because it should only be connected a clockline
        pstarkey:         # The allowed_children attribute of parent classes doesn't prevent this from being connected to something that accepts 
        pstarkey:         # an instance of 'Device' as a child
        pstarkey:         if not isinstance(parent_device, ClockLine):
        pstarkey:             if not hasattr(parent_device, 'name'):
        pstarkey:                 parent_device_name = 'Unknown: not an instance of a labscript device class'
        pstarkey:             else:
        pstarkey:                 parent_device_name = parent_device.name
        pstarkey:             raise LabscriptError('Error instantiating device %s. The parent (%s) must be an instance of ClockLine.'%(name, parent_device_name))
        spielman:         Device.__init__(self, name, parent_device, 'internal', **kwargs) # This 'internal' should perhaps be more descriptive?
        pstarkey:  
        pstarkey:   
        pstarkey: class ClockLine(Device):
        pstarkey:     description = 'Generic ClockLine'
        pstarkey:     allowed_children = [IntermediateDevice]
        pstarkey:     _clock_limit = None
        pstarkey:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, pseudoclock, connection, ramping_allowed = True, **kwargs):
        spielman:         
        pstarkey:         # TODO: Verify that connection is  valid connection of Pseudoclock.parent_device (the PseudoclockDevice)
        spielman:         Device.__init__(self, name, pseudoclock, connection, **kwargs)
        pstarkey:         self.ramping_allowed = ramping_allowed
        pstarkey:         
        pstarkey:     def add_device(self, device):
        pstarkey:         Device.add_device(self, device)
        pstarkey:         if hasattr(device, 'clock_limit') and (self._clock_limit is None or device.clock_limit < self.clock_limit):
        pstarkey:             self._clock_limit = device.clock_limit
        pstarkey:     
        pstarkey:     # define a property to make sure no children overwrite this value themselves
        pstarkey:     # The calculation of maximum clock_limit should be done by the add_device method above
        pstarkey:     @property
        pstarkey:     def clock_limit(self):
        pstarkey:         # If no child device has specified a clock limit
        pstarkey:         if self._clock_limit is None:
        pstarkey:             # return the Pseudoclock clock_limit
        pstarkey:             # TODO: Maybe raise an error instead?
        pstarkey:             #       Maybe all Intermediate devices should be required to have a clock_limit?
        pstarkey:             return self.parent_device.clock_limit
        pstarkey:         return self._clock_limit
        pstarkey: 
        pstarkey:         
        pstarkey: class Pseudoclock(Device):
        pstarkey:     description = 'Generic Pseudoclock'
        pstarkey:     allowed_children = [ClockLine]
        pstarkey:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, pseudoclock_device, connection, **kwargs):
        spielman: 
        spielman:         Device.__init__(self, name, pseudoclock_device, connection, **kwargs)
        pstarkey:         self.clock_limit = pseudoclock_device.clock_limit
        pstarkey:         self.clock_resolution = pseudoclock_device.clock_resolution
        pstarkey:         
        pstarkey:     def add_device(self, device):
        pstarkey:         Device.add_device(self, device)
        pstarkey:         #TODO: Maybe verify here that device.connection (the ClockLine connection) is a valid connection of the parent PseudoClockDevice
        pstarkey:         #      Also see the same comment in ClockLine.__init__
        pstarkey:         # if device.connection not in self.clock_lines:
        pstarkey:             # self.clock_lines[
        pstarkey: 
        pstarkey:     def collect_change_times(self, all_outputs, outputs_by_clockline):
        pstarkey:         """Asks all connected outputs for a list of times that they
        pstarkey:         change state. Takes the union of all of these times. Note
        pstarkey:         that at this point, a change from holding-a-constant-value
        pstarkey:         to ramping-through-values is considered a single state
        pstarkey:         change. The clocking times will be filled in later in the
        pstarkey:         expand_change_times function, and the ramp values filled in with
        pstarkey:         expand_timeseries."""
        pstarkey:         change_times = {}
        pstarkey:         all_change_times = []
        pstarkey:         ramps_by_clockline = {}
        pstarkey:         for clock_line, outputs in outputs_by_clockline.items():
        pstarkey:             change_times.setdefault(clock_line, [])
        pstarkey:             ramps_by_clockline.setdefault(clock_line, [])
        pstarkey:             for output in outputs:
        pstarkey:                 # print 'output name: %s'%output.name
        pstarkey:                 output_change_times = output.get_change_times()
        pstarkey:                 # print output_change_times
        pstarkey:                 change_times[clock_line].extend(output_change_times)
        pstarkey:                 all_change_times.extend(output_change_times)
        pstarkey:                 ramps_by_clockline[clock_line].extend(output.get_ramp_times())
        pstarkey:             
        pstarkey:             # print 'initial_change_times for %s: %s'%(clock_line.name,change_times[clock_line])
        pstarkey:         
        pstarkey:         # Change to a set and back to get rid of duplicates:
        pstarkey:         if not all_change_times:
        pstarkey:             all_change_times.append(0)
        pstarkey:         all_change_times.append(self.parent_device.stop_time)
        pstarkey:         # include trigger times in change_times, so that pseudoclocks always have an instruction immediately following a wait:
        pstarkey:         all_change_times.extend(self.parent_device.trigger_times)
        pstarkey:         
        pstarkey:         ####################################################################################################
        pstarkey:         # Find out whether any other clockline has a change time during a ramp on another clockline.       #
        pstarkey:         # If it does, we need to let the ramping clockline know it needs to break it's loop at that time   #
        pstarkey:         ####################################################################################################
        pstarkey:         # convert all_change_times to a numpy array
        pstarkey:         all_change_times_numpy = array(all_change_times)
        pstarkey:         
        pstarkey:         # quantise the all change times to the pseudoclock clock resolution
        pstarkey:         # all_change_times_numpy = (all_change_times_numpy/self.clock_resolution).round()*self.clock_resolution
        pstarkey:         all_change_times_numpy = self.quantise_to_pseudoclock(all_change_times_numpy)
        pstarkey:         
        pstarkey:         # Loop through each clockline
        pstarkey:         # print ramps_by_clockline
        pstarkey:         for clock_line, ramps in ramps_by_clockline.items():
        pstarkey:             # for each clockline, loop through the ramps on that clockline
        pstarkey:             for ramp_start_time, ramp_end_time in ramps:
        pstarkey:                 # for each ramp, check to see if there is a change time in all_change_times which intersects
        pstarkey:                 # with the ramp. If there is, add a change time into this clockline at that point
        pstarkey:                 indices = np.where((ramp_start_time < all_change_times_numpy) & (all_change_times_numpy < ramp_end_time))
        pstarkey:                 for idx in indices[0]:
        pstarkey:                     change_times[clock_line].append(all_change_times_numpy[idx])
        pstarkey:                 
        pstarkey:         # Get rid of duplicates:
        pstarkey:         all_change_times = list(set(all_change_times_numpy))
        pstarkey:         all_change_times.sort()  
        pstarkey:         
        pstarkey:         # Check that the pseudoclock can handle updates this fast
        pstarkey:         for i, t in enumerate(all_change_times[:-1]):
        pstarkey:             dt = all_change_times[i+1] - t
        pstarkey:             if dt < 1.0/self.clock_limit:
        pstarkey:                 raise LabscriptError('Commands have been issued to devices attached to %s at t= %s s and %s s. '%(self.name, str(t),str(all_change_times[i+1])) +
        pstarkey:                                      'This Pseudoclock cannot support update delays shorter than %s sec.'%(str(1.0/self.clock_limit)))
        pstarkey: 
        pstarkey:         ####################################################################################################
        pstarkey:         # For each clockline, make sure we have a change time for triggers, stop_time, t=0 and             #
        pstarkey:         # check that no change tiems are too close together                                                #
        pstarkey:         ####################################################################################################
        pstarkey:         for clock_line, change_time_list in change_times.items():
        pstarkey:             # include trigger times in change_times, so that pseudoclocks always have an instruction immediately following a wait:
        pstarkey:             change_time_list.extend(self.parent_device.trigger_times)
        pstarkey:             
        pstarkey:             # If the device has no children, we still need it to have a
        pstarkey:             # single instruction. So we'll add 0 as a change time:
        pstarkey:             if not change_time_list:
        pstarkey:                 change_time_list.append(0)
        pstarkey:             
        pstarkey:             # quantise the all change times to the pseudoclock clock resolution
        pstarkey:             # change_time_list = (array(change_time_list)/self.clock_resolution).round()*self.clock_resolution
        pstarkey:             change_time_list = self.quantise_to_pseudoclock(change_time_list)
        pstarkey:             
        pstarkey:             # Get rid of duplicates if trigger times were already in the list:
        pstarkey:             change_time_list = list(set(change_time_list))
        pstarkey:             change_time_list.sort()
        pstarkey:             
        pstarkey:             # Check that no two instructions are too close together:
        pstarkey:             for i, t in enumerate(change_time_list[:-1]):
        pstarkey:                 dt = change_time_list[i+1] - t
        pstarkey:                 if dt < 1.0/clock_line.clock_limit:
        pstarkey:                     raise LabscriptError('Commands have been issued to devices attached to %s at t= %s s and %s s. '%(self.name, str(t),str(change_time_list[i+1])) +
        pstarkey:                                          'One or more connected devices on ClockLine %s cannot support update delays shorter than %s sec.'%(clock_line.name, str(1.0/clock_line.clock_limit)))
        pstarkey:             
        pstarkey:             # Also add the stop time as as change time. First check that it isn't too close to the time of the last instruction:
        cbilling:             if not self.parent_device.stop_time in change_time_list:
        cbilling:                 dt = self.parent_device.stop_time - change_time_list[-1]
        cbilling:                 if abs(dt) < 1.0/clock_line.clock_limit:
        cbilling:                     raise LabscriptError('The stop time of the experiment is t= %s s, but the last instruction for a device attached to %s is at t= %s s. '%( str(self.stop_time), self.name, str(change_time_list[-1])) +
        cbilling:                                          'One or more connected devices cannot support update delays shorter than %s sec. Please set the stop_time a bit later.'%str(1.0/clock_line.clock_limit))
        cbilling:                 
        cbilling:                 change_time_list.append(self.parent_device.stop_time)
        pstarkey: 
        pstarkey:             # Sort change times so self.stop_time will be in the middle
        pstarkey:             # somewhere if it is prior to the last actual instruction. Whilst
        pstarkey:             # this means the user has set stop_time in error, not catching
        pstarkey:             # the error here allows it to be caught later by the specific
        pstarkey:             # device that has more instructions after self.stop_time. Thus
        pstarkey:             # we provide the user with sligtly more detailed error info.
        pstarkey:             change_time_list.sort()
        pstarkey:             
        pstarkey:             # because we made the list into a set and back to a list, it is now a different object
        pstarkey:             # so modifying it won't update the list in the dictionary.
        pstarkey:             # So store the updated list in the dictionary
        pstarkey:             change_times[clock_line] = change_time_list
        pstarkey:         return all_change_times, change_times
        pstarkey:     
        pstarkey:     def expand_change_times(self, all_change_times, change_times, outputs_by_clockline):
        pstarkey:         """For each time interval delimited by change_times, constructs
        pstarkey:         an array of times at which the clock for this device needs to
        pstarkey:         tick. If the interval has all outputs having constant values,
        pstarkey:         then only the start time is stored.  If one or more outputs are
        pstarkey:         ramping, then the clock ticks at the maximum clock rate requested
        pstarkey:         by any of the outputs. Also produces a higher level description
        pstarkey:         of the clocking; self.clock. This list contains the information
        pstarkey:         that facilitates programming a pseudo clock using loops."""
        pstarkey:         all_times = {}
        pstarkey:         clocks_in_use = []
        pstarkey:         # for output in outputs:
        pstarkey:             # if output.parent_device.clock_type != 'slow clock':            
        pstarkey:                 # if output.parent_device.clock_type not in all_times:
        pstarkey:                     # all_times[output.parent_device.clock_type] = []
        pstarkey:                 # if output.parent_device.clock_type not in clocks_in_use:
        pstarkey:                     # clocks_in_use.append(output.parent_device.clock_type)
        pstarkey:         
        pstarkey:         clock = []
        pstarkey:         clock_line_current_indices = {}
        pstarkey:         for clock_line, outputs in outputs_by_clockline.items():
        pstarkey:             clock_line_current_indices[clock_line] = 0
        pstarkey:             all_times[clock_line] = []
        pstarkey:         
        pstarkey:         # iterate over all change times
        pstarkey:         # for clock_line, times in change_times.items():
        pstarkey:             # print '%s: %s'%(clock_line.name, times)
        pstarkey:         for i, time in enumerate(all_change_times):
        pstarkey:             if time in self.parent_device.trigger_times[1:]:
        pstarkey:                 # A wait instruction:
        pstarkey:                 clock.append('WAIT')
        pstarkey:                 
        pstarkey:             # list of enabled clocks
        pstarkey:             enabled_clocks = []
        pstarkey:             enabled_looping_clocks = []
        pstarkey:             # enabled_non_looping_clocks = []
        pstarkey:             
        pstarkey:             # update clock_line indices
        pstarkey:             for clock_line in clock_line_current_indices:
        pstarkey:                 try:
        pstarkey:                     while change_times[clock_line][clock_line_current_indices[clock_line]] < time:
        pstarkey:                         clock_line_current_indices[clock_line] += 1
        pstarkey:                 except IndexError:
        pstarkey:                     # Fix the index to the last one
        pstarkey:                     clock_line_current_indices[clock_line] = len(change_times[clock_line]) - 1
        pstarkey:                     # print a warning
        pstarkey:                     message = ''.join(['WARNING: ClockLine %s has it\'s last change time at t=%.15f but another ClockLine has a change time at t=%.15f. '%(clock_line.name, change_times[clock_line][-1], time), 
        pstarkey:                               'This should never happen, as the last change time should always be the time passed to stop(). ', 
        pstarkey:                               'Perhaps you have an instruction after the stop time of the experiment?'])
        pstarkey:                     sys.stderr.write(message+'\n')
        pstarkey:                     
        pstarkey:                 # Let's work out which clock_lines are enabled for this instruction
        pstarkey:                 if time == change_times[clock_line][clock_line_current_indices[clock_line]]:
        pstarkey:                     enabled_clocks.append(clock_line)
        pstarkey:             
        pstarkey:             # what's the fastest clock rate?
        pstarkey:             maxrate = 0
        pstarkey:             local_clock_limit = self.clock_limit # the Pseudoclock clock limit
        pstarkey:             for clock_line in enabled_clocks:
        pstarkey:                 for output in outputs_by_clockline[clock_line]:
        pstarkey:                     # Check if output is sweeping and has highest clock rate
        pstarkey:                     # so far. If so, store its clock rate to max_rate:
        pstarkey:                     if hasattr(output,'timeseries') and isinstance(output.timeseries[clock_line_current_indices[clock_line]],dict):
        pstarkey:                         if clock_line not in enabled_looping_clocks:
        pstarkey:                             enabled_looping_clocks.append(clock_line)
        pstarkey:                                 
        pstarkey:                         if output.timeseries[clock_line_current_indices[clock_line]]['clock rate'] > maxrate:
        pstarkey:                             # It does have the highest clock rate? Then store that rate to max_rate:
        pstarkey:                             maxrate = output.timeseries[clock_line_current_indices[clock_line]]['clock rate']
        pstarkey:                 
        pstarkey:                         # only check this for ramping clock_lines
        pstarkey:                         # non-ramping clock-lines have already had the clock_limit checked within collect_change_times()
        pstarkey:                         if local_clock_limit > clock_line.clock_limit:
        pstarkey:                             local_clock_limit = clock_line.clock_limit
        pstarkey:                         
        pstarkey:             # find non-looping clocks
        pstarkey:             # for clock_line in enabled_clocks:
        pstarkey:                 # if clock_line not in enabled_looping_clocks:
        pstarkey:                     # enabled_non_looping_clocks.append(clock_line)
        pstarkey:             
        pstarkey:             if maxrate:
        pstarkey:                 # round to the nearest clock rate that the pseudoclock can actually support:
        pstarkey:                 period = 1/maxrate
        pstarkey:                 quantised_period = period/self.clock_resolution
        pstarkey:                 quantised_period = round(quantised_period)
        pstarkey:                 period = quantised_period*self.clock_resolution
        pstarkey:                 maxrate = 1/period
        pstarkey:             if maxrate > local_clock_limit:
        pstarkey:                 raise LabscriptError('At t = %s sec, a clock rate of %s Hz was requested. '%(str(time),str(maxrate)) + 
        pstarkey:                                     'One or more devices connected to %s cannot support clock rates higher than %sHz.'%(str(self.name),str(local_clock_limit)))
        pstarkey:                 
        pstarkey:             if maxrate:
        pstarkey:                 # If there was ramping at this timestep, how many clock ticks fit before the next instruction?
        pstarkey:                 n_ticks, remainder = divmod((all_change_times[i+1] - time)*maxrate,1)
        pstarkey:                 n_ticks = int(n_ticks)
        pstarkey:                 # Can we squeeze the final clock cycle in at the end?
        pstarkey:                 if remainder and remainder/float(maxrate) >= 1/float(local_clock_limit):
        pstarkey:                     # Yes we can. Clock speed will be as
        pstarkey:                     # requested. Otherwise the final clock cycle will
        pstarkey:                     # be too long, by the fraction 'remainder'.
        pstarkey:                     n_ticks += 1
        pstarkey:                 duration = n_ticks/float(maxrate) # avoiding integer division
        pstarkey:                 ticks = linspace(time,time + duration,n_ticks,endpoint=False)
        pstarkey:                 
        pstarkey:                 for clock_line in enabled_clocks:
        pstarkey:                     if clock_line in enabled_looping_clocks:
        pstarkey:                         all_times[clock_line].append(ticks)
        pstarkey:                     else:
        pstarkey:                         all_times[clock_line].append(time)
        pstarkey:                 
        pstarkey:                 if n_ticks > 1:
        pstarkey:                     # If n_ticks is only one, then this step doesn't do
        pstarkey:                     # anything, it has reps=0. So we should only include
        pstarkey:                     # it if n_ticks > 1.
        pstarkey:                     if n_ticks > 2:
        pstarkey:                         #If there is more than one clock tick here,
        pstarkey:                         #then we split the ramp into an initial clock
        pstarkey:                         #tick, during which the slow clock ticks, and
        pstarkey:                         #the rest of the ramping time, during which the
        pstarkey:                         #slow clock does not tick.
        pstarkey:                         clock.append({'start': time, 'reps': 1, 'step': 1/float(maxrate), 'enabled_clocks':enabled_clocks})
        pstarkey:                         clock.append({'start': time + 1/float(maxrate), 'reps': n_ticks-2, 'step': 1/float(maxrate), 'enabled_clocks':enabled_looping_clocks})
        pstarkey:                     else:
        pstarkey:                         clock.append({'start': time, 'reps': n_ticks-1, 'step': 1/float(maxrate), 'enabled_clocks':enabled_clocks})
        pstarkey:                         
        pstarkey:                     # clock.append({'start': time, 'reps': n_ticks-1, 'step': 1/float(maxrate), 'enabled_clocks':enabled_clocks})
        pstarkey:                 # The last clock tick has a different duration depending on the next step. 
        pstarkey:                 clock.append({'start': ticks[-1], 'reps': 1, 'step': all_change_times[i+1] - ticks[-1], 'enabled_clocks':enabled_clocks if n_ticks == 1 else enabled_looping_clocks})
        pstarkey:             else:
        pstarkey:                 for clock_line in enabled_clocks:
        pstarkey:                     all_times[clock_line].append(time)
        pstarkey:                     
        pstarkey:                 try: 
        pstarkey:                     # If there was no ramping, here is a single clock tick:
        pstarkey:                     clock.append({'start': time, 'reps': 1, 'step': all_change_times[i+1] - time, 'enabled_clocks':enabled_clocks})
        pstarkey:                 except IndexError:
        pstarkey:                     if i != len(all_change_times) - 1:
        pstarkey:                         raise
        pstarkey:                     if self.parent_device.stop_time > time:
        pstarkey:                         # There is no next instruction. Hold the last clock
        pstarkey:                         # tick until self.parent_device.stop_time.
        pstarkey:                         raise Exception('This shouldn\'t happen -- stop_time should always be equal to the time of the last instruction. Please report a bug.')
        pstarkey:                         # I commented this out because it is after a raised exception so never ran.... - Phil
        pstarkey:                         # clock.append({'start': time, 'reps': 1, 'step': self.parent_device.stop_time - time,'slow_clock_tick':True}) 
        pstarkey:                     # Error if self.parent_device.stop_time has been set to less
        pstarkey:                     # than the time of the last instruction:
        cbilling:                     elif self.parent_device.stop_time < time:
        pstarkey:                         raise LabscriptError('%s %s has more instructions (at t=%.15f) after the experiment\'s stop time (t=%.15f).'%(self.description,self.name, time, self.parent_device.stop_time))
        pstarkey:                     # If self.parent_device.stop_time is the same as the time of the last
        pstarkey:                     # instruction, then we'll get the last instruction
        pstarkey:                     # out still, so that the total number of clock
        pstarkey:                     # ticks matches the number of data points in the
        pstarkey:                     # Output.raw_output arrays. We'll make this last
        pstarkey:                     # cycle be at ten times the minimum step duration.
        pstarkey:                     else:
        pstarkey:                         # find the slowest clock_limit
        pstarkey:                         enabled_clocks = []
        pstarkey:                         local_clock_limit = 1.0/self.clock_resolution # the Pseudoclock clock limit
        pstarkey:                         for clock_line, outputs in outputs_by_clockline.items():
        pstarkey:                             if local_clock_limit > clock_line.clock_limit:
        pstarkey:                                 local_clock_limit = clock_line.clock_limit
        pstarkey:                             enabled_clocks.append(clock_line)
        pstarkey:                         clock.append({'start': time, 'reps': 1, 'step': 10.0/self.clock_limit, 'enabled_clocks':enabled_clocks})
        pstarkey:         # for row in clock:
        pstarkey:             # print row
        pstarkey:         return all_times, clock
        pstarkey:     
        pstarkey:     def get_outputs_by_clockline(self):
     janwerkmann:         outputs_by_clockline = {}
     janwerkmann:         for clock_line in self.child_devices:
     janwerkmann:             if isinstance(clock_line, ClockLine):
     janwerkmann:                 outputs_by_clockline[clock_line] = []
     janwerkmann: 
        pstarkey:         all_outputs = self.get_all_outputs()
        pstarkey:         for output in all_outputs:
        pstarkey:             # TODO: Make this a bit more robust (can we assume things always have this hierarchy?)
        pstarkey:             clock_line = output.parent_clock_line
        pstarkey:             assert clock_line.parent_device == self
        pstarkey:             outputs_by_clockline[clock_line].append(output)
     janwerkmann: 
        pstarkey:         return all_outputs, outputs_by_clockline
             jan: 
        pstarkey:     def generate_clock(self):
        pstarkey:         all_outputs, outputs_by_clockline = self.get_outputs_by_clockline()
        pstarkey:         
        pstarkey:         # Get change_times for all outputs, and also grouped by clockline
        pstarkey:         all_change_times, change_times = self.collect_change_times(all_outputs, outputs_by_clockline)
        pstarkey:                
        pstarkey:         # for each clock line
        pstarkey:         for clock_line, clock_line_change_times in change_times.items():
        pstarkey:             # and for each output on the clockline
        pstarkey:             for output in outputs_by_clockline[clock_line]:
        pstarkey:                 # call make_timeseries to expand the list of instructions for each change_time on this clock line
        pstarkey:                 output.make_timeseries(clock_line_change_times)
        pstarkey: 
        pstarkey:         # now generate the clock meta data for the Pseudoclock
        pstarkey:         # also generate everytime point each clock line will tick (expand ramps)
        pstarkey:         all_times, self.clock = self.expand_change_times(all_change_times, change_times, outputs_by_clockline)
        pstarkey:         
        pstarkey:         # for each clockline
        pstarkey:         for clock_line, outputs in outputs_by_clockline.items():
        pstarkey:             # and for each output
        pstarkey:             for output in outputs:
        pstarkey:                 # evaluate the output at each time point the clock line will tick at
        pstarkey:                 output.expand_timeseries(all_times[clock_line])
        pstarkey:                 
        pstarkey:         # TODO: is this needed? Let's say no...
        pstarkey:         # self.all_change_times = fastflatten(all_change_times, float)
        pstarkey:         
        pstarkey:         # Flatten the clock line times for use by the child devices for writing instruction tables
        pstarkey:         # TODO: (if this needed or was it just for runviewer meta data that we don't need anymore?)
        pstarkey:         self.times = {}
        pstarkey:         for clock_line, time_array in all_times.items():
        pstarkey:             self.times[clock_line] = fastflatten(time_array,float)
        pstarkey:         
        pstarkey:     def generate_code(self, hdf5_file):
        pstarkey:         self.generate_clock()
        pstarkey:         Device.generate_code(self, hdf5_file)
        pstarkey:         
        cbilling: 
        cbilling: class TriggerableDevice(Device):
        cbilling:     trigger_edge_type = 'rising'
        cbilling:     # A class devices should inherit if they do
        cbilling:     # not require a pseudoclock, but do require a trigger.
        cbilling:     # This enables them to have a Trigger divice as a parent
        spielman:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, parent_device, connection, parentless=False, **kwargs):
        spielman: 
        cbilling:         if None in [parent_device, connection] and not parentless:
        cbilling:             raise LabscriptError('No parent specified. If this device does not require a parent, set parentless=True')
        cbilling:         if isinstance(parent_device, Trigger):
        cbilling:             if self.trigger_edge_type != parent_device.trigger_edge_type:
        cbilling:                 raise LabscriptError('Trigger edge type for %s is \'%s\', ' % (name, self.trigger_edge_type) + 
        cbilling:                                       'but existing Trigger object %s ' % parent_device.name +
        cbilling:                                       'has edge type \'%s\'' % parent_device.trigger_edge_type)
        cbilling:             self.trigger_device = parent_device
        cbilling:         elif parent_device is not None:
        cbilling:             # Instantiate a trigger object to be our parent:
        cbilling:             self.trigger_device = Trigger(name + '_trigger', parent_device, connection, self.trigger_edge_type)
        cbilling:             parent_device = self.trigger_device
        cbilling:             connection = 'trigger'
        spielman:             
        spielman:         Device.__init__(self, name, parent_device, connection, **kwargs)
        cbilling:     
        cbilling:     
        cbilling: class PseudoclockDevice(TriggerableDevice):
        pstarkey:     description = 'Generic Pseudoclock Device'
        pstarkey:     allowed_children = [Pseudoclock]
        pstarkey:     trigger_edge_type = 'rising'
        pstarkey:     # How long after a trigger the next instruction is actually output:
        pstarkey:     trigger_delay = 0
        pstarkey:     # How long a trigger line must remain high/low in order to be detected:
        pstarkey:     trigger_minimum_duration = 0 
        pstarkey:     # How long after the start of a wait instruction the device is actually capable of resuming:
        pstarkey:     wait_delay = 0
        pstarkey:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, trigger_device=None, trigger_connection=None, **kwargs):
        spielman: 
        pstarkey:         if trigger_device is None:
        pstarkey:             for device in compiler.inventory:
        cbilling:                 if isinstance(device, PseudoclockDevice) and device.is_master_pseudoclock:
        pstarkey:                     raise LabscriptError('There is already a master pseudoclock device: %s.'%device.name + 
        pstarkey:                                          'There cannot be multiple master pseudoclock devices - please provide a trigger_device for one of them.')
        spielman:             TriggerableDevice.__init__(self, name, parent_device=None, connection=None, parentless=True, **kwargs)
        pstarkey:         else:
        cbilling:             # The parent device declared was a digital output channel: the following will
        cbilling:             # automatically instantiate a Trigger for it and set it as self.trigger_device:
        spielman:             TriggerableDevice.__init__(self, name, parent_device=trigger_device, connection=trigger_connection, **kwargs)
        pstarkey:             # Ensure that the parent pseudoclock device is, in fact, the master pseudoclock device.
        cbilling:             if not self.trigger_device.pseudoclock_device.is_master_pseudoclock:
        pstarkey:                 raise LabscriptError('All secondary pseudoclock devices must be triggered by a device being clocked by the master pseudoclock device.' +
        pstarkey:                                      'Pseudoclocks triggering each other in series is not supported.')
        pstarkey:         self.trigger_times = []
        pstarkey:         self.wait_times = []
        pstarkey:         self.initial_trigger_time = 0
        pstarkey:     
        pstarkey:     @property    
        pstarkey:     def is_master_pseudoclock(self):
        pstarkey:         return self.parent_device is None
        pstarkey:     
        pstarkey:     def set_initial_trigger_time(self, t):
        shjohnst:         t = round(t,10)
        pstarkey:         if compiler.start_called:
        pstarkey:             raise LabscriptError('Initial trigger times must be set prior to calling start()')
        pstarkey:         if self.is_master_pseudoclock:
        pstarkey:             raise LabscriptError('Initial trigger time of master clock is always zero, it cannot be changed.')
        pstarkey:         else:
        pstarkey:             self.initial_trigger_time = t
        pstarkey:             
        pstarkey:     def trigger(self, t, duration, wait_delay = 0):
        pstarkey:         """Ask the trigger device to produce a digital pulse of a given duration to trigger this pseudoclock"""
          rander:         if type(t) in [str, bytes] and t == 'initial':
        pstarkey:             t = self.initial_trigger_time
        pstarkey:         t = round(t,10)
        pstarkey:         if self.is_master_pseudoclock:
        pstarkey:             if compiler.wait_monitor is not None:
        pstarkey:                 # Make the wait monitor pulse to signify starting or resumption of the experiment:
        pstarkey:                 compiler.wait_monitor.trigger(t, duration)
        pstarkey:             elif t != self.initial_trigger_time:
        pstarkey:                 raise LabscriptError("You cannot use waits in unless you have a wait monitor." +
        pstarkey:                                      "Please instantiate a WaitMonitor in your connection table.")
        pstarkey:             self.trigger_times.append(t)
        pstarkey:         else:
        pstarkey:             self.trigger_device.trigger(t, duration)
        pstarkey:             self.trigger_times.append(round(t + wait_delay,10))
        pstarkey:             
        pstarkey:     def do_checks(self, outputs):
        cbilling:         """Basic error checking to ensure the user's instructions make sense"""
        pstarkey:         for output in outputs:
        pstarkey:             output.do_checks(self.trigger_times)
        pstarkey:             
        pstarkey:     def offset_instructions_from_trigger(self, outputs):
        pstarkey:         for output in outputs:
        pstarkey:             output.offset_instructions_from_trigger(self.trigger_times)
        pstarkey:         
        pstarkey:         if not self.is_master_pseudoclock:
        pstarkey:             # Store the unmodified initial_trigger_time
        pstarkey:             initial_trigger_time = self.trigger_times[0]
        pstarkey:             # Adjust the stop time relative to the last trigger time
        shjohnst:             self.stop_time = round(self.stop_time - initial_trigger_time - self.trigger_delay * len(self.trigger_times),10)
        pstarkey:             
        pstarkey:             # Modify the trigger times themselves so that we insert wait instructions at the right times:
        shjohnst:             self.trigger_times = [round(t - initial_trigger_time - i*self.trigger_delay,10) for i, t in enumerate(self.trigger_times)]
        pstarkey:         
          rander:         # quantise the trigger times and stop time to the pseudoclock clock resolution
          rander:         self.trigger_times = self.quantise_to_pseudoclock(self.trigger_times)
        pstarkey:         self.stop_time = self.quantise_to_pseudoclock(self.stop_time)
        pstarkey:                             
        pstarkey:     def generate_code(self, hdf5_file):
        pstarkey:         outputs = self.get_all_outputs()
        pstarkey:         self.do_checks(outputs)
        pstarkey:         self.offset_instructions_from_trigger(outputs)
        pstarkey:         Device.generate_code(self, hdf5_file)
        pstarkey:         
        pstarkey:     
        pstarkey: class Output(Device):
        pstarkey:     description = 'generic output'
        pstarkey:     allowed_states = {}
        pstarkey:     dtype = float64
        pstarkey:     scale_factor = 1
        spielman:     
        spielman:     @set_passed_properties(property_names = {})
     janwerkmann:     def __init__(self,name,parent_device,connection,limits = None,unit_conversion_class = None, unit_conversion_parameters = None, default_value=None, **kwargs):
        cbilling:         Device.__init__(self,name,parent_device,connection, **kwargs)
        spielman: 
        pstarkey:         self.instructions = {}
        pstarkey:         self.ramp_limits = [] # For checking ramps don't overlap
     janwerkmann:         if default_value is not None:
     janwerkmann:             self.default_value = default_value
        pstarkey:         if not unit_conversion_parameters:
        pstarkey:             unit_conversion_parameters = {}
        pstarkey:         self.unit_conversion_class = unit_conversion_class
        cbilling:         self.set_properties(unit_conversion_parameters,
     janwerkmann:                             {'unit_conversion_parameters': list(unit_conversion_parameters.keys())})
     janwerkmann: 
        pstarkey:         # Instantiate the calibration
        pstarkey:         if unit_conversion_class is not None:
        pstarkey:             self.calibration = unit_conversion_class(unit_conversion_parameters)
        pstarkey:             # Validate the calibration class
        pstarkey:             for units in self.calibration.derived_units:
        pstarkey:                 #Does the conversion to base units function exist for each defined unit type?
        pstarkey:                 if not hasattr(self.calibration,units+"_to_base"):
        pstarkey:                     raise LabscriptError('The function "%s_to_base" does not exist within the calibration "%s" used in output "%s"'%(units,self.unit_conversion_class,self.name))
        pstarkey:                 #Does the conversion to base units function exist for each defined unit type?
        pstarkey:                 if not hasattr(self.calibration,units+"_from_base"):
        pstarkey:                     raise LabscriptError('The function "%s_from_base" does not exist within the calibration "%s" used in output "%s"'%(units,self.unit_conversion_class,self.name))
        pstarkey:         
        pstarkey:         # If limits exist, check they are valid
        pstarkey:         # Here we specifically differentiate "None" from False as we will later have a conditional which relies on
        pstarkey:         # self.limits being either a correct tuple, or "None"
        pstarkey:         if limits is not None:
        pstarkey:             if not isinstance(limits,tuple) or len(limits) is not 2:
        pstarkey:                 raise LabscriptError('The limits for "%s" must be tuple of length 2. Eg. limits=(1,2)'%(self.name))
        pstarkey:             if limits[0] > limits[1]:
        pstarkey:                 raise LabscriptError('The first element of the tuple must be lower than the second element. Eg limits=(1,2), NOT limits=(2,1)')
        pstarkey:         # Save limits even if they are None        
        pstarkey:         self.limits = limits
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def clock_limit(self):
        pstarkey:         parent = self.parent_clock_line
        pstarkey:         return parent.clock_limit
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def trigger_delay(self):
        pstarkey:         """The earliest time output can be commanded from this device after a trigger.
        pstarkey:         This is nonzeo on secondary pseudoclocks due to triggering delays."""
        pstarkey:         parent = self.pseudoclock_device
        pstarkey:         if parent.is_master_pseudoclock:
        pstarkey:             return 0
        pstarkey:         else:
        pstarkey:             return parent.trigger_delay
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def wait_delay(self):
        pstarkey:         """The earliest time output can be commanded from this device after a wait.
        pstarkey:         This is nonzeo on secondary pseudoclocks due to triggering delays and the fact
        pstarkey:         that the master clock doesn't provide a resume trigger to secondary clocks until
        pstarkey:         a minimum time has elapsed: compiler.wait_delay. This is so that if a wait is 
        pstarkey:         extremely short, the child clock is actually ready for the trigger.
        pstarkey:         """
        pstarkey:         delay = compiler.wait_delay if self.pseudoclock_device.is_master_pseudoclock else 0
        pstarkey:         return self.trigger_delay + delay
        pstarkey:             
        pstarkey:     def apply_calibration(self,value,units):
        pstarkey:         # Is a calibration in use?
        pstarkey:         if self.unit_conversion_class is None:
        pstarkey:             raise LabscriptError('You can not specify the units in an instruction for output "%s" as it does not have a calibration associated with it'%(self.name))
        pstarkey:                     
        pstarkey:         # Does a calibration exist for the units specified?
        pstarkey:         if units not in self.calibration.derived_units:
        pstarkey:             raise LabscriptError('The units "%s" does not exist within the calibration "%s" used in output "%s"'%(units,self.unit_conversion_class,self.name))
        pstarkey:                     
        pstarkey:         # Return the calibrated value
        pstarkey:         return getattr(self.calibration,units+"_to_base")(value)
        pstarkey:         
        pstarkey:     def instruction_to_string(self,instruction):
        pstarkey:         """gets a human readable description of an instruction"""
        pstarkey:         if isinstance(instruction,dict):
        pstarkey:             return instruction['description']
        pstarkey:         elif self.allowed_states:
        pstarkey:             return str(self.allowed_states[instruction])
        pstarkey:         else:
        pstarkey:             return str(instruction)
        pstarkey: 
        pstarkey:     def add_instruction(self,time,instruction,units=None):
        pstarkey:         if not compiler.start_called:
        pstarkey:             raise LabscriptError('Cannot add instructions prior to calling start()')
        pstarkey:         # round to the nearest 0.1 nanoseconds, to prevent floating point
        pstarkey:         # rounding errors from breaking our equality checks later on.
        pstarkey:         time = round(time,10)
        pstarkey:         # Also round end time of ramps to the nearest 0.1 ns:
        pstarkey:         if isinstance(instruction,dict):
        pstarkey:             instruction['end time'] = round(instruction['end time'],10)
        pstarkey:             instruction['initial time'] = round(instruction['initial time'],10)
        pstarkey:         # Check that time is not negative or too soon after t=0:
        pstarkey:         if time < self.t0:
        pstarkey:             err = ' '.join([self.description, self.name, 'has an instruction at t=%ss,'%str(time),
        pstarkey:                  'Due to the delay in triggering its pseudoclock device, the earliest output possible is at t=%s.'%str(self.t0)])
        pstarkey:             raise LabscriptError(err)
        pstarkey:         # Check that this doesn't collide with previous instructions:
        pstarkey:         if time in self.instructions.keys():
        pstarkey:             if not config.suppress_all_warnings:
        pstarkey:                 message = ' '.join(['WARNING: State of', self.description, self.name, 'at t=%ss'%str(time),
        pstarkey:                           'has already been set to %s.'%self.instruction_to_string(self.instructions[time]),
        pstarkey:                           'Overwriting to %s. (note: all values in base units where relevant)'%self.instruction_to_string(self.apply_calibration(instruction,units) if units and not isinstance(instruction,dict) else instruction)])
        pstarkey:                 sys.stderr.write(message+'\n')
        pstarkey:         # Check that ramps don't collide
        pstarkey:         if isinstance(instruction,dict):
        pstarkey:             # No ramps allowed if this output is on a slow clock:
        pstarkey:             if not self.parent_clock_line.ramping_allowed:
        pstarkey:                 raise LabscriptError('%s %s is on clockline that does not support ramping. '%(self.description, self.name) + 
        pstarkey:                                      'It cannot have a function ramp as an instruction.')
        pstarkey:             for start, end in self.ramp_limits:
        pstarkey:                 if start < time < end or start < instruction['end time'] < end:
        pstarkey:                     err = ' '.join(['State of', self.description, self.name, 'from t = %ss to %ss'%(str(start),str(end)),
        pstarkey:                         'has already been set to %s.'%self.instruction_to_string(self.instructions[start]),
        pstarkey:                         'Cannot set to %s from t = %ss to %ss.'%(self.instruction_to_string(instruction),str(time),str(instruction['end time']))])
        pstarkey:                     raise LabscriptError(err)
        pstarkey:             self.ramp_limits.append((time,instruction['end time']))
        pstarkey:             # Check that start time is before end time:
        pstarkey:             if time > instruction['end time']:
        pstarkey:                 raise LabscriptError('%s %s has been passed a function ramp %s with a negative duration.'%(self.description, self.name, self.instruction_to_string(instruction)))
        pstarkey:             if instruction['clock rate'] == 0:
        pstarkey:                 raise LabscriptError('A nonzero sample rate is required.')
        pstarkey:             # Else we have a "constant", single valued instruction
        pstarkey:         else:
        pstarkey:             # If we have units specified, convert the value
        pstarkey:             if units is not None:
        pstarkey:                 # Apply the unit calibration now
        pstarkey:                 instruction = self.apply_calibration(instruction,units)
        pstarkey:             # if we have limits, check the value is valid
        pstarkey:             if self.limits:
            matt:                 if (instruction < self.limits[0]) or (instruction > self.limits[1]):
        cbilling:                     raise LabscriptError('You cannot program the value %s (base units) to %s as it falls outside the limits (%d to %d)'%(str(instruction), self.name, self.limits[0], self.limits[1]))
        pstarkey:         self.instructions[time] = instruction
        pstarkey:     
        pstarkey:     def do_checks(self, trigger_times):
        cbilling:         """Basic error checking to ensure the user's instructions make sense"""
        pstarkey:         # Check if there are no instructions. Generate a warning and insert an
        pstarkey:         # instruction telling the output to remain at its default value.
        pstarkey:         if not self.instructions:
        pstarkey:             if not config.suppress_mild_warnings and not config.suppress_all_warnings:
        pstarkey:                 sys.stderr.write(' '.join(['WARNING:', self.name, 'has no instructions. It will be set to %s for all time.\n'%self.instruction_to_string(self.default_value)]))
        pstarkey:             self.add_instruction(self.t0, self.default_value)  
        pstarkey:         # Check if there are no instructions at the initial time. Generate a warning and insert an
        pstarkey:         # instruction telling the output to start at its default value.
        pstarkey:         if self.t0 not in self.instructions.keys():
        pstarkey:             if not config.suppress_mild_warnings and not config.suppress_all_warnings:
        pstarkey:                sys.stderr.write(' '.join(['WARNING:', self.name, 'has no initial instruction. It will initially be set to %s.\n'%self.instruction_to_string(self.default_value)]))
        pstarkey:             self.add_instruction(self.t0, self.default_value) 
        pstarkey:         # Check that ramps have instructions following them.
        pstarkey:         # If they don't, insert an instruction telling them to hold their final value.
     janwerkmann:         for instruction in list(self.instructions.values()):
        pstarkey:             if isinstance(instruction, dict) and instruction['end time'] not in self.instructions.keys():
        pstarkey:                 self.add_instruction(instruction['end time'], instruction['function'](instruction['end time']-instruction['initial time']), instruction['units'])
        pstarkey:         # Checks for trigger times:
        pstarkey:         for trigger_time in trigger_times:
        pstarkey:             for t, instruction in self.instructions.items():
        pstarkey:                 # Check no ramps are happening at the trigger time:
        pstarkey:                 if isinstance(instruction, dict) and instruction['initial time'] < trigger_time and instruction['end time'] > trigger_time:
        pstarkey:                     err = (' %s %s has a ramp %s from t = %s to %s. ' % (self.description, 
        pstarkey:                             self.name, instruction['description'], str(instruction['initial time']), str(instruction['end time'])) +
        pstarkey:                            'This overlaps with a trigger at t=%s, and so cannot be performed.' % str(trigger_time))
        pstarkey:                     raise LabscriptError(err)
        pstarkey:                 # Check that nothing is happening during the delay time after the trigger:
        cbilling:                 if round(trigger_time,10) < round(t,10) < round(trigger_time + self.trigger_delay, 10):
        pstarkey:                     err = (' %s %s has an instruction at t = %s. ' % (self.description, self.name, str(t)) + 
        pstarkey:                            'This is too soon after a trigger at t=%s, '%str(trigger_time) + 
        pstarkey:                            'the earliest output possible after this trigger is at t=%s'%str(trigger_time + self.trigger_delay))
        pstarkey:                     raise LabscriptError(err)
        pstarkey:                 # Check that there are no instructions too soon before the trigger:
        pstarkey:                 if 0 < trigger_time - t < max(self.clock_limit, compiler.wait_delay):
        pstarkey:                     err = (' %s %s has an instruction at t = %s. ' % (self.description, self.name, str(t)) + 
        pstarkey:                            'This is too soon before a trigger at t=%s, '%str(trigger_time) + 
        pstarkey:                            'the latest output possible before this trigger is at t=%s'%str(trigger_time - max(self.clock_limit, compiler.wait_delay)))
        pstarkey:                            
        pstarkey:     def offset_instructions_from_trigger(self, trigger_times):
        pstarkey:         """Subtracts self.trigger_delay from all instructions at or after each trigger_time"""
        pstarkey:         offset_instructions = {}
        pstarkey:         for t, instruction in self.instructions.items():
        pstarkey:             # How much of a delay is there for this instruction? That depends how many triggers there are prior to it:
        pstarkey:             n_triggers_prior = len([time for time in trigger_times if time < t])
        pstarkey:             # The cumulative offset at this point in time:
        pstarkey:             offset = self.trigger_delay * n_triggers_prior + trigger_times[0]
        shjohnst:             offset = round(offset,10)
        pstarkey:             if isinstance(instruction,dict):
        pstarkey:                 offset_instruction = instruction.copy()
        pstarkey:                 offset_instruction['end time'] = self.quantise_to_pseudoclock(round(instruction['end time'] - offset,10))
        pstarkey:                 offset_instruction['initial time'] = self.quantise_to_pseudoclock(round(instruction['initial time'] - offset,10))
        pstarkey:             else:
        pstarkey:                 offset_instruction = instruction
        pstarkey:                 
        pstarkey:             offset_instructions[self.quantise_to_pseudoclock(round(t - offset,10))] = offset_instruction
        pstarkey:         self.instructions = offset_instructions
        pstarkey:             
        pstarkey:         # offset each of the ramp_limits for use in the calculation within Pseudoclock/ClockLine
        pstarkey:         # so that the times in list are consistent with the ones in self.instructions
        pstarkey:         for i, times in enumerate(self.ramp_limits):
        pstarkey:             n_triggers_prior = len([time for time in trigger_times if time < times[0]])
        pstarkey:             # The cumulative offset at this point in time:
        pstarkey:             offset = self.trigger_delay * n_triggers_prior + trigger_times[0]
        shjohnst:             offset = round(offset,10)
        pstarkey:             
        pstarkey:             # offset start and end time of ramps
        pstarkey:             # NOTE: This assumes ramps cannot proceed across a trigger command
        pstarkey:             #       (for instance you cannot ramp an output across a WAIT)
        pstarkey:             self.ramp_limits[i] = (self.quantise_to_pseudoclock(round(times[0]-offset,10)), self.quantise_to_pseudoclock(round(times[1]-offset,10)))
        pstarkey:             
        pstarkey:     def get_change_times(self):
        pstarkey:         """If this function is being called, it means that the parent
        pstarkey:         Pseudoclock has requested a list of times that this output changes
        pstarkey:         state."""        
     janwerkmann:         times = list(self.instructions.keys())
        pstarkey:         times.sort()
     janwerkmann: 
     janwerkmann:         current_dict_time = None
     janwerkmann:         for time in times:
     janwerkmann:             if isinstance(self.instructions[time], dict) and current_dict_time is None:
     janwerkmann:                 current_dict_time = self.instructions[time]
     janwerkmann:             elif current_dict_time is not None and current_dict_time['initial time'] < time < current_dict_time['end time']:
     janwerkmann:                 err = ("{:s} {:s} has an instruction at t={:.10f}s. This instruction collides with a ramp on this output at that time. ".format(self.description, self.name, time)+
             jan:                        "The collision {:s} is happening from {:.10f}s till {:.10f}s".format(current_dict_time['description'], current_dict_time['initial time'], current_dict_time['end time']))
     janwerkmann:                 raise LabscriptError(err)
     janwerkmann: 
        pstarkey:         self.times = times
        pstarkey:         return times
        pstarkey:         
        pstarkey:     def get_ramp_times(self):
        pstarkey:         return self.ramp_limits
        pstarkey:     
        pstarkey:     def make_timeseries(self, change_times):
        pstarkey:         """If this is being called, then it means the parent Pseudoclock
        pstarkey:         has asked for a list of this output's states at each time in
        pstarkey:         change_times. (Which are the times that one or more connected
        pstarkey:         outputs in the same pseudoclock change state). By state, I don't
        pstarkey:         mean the value of the output at that moment, rather I mean what
        pstarkey:         instruction it has. This might be a single value, or it might
        pstarkey:         be a reference to a function for a ramp etc. This list of states
        pstarkey:         is stored in self.timeseries rather than being returned."""
        pstarkey:         self.timeseries = []
        pstarkey:         i = 0
        pstarkey:         for change_time in change_times:
        pstarkey:             try:
        pstarkey:                 if i < len(self.times):
        pstarkey:                     while change_time >= self.times[i]:
        pstarkey:                         i += 1
        pstarkey:             except IndexError:
        pstarkey:                 # We allow the index to go one higher, since we're
        pstarkey:                 # intentionally overshooting the mark and are then
        pstarkey:                 # interested in self.times[i-1].  Raise the error
        pstarkey:                 # otherwise.
        pstarkey:                 if not i == len(self.times):
        pstarkey:                     raise
        pstarkey:             instruction = self.instructions[self.times[i-1]]
        pstarkey:             self.timeseries.append(instruction)     
        pstarkey:         
        pstarkey:     def expand_timeseries(self,all_times):
        pstarkey:         """This function evaluates the ramp functions in self.timeseries
        pstarkey:         at the time points in all_times, and creates an array of output
        pstarkey:         values at those times.  These are the values that this output
        pstarkey:         should update to on each clock tick, and are the raw values that
        pstarkey:         should be used to program the output device.  They are stored
        pstarkey:         in self.raw_output."""
        pstarkey:         # If this output is not ramping, then its timeseries should
        pstarkey:         # not be expanded. It's already as expanded as it'll get.
        pstarkey:         if not self.parent_clock_line.ramping_allowed:
        pstarkey:             self.raw_output = fastflatten(self.timeseries,self.dtype)
        pstarkey:             return
        pstarkey:         outputarray = []
        pstarkey:         for i, time in enumerate(all_times):
        pstarkey:             if iterable(time):
        pstarkey:                 if isinstance(self.timeseries[i],dict):
        pstarkey:                     # We evaluate the functions at the midpoints of the
        pstarkey:                     # timesteps in order to remove the zero-order hold
        pstarkey:                     # error introduced by sampling an analog signal:
        pstarkey:                     try:
        pstarkey:                         midpoints = time + 0.5*(time[1] - time[0])
        pstarkey:                     except IndexError:
        pstarkey:                         # Time array might be only one element long, so we
        pstarkey:                         # can't calculate the step size this way. That's
        pstarkey:                         # ok, the final midpoint is determined differently
        pstarkey:                         # anyway:
        pstarkey:                         midpoints = zeros(1)
        pstarkey:                     # We need to know when the first clock tick is after
        pstarkey:                     # this ramp ends. It's either an array element or a
        pstarkey:                     # single number depending on if this ramp is followed
        pstarkey:                     # by another ramp or not:
        pstarkey:                     next_time = all_times[i+1][0] if iterable(all_times[i+1]) else all_times[i+1]
        pstarkey:                     midpoints[-1] = time[-1] + 0.5*(next_time - time[-1])
        pstarkey:                     outarray = self.timeseries[i]['function'](midpoints-self.timeseries[i]['initial time'])
        pstarkey:                     # Now that we have the list of output points, pass them through the unit calibration
        pstarkey:                     if self.timeseries[i]['units'] is not None:
        pstarkey:                         outarray = self.apply_calibration(outarray,self.timeseries[i]['units'])
        pstarkey:                     # if we have limits, check the value is valid
        pstarkey:                     if self.limits:
        pstarkey:                         if ((outarray<self.limits[0])|(outarray>self.limits[1])).any():
             jan:                             raise LabscriptError('The function %s called on "%s" at t=%d generated a value which falls outside the base unit limits (%d to %d)'%(self.timeseries[i]['function'],self.name,midpoints[0],self.limits[0],self.limits[1]))
        pstarkey:                 else:
        pstarkey:                     outarray = empty(len(time),dtype=self.dtype)
        pstarkey:                     outarray.fill(self.timeseries[i])
        pstarkey:                 outputarray.append(outarray)
        pstarkey:             else:
        pstarkey:                 outputarray.append(self.timeseries[i])
        pstarkey:         del self.timeseries # don't need this any more.
        pstarkey:         self.raw_output = fastflatten(outputarray, self.dtype)
        pstarkey:         
        pstarkey: 
        pstarkey: class AnalogQuantity(Output):
        pstarkey:     description = 'analog quantity'
        pstarkey:     default_value = 0
          rander: 
          rander:     def _check_truncation(self, truncation, min=0, max=1):
          rander:         if not (min <= truncation <= max):
          rander:             raise LabscriptError(
          rander:                 'Truncation argument must be between %f and %f (inclusive), but is %f.' % (min, max, truncation))
          rander: 
          rander:     def ramp(self, t, duration, initial, final, samplerate, units=None, truncation=1.):
          rander:         self._check_truncation(truncation)
          rander:         if truncation > 0:
     janwerkmann:             # if start and end value are the same, we don't need to ramp and can save the sample ticks etc
     janwerkmann:             if initial == final:
     janwerkmann:                 self.constant(t, initial, units)
     janwerkmann:                 if not config.suppress_mild_warnings and not config.suppress_all_warnings:
     janwerkmann:                     message = ''.join(['WARNING: AnalogOutput \'%s\' has the same initial and final value at time t=%.10fs with duration %.10fs. In order to save samples and clock ticks this instruction is replaced with a constant output. '%(self.name, t, duration)])
     janwerkmann:                     sys.stderr.write(message + '\n')
     janwerkmann:             else:
        pstarkey:                 self.add_instruction(t, {'function': functions.ramp(round(t + duration, 10) - round(t, 10), initial, final), 'description': 'linear ramp',
     janwerkmann:                                      'initial time': t, 'end time': t + truncation * duration, 'clock rate': samplerate, 'units': units})
     janwerkmann:         return truncation * duration
          rander: 
          rander:     def sine(self, t, duration, amplitude, angfreq, phase, dc_offset, samplerate, units=None, truncation=1.):
          rander:         self._check_truncation(truncation)
          rander:         if truncation > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.sine(round(t + duration, 10) - round(t, 10), amplitude, angfreq, phase, dc_offset), 'description': 'sine wave',
          rander:                                      'initial time': t, 'end time': t + truncation*duration, 'clock rate': samplerate, 'units': units})
          rander:         return truncation*duration
          rander: 
          rander:     def sine_ramp(self, t, duration, initial, final, samplerate, units=None, truncation=1.):
          rander:         self._check_truncation(truncation)
          rander:         if truncation > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.sine_ramp(round(t + duration, 10) - round(t, 10), initial, final), 'description': 'sinusoidal ramp',
          rander:                                      'initial time': t, 'end time': t + truncation*duration, 'clock rate': samplerate, 'units': units})
          rander:         return truncation*duration
          rander: 
          rander:     def sine4_ramp(self, t, duration, initial, final, samplerate, units=None, truncation=1.):
          rander:         self._check_truncation(truncation)
          rander:         if truncation > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.sine4_ramp(round(t + duration, 10) - round(t, 10), initial, final), 'description': 'sinusoidal ramp',
          rander:                                      'initial time': t, 'end time': t + truncation*duration, 'clock rate': samplerate, 'units': units})
          rander:         return truncation*duration
          rander: 
          rander:     def sine4_reverse_ramp(self, t, duration, initial, final, samplerate, units=None, truncation=1.):
          rander:         self._check_truncation(truncation)
          rander:         if truncation > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.sine4_reverse_ramp(round(t + duration, 10) - round(t, 10), initial, final), 'description': 'sinusoidal ramp',
          rander:                                      'initial time': t, 'end time': t + truncation*duration, 'clock rate': samplerate, 'units': units})
          rander:         return truncation*duration
          rander: 
          rander:     def exp_ramp(self, t, duration, initial, final, samplerate, zero=0, units=None, truncation=1., truncation_type='linear', **kwargs):
          rander:         """Exponential ramp whose rate of change is set by an asymptotic value (zero argument).
          rander:         
          rander:         Parameters:
          rander:         t, duration : time to start the ramp and its duration
          rander:         initial, final : initial and final values of the ramp (sans truncation)
          rander:         zero: asymptotic value of the exponential decay/rise, i.e. limit as t --> inf
          rander:         samplerate: rate to sample the function
          rander:         units: unit conversion to apply to specified values before generating raw output
          rander:         truncation_type: 'linear' or 'exponential'
          rander:             'linear' truncation stops the ramp when it reaches the value given by the 
          rander:             truncation parameter, which must be between initial and final
          rander:             'exponential' truncation stops the ramp after a period of truncation*duration
          rander:             In this instance, the truncation parameter should be between 0 (full truncation)
          rander:             and 1 (no truncation).   
          rander:         """
          rander:         # Backwards compatibility for old kwarg names
          rander:         if 'trunc' in kwargs:
          rander:             truncation = kwargs.pop('trunc')
          rander:         if 'trunc_type' in kwargs:
          rander:             truncation_type = kwargs.pop('trunc_type')
          rander: 
          rander:         # Computed the truncated duration based on the truncation_type
          rander:         if truncation_type == 'linear':
          rander:             self._check_truncation(truncation, min(initial, final), max(initial, final))
          rander:             # Truncate the ramp when it reaches the value truncation
          rander:             trunc_duration = duration * \
          rander:                 log((initial-zero)/(truncation-zero)) / \
          rander:                 log((initial-zero)/(final-zero))
          rander:         elif truncation_type == 'exponential':
          rander:             # Truncate the ramps duration by a fraction truncation
          rander:             self._check_truncation(truncation)
          rander:             trunc_duration = truncation * duration
        pstarkey:         else:
          rander:             raise LabscriptError(
          rander:                 'Truncation type for exp_ramp not supported. Must be either linear or exponential.')
          rander:         if trunc_duration > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.exp_ramp(round(t + duration, 10) - round(t, 10), initial, final, zero), 'description': 'exponential ramp',
          rander:                                      'initial time': t, 'end time': t + trunc_duration, 'clock rate': samplerate, 'units': units})
        pstarkey:         return trunc_duration
          rander: 
          rander:     def exp_ramp_t(self, t, duration, initial, final, time_constant, samplerate, units=None, truncation=1., truncation_type='linear', **kwargs):
          rander:         """Exponential ramp whose rate of change is set by the time_constant.
          rander:         
          rander:         Parameters:
          rander:         t, duration : time to start the ramp and its duration
          rander:         initial, final : initial and final values of the ramp (sans truncation)
          rander:         time_constant: 1/e time of the exponential decay/rise
          rander:         samplerate: rate to sample the function
          rander:         units: unit conversion to apply to specified values before generating raw output
          rander:         truncation_type: 'linear' or 'exponential'
          rander:             'linear' truncation stops the ramp when it reaches the value given by the 
          rander:             truncation parameter, which must be between initial and final
          rander:             'exponential' truncation stops the ramp after a period of truncation*duration
          rander:             In this instance, the truncation parameter should be between 0 (full truncation)
          rander:             and 1 (no truncation).   
          rander:         """
          rander:         # Backwards compatibility for old kwarg names
          rander:         if 'trunc' in kwargs:
          rander:             truncation = kwargs.pop('trunc')
          rander:         if 'trunc_type' in kwargs:
          rander:             truncation_type = kwargs.pop('trunc_type')
          rander: 
          rander:         zero = (final-initial*exp(-duration/time_constant)) / \
          rander:             (1-exp(-duration/time_constant))
          rander:         if truncation_type == 'linear':
          rander:             self._check_truncation(truncation, min(initial, final), max(initial, final))
          rander:             trunc_duration = time_constant * \
          rander:                 log((initial-zero)/(truncation-zero))
          rander:         elif truncation_type == 'exponential':
          rander:             self._check_truncation(truncation)
          rander:             trunc_duration = truncation * duration
        pstarkey:         else:
          rander:             raise LabscriptError(
          rander:                 'Truncation type for exp_ramp_t not supported. Must be either linear or exponential.')
          rander:         if trunc_duration > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.exp_ramp_t(round(t + duration, 10) - round(t, 10), initial, final, time_constant), 'description': 'exponential ramp with time consntant',
          rander:                                      'initial time': t, 'end time': t + trunc_duration, 'clock rate': samplerate, 'units': units})
        pstarkey:         return trunc_duration
          rander: 
          rander:     def piecewise_accel_ramp(self, t, duration, initial, final, samplerate, units=None, truncation=1.):
          rander:         self._check_truncation(truncation)
          rander:         if truncation > 0:
        pstarkey:             self.add_instruction(t, {'function': functions.piecewise_accel(round(t + duration, 10) - round(t, 10), initial, final), 'description': 'piecewise linear accelleration ramp',
          rander:                                      'initial time': t, 'end time': t + truncation*duration, 'clock rate': samplerate, 'units': units})
          rander:         return truncation*duration
          rander: 
        cbilling:     def customramp(self, t, duration, function, *args, **kwargs):
        cbilling:         units = kwargs.pop('units', None)
        cbilling:         samplerate = kwargs.pop('samplerate')
          rander:         truncation = kwargs.pop('truncation', 1.)
          rander:         self._check_truncation(truncation)
          rander: 
        cbilling:         def custom_ramp_func(t_rel):
        cbilling:             """The function that will return the result of the user's function,
        cbilling:             evaluated at relative times t_rel from 0 to duration"""
        pstarkey:             return function(t_rel, round(t + duration, 10) - round(t, 10), *args, **kwargs)
          rander: 
          rander:         if truncation > 0:
          rander:             self.add_instruction(t, {'function': custom_ramp_func, 'description': 'custom ramp: %s' % function.__name__,
          rander:                                      'initial time': t, 'end time': t + truncation*duration, 'clock rate': samplerate, 'units': units})
          rander:         return truncation*duration
          rander: 
        spielman:     def constant(self,t,value,units=None):
        pstarkey:         # verify that value can be converted to float
        spielman:         try:
        spielman:             val = float(value)
        spielman:         except:
        spielman:             raise LabscriptError('in constant, value cannot be converted to float')
          rander:         self.add_instruction(t, value, units)
        pstarkey:         
        pstarkey:       
        pstarkey: class AnalogOut(AnalogQuantity):
        pstarkey:     description = 'analog output'
        pstarkey:     
        cbilling:     
        pstarkey: class StaticAnalogQuantity(Output):
        pstarkey:     description = 'static analog quantity'
        pstarkey:     default_value = 0.0
        spielman:     
        spielman:     @set_passed_properties(property_names = {})
     janwerkmann:     def __init__(self, *args, **kwargs):
        cbilling:         Output.__init__(self, *args, **kwargs)
        cbilling:         self._static_value = None
        cbilling:         
        cbilling:     def constant(self, value, units=None):
        cbilling:         if self._static_value is None:
        pstarkey:             # If we have units specified, convert the value
        pstarkey:             if units is not None:
        pstarkey:                 # Apply the unit calibration now
        cbilling:                 value = self.apply_calibration(value, units)
        pstarkey:             # if we have limits, check the value is valid
        pstarkey:             if self.limits:
        cbilling:                 minval, maxval = self.limits
        cbilling:                 if not minval <= value <= maxval:
        cbilling:                     raise LabscriptError('You cannot program the value %s (base units) to %s as it falls outside the limits (%s to %s)'%(str(value), self.name, str(self.limits[0]), str(self.limits[1])))
        cbilling:             self._static_value = value
        pstarkey:         else:
        cbilling:             raise LabscriptError('%s %s has already been set to %s (base units). It cannot also be set to %s (%s).'%(self.description, self.name, str(self._static_value), str(value),units if units is not None else "base units"))
        pstarkey:     
        pstarkey:     def get_change_times(self):
        cbilling:         return []  # Return an empty list as the calling function at the pseudoclock level expects a list
        cbilling:         
        pstarkey:     def make_timeseries(self,change_times):
        pstarkey:         pass
        pstarkey:     
        pstarkey:     def expand_timeseries(self,*args,**kwargs):
     janwerkmann:         self.raw_output = array([self.static_value], dtype=self.dtype)
     janwerkmann: 
        cbilling:     @property
        cbilling:     def static_value(self):
        cbilling:         if self._static_value is None:
        cbilling:             if not config.suppress_mild_warnings and not config.suppress_all_warnings:
        cbilling:                 sys.stderr.write(' '.join(['WARNING:', self.name, 'has no value set. It will be set to %s.\n'%self.instruction_to_string(self.default_value)]))
        cbilling:             self._static_value = self.default_value
        cbilling:         return self._static_value
        cbilling:         
        pstarkey: class StaticAnalogOut(StaticAnalogQuantity):
        pstarkey:     description = 'static analog output'
        pstarkey:         
        pstarkey: class DigitalQuantity(Output):
        pstarkey:     description = 'digital quantity'
        pstarkey:     allowed_states = {1:'high', 0:'low'}
        pstarkey:     default_value = 0
        pstarkey:     dtype = uint32
        pstarkey:     
        pstarkey:     # Redefine __init__ so that you cannot define a limit or calibration for DO
     janwerkmann:     @set_passed_properties(property_names = {"connection_table_properties": ["inverted"]})
             jan:     def __init__(self, name, parent_device, connection, inverted=False, **kwargs):
        spielman:         Output.__init__(self,name,parent_device,connection, **kwargs)
     janwerkmann:         self.inverted = bool(inverted)
     janwerkmann: 
        pstarkey:     def go_high(self,t):
             jan:         self.add_instruction(t, 1)
     janwerkmann: 
        pstarkey:     def go_low(self,t):
             jan:         self.add_instruction(t, 0)
             jan: 
             jan:     def enable(self,t):
     janwerkmann:         if self.inverted:
             jan:             self.go_low(t)
     janwerkmann:         else:
             jan:             self.go_high(t)
             jan: 
             jan:     def disable(self,t):
             jan:         if self.inverted:
             jan:             self.go_high(t)
             jan:         else:
             jan:             self.go_low(t)
             jan: 
        pstarkey:     '''
        pstarkey:     This function only works if the DigitalQuantity is on a fast clock
        pstarkey:     
        pstarkey:     The pulse_sequence parameter should be specified as a list of tuples. 
        pstarkey:     Each tuple should be of the form (time,state)
        pstarkey:     
        pstarkey:     The period parmeter should, in general, be longer than the entire pulse sequence, 
        pstarkey:     and defines how long the final tuple should be held for before repeating the pulse sequence.
        pstarkey:     
        pstarkey:     The pulse sequence specified will be repeated from time t until t+duration.
        pstarkey:     
        pstarkey:     The samplerate parameter specifies how often to update the output
        pstarkey:     
        pstarkey:     Note 1: The samplerate should be significantly faster than the smallest time difference between 
        pstarkey:     two states in the pulse sequence, or else points in your pulse sequence may never be evaluated.
        pstarkey:     
        pstarkey:     Note 2: The time points your pulse sequence is evaluated at may be different than you expect,
        pstarkey:     if another output changes state between t and t+duration. As such, you should set the samplerate
        pstarkey:     high enough that even if this rounding of tie points occurs (to fit in the update required to change the other output)
        pstarkey:     your pulse sequence will not be significantly altered)
        pstarkey:     '''
        pstarkey:     def repeat_pulse_sequence(self,t,duration,pulse_sequence,period,samplerate):
        pstarkey:         self.add_instruction(t, {'function': functions.pulse_sequence(pulse_sequence,period), 'description':'pulse sequence',
        pstarkey:                                  'initial time':t, 'end time': t + duration, 'clock rate': samplerate, 'units': None})
        pstarkey:         
        pstarkey:         return duration
        pstarkey: 
        cbilling:         
        pstarkey: class DigitalOut(DigitalQuantity):
        pstarkey:     description = 'digital output'
        pstarkey: 
        cbilling:     
        pstarkey: class StaticDigitalQuantity(DigitalQuantity):
        pstarkey:     description = 'static digital quantity'
        cbilling:     default_value = 0
        pstarkey:     
        spielman:     @set_passed_properties(property_names = {})
        cbilling:     def __init__(self, *args, **kwargs):
        cbilling:         DigitalQuantity.__init__(self, *args, **kwargs)
        cbilling:         self._static_value = None
        cbilling:         
        pstarkey:     def go_high(self):
        cbilling:         if self._static_value is not None:
        pstarkey:             self.add_instruction(0,1)
        cbilling:             self._static_value = 1
        cbilling:             
        pstarkey:     def go_low(self):
        cbilling:         if self._static_value is not None:
        pstarkey:             self.add_instruction(0,0) 
        cbilling:             self._static_value = 0
        pstarkey:         else:
        cbilling:             raise LabscriptError('%s %s has already been set to %s. It cannot also be set to %s.'%(self.description, self.name, self.instruction_to_string[self._static_value], self.instruction_to_string[value]))
        pstarkey:     
        pstarkey:     def get_change_times(self):
        cbilling:         return []  # Return an empty list as the calling function at the pseudoclock level expects a list
        pstarkey:     
        pstarkey:     def make_timeseries(self,change_times):
        pstarkey:         pass
        pstarkey:     
        pstarkey:     def expand_timeseries(self,*args,**kwargs):
     janwerkmann:         self.raw_output = array([self.static_value], dtype=self.dtype)
     janwerkmann: 
        cbilling:     @property
        cbilling:     def static_value(self):
        cbilling:         if self._static_value is None:
        cbilling:             if not config.suppress_mild_warnings and not config.suppress_all_warnings:
        cbilling:                 sys.stderr.write(' '.join(['WARNING:', self.name, 'has no value set. It will be set to %s.\n'%self.instruction_to_string(self.default_value)]))
        cbilling:             self._static_value = self.default_value
        cbilling:         return self._static_value
        cbilling:     
        pstarkey: 
        pstarkey: class StaticDigitalOut(StaticDigitalQuantity):
        pstarkey:     description = 'static digital output'
        pstarkey:         
        pstarkey: class AnalogIn(Device):
        pstarkey:     description = 'Analog Input'
        spielman:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self,name,parent_device,connection,scale_factor=1.0,units='Volts',**kwargs):
        spielman:                 
        spielman:         self.acquisitions = []
        spielman:         self.scale_factor = scale_factor
        spielman:         self.units=units
        spielman:         Device.__init__(self,name,parent_device,connection, **kwargs)
        pstarkey:    
        pstarkey:     def acquire(self,label,start_time,end_time,wait_label='',scale_factor=None,units=None):
        pstarkey:         if scale_factor is None:
        pstarkey:             scale_factor = self.scale_factor
        pstarkey:         if units is None:
        pstarkey:             units = self.units
        pstarkey:         self.acquisitions.append({'start_time': start_time, 'end_time': end_time,
        pstarkey:                                  'label': label, 'wait_label':wait_label, 'scale_factor':scale_factor,'units':units})
        pstarkey:         return end_time - start_time
     janwerkmann: 
     janwerkmann: 
        pstarkey: class Shutter(DigitalOut):
        pstarkey:     description = 'shutter'
        pstarkey:     
             jan:     @set_passed_properties(
             jan:         property_names = {"connection_table_properties": ["open_state"]}
             jan:         )
        spielman:     def __init__(self,name,parent_device,connection,delay=(0,0),open_state=1,
        spielman:                  **kwargs):
        spielman: 
     janwerkmann:         DigitalOut.__init__(self, name, parent_device, connection, inverted=not bool(open_state), **kwargs)
        pstarkey:         self.open_delay, self.close_delay = delay
        pstarkey:         self.open_state = open_state
        pstarkey:         if self.open_state == 1:
        pstarkey:             self.allowed_states = {0: 'closed', 1: 'open'}
        pstarkey:         elif self.open_state == 0:
        pstarkey:             self.allowed_states = {1: 'closed', 0: 'open'}
        pstarkey:         else:
        pstarkey:             raise LabscriptError("Shutter %s wasn't instantiated with open_state = 0 or 1." % self.name)
     janwerkmann:         self.actual_times = {}
        pstarkey: 
        pstarkey:     # If a shutter is asked to do something at t=0, it cannot start moving
        pstarkey:     # earlier than that.  So initial shutter states will have imprecise
        pstarkey:     # timing. Not throwing a warning here because if I did, every run
        pstarkey:     # would throw a warning for every shutter. The documentation will
        pstarkey:     # have to make a point of this.
        pstarkey:     def open(self, t):
     janwerkmann:         t_calc = t-self.open_delay if t >= self.open_delay else 0
     janwerkmann:         self.actual_times[t] = {'time': t_calc, 'instruction': 1}
             jan:         self.enable(t_calc)
        pstarkey: 
        pstarkey:     def close(self, t):
     janwerkmann:         t_calc = t-self.close_delay if t >= self.close_delay else 0
     janwerkmann:         self.actual_times[t] = {'time': t_calc, 'instruction': 0}
             jan:         self.disable(t_calc)
     janwerkmann: 
        pstarkey:     def generate_code(self, hdf5_file):
        pstarkey:         classname = self.__class__.__name__
             jan:         calibration_table_dtypes = dtype_workaround([('name','a256'), ('open_delay',float), ('close_delay',float)])
        pstarkey:         if classname not in hdf5_file['calibrations']:
        pstarkey:             hdf5_file['calibrations'].create_dataset(classname, (0,), dtype=calibration_table_dtypes, maxshape=(None,))
        pstarkey:         metadata = (self.name,self.open_delay,self.close_delay)
        pstarkey:         dataset = hdf5_file['calibrations'][classname]
        pstarkey:         dataset.resize((len(dataset)+1,))
        pstarkey:         dataset[len(dataset)-1] = metadata
     janwerkmann: 
     janwerkmann:     def get_change_times(self, *args, **kwargs):
     janwerkmann:         retval = DigitalOut.get_change_times(self, *args, **kwargs)
     janwerkmann: 
     janwerkmann:         if len(self.actual_times)>1:
             jan:             sorted_times = list(self.actual_times.keys())
     janwerkmann:             sorted_times.sort()
     janwerkmann:             for i in range(len(sorted_times)-1):
     janwerkmann:                 time = sorted_times[i]
     janwerkmann:                 next_time = sorted_times[i+1]
     janwerkmann:                 # only look at instructions that contain a state change
     janwerkmann:                 if self.actual_times[time]['instruction'] != self.actual_times[next_time]['instruction']:
     janwerkmann:                     state1 = 'open' if self.actual_times[next_time]['instruction'] == 1 else 'close'
     janwerkmann:                     state2 = 'opened' if self.actual_times[time]['instruction'] == 1 else 'closed'
     janwerkmann:                     if self.actual_times[next_time]['time'] < self.actual_times[time]['time']:
     janwerkmann:                         message = "WARNING: The shutter '{:s}' is requested to {:s} too early (taking delay into account) at t={:.10f}s when it is still not {:s} from an earlier instruction at t={:.10f}s".format(self.name, state1, next_time, state2, time)
     janwerkmann:                         sys.stderr.write(message+'\n')
     janwerkmann:                 elif not config.suppress_mild_warnings and not config.suppress_all_warnings:
     janwerkmann:                     state1 = 'open' if self.actual_times[next_time]['instruction'] == 1 else 'close'
     janwerkmann:                     state2 = 'opened' if self.actual_times[time]['instruction'] == 0 else 'closed'
     janwerkmann:                     message = "WARNING: The shutter '{:s}' is requested to {:s} at t={:.10f}s but was never {:s} after an earlier instruction at t={:.10f}s".format(self.name, state1, next_time, state2, time)
     janwerkmann:                     sys.stderr.write(message+'\n')
     janwerkmann:         return retval
     janwerkmann: 
     janwerkmann: 
        pstarkey: class Trigger(DigitalOut):
        pstarkey:     description = 'trigger device'
        pstarkey:     allowed_states = {1:'high', 0:'low'}
        cbilling:     allowed_children = [TriggerableDevice]
        spielman: 
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, parent_device, connection, trigger_edge_type='rising',
        spielman:                  **kwargs):
        spielman: 
        spielman:         DigitalOut.__init__(self,name,parent_device,connection, **kwargs)
        pstarkey:         self.trigger_edge_type = trigger_edge_type
        pstarkey:         if self.trigger_edge_type == 'rising':
        pstarkey:             self.enable = self.go_high
        pstarkey:             self.disable = self.go_low
        pstarkey:             self.allowed_states = {1:'enabled', 0:'disabled'}
        pstarkey:         elif self.trigger_edge_type == 'falling':
        pstarkey:             self.enable = self.go_low
        pstarkey:             self.disable = self.go_high
        pstarkey:             self.allowed_states = {1:'disabled', 0:'enabled'}
        pstarkey:         else:
        pstarkey:             raise ValueError('trigger_edge_type must be \'rising\' or \'falling\', not \'%s\'.'%trigger_edge_type)
        cbilling:         # A list of the times this trigger has been asked to trigger:
        cbilling:         self.triggerings = []
        cbilling:         
        cbilling:         
        pstarkey:     def trigger(self, t, duration):
        cbilling:         assert duration > 0, "Negative or zero trigger duration given"
        pstarkey:         if t != self.t0 and self.t0 not in self.instructions:
        pstarkey:             self.disable(self.t0)
        cbilling:         
        cbilling:         start = t
        cbilling:         end = t + duration
        cbilling:         for other_start, other_duration in self.triggerings:
        cbilling:             other_end = other_start + other_duration
        cbilling:             # Check for overlapping exposures:
        cbilling:             if not (end < other_start or start > other_end):
        cbilling:                 raise LabscriptError('%s %s has two overlapping triggerings: ' %(self.description, self.name) + \
        cbilling:                                      'one at t = %fs for %fs, and another at t = %fs for %fs.'%(start, duration, other_start, other_duration))
        pstarkey:         self.enable(t)
        pstarkey:         self.disable(round(t + duration,10))
        cbilling:         self.triggerings.append((t, duration))
        pstarkey: 
        cbilling:     def add_device(self, device):
        cbilling:         if not device.connection == 'trigger':
        cbilling:             raise LabscriptError('The \'connection\' string of device %s '%device.name + 
        cbilling:                                  'to %s must be \'trigger\', not \'%s\''%(self.name, repr(device.connection)))
        cbilling:         DigitalOut.add_device(self, device)
        cbilling: 
        cbilling:         
        pstarkey: class WaitMonitor(Trigger):
        spielman:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self, name, parent_device, connection, acquisition_device, acquisition_connection, timeout_device, timeout_connection,
        spielman:                   **kwargs):
        spielman: 
        pstarkey:         if compiler.wait_monitor is not None:
        pstarkey:             raise LabscriptError("Cannot instantiate a second WaitMonitor: there can be only be one in the experiment")
        pstarkey:         compiler.wait_monitor = self
        spielman:         Trigger.__init__(self, name, parent_device, connection, trigger_edge_type='rising', **kwargs)
        pstarkey:         if not parent_device.pseudoclock_device.is_master_pseudoclock:
        pstarkey:             raise LabscriptError('The output device for monitoring wait durations must be clocked by the master pseudoclock device')
        pstarkey:         # TODO: acquisition_device must be the same as timeout_device at the moment (given the current BLACS implementation)
        pstarkey:         self.acquisition_device = acquisition_device
        pstarkey:         self.acquisition_connection = acquisition_connection 
        pstarkey:         self.timeout_device = timeout_device
        pstarkey:         self.timeout_connection = timeout_connection 
        pstarkey:         
        pstarkey:         
        pstarkey: class DDS(Device):
        pstarkey:     description = 'DDS'
        pstarkey:     allowed_children = [AnalogQuantity,DigitalOut,DigitalQuantity] # Adds its own children when initialised
        spielman: 
        spielman:     @set_passed_properties(property_names = {})
        pstarkey:     def __init__(self, name, parent_device, connection, digital_gate={}, freq_limits=None, freq_conv_class=None, freq_conv_params={},
        spielman:                  amp_limits=None, amp_conv_class=None, amp_conv_params={}, phase_limits=None, phase_conv_class=None, phase_conv_params = {},
        spielman:                  **kwargs):
        pstarkey:         #self.clock_type = parent_device.clock_type # Don't see that this is needed anymore
        pstarkey:         
        cbilling:         # Here we set call_parents_add_device=False so that we
        cbilling:         # can do additional initialisation before manually calling
        cbilling:         # self.parent_device.add_device(self). This allows the parent's
        cbilling:         # add_device method to perform checks based on the code below,
        cbilling:         # whilst still providing us with the checks and attributes that
        cbilling:         # Device.__init__ gives us in the meantime.
        spielman:         Device.__init__(self, name, parent_device, connection, call_parents_add_device=False, **kwargs)
        cbilling:                 
        cbilling:         # Ask the parent device if it has default unit conversion classes it would like us to use:
        cbilling:         if hasattr(parent_device, 'get_default_unit_conversion_classes'):
        cbilling:             classes = self.parent_device.get_default_unit_conversion_classes(self)
        cbilling:             default_freq_conv, default_amp_conv, default_phase_conv = classes
        cbilling:             # If the user has not overridden, use these defaults. If
        cbilling:             # the parent does not have a default for one or more of amp,
        cbilling:             # freq or phase, it should return None for them.
        pstarkey:             if freq_conv_class is None:
        cbilling:                 freq_conv_class = default_freq_conv
        pstarkey:             if amp_conv_class is None:
        cbilling:                 amp_conv_class = default_amp_conv
        cbilling:             if phase_conv_class is None:
        cbilling:                 phase_conv_class = default_phase_conv
        pstarkey:         
        pstarkey:         self.frequency = AnalogQuantity(self.name + '_freq', self, 'freq', freq_limits, freq_conv_class, freq_conv_params)
        pstarkey:         self.amplitude = AnalogQuantity(self.name + '_amp', self, 'amp', amp_limits, amp_conv_class, amp_conv_params)
        pstarkey:         self.phase = AnalogQuantity(self.name + '_phase', self, 'phase', phase_limits, phase_conv_class, phase_conv_params)
        cbilling: 
        pstarkey:         self.gate = None
        cbilling:         if 'device' in digital_gate and 'connection' in digital_gate:            
        cbilling:             self.gate = DigitalOut(name + '_gate', digital_gate['device'], digital_gate['connection'])
        cbilling:         # Did they only put one key in the dictionary, or use the wrong keywords?
        cbilling:         elif len(digital_gate) > 0:
        cbilling:             raise LabscriptError('You must specify the "device" and "connection" for the digital gate of %s.' % (self.name))
        cbilling:         
        cbilling:         # If the user has not specified a gate, and the parent device
        cbilling:         # supports gating of DDS output, it should add a gate to this
        cbilling:         # instance in its add_device method, which is called below. If
        cbilling:         # they *have* specified a gate device, but the parent device
        cbilling:         # has its own gating (such as the PulseBlaster), it should
        cbilling:         # check this and throw an error in its add_device method. See
        cbilling:         # labscript_devices.PulseBlaster.PulseBlaster.add_device for an
        cbilling:         # example of this.
        cbilling:         self.parent_device.add_device(self)
        cbilling:         
        pstarkey:     def setamp(self, t, value, units=None):
        pstarkey:         self.amplitude.constant(t, value, units)
        pstarkey:         
        pstarkey:     def setfreq(self, t, value, units=None):
        pstarkey:         self.frequency.constant(t, value, units)
        pstarkey:         
        pstarkey:     def setphase(self, t, value, units=None):
        pstarkey:         self.phase.constant(t, value, units)
        pstarkey:         
        pstarkey:     def enable(self, t):
        cbilling:         if self.gate is None:
        pstarkey:             raise LabscriptError('DDS %s does not have a digital gate, so you cannot use the enable(t) method.' % (self.name))
        cbilling:         self.gate.go_high(t)
        cbilling: 
        pstarkey:     def disable(self, t):
        cbilling:         if self.gate is None:
        pstarkey:             raise LabscriptError('DDS %s does not have a digital gate, so you cannot use the disable(t) method.' % (self.name))
        cbilling:         self.gate.go_low(t)
        pstarkey:             
        pstarkey:     def pulse(self, duration, amplitude, frequency, phase=None, print_summary=True):
        pstarkey:         if print_summary:
        shjohnst:             functions.print_time(t, '%s pulse at %.4f MHz for %.3f ms' % (self.name, frequency/MHz, duration/ms))
        pstarkey:         self.setamp(t, amplitude)
        cbilling:         if frequency is not None:
        pstarkey:             self.setfreq(t, frequency)
        cbilling:         if phase is not None:
        pstarkey:             self.setphase(t, phase)
        pstarkey:         if amplitude != 0:
        pstarkey:             self.enable(t)
        pstarkey:         self.disable(t)
        pstarkey:         self.setamp(t, 0)
        pstarkey:         return duration
        pstarkey: 
        cbilling: 
        pstarkey: class StaticDDS(Device):
        pstarkey:     description = 'Static RF'
        pstarkey:     allowed_children = [StaticAnalogQuantity,DigitalOut,StaticDigitalOut]
        spielman:     
        spielman:     @set_passed_properties(property_names = {})
        spielman:     def __init__(self,name,parent_device,connection,digital_gate = {},freq_limits = None,freq_conv_class = None,freq_conv_params = {},amp_limits=None,amp_conv_class = None,amp_conv_params = {},phase_limits=None,phase_conv_class = None,phase_conv_params = {},
        spielman:                  **kwargs):
        pstarkey:         #self.clock_type = parent_device.clock_type # Don't see that this is needed anymore
        pstarkey:         
        cbilling:         # We tell Device.__init__ to not call
        cbilling:         # self.parent.add_device(self), we'll do that ourselves later
        cbilling:         # after further intitialisation, so that the parent can see the
        cbilling:         # freq/amp/phase objects and manipulate or check them from within
        cbilling:         # its add_device method.
        spielman:         Device.__init__(self,name,parent_device,connection, call_parents_add_device=False, **kwargs)
chrisjbillington: 
chrisjbillington:         # Ask the parent device if it has default unit conversion classes it would like us to use:
chrisjbillington:         if hasattr(parent_device, 'get_default_unit_conversion_classes'):
chrisjbillington:             classes = parent_device.get_default_unit_conversion_classes(self)
chrisjbillington:             default_freq_conv, default_amp_conv, default_phase_conv = classes
chrisjbillington:             # If the user has not overridden, use these defaults. If
chrisjbillington:             # the parent does not have a default for one or more of amp,
chrisjbillington:             # freq or phase, it should return None for them.
chrisjbillington:             if freq_conv_class is None:
chrisjbillington:                 freq_conv_class = default_freq_conv
chrisjbillington:             if amp_conv_class is None:
chrisjbillington:                 amp_conv_class = default_amp_conv
chrisjbillington:             if phase_conv_class is None:
chrisjbillington:                 phase_conv_class = default_phase_conv
chrisjbillington: 
        pstarkey:         self.frequency = StaticAnalogQuantity(self.name+'_freq',self,'freq',freq_limits,freq_conv_class,freq_conv_params)
        cbilling:         self.amplitude = StaticAnalogQuantity(self.name+'_amp',self,'amp',amp_limits,amp_conv_class,amp_conv_params)
        cbilling:         self.phase = StaticAnalogQuantity(self.name+'_phase',self,'phase',phase_limits,phase_conv_class,phase_conv_params)        
        pstarkey:         
        cbilling:         if 'device' in digital_gate and 'connection' in digital_gate:            
        cbilling:             self.gate = DigitalOut(self.name+'_gate',digital_gate['device'],digital_gate['connection'])
        cbilling:         # Did they only put one key in the dictionary, or use the wrong keywords?
        cbilling:         elif len(digital_gate) > 0:
        cbilling:             raise LabscriptError('You must specify the "device" and "connection" for the digital gate of %s.'%(self.name))
        cbilling:         # Now we call the parent's add_device method. This is a must, since we didn't do so earlier from Device.__init__.
        cbilling:         self.parent_device.add_device(self)
        pstarkey:         
        pstarkey:     def setamp(self,value,units=None):
        cbilling:         self.amplitude.constant(value,units)
        pstarkey:         
        pstarkey:     def setfreq(self,value,units=None):
        pstarkey:         self.frequency.constant(value,units)
        pstarkey:         
        pstarkey:     def setphase(self,value,units=None):
        cbilling:         self.phase.constant(value,units) 
        pstarkey:             
        pstarkey:     def enable(self,t=None):        
        cbilling:         if self.gate:
        cbilling:             self.gate.go_high(t)
        pstarkey:         else:
        cbilling:             raise LabscriptError('DDS %s does not have a digital gate, so you cannot use the enable(t) method.'%(self.name))
        cbilling:                         
        pstarkey:     def disable(self,t=None):
        cbilling:         if self.gate:
        cbilling:             self.gate.go_low(t)
        pstarkey:         else:
        cbilling:             raise LabscriptError('DDS %s does not have a digital gate, so you cannot use the disable(t) method.'%(self.name))
        pstarkey:               
        pstarkey: class LabscriptError(Exception):
        pstarkey:     pass
             jan: 
             jan: def save_time_markers(hdf5_file):
             jan:     time_markers = compiler.time_markers
             jan:     dtypes = dtype_workaround([('label','a256'), ('time', float), ('color', '(1,3)uint8')])
             jan:     data_array = zeros(len(time_markers), dtype=dtypes)
             jan:     for i, t in enumerate(time_markers):
             jan:         data_array[i] = time_markers[t]["label"], t, time_markers[t]["color"]
             jan:     time_markers_dataset = hdf5_file.create_dataset('time_markers', data = data_array)
             jan: 
        pstarkey: def generate_connection_table(hdf5_file):
        pstarkey:     connection_table = []
        pstarkey:     devicedict = {}
        pstarkey:     
        cbilling:     # Only use a string dtype as long as is needed:
        cbilling:     max_BLACS_conn_length = -1
        cbilling: 
        pstarkey:     for device in compiler.inventory:
        pstarkey:         devicedict[device.name] = device
        cbilling: 
        cbilling:         unit_conversion_parameters = device._properties['unit_conversion_parameters']
        cbilling:         serialised_unit_conversion_parameters = labscript_utils.properties.serialise(unit_conversion_parameters)
        cbilling: 
        cbilling:         properties = device._properties["connection_table_properties"]
        cbilling:         serialised_properties = labscript_utils.properties.serialise(properties)
        pstarkey:         
        pstarkey:         # If the device has a BLACS_connection atribute, then check to see if it is longer than the size of the hdf5 column
        pstarkey:         if hasattr(device,"BLACS_connection"):
        pstarkey:             # Make sure it is a string!
        pstarkey:             BLACS_connection = str(device.BLACS_connection)
        pstarkey:             if len(BLACS_connection) > max_BLACS_conn_length:
        pstarkey:                 max_BLACS_conn_length = len(BLACS_connection)
        pstarkey:         else:
        pstarkey:             BLACS_connection = ""
        pstarkey:             
        pstarkey:             #if there is no BLACS connection, make sure there is no "gui" or "worker" entry in the connection table properties
        pstarkey:             if 'worker' in properties or 'gui' in properties:
        pstarkey:                 raise LabscriptError('You cannot specify a remote GUI or worker for a device (%s) that does not have a tab in BLACS'%(device.name))
        pstarkey:             
        pstarkey:             
        pstarkey:         connection_table.append((device.name, device.__class__.__name__,
        pstarkey:                                  device.parent_device.name if device.parent_device else str(None),
        pstarkey:                                  str(device.connection if device.parent_device else str(None)),
        pstarkey:                                  device.unit_conversion_class.__name__ if hasattr(device,"unit_conversion_class") and device.unit_conversion_class is not None else str(None),
        cbilling:                                  serialised_unit_conversion_parameters,
        pstarkey:                                  BLACS_connection,
        cbilling:                                  serialised_properties))
        pstarkey:     
        cbilling:     connection_table.sort()
     janwerkmann:     vlenstring = h5py.special_dtype(vlen=str)
             jan:     connection_table_dtypes = dtype_workaround([('name','a256'), ('class','a256'), ('parent','a256'), ('parent port','a256'),
        cbilling:                                ('unit conversion class','a256'), ('unit conversion params', vlenstring),
        pstarkey:                                ('BLACS_connection','a'+str(max_BLACS_conn_length)),
             jan:                                ('properties', vlenstring)])
        pstarkey:     connection_table_array = empty(len(connection_table),dtype=connection_table_dtypes)
        pstarkey:     for i, row in enumerate(connection_table):
        pstarkey:         connection_table_array[i] = row
        pstarkey:     dataset = hdf5_file.create_dataset('connection table', compression=config.compression, data=connection_table_array, maxshape=(None,))
        cbilling:     
        cbilling:     if compiler.master_pseudoclock is None:
        cbilling:         master_pseudoclock_name = 'None'
        cbilling:     else:
        cbilling:         master_pseudoclock_name = compiler.master_pseudoclock.name
        cbilling:     dataset.attrs['master_pseudoclock'] = master_pseudoclock_name
        cbilling:   
        pstarkey:   
        pstarkey: def save_labscripts(hdf5_file):
        pstarkey:     if compiler.labscript_file is not None:
        pstarkey:         script_text = open(compiler.labscript_file).read()
        pstarkey:     else:
        pstarkey:         script_text = ''
        pstarkey:     script = hdf5_file.create_dataset('script',data=script_text)
        cbilling:     script.attrs['name'] = os.path.basename(compiler.labscript_file).encode() if compiler.labscript_file is not None else ''
        cbilling:     script.attrs['path'] = os.path.dirname(compiler.labscript_file).encode() if compiler.labscript_file is not None else sys.path[0]
        pstarkey:     try:
        pstarkey:         import labscriptlib
        pstarkey:         prefix = os.path.dirname(labscriptlib.__file__)
        pstarkey:         for module in sys.modules.values():
        pstarkey:             if hasattr(module,'__file__'):
        pstarkey:                 path = os.path.abspath(module.__file__)
        pstarkey:                 if path.startswith(prefix) and (path.endswith('.pyc') or path.endswith('.py')):
          rander:                     path = path.replace('.pyc', '.py')
          rander:                     save_path = 'labscriptlib/' + path.replace(prefix, '').replace('\\', '/').replace('//', '/')
        pstarkey:                     if save_path in hdf5_file:
        pstarkey:                         # Don't try to save the same module script twice! 
        pstarkey:                         # (seems to at least double count __init__.py when you import an entire module as in from labscriptlib.stages import * where stages is a folder with an __init__.py file.
        pstarkey:                         # Doesn't seem to want to double count files if you just import the contents of a file within a module
        pstarkey:                         continue
        pstarkey:                     hdf5_file.create_dataset(save_path, data=open(path).read())
             jan:                     if compiler.save_hg_info:
             jan:                         hg_commands = [['log', '--limit', '1'], ['status'], ['diff']]
             jan:                         for command in hg_commands:
             jan:                             process = subprocess.Popen(['hg'] + command + [os.path.split(path)[1]], cwd=os.path.split(path)[0],
             jan:                                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE, startupinfo=startupinfo)
             jan:                             info, err = process.communicate()
             jan:                             if info or err:
             jan:                                 hdf5_file[save_path].attrs['hg ' + str(command[0])] = info.decode('utf-8') + '\n' + err.decode('utf-8')
        pstarkey:     except ImportError:
        pstarkey:         pass
        pstarkey:     except WindowsError if os.name == 'nt' else None:
          rander:         sys.stderr.write('Warning: Cannot save Mercurial data for imported scripts. Check that the hg command can be run from the command line.\n')
        cbilling: 
        cbilling: 
        cbilling: def write_device_properties(hdf5_file):
        cbilling:     for device in compiler.inventory:
        cbilling:         device_properties = device._properties["device_properties"]
        cbilling:         # Special case: We don't create the group if the only property is an
        cbilling:         # empty dict called 'added properties'. This is because this property
        cbilling:         # is present in all devices, and represents a place to pass in
        cbilling:         # arbitrary data from labscript experiment scripts. We don't want a
        cbilling:         # group for every device if nothing is actually being passed in, so we
        cbilling:         # ignore this case.
        cbilling:         if device_properties and device_properties != {'added_properties':{}}:
        cbilling:             # Create group if doesn't exist:
        cbilling:             if not device.name in hdf5_file['devices']:
        cbilling:                 hdf5_file['/devices'].create_group(device.name)
        cbilling:             labscript_utils.properties.set_device_properties(hdf5_file, device.name, device_properties)
        cbilling: 
        cbilling: 
        pstarkey: def generate_wait_table(hdf5_file):
             jan:     dtypes = dtype_workaround([('label','a256'), ('time', float), ('timeout', float)])
        pstarkey:     data_array = zeros(len(compiler.wait_table), dtype=dtypes)
        pstarkey:     for i, t in enumerate(sorted(compiler.wait_table)):
        pstarkey:         label, timeout = compiler.wait_table[t]
        pstarkey:         data_array[i] = label, t, timeout
        pstarkey:     dataset = hdf5_file.create_dataset('waits', data = data_array)
        pstarkey:     if compiler.wait_monitor is not None:
        pstarkey:         acquisition_device = compiler.wait_monitor.acquisition_device.name 
        pstarkey:         acquisition_connection = compiler.wait_monitor.acquisition_connection
        pstarkey:         timeout_device = compiler.wait_monitor.timeout_device.name 
        pstarkey:         timeout_connection = compiler.wait_monitor.timeout_connection
        pstarkey:     else:
        pstarkey:         acquisition_device, acquisition_connection, timeout_device, timeout_connection = '','','',''
        pstarkey:     dataset.attrs['wait_monitor_acquisition_device'] = acquisition_device
        pstarkey:     dataset.attrs['wait_monitor_acquisition_connection'] = acquisition_connection
        pstarkey:     dataset.attrs['wait_monitor_timeout_device'] = timeout_device
        pstarkey:     dataset.attrs['wait_monitor_timeout_connection'] = timeout_connection
        pstarkey:     
        pstarkey: def generate_code():
        pstarkey:     if compiler.hdf5_filename is None:
        pstarkey:         raise LabscriptError('hdf5 file for compilation not set. Please call labscript_init')
        cbilling:     elif not os.path.exists(compiler.hdf5_filename):
        cbilling:         with h5py.File(compiler.hdf5_filename ,'w') as hdf5_file:
        cbilling:             hdf5_file.create_group('globals')
        pstarkey:     with h5py.File(compiler.hdf5_filename) as hdf5_file:
        cbilling:         try:
        cbilling:             hdf5_file.create_group('devices')
        cbilling:             hdf5_file.create_group('calibrations')
        cbilling:         except ValueError:
        cbilling:             # Group(s) already exist - this is not a fresh h5 file, we cannot compile with it:
        cbilling:             raise ValueError('The HDF5 file %s already contains compilation data '%compiler.hdf5_filename +
        cbilling:                              '(possibly partial if due to failed compilation). ' +
        cbilling:                              'Please use a fresh shot file. ' +
        cbilling:                              'If this one was autogenerated by a previous compilation, ' +
        cbilling:                              'and you wish to have a new one autogenerated, '+
        cbilling:                              'simply delete it and run again, or add the \'-f\' command line ' +
        cbilling:                              'argument to automatically overwrite.')
        pstarkey:         for device in compiler.inventory:
        cbilling:             if device.parent_device is None:
        pstarkey:                 device.generate_code(hdf5_file)
             jan:                 
             jan:         save_time_markers(hdf5_file)
        pstarkey:         generate_connection_table(hdf5_file)
        cbilling:         write_device_properties(hdf5_file)
        pstarkey:         generate_wait_table(hdf5_file)
        pstarkey:         save_labscripts(hdf5_file)
        pstarkey: 
        pstarkey: def trigger_all_pseudoclocks(t='initial'):
        pstarkey:     # Must wait this long before providing a trigger, in case child clocks aren't ready yet:
        pstarkey:     wait_delay = compiler.wait_delay
          rander:     if type(t) in [str, bytes] and t == 'initial':
        pstarkey:         # But not at the start of the experiment:
        pstarkey:         wait_delay = 0
        pstarkey:     # Trigger them all:
        pstarkey:     for pseudoclock in compiler.all_pseudoclocks:
        pstarkey:         pseudoclock.trigger(t, compiler.trigger_duration)
        pstarkey:     # How long until all devices can take instructions again? The user
        pstarkey:     # can command output from devices on the master clock immediately,
        pstarkey:     # but unless things are time critical, they can wait this long and
        pstarkey:     # know for sure all devices can receive instructions:
        pstarkey:     max_delay_time = max_or_zero([pseudoclock.trigger_delay for pseudoclock in compiler.all_pseudoclocks if not pseudoclock.is_master_pseudoclock])
        pstarkey:     # On the other hand, perhaps the trigger duration and clock limit of the master clock is
        pstarkey:     # limiting when we can next give devices instructions:
        pstarkey:     # So find the max of 1.0/clock_limit of every clockline on every pseudoclock of the master pseudoclock
        pstarkey:     master_pseudoclock_delay = max(1.0/compiler.master_pseudoclock.clock_limit, max_or_zero([1.0/clockline.clock_limit for pseudoclock in compiler.master_pseudoclock.child_devices for clockline in pseudoclock.child_devices]))
        pstarkey:     max_delay = max(compiler.trigger_duration + master_pseudoclock_delay, max_delay_time)    
        pstarkey:     return max_delay + wait_delay
        pstarkey:     
        pstarkey: def wait(label, t, timeout=5):
        pstarkey:     if not str(label):
        pstarkey:         raise LabscriptError('Wait must have a name')
        pstarkey:     max_delay = trigger_all_pseudoclocks(t)
        pstarkey:     if t in compiler.wait_table:
        pstarkey:         raise LabscriptError('There is already a wait at t=%s'%str(t))
          philip:     if any([label==existing_label for existing_label, _ in compiler.wait_table.values()]):
        pstarkey:         raise LabscriptError('There is already a wait named %s'%str(label))
        pstarkey:     compiler.wait_table[t] = str(label), float(timeout)
        pstarkey:     return max_delay
        pstarkey: 
        shjohnst: def add_time_marker(t, label, color=(0,0,0), verbose = False):
             jan:     #color in rgb
        shjohnst:     if verbose:
        shjohnst:         functions.print_time(t,label)
             jan:     compiler.time_markers[t] = {"label":label, "color":color}
             jan: 
        pstarkey: def start():
        pstarkey:     compiler.start_called = True
        pstarkey:     # Get and save some timing info about the pseudoclocks:
        pstarkey:     # TODO: What if you need to trigger individual Pseudolocks on the one device, rather than the PseudoclockDevice as a whole?
        cbilling:     pseudoclocks = [device for device in compiler.inventory if isinstance(device, PseudoclockDevice)]
        cbilling:     compiler.all_pseudoclocks = pseudoclocks
        cbilling:     toplevel_devices = [device for device in compiler.inventory if device.parent_device is None]
        cbilling:     master_pseudoclocks = [pseudoclock for pseudoclock in pseudoclocks if pseudoclock.is_master_pseudoclock]
        cbilling:     if len(master_pseudoclocks) > 1:
        cbilling:         raise LabscriptError('Cannot have more than one master pseudoclock')
        cbilling:     if not toplevel_devices:
        cbilling:         raise LabscriptError('No toplevel devices and no master pseudoclock found')
        cbilling:     elif pseudoclocks:
        cbilling:         (master_pseudoclock,) = master_pseudoclocks
        cbilling:         compiler.master_pseudoclock = master_pseudoclock
        cbilling:         # Which pseudoclock requires the longest pulse in order to trigger it?
        cbilling:         compiler.trigger_duration = max_or_zero([pseudoclock.trigger_minimum_duration for pseudoclock in pseudoclocks if not pseudoclock.is_master_pseudoclock])
        cbilling:         
        cbilling:         trigger_clock_limits = [pseudoclock.trigger_device.clock_limit for pseudoclock in pseudoclocks if not pseudoclock.is_master_pseudoclock]
        cbilling:         if len(trigger_clock_limits) > 0:
        cbilling:             min_clock_limit = min(trigger_clock_limits)
        cbilling:             min_clock_limit = min([min_clock_limit, master_pseudoclock.clock_limit])
        cbilling:         else:
        cbilling:             min_clock_limit = master_pseudoclock.clock_limit
        pstarkey:     
        pstarkey:         # ensure we don't tick faster than attached devices to the master pseudoclock can handle
        pstarkey:         clockline_limits = [clockline.clock_limit for pseudoclock in master_pseudoclock.child_devices for clockline in pseudoclock.child_devices]
        pstarkey:         min_clock_limit = min(min_clock_limit, min(clockline_limits))
        pstarkey:     
        cbilling:         # check the minimum trigger duration for the waitmonitor
        cbilling:         if compiler.wait_monitor is not None:
        cbilling:             compiler.trigger_duration = max(compiler.trigger_duration, 2.0/compiler.wait_monitor.clock_limit)
        cbilling:         # Provide this, or the minimum possible pulse, whichever is longer:
        pstarkey:         compiler.trigger_duration = max(2.0/min_clock_limit, compiler.trigger_duration) + 2*master_pseudoclock.clock_resolution
        cbilling:         # Must wait this long before providing a trigger, in case child clocks aren't ready yet:
        cbilling:         compiler.wait_delay = max_or_zero([pseudoclock.wait_delay for pseudoclock in pseudoclocks if not pseudoclock.is_master_pseudoclock])
        cbilling:         
        cbilling:         # Have the master clock trigger pseudoclocks at t = 0:
        cbilling:         max_delay = trigger_all_pseudoclocks()
        cbilling:     else:
        cbilling:         # No pseudoclocks, only other toplevel devices:
        cbilling:         compiler.master_pseudoclock = None
        cbilling:         compiler.trigger_duration = 0
        cbilling:         compiler.wait_delay = 0
        cbilling:         max_delay = 0
        pstarkey:     return max_delay
        pstarkey:     
        pstarkey: def stop(t):
        pstarkey:     # Indicate the end of an experiment and initiate compilation:
        pstarkey:     if t == 0:
        pstarkey:         raise LabscriptError('Stop time cannot be t=0. Please make your run a finite duration')
        pstarkey:     for device in compiler.inventory:
        pstarkey:         if isinstance(device, PseudoclockDevice):
        pstarkey:             device.stop_time = t
        pstarkey:     generate_code()
        pstarkey: 
        pstarkey: # TO_DELETE:runmanager-batchompiler-agnostic
        pstarkey: #   entire function load_globals can be deleted
        pstarkey: def load_globals(hdf5_filename):
        pstarkey:     import runmanager
        cbilling:     params = runmanager.get_shot_globals(hdf5_filename)
        pstarkey:     with h5py.File(hdf5_filename,'r') as hdf5_file:
        pstarkey:         for name in params.keys():
        pstarkey:             if name in globals() or name in locals() or name in _builtins_dict:
        pstarkey:                 raise LabscriptError('Error whilst parsing globals from %s. \'%s\''%(hdf5_filename,name) +
        pstarkey:                                      ' is already a name used by Python, labscript, or Pylab.'+
        pstarkey:                                      ' Please choose a different variable name to avoid a conflict.')
        pstarkey:             if name in keyword.kwlist:
        pstarkey:                 raise LabscriptError('Error whilst parsing globals from %s. \'%s\''%(hdf5_filename,name) +
        pstarkey:                                      ' is a reserved Python keyword.' +
        pstarkey:                                      ' Please choose a different variable name.')
        pstarkey:             try:
        pstarkey:                 assert '.' not in name
        pstarkey:                 exec(name + ' = 0')
        pstarkey:                 exec('del ' + name )
        pstarkey:             except:
        pstarkey:                 raise LabscriptError('ERROR whilst parsing globals from %s. \'%s\''%(hdf5_filename,name) +
        pstarkey:                                      'is not a valid Python variable name.' +
        pstarkey:                                      ' Please choose a different variable name.')
        pstarkey:                                      
        pstarkey:             # Workaround for the fact that numpy.bool_ objects dont 
        pstarkey:             # match python's builtin True and False when compared with 'is':
        pstarkey:             if type(params[name]) == bool_: # bool_ is numpy.bool_, imported from pylab
        pstarkey:                 params[name] = bool(params[name])                         
        cbilling:             # 'None' is stored as an h5py null object reference:
        cbilling:             if isinstance(params[name], h5py.Reference) and not params[name]:
        cbilling:                 params[name] = None
        pstarkey:             _builtins_dict[name] = params[name]
        pstarkey:             
        pstarkey: # TO_DELETE:runmanager-batchompiler-agnostic 
        pstarkey: #   load_globals_values=True            
        pstarkey: def labscript_init(hdf5_filename, labscript_file=None, new=False, overwrite=False, load_globals_values=True):
        pstarkey:     # save the builtins for later restoration in labscript_cleanup
        pstarkey:     compiler._existing_builtins_dict = _builtins_dict.copy()
        pstarkey:     
        pstarkey:     if new:
        cbilling:         # defer file creation until generate_code(), so that filesystem
        cbilling:         # is not littered with h5 files when the user merely imports
        cbilling:         # labscript. If the file already exists, and overwrite is true, delete it so we get one fresh.
        cbilling:         if os.path.exists(hdf5_filename) and overwrite:
        cbilling:             os.unlink(hdf5_filename)
        cbilling:     elif not os.path.exists(hdf5_filename):
        pstarkey:         raise LabscriptError('Provided hdf5 filename %s doesn\'t exist.'%hdf5_filename)
        pstarkey:     # TO_DELETE:runmanager-batchompiler-agnostic 
        pstarkey:     elif load_globals_values:
        pstarkey:         load_globals(hdf5_filename) 
        pstarkey:     # END_DELETE:runmanager-batchompiler-agnostic 
        pstarkey:     
        pstarkey:     compiler.hdf5_filename = hdf5_filename
        cbilling:     if labscript_file is None:
        cbilling:         import __main__
        cbilling:         labscript_file = __main__.__file__
        pstarkey:     compiler.labscript_file = os.path.abspath(labscript_file)
        pstarkey:     
        pstarkey: 
        pstarkey: def labscript_cleanup():
        pstarkey:     """restores builtins and the labscript module to its state before
        pstarkey:     labscript_init() was called"""
        pstarkey:     for name in _builtins_dict.copy(): 
        pstarkey:         if name not in compiler._existing_builtins_dict:
        pstarkey:             del _builtins_dict[name]
        pstarkey:         else:
        pstarkey:             _builtins_dict[name] = compiler._existing_builtins_dict[name]
        pstarkey:     
        pstarkey:     compiler.inventory = []
        pstarkey:     compiler.hdf5_filename = None
        pstarkey:     compiler.labscript_file = None
        pstarkey:     compiler.start_called = False
        pstarkey:     compiler.wait_table = {}
        pstarkey:     compiler.wait_monitor = None
        pstarkey:     compiler.master_pseudoclock = None
        pstarkey:     compiler.all_pseudoclocks = None
        pstarkey:     compiler.trigger_duration = 0
        pstarkey:     compiler.wait_delay = 0
             jan:     compiler.time_markers = {}
        pstarkey:     compiler._PrimaryBLACS = None
             jan:     compiler.save_hg_info = True
             jan: 
     janwerkmann: class compiler(object):
        pstarkey:     # The labscript file being compiled:
        pstarkey:     labscript_file = None
        pstarkey:     # All defined devices:
        pstarkey:     inventory = []
        pstarkey:     # The filepath of the h5 file containing globals and which will
        pstarkey:     # contain compilation output:
        pstarkey:     hdf5_filename = None
        pstarkey:     start_called = False
        pstarkey:     wait_table = {}
        pstarkey:     wait_monitor = None
        pstarkey:     master_pseudoclock = None
        pstarkey:     all_pseudoclocks = None
        pstarkey:     trigger_duration = 0
        pstarkey:     wait_delay = 0
             jan:     time_markers = {}
        pstarkey:     _PrimaryBLACS = None
             jan:     save_hg_info = True
             jan: 
        pstarkey:     # safety measure in case cleanup is called before init
        pstarkey:     _existing_builtins_dict = _builtins_dict.copy() 
