        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /__init__.py                                                      #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: 
           Chris: __version__ = '2.2.0'
chrisjbillington: 
chrisjbillington: 
chrisjbillington: import os
chrisjbillington: from labscript_utils import labscript_suite_install_dir
chrisjbillington: if labscript_suite_install_dir is not None:
chrisjbillington:     BLACS_DIR = os.path.join(labscript_suite_install_dir, 'blacs')
chrisjbillington: else:
chrisjbillington:     # No labscript install directory found? Fall back to relying on __file__ and
chrisjbillington:     # hope that it is not a relative path that has been invalidated by a call to
chrisjbillington:     # os.chdir() between interpreter start and now (this can happen if blacs is run
chrisjbillington:     # with python 2 using "python -m blacs" whilst the current directory is the
chrisjbillington:     # parent of the blacs directory):
chrisjbillington:     BLACS_DIR = os.path.dirname(os.path.realpath(__file__))
chrisjbillington: if not os.path.isdir(BLACS_DIR):
chrisjbillington:     # Don't want to continue if we have not found the directory:
chrisjbillington:     msg = "Cannot locate the directory BLACS is installed in."
chrisjbillington:     raise RuntimeError(msg)
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /main.pyw                                                         #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann: 
            Phil: import logging, logging.handlers
            Phil: import os
            Phil: import socket
        pstarkey: import subprocess
            Phil: import sys
        pstarkey: import time
            Phil: 
        cbilling: import signal
        cbilling: # Quit on ctrl-c
        cbilling: signal.signal(signal.SIGINT, signal.SIG_DFL)
        cbilling: 
        pstarkey: # check if we should delay!
        pstarkey: try:
        pstarkey:     if '--delay' in sys.argv:
        pstarkey:         delay = int(sys.argv[sys.argv.index('--delay')+1])
        pstarkey:         time.sleep(delay)
        pstarkey: except:
     janwerkmann:     print('You should specify "--delay x" where x is an integer')
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
     janwerkmann: from qtutils.qt import QT_ENV
     janwerkmann: from qtutils.qt.QtCore import pyqtSignal as Signal
        cbilling: 
        cbilling: try:
        cbilling:     from labscript_utils import check_version
        cbilling: except ImportError:
        cbilling:     raise ImportError('Require labscript_utils > 2.1.0')
        cbilling: 
chrisjbillington: check_version('labscript_utils', '2.7.1', '3')
     janwerkmann: check_version('qtutils', '2.0.0', '3.0.0')
           Chris: check_version('zprocess', '1.1.2', '3')
        pstarkey: check_version('labscript_devices', '2.0', '3')
        pstarkey: 
        cbilling: 
        pstarkey: # Pythonlib imports
        pstarkey: ### Must be in this order
        pstarkey: import zprocess.locking, labscript_utils.h5_lock, h5py
        pstarkey: zprocess.locking.set_client_process_name('BLACS')
        pstarkey: ###
             jan: from zprocess import zmq_get, ZMQServer, raise_exception_in_thread
          rander: from labscript_utils.setup_logging import setup_logging
        pstarkey: import labscript_utils.shared_drive
            Phil: 
        cbilling: # Custom Excepthook
        pstarkey: import labscript_utils.excepthook
        cbilling: # Setup logging
          rander: logger = setup_logging('BLACS')
        pstarkey: labscript_utils.excepthook.set_logger(logger)
        cbilling: 
        pstarkey: # now log versions (must be after setup logging)
        pstarkey: try:
        pstarkey:     import sys
        pstarkey:     logger.info('Python Version: %s'%sys.version)
        pstarkey:     logger.info('Platform: %s'%sys.platform)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find python version')
        pstarkey: 
        pstarkey: try:
        pstarkey:     import sys
        pstarkey:     logger.info('windows version: %s'%str(sys.getwindowsversion()))
        pstarkey: except Exception:
        pstarkey:     pass
        cbilling: 
        pstarkey: try:
        pstarkey:     import zmq
        pstarkey:     logger.info('PyZMQ Version: %s'%zmq.__version__)
        pstarkey:     logger.info('ZMQ Version: %s'%zmq.zmq_version())
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find PyZMQ version')
        pstarkey: 
        pstarkey: try:
        pstarkey:     import h5py
        pstarkey:     logger.info('h5py Version: %s'%h5py.version.info)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find h5py version')
        cbilling: 
        pstarkey: try:
     janwerkmann:     logger.info('Qt Enviroment: %s' % QT_ENV)
     janwerkmann:     logger.info('PySide/PyQt Version: %s' % PYQT_VERSION_STR)
     janwerkmann:     logger.info('Qt Version: %s' % QT_VERSION_STR)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find PySide/PyQt version')
        pstarkey: 
        pstarkey: try:
        pstarkey:     import qtutils
        pstarkey:     logger.info('qtutils Version: %s'%qtutils.__version__)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find qtutils version')
        cbilling: 
        pstarkey: try:
        pstarkey:     import zprocess
        pstarkey:     logger.info('zprocess Version: %s'%zprocess.__version__)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find zprocess version')
        cbilling: 
        pstarkey: try:
        pstarkey:     import labscript_utils
        pstarkey:     logger.info('labscript_utils Version: %s'%labscript_utils.__version__)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find labscript_utils version')
            Phil: 
        pstarkey: try:
        pstarkey:     import blacs
        pstarkey:     logger.info('BLACS Version: %s'%blacs.__version__)
        pstarkey: except Exception:
        pstarkey:     logger.error('Failed to find blacs version')
        cbilling: 
        cbilling: 
            Phil: # Connection Table Code
chrisjbillington: from labscript_utils.connections import ConnectionTable
            Phil: #Draggable Tab Widget Code
        pstarkey: from labscript_utils.qtwidgets.dragdroptab import DragDropTabWidget
            Phil: # Lab config code
     janwerkmann: from labscript_utils.labconfig import LabConfig, config_prefix, hostname
            Phil: # Qt utils for running functions in the main thread
            Phil: from qtutils import *
        cbilling: # And for icons:
        cbilling: import qtutils.icons
        pstarkey: # Analysis Submission code
chrisjbillington: from blacs.analysis_submission import AnalysisSubmission
            Phil: # Queue Manager Code
chrisjbillington: from blacs.experiment_queue import QueueManager, QueueTreeview
        cbilling: # Module containing hardware compatibility:
        cbilling: import labscript_devices
        pstarkey: # Save/restore frontpanel code
chrisjbillington: from blacs.front_panel_settings import FrontPanelSettings
        pstarkey: # Notifications system
chrisjbillington: from blacs.notifications import Notifications
        pstarkey: # Preferences system
        pstarkey: from labscript_utils.settings import Settings
        pstarkey: #import settings_pages
chrisjbillington: import blacs.plugins as plugins
            Phil: 
chrisjbillington: from blacs import BLACS_DIR
        cbilling: 
        cbilling: 
        cbilling: def set_win_appusermodel(window_id):
        cbilling:     from labscript_utils.winshell import set_appusermodel, appids, app_descriptions
        cbilling:     icon_path = os.path.abspath('blacs.ico')
        cbilling:     executable = sys.executable.lower()
        cbilling:     if not executable.endswith('w.exe'):
        cbilling:         executable = executable.replace('.exe', 'w.exe')
chrisjbillington:     relaunch_command = executable + ' ' + os.path.join(BLACS_DIR, '__main__.py')
        cbilling:     relaunch_display_name = app_descriptions['blacs']
        cbilling:     set_appusermodel(window_id, appids['blacs'], icon_path, relaunch_command, relaunch_display_name)
        cbilling: 
        cbilling: 
        pstarkey: class BLACSWindow(QMainWindow):
        cbilling:     newWindow = Signal(int)
        cbilling: 
        cbilling:     def event(self, event):
        cbilling:         result = QMainWindow.event(self, event)
        cbilling:         if event.type() == QEvent.WinIdChange:
        cbilling:             self.newWindow.emit(self.effectiveWinId())
        cbilling:         return result
        cbilling: 
        pstarkey:     def closeEvent(self, event):
        pstarkey:         #print 'aaaaa'
        pstarkey:         if self.blacs.exit_complete:
        pstarkey:             event.accept()
        pstarkey:             if self.blacs._relaunch:
        pstarkey:                 logger.info('relaunching BLACS after quit')
        pstarkey:                 relaunch_delay = '2'
        pstarkey:                 if '--delay' in sys.argv:
        pstarkey:                     index = sys.argv.index('--delay') + 1
        pstarkey:                     try:
        pstarkey:                         int(sys.argv[index])
        pstarkey:                         sys.argv[index] = relaunch_delay
        pstarkey:                     except:
        pstarkey:                         sys.argv.insert(index,relaunch_delay)
        pstarkey:                 else:
        pstarkey:                     sys.argv.append('--delay')
        pstarkey:                     sys.argv.append(relaunch_delay)
        pstarkey:                 subprocess.Popen([sys.executable] + sys.argv)
        pstarkey:         else:
        pstarkey:             event.ignore()
        pstarkey:             logger.info('destroy called')
        pstarkey:             if not self.blacs.exiting:
        pstarkey:                 self.blacs.exiting = True
        pstarkey:                 self.blacs.queue.manager_running = False
        pstarkey:                 self.blacs.settings.close()
        cbilling:                 experiment_server.shutdown()
        pstarkey:                 for module_name, plugin in self.blacs.plugins.items():
        pstarkey:                     try:
        pstarkey:                         plugin.close()
        pstarkey:                     except Exception as e:
        pstarkey:                         logger.error('Could not close plugin %s. Error was: %s'%(module_name,str(e)))
        cbilling: 
        pstarkey:                 inmain_later(self.blacs.on_save_exit)
        cbilling: 
        pstarkey:             QTimer.singleShot(100,self.close)
        cbilling: 
            Phil: class BLACS(object):
            Phil: 
            Phil:     tab_widget_ids = 7
        cbilling: 
        pstarkey:     def __init__(self,application):
        pstarkey:         self.qt_application = application
        pstarkey:         #self.qt_application.aboutToQuit.connect(self.destroy)
        pstarkey:         self._relaunch = False
        pstarkey:         self.exiting = False
        pstarkey:         self.exit_complete = False
        cbilling: 
        pstarkey:         logger.info('Loading BLACS ui')
        pstarkey:         #self.ui = BLACSWindow(self).ui
        pstarkey:         loader = UiLoader()
        pstarkey:         loader.registerCustomWidget(QueueTreeview)
        pstarkey:         #loader.registerCustomPromotion('BLACS',BLACSWindow)
chrisjbillington:         self.ui = loader.load(os.path.join(BLACS_DIR, 'main.ui'), BLACSWindow())
        pstarkey:         logger.info('BLACS ui loaded')
        pstarkey:         self.ui.blacs=self
        pstarkey:         self.tab_widgets = {}
        pstarkey:         self.exp_config = exp_config # Global variable
        pstarkey:         self.settings_path = settings_path # Global variable
        pstarkey:         self.connection_table = connection_table # Global variable
            Phil:         self.connection_table_h5file = self.exp_config.get('paths','connection_table_h5')
            Phil:         self.connection_table_labscript = self.exp_config.get('paths','connection_table_py')
        cbilling: 
        pstarkey:         # Setup the UI
        pstarkey:         self.ui.main_splitter.setStretchFactor(0,0)
        pstarkey:         self.ui.main_splitter.setStretchFactor(1,1)
        cbilling: 
        pstarkey:         self.tablist = {}
        pstarkey:         self.panes = {}
        pstarkey:         self.settings_dict = {}
        cbilling: 
        cbilling:         # Find which devices are connected to BLACS, and what their labscript class names are:
        cbilling:         logger.info('finding connected devices in connection table')
        cbilling:         self.attached_devices = self.connection_table.get_attached_devices()
        cbilling: 
        pstarkey:         # Store the panes in a dictionary for easy access
        pstarkey:         self.panes['tab_top_vertical_splitter'] = self.ui.tab_top_vertical_splitter
        pstarkey:         self.panes['tab_bottom_vertical_splitter'] = self.ui.tab_bottom_vertical_splitter
        pstarkey:         self.panes['tab_horizontal_splitter'] = self.ui.tab_horizontal_splitter
        pstarkey:         self.panes['main_splitter'] = self.ui.main_splitter
        cbilling: 
        cbilling:         # Get settings to restore
        pstarkey:         logger.info('Loading front panel settings')
        pstarkey:         self.front_panel_settings = FrontPanelSettings(self.settings_path, self.connection_table)
        pstarkey:         self.front_panel_settings.setup(self)
        pstarkey:         settings,question,error,tab_data = self.front_panel_settings.restore()
        cbilling: 
        pstarkey:         # TODO: handle question/error cases
        cbilling: 
        pstarkey:         logger.info('restoring window data')
        pstarkey:         self.restore_window(tab_data)
        cbilling: 
        pstarkey:         #splash.update_text('Creating the device tabs...')
        pstarkey:         # Create the notebooks
        pstarkey:         logger.info('Creating tab widgets')
            Phil:         for i in range(4):
        pstarkey:             self.tab_widgets[i] = DragDropTabWidget(self.tab_widget_ids)
chrisjbillington:             self.tab_widgets[i].setElideMode(Qt.ElideRight)
            Phil:             getattr(self.ui,'tab_container_%d'%i).addWidget(self.tab_widgets[i])
        cbilling: 
        pstarkey:         logger.info('Instantiating devices')
             jan:         self.failed_device_settings = {}
        cbilling:         for device_name, labscript_device_class_name in self.attached_devices.items():
             jan:             try:
             jan:                 self.settings_dict.setdefault(device_name,{"device_name":device_name})
             jan:                 # add common keys to settings:
             jan:                 self.settings_dict[device_name]["connection_table"] = self.connection_table
             jan:                 self.settings_dict[device_name]["front_panel_settings"] = settings[device_name] if device_name in settings else {}
             jan:                 self.settings_dict[device_name]["saved_data"] = tab_data[device_name]['data'] if device_name in tab_data else {}
             jan:                 # Instantiate the device
             jan:                 logger.info('instantiating %s'%device_name)
             jan:                 TabClass = labscript_devices.get_BLACS_tab(labscript_device_class_name)
             jan:                 self.tablist[device_name] = TabClass(self.tab_widgets[0],self.settings_dict[device_name])
             jan:             except Exception:
             jan:                 self.failed_device_settings[device_name] = {"front_panel": self.settings_dict[device_name]["front_panel_settings"], "save_data": self.settings_dict[device_name]["saved_data"]}
             jan:                 del self.settings_dict[device_name]
             jan:                 del self.attached_devices[device_name]
             jan:                 self.connection_table.remove_device(device_name)
             jan:                 raise_exception_in_thread(sys.exc_info())
        cbilling: 
        pstarkey:         logger.info('reordering tabs')
        pstarkey:         self.order_tabs(tab_data)
        cbilling: 
        pstarkey:         logger.info('starting analysis submission thread')
        pstarkey:         # setup analysis submission
        pstarkey:         self.analysis_submission = AnalysisSubmission(self,self.ui)
        pstarkey:         if 'analysis_data' not in tab_data['BLACS settings']:
        pstarkey:             tab_data['BLACS settings']['analysis_data'] = {}
        pstarkey:         else:
        pstarkey:             tab_data['BLACS settings']['analysis_data'] = eval(tab_data['BLACS settings']['analysis_data'])
        pstarkey:         self.analysis_submission.restore_save_data(tab_data['BLACS settings']["analysis_data"])
        cbilling: 
        pstarkey:         logger.info('starting queue manager thread')
            Phil:         # Setup the QueueManager
        cbilling:         self.queue = QueueManager(self,self.ui)
        pstarkey:         if 'queue_data' not in tab_data['BLACS settings']:
        pstarkey:             tab_data['BLACS settings']['queue_data'] = {}
        pstarkey:         else:
     janwerkmann:             # quick fix for qt objects not loading that were saved before qtutil 2 changes
     janwerkmann:             try:
     janwerkmann:                 tab_data['BLACS settings']['queue_data'] = eval(tab_data['BLACS settings']['queue_data'])
     janwerkmann:             except NameError:
     janwerkmann:                 tab_data['BLACS settings']['queue_data'] = {}
        pstarkey:         self.queue.restore_save_data(tab_data['BLACS settings']['queue_data'])
        cbilling: 
        pstarkey:         logger.info('instantiating plugins')
        pstarkey:         # setup the plugin system
        pstarkey:         settings_pages = []
        pstarkey:         self.plugins = {}
        pstarkey:         plugin_settings = eval(tab_data['BLACS settings']['plugin_data']) if 'plugin_data' in tab_data['BLACS settings'] else {}
        cbilling:         for module_name, module in plugins.modules.items():
        pstarkey:             try:
        pstarkey:                 # instantiate the plugin
        cbilling:                 self.plugins[module_name] = module.Plugin(plugin_settings[module_name] if module_name in plugin_settings else {})
        cbilling:             except Exception:
        cbilling:                 logger.exception('Could not instantiate plugin \'%s\'. Skipping')
        cbilling: 
        pstarkey:         blacs_data = {'exp_config':self.exp_config,
        pstarkey:                       'ui':self.ui,
        pstarkey:                       'set_relaunch':self.set_relaunch,
        pstarkey:                       'plugins':self.plugins,
        pstarkey:                       'connection_table_h5file':self.connection_table_h5file,
        pstarkey:                       'connection_table_labscript':self.connection_table_labscript,
        pstarkey:                       'experiment_queue':self.queue
        pstarkey:                      }
        cbilling: 
        pstarkey:         def create_menu(parent, menu_parameters):
        pstarkey:             if 'name' in menu_parameters:
        pstarkey:                 if 'menu_items' in menu_parameters:
        pstarkey:                     child = parent.addMenu(menu_parameters['name'])
        pstarkey:                     for child_menu_params in menu_parameters['menu_items']:
        pstarkey:                         create_menu(child,child_menu_params)
        pstarkey:                 else:
chrisjbillington:                     if 'icon' in menu_parameters:
chrisjbillington:                         child = parent.addAction(QIcon(menu_parameters['icon']), menu_parameters['name'])
chrisjbillington:                     else:
chrisjbillington:                         child = parent.addAction(menu_parameters['name'])
        cbilling: 
        cbilling:                 if 'action' in menu_parameters:
        cbilling:                     child.triggered.connect(menu_parameters['action'])
        cbilling: 
        pstarkey:             elif 'separator' in menu_parameters:
        pstarkey:                 parent.addSeparator()
        cbilling: 
        pstarkey:         # setup the Notification system
        pstarkey:         logger.info('setting up notification system')
        pstarkey:         self.notifications = Notifications(blacs_data)
        cbilling: 
        pstarkey:         settings_callbacks = []
        pstarkey:         for module_name, plugin in self.plugins.items():
        pstarkey:             try:
        pstarkey:                 # Setup settings page
        pstarkey:                 settings_pages.extend(plugin.get_setting_classes())
        pstarkey:                 # Setup menu
        pstarkey:                 if plugin.get_menu_class():
        pstarkey:                     # must store a reference or else the methods called when the menu actions are triggered
        pstarkey:                     # (contained in this object) will be garbaged collected
        pstarkey:                     menu = plugin.get_menu_class()(blacs_data)
        pstarkey:                     create_menu(self.ui.menubar,menu.get_menu_items())
        pstarkey:                     plugin.set_menu_instance(menu)
        cbilling: 
        pstarkey:                 # Setup notifications
        pstarkey:                 plugin_notifications = {}
        pstarkey:                 for notification_class in plugin.get_notification_classes():
        pstarkey:                     self.notifications.add_notification(notification_class)
        pstarkey:                     plugin_notifications[notification_class] = self.notifications.get_instance(notification_class)
        pstarkey:                 plugin.set_notification_instances(plugin_notifications)
        cbilling: 
        pstarkey:                 # Register callbacks
        pstarkey:                 callbacks = plugin.get_callbacks()
        pstarkey:                 # save the settings_changed callback in a separate list for setting up later
        pstarkey:                 if isinstance(callbacks,dict) and 'settings_changed' in callbacks:
        pstarkey:                     settings_callbacks.append(callbacks['settings_changed'])
        cbilling: 
        cbilling:             except Exception:
        cbilling:                 logger.exception('Plugin \'%s\' error. Plugin may not be functional.'%module_name)
        cbilling: 
        cbilling: 
        pstarkey:         # setup the BLACS preferences system
        pstarkey:         logger.info('setting up preferences system')
        pstarkey:         self.settings = Settings(file=self.settings_path, parent = self.ui, page_classes=settings_pages)
        cbilling:         for callback in settings_callbacks:
        pstarkey:             self.settings.register_callback(callback)
        cbilling: 
        pstarkey:         # update the blacs_data dictionary with the settings system
        pstarkey:         blacs_data['settings'] = self.settings
        cbilling: 
        pstarkey:         for module_name, plugin in self.plugins.items():
        pstarkey:             try:
        pstarkey:                 plugin.plugin_setup_complete(blacs_data)
        cbilling:             except Exception:
        pstarkey:                 # backwards compatibility for old plugins
        pstarkey:                 try:
        pstarkey:                     plugin.plugin_setup_complete()
        pstarkey:                     logger.warning('Plugin \'%s\' using old API. Please update Plugin.plugin_setup_complete method to accept a dictionary of blacs_data as the only argument.'%module_name)
        pstarkey:                 except Exception:
        pstarkey:                     logger.exception('Plugin \'%s\' error. Plugin may not be functional.'%module_name)
        cbilling: 
        pstarkey:         # Connect menu actions
        pstarkey:         self.ui.actionOpenPreferences.triggered.connect(self.on_open_preferences)
        pstarkey:         self.ui.actionSave.triggered.connect(self.on_save_front_panel)
        cbilling:         self.ui.actionOpen.triggered.connect(self.on_load_front_panel)
chrisjbillington:         self.ui.actionExit.triggered.connect(self.ui.close)
        cbilling: 
        cbilling:         # Connect the windows AppId stuff:
        cbilling:         if os.name == 'nt':
        cbilling:             self.ui.newWindow.connect(set_win_appusermodel)
        cbilling: 
        pstarkey:         logger.info('showing UI')
            Phil:         self.ui.show()
        cbilling: 
        pstarkey:     def set_relaunch(self,value):
        pstarkey:         self._relaunch = bool(value)
        cbilling: 
        pstarkey:     def restore_window(self,tab_data):
        pstarkey:         # read out position settings:
        pstarkey:         try:
        pstarkey:             # There are some dodgy hacks going on here to try and restore the window position correctly
        pstarkey:             # Unfortunately Qt has two ways of measuring teh window position, one with the frame/titlebar
        pstarkey:             # and one without. If you use the one that measures including the titlebar, you don't
        pstarkey:             # know what the window size was when the window was UNmaximized.
        pstarkey:             #
        pstarkey:             # Anyway, no idea if this works cross platform (tested on windows 8)
        pstarkey:             # Feel free to rewrite this, along with the code in front_panel_settings.py
        pstarkey:             # which stores the values
        pstarkey:             #
        cbilling:             # Actually this is a waste of time because if you close when maximized, reoopen and then
        pstarkey:             # de-maximize, the window moves to a random position (not the position it was at before maximizing)
        pstarkey:             # so bleh!
        pstarkey:             self.ui.move(tab_data['BLACS settings']["window_xpos"]-tab_data['BLACS settings']['window_frame_width']/2,tab_data['BLACS settings']["window_ypos"]-tab_data['BLACS settings']['window_frame_height']+tab_data['BLACS settings']['window_frame_width']/2)
        pstarkey:             self.ui.resize(tab_data['BLACS settings']["window_width"],tab_data['BLACS settings']["window_height"])
        cbilling: 
        pstarkey:             if 'window_maximized' in tab_data['BLACS settings'] and tab_data['BLACS settings']['window_maximized']:
        pstarkey:                 self.ui.showMaximized()
        cbilling: 
        pstarkey:             for pane_name,pane in self.panes.items():
        pstarkey:                 pane.setSizes(tab_data['BLACS settings'][pane_name])
        cbilling: 
        pstarkey:         except Exception as e:
        pstarkey:             logger.warning("Unable to load window and notebook defaults. Exception:"+str(e))
        cbilling: 
        pstarkey:     def order_tabs(self,tab_data):
        pstarkey:         # Move the tabs to the correct notebook
        cbilling:         for device_name in self.attached_devices:
        pstarkey:             notebook_num = 0
        pstarkey:             if device_name in tab_data:
        pstarkey:                 notebook_num = int(tab_data[device_name]["notebook"])
        cbilling:                 if notebook_num not in self.tab_widgets:
        pstarkey:                     notebook_num = 0
        cbilling: 
        pstarkey:             #Find the notebook the tab is in, and remove it:
        pstarkey:             for notebook in self.tab_widgets.values():
        pstarkey:                 tab_index = notebook.indexOf(self.tablist[device_name]._ui)
        pstarkey:                 if tab_index != -1:
        pstarkey:                     notebook.removeTab(tab_index)
        pstarkey:                     self.tab_widgets[notebook_num].addTab(self.tablist[device_name]._ui,device_name)
        pstarkey:                     break
        cbilling: 
        pstarkey:         # splash.update_text('restoring tab positions...')
        pstarkey:         # # Now that all the pages are created, reorder them!
        cbilling:         for device_name in self.attached_devices:
        pstarkey:             if device_name in tab_data:
        pstarkey:                 notebook_num = int(tab_data[device_name]["notebook"])
        cbilling:                 if notebook_num in self.tab_widgets:
        pstarkey:                     self.tab_widgets[notebook_num].tab_bar.moveTab(self.tab_widgets[notebook_num].indexOf(self.tablist[device_name]._ui),int(tab_data[device_name]["page"]))
        cbilling: 
        pstarkey:         # # Now that they are in the correct order, set the correct one visible
        pstarkey:         for device_name,device_data in tab_data.items():
        pstarkey:             if device_name == 'BLACS settings':
        pstarkey:                 continue
        pstarkey:             # if the notebook still exists and we are on the entry that is visible
        pstarkey:             if bool(device_data["visible"]) and int(device_data["notebook"]) in self.tab_widgets:
        pstarkey:                 self.tab_widgets[int(device_data["notebook"])].tab_bar.setCurrentIndex(int(device_data["page"]))
        cbilling: 
        pstarkey:     def update_all_tab_settings(self,settings,tab_data):
        pstarkey:         for device_name,tab in self.tablist.items():
        pstarkey:             self.settings_dict[device_name]["front_panel_settings"] = settings[device_name] if device_name in settings else {}
        cbilling:             self.settings_dict[device_name]["saved_data"] = tab_data[device_name]['data'] if device_name in tab_data else {}
        pstarkey:             tab.update_from_settings(self.settings_dict[device_name])
        cbilling: 
        cbilling: 
        pstarkey:     def on_load_front_panel(self,*args,**kwargs):
        pstarkey:         # get the file:
        pstarkey:         # create file chooser dialog
        pstarkey:         dialog = QFileDialog(None,"Select file to load", self.exp_config.get('paths','experiment_shot_storage'), "HDF5 files (*.h5 *.hdf5)")
        pstarkey:         dialog.setViewMode(QFileDialog.Detail)
        pstarkey:         dialog.setFileMode(QFileDialog.ExistingFile)
        pstarkey:         if dialog.exec_():
        pstarkey:             selected_files = dialog.selectedFiles()
        pstarkey:             filepath = str(selected_files[0])
        pstarkey:             # Qt has this weird behaviour where if you type in the name of a file that exists
        pstarkey:             # but does not have the extension you have limited the dialog to, the OK button is greyed out
        cbilling:             # but you can hit enter and the file will be selected.
        pstarkey:             # So we must check the extension of each file here!
        pstarkey:             if filepath.endswith('.h5') or filepath.endswith('.hdf5'):
        pstarkey:                 try:
        pstarkey:                     # TODO: Warn that this will restore values, but not channels that are locked
        pstarkey:                     message = QMessageBox()
        pstarkey:                     message.setText("""Warning: This will modify front panel values and cause device output values to update.
        pstarkey:                     \nThe queue and files waiting to be sent for analysis will be cleared.
        pstarkey:                     \n
        pstarkey:                     \nNote: Channels that are locked will not be updated.\n\nDo you wish to continue?""")
        pstarkey:                     message.setIcon(QMessageBox.Warning)
        pstarkey:                     message.setWindowTitle("BLACS")
        pstarkey:                     message.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
        cbilling: 
        cbilling:                     if message.exec_() == QMessageBox.Yes:
        pstarkey:                         front_panel_settings = FrontPanelSettings(filepath, self.connection_table)
        pstarkey:                         settings,question,error,tab_data = front_panel_settings.restore()
        pstarkey:                         #TODO: handle question/error
        cbilling: 
        pstarkey:                         # Restore window data
        pstarkey:                         self.restore_window(tab_data)
        cbilling:                         self.order_tabs(tab_data)
        pstarkey:                         self.update_all_tab_settings(settings,tab_data)
        cbilling: 
        pstarkey:                         # restore queue data
        pstarkey:                         if 'queue_data' not in tab_data['BLACS settings']:
        pstarkey:                             tab_data['BLACS settings']['queue_data'] = {}
        pstarkey:                         else:
     janwerkmann:                             # quick fix for qt objects not loading that were saved before qtutil 2 changes
     janwerkmann:                             try:
     janwerkmann:                                 tab_data['BLACS settings']['queue_data'] = eval(tab_data['BLACS settings']['queue_data'])
     janwerkmann:                             except NameError:
     janwerkmann:                                 tab_data['BLACS settings']['queue_data'] = {}
        pstarkey:                         self.queue.restore_save_data(tab_data['BLACS settings']['queue_data'])
        pstarkey:                         # restore analysis data
        pstarkey:                         if 'analysis_data' not in tab_data['BLACS settings']:
        pstarkey:                             tab_data['BLACS settings']['analysis_data'] = {}
        pstarkey:                         else:
        pstarkey:                             tab_data['BLACS settings']['analysis_data'] = eval(tab_data['BLACS settings']['analysis_data'])
        pstarkey:                         self.analysis_submission.restore_save_data(tab_data['BLACS settings']["analysis_data"])
        pstarkey:                 except Exception as e:
        pstarkey:                     logger.exception("Unable to load the front panel in %s."%(filepath))
        pstarkey:                     message = QMessageBox()
        pstarkey:                     message.setText("Unable to load the front panel. The error encountered is printed below.\n\n%s"%str(e))
        pstarkey:                     message.setIcon(QMessageBox.Information)
        pstarkey:                     message.setWindowTitle("BLACS")
        cbilling:                     message.exec_()
        pstarkey:                 finally:
        pstarkey:                     dialog.deleteLater()
        pstarkey:             else:
        pstarkey:                 dialog.deleteLater()
        pstarkey:                 message = QMessageBox()
        pstarkey:                 message.setText("You did not select a file ending with .h5 or .hdf5. Please try again")
        pstarkey:                 message.setIcon(QMessageBox.Information)
        pstarkey:                 message.setWindowTitle("BLACS")
        pstarkey:                 message.exec_()
        pstarkey:                 QTimer.singleShot(10,self.on_load_front_panel)
        cbilling: 
        pstarkey:     def on_save_exit(self):
        pstarkey:         # Save front panel
        pstarkey:         data = self.front_panel_settings.get_save_data()
        cbilling: 
             jan:         if len(self.failed_device_settings) > 0:
             jan:             message = ('Save data from broken tabs? \n Broken tabs are: \n {}'.format(list(self.failed_device_settings.keys())))
             jan:             reply = QMessageBox.question(self.ui, 'Save broken tab data?', message,
             jan:                                                QMessageBox.Yes | QMessageBox.No)
             jan:             if reply == QMessageBox.Yes:
             jan:                 data[0].update(self.failed_device_settings)
             jan: 
        pstarkey:         # with h5py.File(self.settings_path,'r+') as h5file:
        pstarkey:            # if 'connection table' in h5file:
        pstarkey:                # del h5file['connection table']
        cbilling: 
        pstarkey:         self.front_panel_settings.save_front_panel_to_h5(self.settings_path,data[0],data[1],data[2],data[3],{"overwrite":True},force_new_conn_table=True)
        pstarkey:         logger.info('Destroying tabs')
        pstarkey:         for tab in self.tablist.values():
        cbilling:             tab.destroy()
        cbilling: 
        pstarkey:         #gobject.timeout_add(100,self.finalise_quit,time.time())
        pstarkey:         QTimer.singleShot(100,lambda: self.finalise_quit(time.time()))
        cbilling: 
        pstarkey:     def finalise_quit(self,initial_time):
        pstarkey:         logger.info('finalise_quit called')
        pstarkey:         tab_close_timeout = 2
        pstarkey:         # Kill any tabs which didn't close themselves:
     janwerkmann:         for name, tab in list(self.tablist.items()):
        pstarkey:             if tab.destroy_complete:
        pstarkey:                 del self.tablist[name]
        pstarkey:         if self.tablist:
     janwerkmann:             for name, tab in list(self.tablist.items()):
        pstarkey:                 # If a tab has a fatal error or is taking too long to close, force close it:
        pstarkey:                 if (time.time() - initial_time > tab_close_timeout) or tab.state == 'fatal error':
        pstarkey:                     try:
        cbilling:                         tab.close_tab()
        pstarkey:                     except Exception as e:
        pstarkey:                         logger.error('Couldn\'t close tab:\n%s'%str(e))
        pstarkey:                     del self.tablist[name]
        pstarkey:         if self.tablist:
        pstarkey:             QTimer.singleShot(100,lambda: self.finalise_quit(initial_time))
        pstarkey:         else:
        pstarkey:             self.exit_complete = True
        pstarkey:             logger.info('quitting')
        cbilling: 
        pstarkey:     def on_save_front_panel(self,*args,**kwargs):
        pstarkey:         data = self.front_panel_settings.get_save_data()
        cbilling: 
        pstarkey:         # Open save As dialog
        pstarkey:         dialog = QFileDialog(None,"Save BLACS state", self.exp_config.get('paths','experiment_shot_storage'), "HDF5 files (*.h5)")
        pstarkey:         try:
        pstarkey:             dialog.setViewMode(QFileDialog.Detail)
        pstarkey:             dialog.setFileMode(QFileDialog.AnyFile)
        pstarkey:             dialog.setAcceptMode(QFileDialog.AcceptSave)
        cbilling: 
        pstarkey:             if dialog.exec_():
        pstarkey:                 current_file = str(dialog.selectedFiles()[0])
        pstarkey:                 if not current_file.endswith('.h5'):
        pstarkey:                     current_file += '.h5'
        pstarkey:                 self.front_panel_settings.save_front_panel_to_h5(current_file,data[0],data[1],data[2],data[3])
        pstarkey:         except Exception:
        pstarkey:             raise
        pstarkey:         finally:
        pstarkey:             dialog.deleteLater()
        cbilling: 
        pstarkey:     def on_open_preferences(self,*args,**kwargs):
        pstarkey:         self.settings.create_dialog()
        cbilling: 
        pstarkey: class ExperimentServer(ZMQServer):
        pstarkey:     def handler(self, h5_filepath):
     janwerkmann:         print(h5_filepath)
        pstarkey:         message = self.process(h5_filepath)
        pstarkey:         logger.info('Request handler: %s ' % message.strip())
        pstarkey:         return message
            Phil: 
            Phil:     @inmain_decorator(wait_for_return=True)
            Phil:     def process(self,h5_filepath):
            Phil:         # Convert path to local slashes and shared drive prefix:
        cbilling:         logger.info('received filepath: %s'%h5_filepath)
        pstarkey:         h5_filepath = labscript_utils.shared_drive.path_to_local(h5_filepath)
            Phil:         logger.info('local filepath: %s'%h5_filepath)
        pstarkey:         return app.queue.process_request(h5_filepath)
            Phil: 
        cbilling: 
            Phil: if __name__ == '__main__':
        pstarkey:     if 'tracelog' in sys.argv:
        pstarkey:         ##########
        pstarkey:         import labscript_utils.tracelog
chrisjbillington:         labscript_utils.tracelog.log(os.path.join(BLACS_DIR, 'blacs_trace.log'),
chrisjbillington:                                      ['__main__','BLACS.tab_base_classes',
chrisjbillington:                                       'qtutils',
chrisjbillington:                                       'labscript_utils.qtwidgets.ddsoutput',
chrisjbillington:                                       'labscript_utils.qtwidgets.analogoutput',
chrisjbillington:                                       'BLACS.hardware_interfaces.ni_pcie_6363',
chrisjbillington:                                       'BLACS.hardware_interfaces.output_classes',
chrisjbillington:                                       'BLACS.device_base_class',
chrisjbillington:                                       'BLACS.tab_base_classes',
chrisjbillington:                                       'BLACS.plugins.connection_table',
chrisjbillington:                                       'BLACS.recompile_and_restart',
chrisjbillington:                                       'filewatcher',
chrisjbillington:                                       'queue',
chrisjbillington:                                       'notifications',
chrisjbillington:                                       'connections',
chrisjbillington:                                       'analysis_submission',
chrisjbillington:                                       'settings',
chrisjbillington:                                       'front_panel_settings',
chrisjbillington:                                       'labscript_utils.h5_lock',
chrisjbillington:                                       'labscript_utils.shared_drive',
chrisjbillington:                                       'labscript_utils.labconfig',
chrisjbillington:                                       'zprocess',
chrisjbillington:                                      ], sub=True)
        pstarkey:         ##########
        pstarkey: 
        pstarkey: 
     janwerkmann:     settings_path = os.path.join(config_prefix,'%s_BLACS.h5'%hostname)
            Phil:     required_config_params = {"DEFAULT":["experiment_name"],
            Phil:                               "programs":["text_editor",
            Phil:                                           "text_editor_arguments",
            Phil:                                          ],
            Phil:                               "paths":["shared_drive",
            Phil:                                        "connection_table_h5",
        cbilling:                                        "connection_table_py",
            Phil:                                       ],
        pstarkey:                               "ports":["BLACS", "lyse"],
            Phil:                              }
     janwerkmann:     exp_config = LabConfig(required_params = required_config_params)
        cbilling: 
            Phil:     port = int(exp_config.get('ports','BLACS'))
        cbilling: 
        pstarkey:     # Start experiment server
        pstarkey:     experiment_server = ExperimentServer(port)
            Phil: 
        pstarkey:     # Create Connection Table object
        pstarkey:     logger.info('About to load connection table: %s'%exp_config.get('paths','connection_table_h5'))
        cbilling:     connection_table_h5_file = exp_config.get('paths','connection_table_h5')
             jan:     connection_table = ConnectionTable(connection_table_h5_file, logging_prefix='BLACS')
        cbilling: 
        pstarkey:     logger.info('connection table loaded')
        cbilling: 
        pstarkey:     qapplication = QApplication(sys.argv)
           Chris:     qapplication.setAttribute(Qt.AA_DontShowIconsInMenus, False)
        pstarkey:     logger.info('QApplication instantiated')
        pstarkey:     app = BLACS(qapplication)
        cbilling: 
        pstarkey:     logger.info('BLACS instantiated')
            Phil:     def execute_program():
        cbilling:         qapplication.exec_()
        cbilling: 
        cbilling:     sys.exit(execute_program())
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /analysis_submission.py                                           #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann:     import Queue as queue
     janwerkmann: else:
     janwerkmann:     import queue
        pstarkey: 
        pstarkey: import logging
        pstarkey: import os
        pstarkey: import threading
        pstarkey: import time
        pstarkey: import sys
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
     janwerkmann: 
        pstarkey: from qtutils import *
chrisjbillington: from zprocess import zmq_get, TimeoutError, raise_exception_in_thread
chrisjbillington: from socket import gaierror
        pstarkey: import labscript_utils.shared_drive
chrisjbillington: from labscript_utils.qtwidgets.elide_label import elide_label
chrisjbillington: from blacs import BLACS_DIR
chrisjbillington: 
        pstarkey: 
        pstarkey: class AnalysisSubmission(object):        
        pstarkey:     def __init__(self, BLACS, blacs_ui):
     janwerkmann:         self.inqueue = queue.Queue()
        pstarkey:         self.BLACS = BLACS
        pstarkey:         self.port = int(self.BLACS.exp_config.get('ports', 'lyse'))
        pstarkey:         
chrisjbillington:         self._ui = UiLoader().load(os.path.join(BLACS_DIR, 'analysis_submission.ui'))
        pstarkey:         blacs_ui.analysis.addWidget(self._ui)
chrisjbillington:         self._ui.frame.setMinimumWidth(blacs_ui.queue_controls_frame.sizeHint().width())
chrisjbillington:         elide_label(self._ui.resend_shots_label, self._ui.failed_to_send_frame.layout(), Qt.ElideRight)
        pstarkey:         # connect signals
chrisjbillington:         self._ui.send_to_server.toggled.connect(lambda state: self._set_send_to_server(state))
        pstarkey:         self._ui.server.editingFinished.connect(lambda: self._set_server(self._ui.server.text()))
chrisjbillington:         self._ui.clear_unsent_shots_button.clicked.connect(lambda _: self.clear_waiting_files())
chrisjbillington:         self._ui.retry_button.clicked.connect(lambda _: self.check_retry())
chrisjbillington: 
        pstarkey:         self._waiting_for_submission = []
chrisjbillington:         self.server_online = 'offline'
chrisjbillington:         self.send_to_server = False
chrisjbillington:         self.server = ''
chrisjbillington:         self.time_of_last_connectivity_check = 0
chrisjbillington: 
        pstarkey:         self.mainloop_thread = threading.Thread(target=self.mainloop)
        pstarkey:         self.mainloop_thread.daemon = True
        pstarkey:         self.mainloop_thread.start()
        pstarkey:         
chrisjbillington:         # self.checking_thread = threading.Thread(target=self.check_connectivity_loop)
chrisjbillington:         # self.checking_thread.daemon = True
chrisjbillington:         # self.checking_thread.start()
        pstarkey:     
        pstarkey:     def restore_save_data(self,data):
        pstarkey:         if "server" in data:
        pstarkey:             self.server = data["server"]
        pstarkey:         if "send_to_server" in data:
        pstarkey:             self.send_to_server = data["send_to_server"]
        pstarkey:         if "waiting_for_submission" in data:
        pstarkey:             self._waiting_for_submission = list(data["waiting_for_submission"])
chrisjbillington:         self.inqueue.put(['save data restored', None])
chrisjbillington:         self.check_retry()
        pstarkey:             
        pstarkey:     def get_save_data(self):
        pstarkey:         return {"waiting_for_submission":list(self._waiting_for_submission),
        pstarkey:                 "server":self.server,
        pstarkey:                 "send_to_server":self.send_to_server
        pstarkey:                }
        pstarkey:     
        pstarkey:     def _set_send_to_server(self,value):
        pstarkey:         self.send_to_server = value
        pstarkey:         
        pstarkey:     def _set_server(self,server):
        pstarkey:         self.server = server
chrisjbillington:         self.check_retry()
        pstarkey:     
        pstarkey:     @property
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def send_to_server(self):
        pstarkey:         return self._send_to_server
        pstarkey:         
        pstarkey:     @send_to_server.setter
        pstarkey:     @inmain_decorator(True)
chrisjbillington:     def send_to_server(self, value):
        pstarkey:         self._send_to_server = bool(value)
        pstarkey:         self._ui.send_to_server.setChecked(self.send_to_server)
chrisjbillington:         if self.send_to_server:
chrisjbillington:             self._ui.server.setEnabled(True)
chrisjbillington:             self._ui.server_online.show()
chrisjbillington:             self.check_retry()
chrisjbillington:         else:
chrisjbillington:             self.clear_waiting_files()
chrisjbillington:             self._ui.server.setEnabled(False)
chrisjbillington:             self._ui.server_online.hide()
        pstarkey:     
        pstarkey:     @property
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def server(self):
        pstarkey:         return str(self._server)
        pstarkey:         
        pstarkey:     @server.setter    
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def server(self,value):
        pstarkey:         self._server = value
        pstarkey:         self._ui.server.setText(self.server)
chrisjbillington: 
        pstarkey:     @property
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def server_online(self):
        pstarkey:         return self._server_online
        pstarkey:         
        pstarkey:     @server_online.setter
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def server_online(self,value):
        pstarkey:         self._server_online = str(value)
        pstarkey:         
           Chris:         icon_names = {'checking': ':/qtutils/fugue/hourglass',
           Chris:                       'online': ':/qtutils/fugue/tick',
           Chris:                       'offline': ':/qtutils/fugue/exclamation', 
           Chris:                       '': ':/qtutils/fugue/status-offline'}
           Chris: 
           Chris:         tooltips = {'checking': 'Checking...',
           Chris:                     'online': 'Server is responding',
           Chris:                     'offline': 'Server not responding',
           Chris:                     '': 'Disabled'}
           Chris: 
chrisjbillington:         icon = QIcon(icon_names.get(self._server_online, ':/qtutils/fugue/exclamation-red'))
           Chris:         pixmap = icon.pixmap(QSize(16, 16))
chrisjbillington:         tooltip = tooltips.get(self._server_online, "Invalid server status: %s" % self._server_online)
           Chris: 
           Chris:         # Update GUI:
           Chris:         self._ui.server_online.setPixmap(pixmap)
           Chris:         self._ui.server_online.setToolTip(tooltip)
chrisjbillington:         self.update_waiting_files_message()
           Chris: 
chrisjbillington: 
chrisjbillington:     @inmain_decorator(True)
chrisjbillington:     def update_waiting_files_message(self):
chrisjbillington:         # if there is only one shot and we haven't encountered failure yet, do
chrisjbillington:         # not show the error frame:
chrisjbillington:         if (self.server_online == 'checking') and (len(self._waiting_for_submission) == 1) and not self._ui.failed_to_send_frame.isVisible():
chrisjbillington:             return
           Chris:         if self._waiting_for_submission:
chrisjbillington:             self._ui.failed_to_send_frame.show()
chrisjbillington:             if self.server_online == 'checking':
chrisjbillington:                 self._ui.retry_button.hide()
chrisjbillington:                 text = 'Sending %s shot(s)...' % len(self._waiting_for_submission)
chrisjbillington:             else:
chrisjbillington:                 self._ui.retry_button.show()
chrisjbillington:                 text = '%s shot(s) to send' % len(self._waiting_for_submission)
chrisjbillington:             self._ui.resend_shots_label.setText(text)
           Chris:         else:
chrisjbillington:             self._ui.failed_to_send_frame.hide()
           Chris: 
        pstarkey:     def get_queue(self):
        pstarkey:         return self.inqueue
     janwerkmann: 
     janwerkmann:     @inmain_decorator(True)
chrisjbillington:     def clear_waiting_files(self):
chrisjbillington:         self._waiting_for_submission = []
chrisjbillington:         self.update_waiting_files_message()
chrisjbillington: 
chrisjbillington:     @inmain_decorator(True)
chrisjbillington:     def check_retry(self):
chrisjbillington:         self.inqueue.put(['check/retry', None])
chrisjbillington: 
        pstarkey:     def mainloop(self):
chrisjbillington:         self._mainloop_logger = logging.getLogger('BLACS.AnalysisSubmission.mainloop')
chrisjbillington:         # Ignore signals until save data is restored:
chrisjbillington:         while self.inqueue.get()[0] != 'save data restored':
chrisjbillington:             pass
           Chris:         timeout = 10
        pstarkey:         while True:
chrisjbillington:             try:
chrisjbillington:                 try:
           Chris:                     signal, data = self.inqueue.get(timeout=timeout)
     janwerkmann:                 except queue.Empty:
           Chris:                     timeout = 10
chrisjbillington:                     # Periodic checking of connectivity and resending of files.
chrisjbillington:                     # Don't trigger a re-check if we already failed a connectivity
chrisjbillington:                     # check within the last second:
chrisjbillington:                     if (time.time() - self.time_of_last_connectivity_check) > 1:
chrisjbillington:                         signal = 'check/retry'
chrisjbillington:                     else:
chrisjbillington:                         continue
chrisjbillington:                 if signal == 'check/retry':
chrisjbillington:                     self.check_connectivity()
chrisjbillington:                     if self.server_online == 'online':
chrisjbillington:                         self.submit_waiting_files()
chrisjbillington:                 elif signal == 'file':
chrisjbillington:                     if self.send_to_server:
chrisjbillington:                         self._waiting_for_submission.append(data)
chrisjbillington:                         if self.server_online != 'online':
chrisjbillington:                             # Don't stack connectivity checks if many files are
chrisjbillington:                             # arriving. If we failed a connectivity check less
chrisjbillington:                             # than a second ago then don't check again.
chrisjbillington:                             if (time.time() - self.time_of_last_connectivity_check) > 1:
chrisjbillington:                                 self.check_connectivity()
           Chris:                             else:
           Chris:                                 # But do queue up a check for when we have
           Chris:                                 # been idle for one second:
           Chris:                                 timeout = 1
chrisjbillington:                         if self.server_online == 'online':
chrisjbillington:                             self.submit_waiting_files()
chrisjbillington:                 elif signal == 'close':
chrisjbillington:                     break
     janwerkmann:                 elif signal == 'save data restored':
             jan:                     continue
chrisjbillington:                 else:
chrisjbillington:                     raise ValueError('Invalid signal: %s'%str(signal))
chrisjbillington: 
chrisjbillington:                 self._mainloop_logger.info('Processed signal: %s'%str(signal))
chrisjbillington:             except Exception:
chrisjbillington:                 # Raise in a thread for visibility, but keep going
chrisjbillington:                 raise_exception_in_thread(sys.exc_info())
chrisjbillington:                 self._mainloop_logger.exception("Exception in mainloop, continuing")
        pstarkey:             
chrisjbillington:     def check_connectivity(self):
chrisjbillington:         host = self.server
chrisjbillington:         send_to_server = self.send_to_server
chrisjbillington:         if host and send_to_server:       
chrisjbillington:             self.server_online = 'checking'         
chrisjbillington:             try:
chrisjbillington:                 response = zmq_get(self.port, host, 'hello', timeout=1)
chrisjbillington:             except (TimeoutError, gaierror):
chrisjbillington:                 success = False
chrisjbillington:             else:
chrisjbillington:                 success = (response == 'hello')
        pstarkey:                 
chrisjbillington:             # update GUI
chrisjbillington:             self.server_online = 'online' if success else 'offline'
chrisjbillington:         else:
chrisjbillington:             self.server_online = ''
chrisjbillington: 
chrisjbillington:         self.time_of_last_connectivity_check = time.time()
chrisjbillington: 
        pstarkey:     def submit_waiting_files(self):
chrisjbillington:         success = True
chrisjbillington:         while self._waiting_for_submission and success:
        pstarkey:             path = self._waiting_for_submission[0]
chrisjbillington:             self._mainloop_logger.info('Submitting run file %s.\n'%os.path.basename(path))
chrisjbillington:             data = {'filepath': labscript_utils.shared_drive.path_to_agnostic(path)}
chrisjbillington:             self.server_online = 'checking'
        pstarkey:             try:
chrisjbillington:                 response = zmq_get(self.port, self.server, data, timeout=1)
chrisjbillington:             except (TimeoutError, gaierror):
chrisjbillington:                 success = False
        pstarkey:             else:
chrisjbillington:                 success = (response == 'added successfully')
chrisjbillington:                 try:
chrisjbillington:                     self._waiting_for_submission.pop(0) 
chrisjbillington:                 except IndexError:
chrisjbillington:                     # Queue has been cleared
chrisjbillington:                     pass
chrisjbillington:             if not success:
chrisjbillington:                 break
chrisjbillington:         # update GUI
chrisjbillington:         self.server_online = 'online' if success else 'offline'
chrisjbillington:         self.time_of_last_connectivity_check = time.time()
             jan:         
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /compile_and_restart.py                                           #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: 
        pstarkey: import os
             jan: import shutil
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
        pstarkey: 
        pstarkey: from qtutils import *
        pstarkey: import runmanager
        pstarkey: from qtutils.outputbox import OutputBox
        pstarkey: 
chrisjbillington: from blacs import BLACS_DIR
chrisjbillington: 
chrisjbillington: 
        pstarkey: class CompileAndRestart(QDialog):
        pstarkey:     def __init__(self, blacs, globals_files,connection_table_labscript, output_path, close_notification_func=None):
        pstarkey:         QDialog.__init__(self,blacs['ui'])
        pstarkey:         self.setAttribute(Qt.WA_DeleteOnClose, True) # make sure the dialog is deleted when the window is closed
        pstarkey:         
        pstarkey:         self.globals_files = globals_files
        pstarkey:         self.labscript_file = connection_table_labscript
        pstarkey:         self.output_path = output_path
        pstarkey:         self.tempfilename = self.output_path.strip('.h5')+'.temp.h5'
        pstarkey:         self.blacs = blacs
        pstarkey:         self.close_notification_func = close_notification_func
        pstarkey:         
chrisjbillington:         self.ui = UiLoader().load(os.path.join(BLACS_DIR, 'compile_and_restart.ui'))
        pstarkey:         self.output_box = OutputBox(self.ui.verticalLayout)       
        pstarkey:         self.ui.restart.setEnabled(False)
        pstarkey:         
        pstarkey:         # Connect buttons
        pstarkey:         self.ui.restart.clicked.connect(self.restart)
        pstarkey:         self.ui.compile.clicked.connect(self.compile)
        pstarkey:         self.ui.cancel.clicked.connect(self.reject)
        pstarkey:         
chrisjbillington:         self.setLayout(self.ui.layout())
chrisjbillington:         self.resize(500, 300)
        pstarkey:         self.show()
chrisjbillington:         self.setWindowTitle('Recompile connection table')
        pstarkey:         self.compile()
        pstarkey: 
        pstarkey:     def closeEvent(self,event):
        pstarkey:         if not self.ui.cancel.isEnabled():        
        pstarkey:             event.ignore()            
        pstarkey:         else:
        pstarkey:             event.accept()
        pstarkey:     
        pstarkey:     def on_activate_default(self,window):
        pstarkey:         if self.button_restart.get_sensitive():
        pstarkey:             self.restart()
        pstarkey:         elif self.button_compile.get_sensitive():
        pstarkey:             self.compile()
        pstarkey:                 
        pstarkey:     def compile(self):
        pstarkey:         self.ui.compile.setEnabled(False)
        pstarkey:         self.ui.cancel.setEnabled(False)
        pstarkey:         self.ui.restart.setEnabled(False)
           Chris:         msg = 'Recompiling connection table'
           Chris:         self.ui.label.setText(msg)
           Chris:         self.output_box.output(msg + '\n')
        pstarkey:         runmanager.compile_labscript_with_globals_files_async(self.labscript_file,
        pstarkey:             self.globals_files, self.tempfilename, self.output_box.port, self.finished_compiling)
        pstarkey:     
        pstarkey:     @inmain_decorator(True)    
        pstarkey:     def finished_compiling(self, success):
        pstarkey:         self.ui.compile.setEnabled(True)
        pstarkey:         self.ui.cancel.setEnabled(True)
        pstarkey:         if success:
        pstarkey:             try:
             jan:                 shutil.move(self.tempfilename,self.output_path)
chrisjbillington:             except Exception as e:
chrisjbillington:                 msg = ('Couldn\'t replace existing connection table h5 file. ' + 
chrisjbillington:                        'Is it open in another process? ' +
chrisjbillington:                        'error was:\n %s\n') % str(e)
chrisjbillington:                 self.output_box.output(msg, red=True)
        pstarkey:                 self.ui.label.setText('Compilation failed.')
        pstarkey:                 self.ui.restart.setEnabled(False)
        pstarkey:                 os.remove(self.tempfilename)
     janwerkmann:             else:
     janwerkmann:                 self.ui.restart.setEnabled(True)
     janwerkmann:                 self.ui.cancel.setEnabled(False)
           Chris:                 msg = 'Compilation succeeded, restart when ready'
           Chris:                 self.ui.label.setText(msg)
           Chris:                 self.output_box.output(msg + '\n')
        pstarkey:         else:
        pstarkey:             self.ui.restart.setEnabled(False)
           Chris:             msg = 'Compilation failed. Please fix the errors in the connection table (python file) and try again'
           Chris:             self.ui.label.setText(msg)
           Chris:             self.output_box.output(msg + '\n')
        pstarkey:             try:
        pstarkey:                 os.remove(self.tempfilename)
        pstarkey:             except Exception:
        pstarkey:                 pass
             jan: 
        pstarkey:     def restart(self):
        pstarkey:         #gobject.timeout_add(100, self.blacs.destroy)
        pstarkey:         if self.close_notification_func:
        pstarkey:             self.close_notification_func()
        pstarkey:         QTimer.singleShot(100, self.blacs['ui'].close)
             jan:         self.accept()
        pstarkey:         self.blacs['set_relaunch'](True)
             jan: 
        pstarkey:         #self.blacs.qt_application.aboutToQuit.connect(self.relaunch)
        pstarkey:         #gtk.quit_add(0,self.relaunch)
             jan: 
             jan: 
        pstarkey: if __name__ == '__main__':
        pstarkey:     #gtk.threads_init()
        pstarkey:     globals_file = '/home/bilbo/labconfig/bilbo-laptop_calibrations.h5'
        pstarkey:     labscript_file = '/home/bilbo/labconfig/bilbo-laptop.py'
        pstarkey:     output_path = '/home/bilbo/Desktop/pythonlib/BLACS/connectiontables/bilbo-laptop.h5'
        pstarkey:     #compile_and_restart = CompileAndRestart(None, [], labscript_file, output_path)
        pstarkey:     #gtk.main()
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # /connections.py                                                   #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the program BLACS, in the labscript suite    #
chrisjbillington: # (see http://labscriptsuite.org), and is licensed under the        #
chrisjbillington: # Simplified BSD License. See the license.txt file in the root of   #
chrisjbillington: # the project for the full license.                                 #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
chrisjbillington: # This file solely exists as backward compatibility for programs (i.e. runviewer)
chrisjbillington: # that imported blacs.connections, which has moved to labscript_utils.
chrisjbillington: 
chrisjbillington: from labscript_utils.connections import *
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /device_base_class.py                                             #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
        pstarkey: 
        pstarkey: import logging
        pstarkey: import sys
        pstarkey: import os
        pstarkey: import time
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
     janwerkmann: 
        pstarkey: import labscript_utils.excepthook
        pstarkey: from qtutils import UiLoader
        pstarkey: 
chrisjbillington: from blacs import BLACS_DIR
chrisjbillington: from blacs.tab_base_classes import Tab, Worker, define_state
chrisjbillington: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED
chrisjbillington: from blacs.output_classes import AO, DO, DDS
        pstarkey: from labscript_utils.qtwidgets.toolpalette import ToolPaletteGroup
        pstarkey: 
        pstarkey: 
        pstarkey: class DeviceTab(Tab):
        pstarkey:     def __init__(self,notebook,settings,restart=False):
        pstarkey:         Tab.__init__(self,notebook,settings,restart)
        pstarkey:         self.connection_table = settings['connection_table']
        pstarkey:         
        pstarkey:         # Create the variables we need
        pstarkey:         self._AO = {}
        pstarkey:         self._DO = {}
        pstarkey:         self._DDS = {}
        pstarkey:         
        pstarkey:         self._final_values = {}
        pstarkey:         self._last_programmed_values = {}
        pstarkey:         self._last_remote_values = {}
        pstarkey:         self._primary_worker = None
        pstarkey:         self._secondary_workers = []
        pstarkey:         self._can_check_remote_values = False
        pstarkey:         self._changed_radio_buttons = {}
        pstarkey:         self.destroy_complete = False
        pstarkey:         
        pstarkey:         # Call the initialise GUI function
        pstarkey:         self.initialise_GUI() 
chrisjbillington:         self.restore_save_data(self.settings['saved_data'] if 'saved_data' in self.settings else {})
        cbilling:         self.initialise_workers()
        pstarkey:         self._last_programmed_values = self.get_front_panel_values()
        pstarkey:         if self._can_check_remote_values:
        pstarkey:             self.statemachine_timeout_add(30000,self.check_remote_values)     
        pstarkey:         else:       
        pstarkey:             # If we can check remote values, then no need to call program manual as 
        pstarkey:             # the remote device will either be programmed correctly, or will need an 
        pstarkey:             # inconsistency between local and remote values resolved
        pstarkey:             self.program_device()
        pstarkey:             
        pstarkey:     def initialise_GUI(self):
        pstarkey:         # Override this function
        cbilling:         pass
        cbilling:         
        cbilling:     def initialise_workers(self):
        cbilling:         # Override this function
        pstarkey:         # set the primary worker at this time
        pstarkey:         pass
        pstarkey: 
        pstarkey:     @property
        pstarkey:     def primary_worker(self):
        pstarkey:         return self._primary_worker
        pstarkey:         
        pstarkey:     @primary_worker.setter
        pstarkey:     def primary_worker(self,worker):
        pstarkey:         self._primary_worker = worker
        pstarkey:     
        pstarkey:     def add_secondary_worker(self,worker):
        pstarkey:         if worker not in self._secondary_workers:
        pstarkey:             self._secondary_workers.append(worker)
        pstarkey:     
        pstarkey:     def supports_remote_value_check(self,support):
        pstarkey:         self._can_check_remote_values = bool(support)
        pstarkey:     
        pstarkey:     ############################################################
        pstarkey:     # What do the properties dictionaries need to look like?   #
        pstarkey:     ############################################################
        pstarkey:     #
        pstarkey:     # digital_properties = {'hardware_channel_reference':{}, 'do0':{}}
        pstarkey:     #
        pstarkey:     #
        pstarkey:     # analog_properties = {'hardware_channel_reference':{'base_unit':'V',
        pstarkey:     #                                                    'min':-10.0,
        pstarkey:     #                                                    'max':10.0,
        pstarkey:     #                                                    'step':0.01,
        pstarkey:     #                                                    'decimals':3
        pstarkey:     #                                                    },
        pstarkey:     #                      'ao1':{'base_unit':'V',
        pstarkey:     #                             'min':-10.0,
        pstarkey:     #                             'max':10.0,
        pstarkey:     #                             'step':0.01,
        pstarkey:     #                             'decimals':3
        pstarkey:     #                             },
        pstarkey:     #                     }
        pstarkey:     #
        pstarkey:     #
        pstarkey:     #    dds_properties = {'hardware_channel_reference':{'freq':{'base_unit':'Hz',
        pstarkey:     #                                                            'min':-10.0,
        pstarkey:     #                                                            'max':10.0,
        pstarkey:     #                                                            'step':0.01,
        pstarkey:     #                                                            'decimals':3
        pstarkey:     #                                                            },
        pstarkey:     #                                                     'amp':{'base_unit':'Vpp',
        pstarkey:     #                                                            'min':0.0,
        pstarkey:     #                                                            'max':1.0,
        pstarkey:     #                                                            'step':0.1,
        pstarkey:     #                                                            'decimals':3
        pstarkey:     #                                                            },  
        pstarkey:     #                                                   'phase':{'base_unit':'Degrees',
        pstarkey:     #                                                            'min':0.0,
        pstarkey:     #                                                            'max':360.0,
        pstarkey:     #                                                            'step':1,
        pstarkey:     #                                                            'decimals':2
        pstarkey:     #                                                            },  
        pstarkey:     #                                                    'gate':{},
        pstarkey:     #                                                    },    
        pstarkey:     #                      'dds1':{'freq':{'base_unit':'Hz',
        pstarkey:     #                                      'min':-10.0,
        pstarkey:     #                                      'max':10.0,
        pstarkey:     #                                      'step':0.01,
        pstarkey:     #                                      'decimals':3
        pstarkey:     #                                      },
        pstarkey:     #                               'amp':{'base_unit':'Vpp',
        pstarkey:     #                                      'min':0.0,
        pstarkey:     #                                      'max':1.0,
        pstarkey:     #                                      'step':0.1,
        pstarkey:     #                                      'decimals':3
        pstarkey:     #                                      },  
        pstarkey:     #                             'phase':{'base_unit':'Degrees',
        pstarkey:     #                                      'min':0.0,
        pstarkey:     #                                      'max':360.0,
        pstarkey:     #                                      'step':1,
        pstarkey:     #                                      'decimals':2
        pstarkey:     #                                      }, 
        pstarkey:     #                              'gate':{},
        pstarkey:     #                             },
        pstarkey:     #                     }
        pstarkey:     #
        pstarkey:     def create_digital_outputs(self,digital_properties):
        pstarkey:         for hardware_name,properties in digital_properties.items():
        pstarkey:             # Save the DO object
        pstarkey:             self._DO[hardware_name] = self._create_DO_object(self.device_name,hardware_name,hardware_name,properties)
        pstarkey:     
        pstarkey:     def _create_DO_object(self,parent_device,BLACS_hardware_name,labscript_hardware_name,properties):
        pstarkey:         # Find the connection name
        pstarkey:         device = self.get_child_from_connection_table(parent_device,labscript_hardware_name)
             jan:         connection_name = device.name if device else '-'
             jan: 
        pstarkey:         # Instantiate the DO object
             jan:         return DO(BLACS_hardware_name, connection_name, self.device_name, self.program_device, self.settings)
     janwerkmann: 
        pstarkey:     def create_analog_outputs(self,analog_properties):
        pstarkey:         for hardware_name,properties in analog_properties.items():                    
        pstarkey:             # Create and save the AO object
        pstarkey:             self._AO[hardware_name] = self._create_AO_object(self.device_name,hardware_name,hardware_name,properties)
        pstarkey: 
        pstarkey:     def _create_AO_object(self,parent_device,BLACS_hardware_name,labscript_hardware_name,properties):
        pstarkey:         # Find the connection name
        pstarkey:         device = self.get_child_from_connection_table(parent_device,labscript_hardware_name)
        pstarkey:         connection_name = device.name if device else '-'
        pstarkey:         
        pstarkey:         # Get the calibration details
        pstarkey:         calib_class = None
        pstarkey:         calib_params = {}
        pstarkey:         if device:
        pstarkey:             # get the AO from the connection table, find its calibration details
        pstarkey:             calib_class = device.unit_conversion_class if device.unit_conversion_class != "None" else None
        pstarkey:             calib_params = device.unit_conversion_params
        pstarkey:         
        pstarkey:         # Instantiate the AO object
        pstarkey:         return AO(BLACS_hardware_name, connection_name, self.device_name, self.program_device, self.settings, calib_class, calib_params,
        pstarkey:                 properties['base_unit'], properties['min'], properties['max'], properties['step'], properties['decimals'])
        pstarkey:             
        pstarkey:     def create_dds_outputs(self,dds_properties):
        pstarkey:         for hardware_name,properties in dds_properties.items():
        pstarkey:             device = self.get_child_from_connection_table(self.device_name,hardware_name)
        pstarkey:             connection_name = device.name if device else '-'
        pstarkey:         
        pstarkey:             subchnl_name_list = ['freq','amp','phase']
        pstarkey:             sub_chnls = {}
        pstarkey:             for subchnl in subchnl_name_list:
        pstarkey:                 if subchnl in properties:
        pstarkey:                     # Create the AO object
        pstarkey:                     sub_chnls[subchnl] = self._create_AO_object(connection_name,hardware_name+'_'+subchnl,subchnl,properties[subchnl])
        pstarkey:             
        pstarkey:             if 'gate' in properties:
        pstarkey:                 sub_chnls['gate'] = self._create_DO_object(connection_name,hardware_name+'_gate','gate',properties)
        pstarkey:             
        pstarkey:             self._DDS[hardware_name] = DDS(hardware_name,connection_name,sub_chnls)
        pstarkey:     
        pstarkey:     def get_child_from_connection_table(self, parent_device_name, port):
        pstarkey:         return self.connection_table.find_child(parent_device_name, port)
        pstarkey:     
        pstarkey:     def create_digital_widgets(self,channel_properties):
        pstarkey:         widgets = {}
        pstarkey:         for hardware_name,properties in channel_properties.items():
        pstarkey:             properties.setdefault('args',[])
        pstarkey:             properties.setdefault('kwargs',{})
             jan: 
             jan:             device = self.get_child_from_connection_table(self.device_name,hardware_name)
             jan:             properties['kwargs']['inverted'] = bool(device.properties.get('inverted', False) if device else properties['kwargs'].get('inverted', False))
             jan: 
        pstarkey:             if hardware_name in self._DO:
        pstarkey:                 widgets[hardware_name] = self._DO[hardware_name].create_widget(*properties['args'],**properties['kwargs'])
        pstarkey:         
        pstarkey:         return widgets
        pstarkey:         
        pstarkey:     def create_analog_widgets(self,channel_properties):
        pstarkey:         widgets = {}
        pstarkey:         for hardware_name,properties in channel_properties.items():
        pstarkey:             properties.setdefault('display_name',None)
        pstarkey:             properties.setdefault('horizontal_alignment',False)
        pstarkey:             properties.setdefault('parent',None)
        pstarkey:             if hardware_name in self._AO:
        pstarkey:                 widgets[hardware_name] = self._AO[hardware_name].create_widget(properties['display_name'],properties['horizontal_alignment'],properties['parent'])
        pstarkey:         
        pstarkey:         return widgets
        pstarkey:         
        pstarkey:     def create_dds_widgets(self,channel_properties):
        pstarkey:         widgets = {}
        pstarkey:         for hardware_name,properties in channel_properties.items():
        pstarkey:             properties.setdefault('args',[])
        pstarkey:             properties.setdefault('kwargs',{})
        pstarkey:             if hardware_name in self._DDS:
        pstarkey:                 widgets[hardware_name] = self._DDS[hardware_name].create_widget(*properties['args'],**properties['kwargs'])
        pstarkey:         
        pstarkey:         return widgets
        pstarkey:     
        pstarkey:     def auto_create_widgets(self):
        pstarkey:         dds_properties = {}
        pstarkey:         for channel,output in self._DDS.items():
        pstarkey:             dds_properties[channel] = {}
        pstarkey:         dds_widgets = self.create_dds_widgets(dds_properties)
        pstarkey:         ao_properties = {}
        pstarkey:         for channel,output in self._AO.items():
        pstarkey:             ao_properties[channel] = {}
        pstarkey:         ao_widgets = self.create_analog_widgets(ao_properties)
        pstarkey:         do_properties = {}
        pstarkey:         for channel,output in self._DO.items():
        pstarkey:             do_properties[channel] = {}
        pstarkey:         do_widgets = self.create_digital_widgets(do_properties)
        pstarkey:         
        pstarkey:         return dds_widgets,ao_widgets,do_widgets
        pstarkey:     
        pstarkey:     def auto_place_widgets(self,*args):
        pstarkey:         widget = QWidget()
        pstarkey:         toolpalettegroup = ToolPaletteGroup(widget)
        pstarkey:         for arg in args:
        pstarkey:             # A default sort algorithm that just returns the object (this is equivalent to not specifying the sort gorithm)
        pstarkey:             sort_algorithm = lambda x: x
        pstarkey:             if type(arg) == type(()) and len(arg) > 1 and type(arg[1]) == type({}) and len(arg[1].keys()) > 0:
        pstarkey:                 # we have a name, use it!
        pstarkey:                 name = arg[0]
        pstarkey:                 widget_dict = arg[1]
        pstarkey:                 if len(arg) > 2:
        pstarkey:                     sort_algorithm = arg[2]
        pstarkey:             else:
        pstarkey:                 # ignore things that are not dictionaries or empty dictionaries
        pstarkey:                 if type(arg) != type({}) or len(arg.keys()) < 1:
        pstarkey:                     continue
     janwerkmann:                 if isinstance(self.get_channel(list(arg.keys())[0]),AO):
        pstarkey:                     name = 'Analog Outputs'
     janwerkmann:                 elif isinstance(self.get_channel(list(arg.keys())[0]),DO):
        pstarkey:                     name = 'Digital Outputs'
     janwerkmann:                 elif isinstance(self.get_channel(list(arg.keys())[0]),DDS):
        pstarkey:                     name = 'DDS Outputs'
        pstarkey:                 else:
        pstarkey:                     # If it isn't DO, DDS or AO, we should forget about them and move on to the next argument
        pstarkey:                     continue
        pstarkey:                 widget_dict = arg
        pstarkey:             # Create tool palette
        pstarkey:             if toolpalettegroup.has_palette(name):
        pstarkey:                 toolpalette = toolpalettegroup.get_palette(name)
        pstarkey:             else:
        pstarkey:                 toolpalette = toolpalettegroup.append_new_palette(name)
        pstarkey:                 
        pstarkey:             for channel in sorted(widget_dict.keys(),key=sort_algorithm):
        pstarkey:                 toolpalette.addWidget(widget_dict[channel],True)
        pstarkey:          
        pstarkey:         # Add the widget containing the toolpalettegroup to the tab layout
        pstarkey:         self.get_tab_layout().addWidget(widget)
        pstarkey:         self.get_tab_layout().addItem(QSpacerItem(0,0,QSizePolicy.Minimum,QSizePolicy.MinimumExpanding))
        pstarkey:     
        pstarkey:     # This method should be overridden in your device class if you want to save any data not
        pstarkey:     # stored in an AO, DO or DDS object
        pstarkey:     # This method should return a dictionary, and this dictionary will be passed to the restore_save_data()
        pstarkey:     # method when the tab is initialised
        pstarkey:     def get_save_data(self):
        pstarkey:         return {}
        pstarkey:     
        pstarkey:     # This method should be overridden in your device class if you want to restore data 
        pstarkey:     # (saved by get_save_data()) when teh tab is initialised.
        pstarkey:     # You will be passed a dictionary of the form specified by your get_save_data() method
        pstarkey:     # 
        pstarkey:     # Note: You must handle the case where the data dictionary is empty (or one or more keys are missing)
        pstarkey:     #       This case will occur the first time BLACS is started on a PC, or if the BLACS datastore is destroyed
        pstarkey:     def restore_save_data(self,data):
        pstarkey:         return
        pstarkey:     
        pstarkey:     def update_from_settings(self,settings):
chrisjbillington:         Tab.update_from_settings(self, settings)
        pstarkey:         self.restore_save_data(settings['saved_data'])
chrisjbillington:     
        pstarkey:         self.settings = settings
        pstarkey:         for output in [self._AO,self._DO]:
        pstarkey:             for name,channel in output.items():
        pstarkey:                 if not channel._locked:
        pstarkey:                     channel._update_from_settings(settings)
        pstarkey:                     
        pstarkey:         for name,channel in self._DDS.items():
        pstarkey:             for subchnl_name in channel._sub_channel_list:
        pstarkey:                 if hasattr(channel,subchnl_name):
        pstarkey:                     subchnl = getattr(channel,subchnl_name)
        pstarkey:                     if not subchnl._locked:
        pstarkey:                         subchnl._update_from_settings(settings)
chrisjbillington:     
        pstarkey:     def get_front_panel_values(self):
        pstarkey:         return {channel:item.value for output in [self._AO,self._DO,self._DDS] for channel,item in output.items()}
        pstarkey:     
        pstarkey:     def get_channel(self,channel):
        pstarkey:         if channel in self._AO:
        pstarkey:             return self._AO[channel]
        pstarkey:         elif channel in self._DO:
        pstarkey:             return self._DO[channel]
        pstarkey:         elif channel in self._DDS:
        pstarkey:             return self._DDS[channel]
        pstarkey:         else:
        pstarkey:             return None
        pstarkey:             
        pstarkey:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)
        pstarkey:     def destroy(self):
        pstarkey:         yield(self.queue_work(self._primary_worker,'shutdown'))
        pstarkey:         for worker in self._secondary_workers:
        pstarkey:             yield(self.queue_work(worker,'shutdown'))
        pstarkey:         self.close_tab()
        pstarkey:         self.destroy_complete = True
        pstarkey:     
        pstarkey:     # Only allow this to be called when we are in MODE_MANUAL and keep it queued up if we are not
        pstarkey:     # When pulling out the state from the state queue, we check to see if there is an adjacent state that is more recent, and use that one
        pstarkey:     # or whichever is the latest without encountering a different state).
        pstarkey:     # This prevenets 'a million' calls to program_device from executing, potentially slowing down the system
        pstarkey:     @define_state(MODE_MANUAL,True,delete_stale_states=True)
        pstarkey:     def program_device(self):
        pstarkey:         self._last_programmed_values = self.get_front_panel_values()
        pstarkey:         
        pstarkey:         # get rid of any "remote values changed" dialog
        pstarkey:         self._changed_widget.hide()
        pstarkey:         
        pstarkey:         results = yield(self.queue_work(self._primary_worker,'program_manual',self._last_programmed_values))
        pstarkey:         for worker in self._secondary_workers:
        pstarkey:             if results:
        pstarkey:                 returned_results = yield(self.queue_work(worker,'program_manual',self._last_programmed_values))
        pstarkey:                 results.update(returned_results)
        pstarkey:         
        pstarkey:         # If the worker process returns something, we assume it wants us to coerce the front panel values
        pstarkey:         if results:
        pstarkey:             for channel,remote_value in results.items():
        pstarkey:                 if channel not in self._last_programmed_values:
        pstarkey:                     raise RuntimeError('The worker function program_manual for device %s is returning data for channel %s but the BLACS tab is not programmed to handle this channel'%(self.device_name,channel))
        pstarkey:                 
        pstarkey:                 output = self.get_channel(channel)
        pstarkey:                 if output is None:
        pstarkey:                     raise RuntimeError('The channel %s on device %s is in the last programmed values, but is not in the AO, DO or DDS output store. Something has gone badly wrong!'%(channel,self.device_name))
        pstarkey:                 else:                    
        pstarkey:                     # TODO: Only do this if the front panel values match what we asked to program (eg, the user hasn't changed the value since)
        pstarkey:                     if output.value == self._last_programmed_values[channel]:
        pstarkey:                         output.set_value(remote_value,program=False)
        pstarkey:             
        pstarkey:                         # Update the last_programmed_values            
        pstarkey:                         self._last_programmed_values[channel] = remote_value
        pstarkey:     
        pstarkey:     @define_state(MODE_MANUAL,True)
        pstarkey:     def check_remote_values(self):
        pstarkey:         self._last_remote_values = yield(self.queue_work(self._primary_worker,'check_remote_values'))
        pstarkey:         for worker in self._secondary_workers:
        pstarkey:             if self._last_remote_values:
        pstarkey:                 returned_results = yield(self.queue_work(worker,'check_remote_values'))
        pstarkey:                 self._last_remote_values.update(returned_results)
        pstarkey:         
        pstarkey:         # compare to current front panel values and prompt the user if they don't match
        pstarkey:         # We compare to the last_programmed values so that it doesn't get confused if the user has changed the value on the front panel
        pstarkey:         # and the program_manual command is still queued up
        pstarkey:         
        pstarkey:         # If no results were returned, raise an exception so that we don't keep calling this function over and over again, 
        pstarkey:         # filling up the text box with the same error, eventually consuming all CPU/memory of the PC
        pstarkey:         if not self._last_remote_values or type(self._last_remote_values) != type({}):
        pstarkey:             raise Exception('Failed to get remote values from device. Is it still connected?')
        pstarkey:             
        pstarkey:         # A variable to indicate if any of the channels have a changed value
        pstarkey:         overall_changed = False
        pstarkey:             
        pstarkey:         # A place to store radio buttons in
        pstarkey:         self._changed_radio_buttons = {}
        pstarkey:             
        pstarkey:         # Clean up the previously used layout
        pstarkey:         while not self._ui.changed_layout.isEmpty():
        pstarkey:             item = self._ui.changed_layout.itemAt(0)
        pstarkey:             # This is the only way I could make the widget actually be removed.
        pstarkey:             # using layout.removeItem/removeWidget causes the layout to still draw the old item in its original space, and
        pstarkey:             # then draw new items over the top of the old. Very odd behaviour, could be a windows 8 bug I suppose!
        pstarkey:             item.widget().setParent(None)
        pstarkey:             #TODO: somehow maintain the state of the radio buttons for specific channels between refreshes of this changed dialog.
        pstarkey:             
        pstarkey:         # TODO: Use the proper sort algorithm as defined for placing widgets to order this prompt
        pstarkey:         # We expect a dictionary of channel:value pairs
        pstarkey:         for channel in sorted(self._last_remote_values):
        pstarkey:             remote_value = self._last_remote_values[channel]
        pstarkey:             if channel not in self._last_programmed_values:
        pstarkey:                 raise RuntimeError('The worker function check_remote_values for device %s is returning data for channel %s but the BLACS tab is not programmed to handle this channel'%(self.device_name,channel))
        pstarkey:             
        pstarkey:             # A variable to indicate if this channel has changed
        pstarkey:             changed = False
        pstarkey:             
        pstarkey:             if channel in self._DDS:
        pstarkey:                 front_value = self._last_programmed_values[channel]
        pstarkey:                 # format the entries for the DDS object correctly, then compare
        pstarkey:                 
        pstarkey:                 front_values_formatted = {}
        pstarkey:                 remote_values_formatted = {}
        pstarkey:                 for sub_chnl in front_value:
        pstarkey:                     if sub_chnl not in remote_value:
        pstarkey:                         raise RuntimeError('The worker function check_remote_values has not returned data for the sub-channel %s in channel %s'%(sub_chnl,channel))
        pstarkey:                     
        pstarkey:                     if sub_chnl == 'gate':
        pstarkey:                         front_values_formatted[sub_chnl] = str(bool(int(front_value[sub_chnl])))
        pstarkey:                         remote_values_formatted[sub_chnl] = str(bool(int(remote_value[sub_chnl])))
        pstarkey:                     else:
        pstarkey:                         decimals = self._DDS[channel].__getattribute__(sub_chnl)._decimals
        pstarkey:                         front_values_formatted[sub_chnl] = ("%."+str(decimals)+"f")%front_value[sub_chnl]
        pstarkey:                         remote_values_formatted[sub_chnl] = ("%."+str(decimals)+"f")%remote_value[sub_chnl]
        pstarkey:                         
        pstarkey:                     if front_values_formatted[sub_chnl] != remote_values_formatted[sub_chnl]:
        pstarkey:                         changed = True
        pstarkey:                         
        pstarkey:                 if changed:
chrisjbillington:                     ui = UiLoader().load(os.path.join(BLACS_DIR, 'tab_value_changed_dds.ui'))
        pstarkey:                     ui.channel_label.setText(self._DDS[channel].name)
        pstarkey:                     for sub_chnl in front_value:
        pstarkey:                         ui.__getattribute__('front_%s_value'%sub_chnl).setText(front_values_formatted[sub_chnl])
        pstarkey:                         ui.__getattribute__('remote_%s_value'%sub_chnl).setText(remote_values_formatted[sub_chnl])
        pstarkey:                     
        pstarkey:                     # Hide unused sub_channels of this DDS
        pstarkey:                     for sub_chnl in self._DDS[channel].get_unused_subchnl_list():
        pstarkey:                         ui.__getattribute__('front_%s_value'%sub_chnl).setVisible(False)
        pstarkey:                         ui.__getattribute__('front_%s_label'%sub_chnl).setVisible(False)
        pstarkey:                         ui.__getattribute__('remote_%s_value'%sub_chnl).setVisible(False)
        pstarkey:                         ui.__getattribute__('remote_%s_label'%sub_chnl).setVisible(False)
        pstarkey:                 
        pstarkey:             elif channel in self._DO:
        pstarkey:                 # This is an easy case!
        pstarkey:                 front_value = str(bool(int(self._last_programmed_values[channel])))
        pstarkey:                 remote_value = str(bool(int(remote_value)))
        pstarkey:                 if front_value != remote_value:
        pstarkey:                     changed = True
chrisjbillington:                     ui = UiLoader().load(os.path.join(BLACS_DIR, 'tab_value_changed.ui'))
        pstarkey:                     ui.channel_label.setText(self._DO[channel].name)
        pstarkey:                     ui.front_value.setText(front_value)
        pstarkey:                     ui.remote_value.setText(remote_value)
        pstarkey:             elif channel in self._AO:
        pstarkey:                 # A intermediately complicated case!
        pstarkey:                 front_value = ("%."+str(self._AO[channel]._decimals)+"f")%self._last_programmed_values[channel]
        pstarkey:                 remote_value = ("%."+str(self._AO[channel]._decimals)+"f")%remote_value
        pstarkey:                 if front_value != remote_value:
        pstarkey:                     changed = True
chrisjbillington:                     ui = UiLoader().load(os.path.join(BLACS_DIR, 'tab_value_changed.ui'))
        pstarkey:                     ui.channel_label.setText(self._AO[channel].name)
        pstarkey:                     ui.front_value.setText(front_value)
        pstarkey:                     ui.remote_value.setText(remote_value)
        pstarkey:             else:
        pstarkey:                 raise RuntimeError('device_base_class.py is not programmed to handle channel types other than DDS, AO and DO in check_remote_values')
        pstarkey:                     
        pstarkey:             if changed:
        pstarkey:                 overall_changed = True
        pstarkey:             
        pstarkey:                 # Add the changed widget for this channel to a layout!
        pstarkey:                 self._ui.changed_layout.addWidget(ui)
        pstarkey:                 
        pstarkey:                 # save the radio buttons so that we can access their state later!
        pstarkey:                 self._changed_radio_buttons[channel] = ui.use_remote_values
        pstarkey:                 
        pstarkey:         if overall_changed:
        pstarkey:             # TODO: Disable all widgets for this device, including virtual device widgets...how do I do that?????
        pstarkey:             # Probably need to add a disable/enable method to analog/digital/DDS widgets that disables the widget and is orthogonal to the lock/unlock system
        pstarkey:             # Should probably set a tooltip on the widgets too explaining why they are disabled!
        pstarkey:             # self._device_widget.setSensitive(False)
        pstarkey:             # show the remote_values_change dialog
        pstarkey:             self._changed_widget.show()
        pstarkey:         
        pstarkey:             # Add an "apply" button and link to on_resolve_value_inconsistency
chrisjbillington:             buttonWidget = QWidget()
chrisjbillington:             buttonlayout = QHBoxLayout(buttonWidget)
chrisjbillington:             button = QPushButton(QIcon(':/qtutils/fugue/arrow-turn-000-left'), "Apply")
chrisjbillington:             button.clicked.connect(self.on_resolve_value_inconsistency)
chrisjbillington:             buttonlayout.addWidget(button)
chrisjbillington:             buttonlayout.addStretch()
chrisjbillington: 
chrisjbillington:             self._ui.changed_layout.addWidget(buttonWidget)
chrisjbillington: 
        pstarkey:     def on_resolve_value_inconsistency(self):
        pstarkey:         # get the values and update the device/front panel
        pstarkey:         needs_programming = False
        pstarkey:         for channel,radio in self._changed_radio_buttons.items():
        pstarkey:             if radio.isChecked():
        pstarkey:                 output = self.get_channel(channel)
        pstarkey:                 if output is None:
        pstarkey:                     raise RuntimeError('on_resolve_value_inconsistency is being asked to handle a channel that is not a DDS, AO or DO (channel: %s, device: %s)'%(channel,self.device_name))
        pstarkey:                 # The device already has this value, so no need to program it!
        pstarkey:                 output.set_value(self._last_remote_values[channel],program=False)
        pstarkey:             else:
        pstarkey:                 # we only need to program the device if one or more channels is using the front panel value
        pstarkey:                 needs_programming = True
        pstarkey:                 
        pstarkey:         if needs_programming:
        pstarkey:             self.program_device()
        pstarkey:         else:
        pstarkey:             # Now that the inconsistency is resolved, Let's update the "last programmed values"
        pstarkey:             # to match the remote values
        pstarkey:             self._last_programmed_values = self.get_front_panel_values()
        pstarkey:             
        pstarkey:         self._changed_widget.hide()
        pstarkey:     
        pstarkey:     @define_state(MODE_BUFFERED,True)
        pstarkey:     def start_run(self,notify_queue):
        pstarkey:         raise NotImplementedError('The device %s has not implemented a start method and so cannot be used to trigger the experiment to begin. Please implement the start method or use a different pseudoclock as the master pseudoclock'%self.device_name)
        pstarkey:     
        pstarkey:     @define_state(MODE_MANUAL,True)
        pstarkey:     def transition_to_buffered(self,h5_file,notify_queue): 
        pstarkey:         # Get rid of any "remote values changed" dialog
        pstarkey:         self._changed_widget.hide()
        pstarkey:     
        pstarkey:         self.mode = MODE_TRANSITION_TO_BUFFERED
        pstarkey:         
        pstarkey:         # transition_to_buffered returns the final values of the run, to update the GUI with at the end of the run:
        pstarkey:         transitioned_called = [self._primary_worker]
        pstarkey:         front_panel_values = self.get_front_panel_values()
        pstarkey:         self._final_values = yield(self.queue_work(self._primary_worker,'transition_to_buffered',self.device_name,h5_file,front_panel_values,self._force_full_buffered_reprogram))
        pstarkey:         if self._final_values is not None:
        pstarkey:             for worker in self._secondary_workers:
        pstarkey:                 transitioned_called.append(worker)
        pstarkey:                 extra_final_values = yield(self.queue_work(worker,'transition_to_buffered',self.device_name,h5_file,front_panel_values,self.force_full_buffered_reprogram))
        pstarkey:                 if extra_final_values is not None:
        pstarkey:                     self._final_values.update(extra_final_values)
        pstarkey:                 else:
        pstarkey:                     self._final_values = None
        pstarkey:                     break
        pstarkey:         
        pstarkey:         # If we get None back, then the worker process did not finish properly
        pstarkey:         if self._final_values is None:
        pstarkey:             notify_queue.put([self.device_name,'fail'])
        pstarkey:             self.abort_transition_to_buffered(transitioned_called)
        pstarkey:         else:
        pstarkey:             if self._supports_smart_programming:
        pstarkey:                 self.force_full_buffered_reprogram = False
chrisjbillington:                 self._ui.button_clear_smart_programming.setEnabled(True)
        pstarkey:             # Tell the queue manager that we're done:
        pstarkey:             self.mode = MODE_BUFFERED
        pstarkey:             notify_queue.put([self.device_name,'success'])
        pstarkey:        
        pstarkey:     @define_state(MODE_TRANSITION_TO_BUFFERED,False)
        pstarkey:     def abort_transition_to_buffered(self,workers=None):
        pstarkey:         if workers is None:
        pstarkey:             workers = [self._primary_worker]
        pstarkey:             workers.extend(self._secondary_workers)
        pstarkey:         success = True
        pstarkey:         for worker in workers:
        pstarkey:             abort_success = yield(self.queue_work(worker,'abort_transition_to_buffered'))
        pstarkey:             if not abort_success:
        pstarkey:                 success = False
        pstarkey:                 # don't break here, so that as much of the device is returned to normal
        pstarkey:                 
        pstarkey:         if success:
        pstarkey:             self.mode = MODE_MANUAL
        pstarkey:             self.program_device()
        pstarkey:         else:
        pstarkey:             raise Exception('Could not abort transition_to_buffered. You must restart this device to continue')
        pstarkey:         
        pstarkey:     @define_state(MODE_BUFFERED,False)
        pstarkey:     def abort_buffered(self,notify_queue):
        pstarkey:         success = yield(self.queue_work(self._primary_worker,'abort_buffered'))
        pstarkey:         for worker in self._secondary_workers:
        pstarkey:             abort_success = yield(self.queue_work(worker,'abort_buffered'))
        pstarkey:             if not abort_success:
        pstarkey:                 success = False
        pstarkey:                 # don't break here, so that as much of the device is returned to normal
        pstarkey:         
        pstarkey:         if success:
        pstarkey:             notify_queue.put([self.device_name,'success'])
        pstarkey:             self.mode = MODE_MANUAL
        pstarkey:             self.program_device()
        pstarkey:         else:
        pstarkey:             notify_queue.put([self.device_name,'fail'])
        pstarkey:             raise Exception('Could not abort the buffered sequence. You must restart this device to continue')
        pstarkey:             
        pstarkey:     @define_state(MODE_BUFFERED,False)
        pstarkey:     def transition_to_manual(self,notify_queue,program=False):
        pstarkey:         self.mode = MODE_TRANSITION_TO_MANUAL
        pstarkey:         
        pstarkey:         success = yield(self.queue_work(self._primary_worker,'transition_to_manual'))
        pstarkey:         for worker in self._secondary_workers:
        pstarkey:             transition_success = yield(self.queue_work(worker,'transition_to_manual'))
        pstarkey:             if not transition_success:
        pstarkey:                 success = False
        pstarkey:                 # don't break here, so that as much of the device is returned to normal
        pstarkey:         
        pstarkey:         # Update the GUI with the final values of the run:
        pstarkey:         for channel, value in self._final_values.items():
        pstarkey:             if channel in self._AO:
        pstarkey:                 self._AO[channel].set_value(value,program=False)
        pstarkey:             elif channel in self._DO:
        pstarkey:                 self._DO[channel].set_value(value,program=False)
        pstarkey:             elif channel in self._DDS:
        pstarkey:                 self._DDS[channel].set_value(value,program=False)
        pstarkey:         
        pstarkey:         
        pstarkey:             
        pstarkey:         if success:
        pstarkey:             notify_queue.put([self.device_name,'success'])
        pstarkey:             self.mode = MODE_MANUAL
        pstarkey:         else:
        pstarkey:             notify_queue.put([self.device_name,'fail'])
        pstarkey:             raise Exception('Could not transition to manual. You must restart this device to continue')
        pstarkey:             
        pstarkey:         if program:
        pstarkey:             self.program_device()
        pstarkey:         else:
        pstarkey:             self._last_programmed_values = self.get_front_panel_values()
        pstarkey:             
        pstarkey: class DeviceWorker(Worker):
        pstarkey:     def init(self):
        pstarkey:         # You read correctly, this isn't __init__, it's init. It's the
        pstarkey:         # first thing that will be called in the new process. You should
        pstarkey:         # do imports here, define instance variables, that sort of thing. You
        pstarkey:         # shouldn't import the hardware modules at the top of your file,
        pstarkey:         # because then they will be imported in both the parent and
        pstarkey:         # the child processes and wont be cleanly restarted when the subprocess
        pstarkey:         # is restarted. Since we're inside a method call though, you'll
        pstarkey:         # have to use global statements for the module imports, as shown
        pstarkey:         # below. Either that or you can make them instance variables, ie:
        pstarkey:         # import module; self.module = module. Up to you, I prefer
        pstarkey:         # the former.
        pstarkey:         global serial; import serial
        pstarkey:         global time; import time
        pstarkey:         
        pstarkey:         self.fpv = {}
        pstarkey:     
        pstarkey:     def initialise(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def shutdown(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def program_manual(self,front_panel_values):
        pstarkey:         for channel,value in front_panel_values.items():
        pstarkey:             if type(value) != type(True):
        pstarkey:                 front_panel_values[channel] += 0.001
        pstarkey:         self.fpv = front_panel_values
        pstarkey:         return front_panel_values
        pstarkey:         
        pstarkey:     def check_remote_values(self):
        pstarkey:         front_panel_values = {}
        pstarkey:         for channel,value in self.fpv.items():
        pstarkey:             if type(value) != type(True):
        pstarkey:                 front_panel_values[channel] = value + 1.1
        pstarkey:             else:
        pstarkey:                 front_panel_values[channel] = not value
        pstarkey:         
        pstarkey:         if not front_panel_values:
        pstarkey:             front_panel_values['ao0'] = 0
        pstarkey:         
        pstarkey:         return front_panel_values
        pstarkey:         
        pstarkey:     def transition_to_buffered(self,device_name,h5file,front_panel_values,refresh):
        pstarkey:         time.sleep(3)
        pstarkey:         for channel,value in front_panel_values.items():
        pstarkey:             if type(value) != type(True):
        pstarkey:                 front_panel_values[channel] += 0.003
        pstarkey:         return front_panel_values
        pstarkey:         
        pstarkey:     def abort_transition_to_buffered(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def abort_buffered(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def transition_to_manual(self):
        pstarkey:         return True
        pstarkey:         
        pstarkey:             
        pstarkey: if __name__ == '__main__':
        pstarkey:     import sys
        pstarkey:     import logging.handlers
        pstarkey:     # Setup logging:
        pstarkey:     logger = logging.getLogger('BLACS')
chrisjbillington:     handler = logging.handlers.RotatingFileHandler(os.path.join(BLACS_DIR, 'BLACS.log'), maxBytes=1024**2, backupCount=0)
        pstarkey:     formatter = logging.Formatter('%(asctime)s %(levelname)s %(name)s: %(message)s')
        pstarkey:     handler.setFormatter(formatter)
        pstarkey:     handler.setLevel(logging.DEBUG)
        pstarkey:     logger.addHandler(handler)
     janwerkmann:     if sys.stdout is not None and sys.stdout.isatty():
        pstarkey:         terminalhandler = logging.StreamHandler(sys.stdout)
        pstarkey:         terminalhandler.setFormatter(formatter)
        pstarkey:         terminalhandler.setLevel(logging.DEBUG)
        pstarkey:         logger.addHandler(terminalhandler)
        pstarkey:     else:
        pstarkey:         sys.stdout = sys.stderr = open(os.devnull)
        pstarkey:     logger.setLevel(logging.DEBUG)
        pstarkey:     #labscript_utils.excepthook.set_logger(logger)
        pstarkey:     logger.info('\n\n===============starting===============\n')
        pstarkey:             
        pstarkey: if __name__ == '__main__':
        pstarkey:     # Test case!
        pstarkey:     
        pstarkey:     from connections import ConnectionTable
        pstarkey:     from labscript_utils.qtwidgets.dragdroptab import DragDropTabWidget
        pstarkey:     
        pstarkey:     class MyTab(DeviceTab):
        pstarkey:         
        pstarkey:         def initialise_GUI(self):
        pstarkey:             # Create Digital Output Objects
        pstarkey:             do_prop = {}
        pstarkey:             for i in range(32):
        pstarkey:                 do_prop['port0/line%d'%i] = {}
        pstarkey:             self.create_digital_outputs(do_prop)
        pstarkey:                 
        pstarkey:             # Create Analog Output objects
        pstarkey:             ao_prop = {}
        pstarkey:             for i in range(4):
        pstarkey:                 ao_prop['ao%d'%i] = {'base_unit':'V',
        pstarkey:                                      'min':-10.0,
        pstarkey:                                      'max':10.0,
        pstarkey:                                      'step':0.01,
        pstarkey:                                      'decimals':3
        pstarkey:                                     }            
        pstarkey:             self.create_analog_outputs(ao_prop)
        pstarkey:             
        pstarkey:             # Create widgets for output objects
        pstarkey:             dds_widgets,ao_widgets,do_widgets = self.auto_create_widgets()
        pstarkey:             
        pstarkey:             # This function allows you do sort the order of widgets by hardware name.
        pstarkey:             # it is pass to the Python 'sorted' function as key=sort when passed in as 
        pstarkey:             # the 3rd item of a tuple p(the tuple being an argument of self.auto_place_widgets()
        pstarkey:             #
        pstarkey:             # This function takes the channel name (hardware name) and returns a string (or whatever) 
        pstarkey:             # that when sorted alphabetically, returns the correct order
        pstarkey:             def sort(channel):
        pstarkey:                 port,line = channel.replace('port','').replace('line','').split('/')
        pstarkey:                 port,line = int(port),int(line)
        pstarkey:                 return '%02d/%02d'%(port,line)
        pstarkey:             
        pstarkey:             # and auto place them in the UI
        pstarkey:             self.auto_place_widgets(("DDS Outputs",dds_widgets),("Analog Outputs",ao_widgets),("Digital Outputs - Port 0",do_widgets,sort))
        pstarkey:             
        pstarkey:             # Set the primary worker
        pstarkey:             self.create_worker("my_worker_name",DeviceWorker,{})
        pstarkey:             self.primary_worker = "my_worker_name"    
        pstarkey:             self.create_worker("my_secondary_worker_name",DeviceWorker,{})
        pstarkey:             self.add_secondary_worker("my_secondary_worker_name")
        pstarkey:     
        pstarkey:             self.supports_remote_value_check(True)
        pstarkey:     
        pstarkey:             # Create buttons to test things!
        pstarkey:             button1 = QPushButton("Transition to Buffered")
     janwerkmann:             if PY2:
     janwerkmann:                 from Queue import Queue
     janwerkmann:             else:
     janwerkmann:                 from queue import Queue
        pstarkey:             button1.clicked.connect(lambda: self.transition_to_buffered('',Queue()))
        pstarkey:             self.get_tab_layout().addWidget(button1)
        pstarkey:             button2 = QPushButton("Transition to Manual")
        pstarkey:             button2.clicked.connect(lambda: self.transition_to_manual(Queue()))
        pstarkey:             self.get_tab_layout().addWidget(button2)
        pstarkey:     
        pstarkey:     connection_table = ConnectionTable(r'example_connection_table.h5')
        pstarkey:     
        pstarkey:     class MyWindow(QWidget):
        pstarkey:         
        pstarkey:         def __init__(self,*args,**kwargs):
        pstarkey:             QWidget.__init__(self,*args,**kwargs)
        pstarkey:             self.are_we_closed = False
        pstarkey:         
        pstarkey:         def closeEvent(self,event):
        pstarkey:             if not self.are_we_closed:        
        pstarkey:                 event.ignore()
        pstarkey:                 self.my_tab.destroy()
        pstarkey:                 self.are_we_closed = True
        pstarkey:                 QTimer.singleShot(1000,self.close)
        pstarkey:             else:
        pstarkey:                 if not self.my_tab.destroy_complete: 
        pstarkey:                     QTimer.singleShot(1000,self.close)                    
        pstarkey:                 else:
        pstarkey:                     event.accept()
        pstarkey:     
        pstarkey:         def add_my_tab(self,tab):
        pstarkey:             self.my_tab = tab
        pstarkey:     
        pstarkey:     app = QApplication(sys.argv)
        pstarkey:     window = MyWindow()
        pstarkey:     layout = QVBoxLayout(window)
        pstarkey:     notebook = DragDropTabWidget()
        pstarkey:     layout.addWidget(notebook)
        pstarkey:     
        pstarkey:     tab1 = MyTab(notebook,settings = {'device_name': 'ni_pcie_6363_0', 'connection_table':connection_table})
        pstarkey:     window.add_my_tab(tab1)
        pstarkey:     window.show()
        pstarkey:     def run():
        pstarkey:         app.exec_()
        pstarkey:         
        cbilling:     sys.exit(run())
             jan: #####################################################################
             jan: #                                                                   #
chrisjbillington: # /experiment_queue.py                                                         #
             jan: #                                                                   #
             jan: # Copyright 2013, Monash University                                 #
             jan: #                                                                   #
             jan: # This file is part of the program BLACS, in the labscript suite    #
             jan: # (see http://labscriptsuite.org), and is licensed under the        #
             jan: # Simplified BSD License. See the license.txt file in the root of   #
             jan: # the project for the full license.                                 #
             jan: #                                                                   #
             jan: #####################################################################
             jan: from __future__ import division, unicode_literals, print_function, absolute_import
             jan: from labscript_utils import PY2
             jan: if PY2:
             jan:     str = unicode
             jan:     import Queue as queue
             jan: else:
             jan:     import queue
             jan: 
             jan: import logging
             jan: import os
             jan: import platform
             jan: import threading
             jan: import time
             jan: import sys
             jan: import shutil
             jan: 
             jan: from qtutils.qt.QtCore import *
             jan: from qtutils.qt.QtGui import *
             jan: from qtutils.qt.QtWidgets import *
             jan: 
             jan: import zprocess
             jan: import zprocess.locking, labscript_utils.h5_lock, h5py
             jan: zprocess.locking.set_client_process_name('BLACS.queuemanager')
             jan: 
             jan: from qtutils import *
             jan: 
             jan: from labscript_utils.qtwidgets.elide_label import elide_label
chrisjbillington: from labscript_utils.connections import ConnectionTable
             jan: 
             jan: from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
             jan: 
             jan: FILEPATH_COLUMN = 0
             jan: 
             jan: class QueueTreeview(QTreeView):
             jan:     def __init__(self,*args,**kwargs):
             jan:         QTreeView.__init__(self,*args,**kwargs)
             jan:         self.header().setStretchLastSection(True)
             jan:         self.setAutoScroll(False)
             jan:         self.add_to_queue = None
             jan:         self.delete_selection = None
             jan:         self._logger = logging.getLogger('BLACS.QueueManager') 
             jan: 
             jan:     def keyPressEvent(self,event):
             jan:         if event.key() == Qt.Key_Delete:
             jan:             event.accept()
             jan:             if self.delete_selection:
             jan:                 self.delete_selection()
             jan:         QTreeView.keyPressEvent(self,event)
             jan:         
             jan:     def dragEnterEvent(self, event):
             jan:         if event.mimeData().hasUrls():
             jan:             event.accept()
             jan:         else:
             jan:             event.ignore()
             jan: 
             jan:     def dragMoveEvent(self, event):
             jan:         if event.mimeData().hasUrls():
             jan:             event.setDropAction(Qt.CopyAction)
             jan:             event.accept()
             jan:         else:
             jan:             event.ignore()
             jan: 
             jan:     def dropEvent(self, event):
             jan:         if event.mimeData().hasUrls():
             jan:             event.setDropAction(Qt.CopyAction)
             jan:             event.accept()
             jan:             
             jan:             for url in event.mimeData().urls():
             jan:                 path = str(url.toLocalFile())
             jan:                 if path.endswith('.h5') or path.endswith('.hdf5'):
             jan:                     self._logger.info('Acceptable file dropped. Path is %s'%path)
             jan:                     if self.add_to_queue:
             jan:                         self.add_to_queue(str(path))
             jan:                     else:
             jan:                         self._logger.info('Dropped file not added to queue because there is no access to the neccessary add_to_queue method')
             jan:                 else:
             jan:                     self._logger.info('Invalid file dropped. Path was %s'%path)
             jan:         else:
             jan:             event.ignore()
             jan: 
             jan: class QueueManager(object):
             jan:     
             jan:     REPEAT_ALL = 0
             jan:     REPEAT_LAST = 1
             jan: 
             jan:     ICON_REPEAT = ':qtutils/fugue/arrow-repeat'
             jan:     ICON_REPEAT_LAST = ':qtutils/fugue/arrow-repeat-once'
             jan: 
             jan:     def __init__(self, BLACS, ui):
             jan:         self._ui = ui
             jan:         self.BLACS = BLACS
             jan:         self.last_opened_shots_folder = BLACS.exp_config.get('paths', 'experiment_shot_storage')
             jan:         self._manager_running = True
             jan:         self._manager_paused = False
             jan:         self._manager_repeat = False
             jan:         self._manager_repeat_mode = self.REPEAT_ALL
             jan:         self.master_pseudoclock = self.BLACS.connection_table.master_pseudoclock
             jan:         
             jan:         self._logger = logging.getLogger('BLACS.QueueManager')   
             jan:         
             jan:         # Create listview model
             jan:         self._model = QStandardItemModel()
             jan:         self._create_headers()
             jan:         self._ui.treeview.setModel(self._model)
             jan:         self._ui.treeview.add_to_queue = self.process_request
             jan:         self._ui.treeview.delete_selection = self._delete_selected_items
             jan:         
             jan:         # set up buttons
             jan:         self._ui.queue_pause_button.toggled.connect(self._toggle_pause)
             jan:         self._ui.queue_repeat_button.toggled.connect(self._toggle_repeat)
             jan:         self._ui.queue_delete_button.clicked.connect(self._delete_selected_items)
             jan:         self._ui.queue_clear_button.clicked.connect(self._toggle_clear)
             jan:         self._ui.actionAdd_to_queue.triggered.connect(self.on_add_shots_triggered)
             jan:         self._ui.queue_add_button.setDefaultAction(self._ui.actionAdd_to_queue)
             jan:         self._ui.queue_push_up.clicked.connect(self._move_up)
             jan:         self._ui.queue_push_down.clicked.connect(self._move_down)
             jan:         self._ui.queue_push_to_top.clicked.connect(self._move_top)
             jan:         self._ui.queue_push_to_bottom.clicked.connect(self._move_bottom)
             jan: 
             jan:         # Set the elision of the status labels:
             jan:         elide_label(self._ui.queue_status, self._ui.queue_status_verticalLayout, Qt.ElideRight)
             jan:         elide_label(self._ui.running_shot_name, self._ui.queue_status_verticalLayout, Qt.ElideLeft)
             jan:         
             jan:         # Set up repeat mode button menu:
             jan:         self.repeat_mode_menu = QMenu(self._ui)
             jan: 
             jan:         self.action_repeat_all = QAction(QIcon(self.ICON_REPEAT), 'Repeat all', self._ui)
             jan:         self.action_repeat_last = QAction(QIcon(self.ICON_REPEAT_LAST), 'Repeat last', self._ui)
             jan: 
             jan:         self.action_repeat_all.triggered.connect(lambda *args: setattr(self, 'manager_repeat_mode', self.REPEAT_ALL))
             jan:         self.action_repeat_last.triggered.connect(lambda *args: setattr(self, 'manager_repeat_mode', self.REPEAT_LAST))
             jan: 
             jan:         self.repeat_mode_menu.addAction(self.action_repeat_all)
             jan:         self.repeat_mode_menu.addAction(self.action_repeat_last)
             jan: 
             jan:         self._ui.repeat_mode_select_button.setMenu(self.repeat_mode_menu)
             jan: 
             jan:         # The button already has an arrow indicating a menu, don't draw another one:
             jan:         self._ui.repeat_mode_select_button.setStyleSheet("QToolButton::menu-indicator{width: 0;}")
             jan: 
             jan:         self.manager = threading.Thread(target = self.manage)
             jan:         self.manager.daemon=True
             jan:         self.manager.start()
             jan: 
             jan:         self._callbacks = None
             jan: 
             jan:     def _create_headers(self):
             jan:         self._model.setHorizontalHeaderItem(FILEPATH_COLUMN, QStandardItem('Filepath'))
             jan:         
             jan:     def get_save_data(self):
             jan:         # get list of files in the queue
             jan:         file_list = []
             jan:         for i in range(self._model.rowCount()):
             jan:             file_list.append(self._model.item(i).text())
             jan:         # get button states
             jan:         return {'manager_paused':self.manager_paused,
             jan:                 'manager_repeat':self.manager_repeat,
             jan:                 'manager_repeat_mode':self.manager_repeat_mode,
             jan:                 'files_queued':file_list,
             jan:                 'last_opened_shots_folder': self.last_opened_shots_folder
             jan:                }
             jan:     
             jan:     def restore_save_data(self,data):
             jan:         if 'manager_paused' in data:
             jan:             self.manager_paused = data['manager_paused']
             jan:         if 'manager_repeat' in data:
             jan:             self.manager_repeat = data['manager_repeat']
             jan:         if 'manager_repeat_mode' in data:
             jan:             self.manager_repeat_mode = data['manager_repeat_mode']
             jan:         if 'files_queued' in data:
             jan:             file_list = list(data['files_queued'])
             jan:             self._model.clear()
             jan:             self._create_headers()
             jan:             for file in file_list:
             jan:                 self.process_request(str(file))
             jan:         if 'last_opened_shots_folder' in data:
             jan:             self.last_opened_shots_folder = data['last_opened_shots_folder']
             jan:         
             jan:     @property
             jan:     @inmain_decorator(True)
             jan:     def manager_running(self):
             jan:         return self._manager_running
             jan:         
             jan:     @manager_running.setter
             jan:     @inmain_decorator(True)
             jan:     def manager_running(self,value):
             jan:         value = bool(value)
             jan:         self._manager_running = value
             jan:         
             jan:     def _toggle_pause(self,checked):    
             jan:         self.manager_paused = checked
             jan: 
             jan:     def _toggle_clear(self):
             jan:         self._model.clear()
             jan:         self._create_headers()
             jan: 
             jan:     @property
             jan:     @inmain_decorator(True)
             jan:     def manager_paused(self):
             jan:         return self._manager_paused
             jan:     
             jan:     @manager_paused.setter
             jan:     @inmain_decorator(True)
             jan:     def manager_paused(self,value):
             jan:         value = bool(value)
             jan:         self._manager_paused = value
             jan:         if value != self._ui.queue_pause_button.isChecked():
             jan:             self._ui.queue_pause_button.setChecked(value)
             jan:     
             jan:     def _toggle_repeat(self,checked):    
             jan:         self.manager_repeat = checked
             jan:         
             jan:     @property
             jan:     @inmain_decorator(True)
             jan:     def manager_repeat(self):
             jan:         return self._manager_repeat
             jan: 
             jan:     @manager_repeat.setter
             jan:     @inmain_decorator(True)
             jan:     def manager_repeat(self,value):
             jan:         value = bool(value)
             jan:         self._manager_repeat = value
             jan:         if value != self._ui.queue_repeat_button.isChecked():
             jan:             self._ui.queue_repeat_button.setChecked(value)
             jan: 
             jan:     @property
             jan:     @inmain_decorator(True)
             jan:     def manager_repeat_mode(self):
             jan:         return self._manager_repeat_mode
             jan: 
             jan:     @manager_repeat_mode.setter
             jan:     @inmain_decorator(True)
             jan:     def manager_repeat_mode(self, value):
             jan:         assert value in [self.REPEAT_LAST, self.REPEAT_ALL]
             jan:         self._manager_repeat_mode = value
             jan:         button = self._ui.queue_repeat_button
             jan:         if value == self.REPEAT_ALL:
             jan:             button.setIcon(QIcon(self.ICON_REPEAT))
             jan:         elif value == self.REPEAT_LAST:
             jan:             button.setIcon(QIcon(self.ICON_REPEAT_LAST))
             jan: 
             jan:     @inmain_decorator(True)
             jan:     def get_callbacks(self, name, update_cache=False):
             jan:         if update_cache or self._callbacks is None:
             jan:             self._callbacks = {}
             jan:             try:
             jan:                 for plugin in self.BLACS.plugins.values():
             jan:                     callbacks = plugin.get_callbacks()
             jan:                     if isinstance(callbacks, dict):
             jan:                         for callback_name, callback in callbacks.items():
             jan:                             if callback_name not in self._callbacks:
             jan:                                 self._callbacks[callback_name] = []
             jan:                             self._callbacks[callback_name].append(callback)
             jan:             except Exception as e:
             jan:                 self._logger.exception('A Error occurred during get_callbacks.')
             jan: 
             jan:         if name in self._callbacks:
             jan:             return self._callbacks[name]
             jan:         else:
             jan:             return []
             jan: 
             jan:     def on_add_shots_triggered(self):
             jan:         shot_files = QFileDialog.getOpenFileNames(self._ui, 'Select shot files',
             jan:                                                   self.last_opened_shots_folder,
             jan:                                                   "HDF5 files (*.h5)")
             jan:         if isinstance(shot_files, tuple):
             jan:             shot_files, _ = shot_files
             jan: 
             jan:         if not shot_files:
             jan:             # User cancelled selection
             jan:             return
             jan:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
             jan:         shot_files = [os.path.abspath(str(shot_file)) for shot_file in shot_files]
             jan: 
             jan:         # Save the containing folder for use next time we open the dialog box:
             jan:         self.last_opened_shots_folder = os.path.dirname(shot_files[0])
             jan:         # Queue the files to be opened:
             jan:         for filepath in shot_files:
             jan:             if filepath.endswith('.h5'):
             jan:                 self.process_request(str(filepath))
             jan: 
             jan:     def _delete_selected_items(self):
             jan:         index_list = self._ui.treeview.selectedIndexes()
             jan:         while index_list:
             jan:             self._model.takeRow(index_list[0].row())
             jan:             index_list = self._ui.treeview.selectedIndexes()
             jan:     
             jan:     def _move_up(self):        
             jan:         # Get the selection model from the treeview
             jan:         selection_model = self._ui.treeview.selectionModel()    
             jan:         # Create a list of select row indices
             jan:         selected_row_list = [index.row() for index in sorted(selection_model.selectedRows())]
             jan:         # For each row selected
             jan:         for i,row in enumerate(selected_row_list):
             jan:             # only move the row if it is not element 0, and the row above it is not selected
             jan:             # (note that while a row above may have been initially selected, it should by now, be one row higher
             jan:             # since we start moving elements of the list upwards starting from the lowest index)
             jan:             if row > 0 and (row-1) not in selected_row_list:
             jan:                 # Remove the selected row
             jan:                 items = self._model.takeRow(row)
             jan:                 # Add the selected row into a position one above
             jan:                 self._model.insertRow(row-1,items)
             jan:                 # Since it is now a newly inserted row, select it again
             jan:                 selection_model.select(self._model.indexFromItem(items[0]),QItemSelectionModel.SelectCurrent)
             jan:                 # reupdate the list of selected indices to reflect this change
             jan:                 selected_row_list[i] -= 1
             jan:        
             jan:     def _move_down(self):
             jan:         # Get the selection model from the treeview
             jan:         selection_model = self._ui.treeview.selectionModel()    
             jan:         # Create a list of select row indices
             jan:         selected_row_list = [index.row() for index in reversed(sorted(selection_model.selectedRows()))]
             jan:         # For each row selected
             jan:         for i,row in enumerate(selected_row_list):
             jan:             # only move the row if it is not the last element, and the row above it is not selected
             jan:             # (note that while a row below may have been initially selected, it should by now, be one row lower
             jan:             # since we start moving elements of the list upwards starting from the highest index)
             jan:             if row < self._model.rowCount()-1 and (row+1) not in selected_row_list:
             jan:                 # Remove the selected row
             jan:                 items = self._model.takeRow(row)
             jan:                 # Add the selected row into a position one above
             jan:                 self._model.insertRow(row+1,items)
             jan:                 # Since it is now a newly inserted row, select it again
             jan:                 selection_model.select(self._model.indexFromItem(items[0]),QItemSelectionModel.SelectCurrent)
             jan:                 # reupdate the list of selected indices to reflect this change
             jan:                 selected_row_list[i] += 1
             jan:         
             jan:     def _move_top(self):
             jan:         # Get the selection model from the treeview
             jan:         selection_model = self._ui.treeview.selectionModel()    
             jan:         # Create a list of select row indices
             jan:         selected_row_list = [index.row() for index in sorted(selection_model.selectedRows())]
             jan:         # For each row selected
             jan:         for i,row in enumerate(selected_row_list):
             jan:             # only move the row while it is not element 0, and the row above it is not selected
             jan:             # (note that while a row above may have been initially selected, it should by now, be one row higher
             jan:             # since we start moving elements of the list upwards starting from the lowest index)
             jan:             while row > 0 and (row-1) not in selected_row_list:
             jan:                 # Remove the selected row
             jan:                 items = self._model.takeRow(row)
             jan:                 # Add the selected row into a position one above
             jan:                 self._model.insertRow(row-1,items)
             jan:                 # Since it is now a newly inserted row, select it again
             jan:                 selection_model.select(self._model.indexFromItem(items[0]),QItemSelectionModel.SelectCurrent)
             jan:                 # reupdate the list of selected indices to reflect this change
             jan:                 selected_row_list[i] -= 1
             jan:                 row -= 1
             jan:               
             jan:     def _move_bottom(self):
             jan:         selection_model = self._ui.treeview.selectionModel()    
             jan:         # Create a list of select row indices
             jan:         selected_row_list = [index.row() for index in reversed(sorted(selection_model.selectedRows()))]
             jan:         # For each row selected
             jan:         for i,row in enumerate(selected_row_list):
             jan:             # only move the row while it is not the last element, and the row above it is not selected
             jan:             # (note that while a row below may have been initially selected, it should by now, be one row lower
             jan:             # since we start moving elements of the list upwards starting from the highest index)
             jan:             while row < self._model.rowCount()-1 and (row+1) not in selected_row_list:
             jan:                 # Remove the selected row
             jan:                 items = self._model.takeRow(row)
             jan:                 # Add the selected row into a position one above
             jan:                 self._model.insertRow(row+1,items)
             jan:                 # Since it is now a newly inserted row, select it again
             jan:                 selection_model.select(self._model.indexFromItem(items[0]),QItemSelectionModel.SelectCurrent)
             jan:                 # reupdate the list of selected indices to reflect this change
             jan:                 selected_row_list[i] += 1
             jan:                 row += 1
             jan:     
             jan:     @inmain_decorator(True)
             jan:     def append(self, h5files):
             jan:         for file in h5files:
             jan:             item = QStandardItem(file)
             jan:             item.setToolTip(file)
             jan:             self._model.appendRow(item)
             jan:     
             jan:     @inmain_decorator(True)
             jan:     def prepend(self,h5file):
             jan:         if not self.is_in_queue(h5file):
             jan:             self._model.insertRow(0,QStandardItem(h5file))
             jan:     
             jan:     def process_request(self,h5_filepath):
             jan:         # check connection table
             jan:         try:
chrisjbillington:             new_conn = ConnectionTable(h5_filepath, logging_prefix='BLACS')
chrisjbillington:         except Exception:
             jan:             return "H5 file not accessible to Control PC\n"
             jan:         result,error = inmain(self.BLACS.connection_table.compare_to,new_conn)
             jan:         if result:
             jan:             # Has this run file been run already?
             jan:             with h5py.File(h5_filepath) as h5_file:
             jan:                 if 'data' in h5_file['/']:
             jan:                     rerun = True
             jan:                 else:
             jan:                     rerun = False
             jan:             if rerun or self.is_in_queue(h5_filepath):
             jan:                 self._logger.debug('Run file has already been run! Creating a fresh copy to rerun')
             jan:                 new_h5_filepath, repeat_number = self.new_rep_name(h5_filepath)
             jan:                 # Keep counting up until we get a filename that isn't in the filesystem:
             jan:                 while os.path.exists(new_h5_filepath):
             jan:                     new_h5_filepath, repeat_number = self.new_rep_name(new_h5_filepath)
             jan:                 success = self.clean_h5_file(h5_filepath, new_h5_filepath, repeat_number=repeat_number)
             jan:                 if not success:
             jan:                    return 'Cannot create a re run of this experiment. Is it a valid run file?'
             jan:                 self.append([new_h5_filepath])
             jan:                 message = "Experiment added successfully: experiment to be re-run\n"
             jan:             else:
             jan:                 self.append([h5_filepath])
             jan:                 message = "Experiment added successfully\n"
             jan:             if self.manager_paused:
             jan:                 message += "Warning: Queue is currently paused\n"
             jan:             if not self.manager_running:
             jan:                 message = "Error: Queue is not running\n"
             jan:             return message
             jan:         else:
             jan:             # TODO: Parse and display the contents of "error" in a more human readable format for analysis of what is wrong!
             jan:             message =  ("Connection table of your file is not a subset of the experimental control apparatus.\n"
             jan:                        "You may have:\n"
             jan:                        "    Submitted your file to the wrong control PC\n"
             jan:                        "    Added new channels to your h5 file, without rewiring the experiment and updating the control PC\n"
             jan:                        "    Renamed a channel at the top of your script\n"
             jan:                        "    Submitted an old file, and the experiment has since been rewired\n"
             jan:                        "\n"
             jan:                        "Please verify your experiment script matches the current experiment configuration, and try again\n"
             jan:                        "The error was %s\n"%error)
             jan:             return message
             jan:             
             jan:     def new_rep_name(self, h5_filepath):
             jan:         basename, ext = os.path.splitext(h5_filepath)
             jan:         if '_rep' in basename and ext == '.h5':
             jan:             reps = basename.split('_rep')[-1]
             jan:             try:
             jan:                 reps = int(reps)
             jan:             except ValueError:
             jan:                 # not a rep
             jan:                 pass
             jan:             else:
             jan:                 return ''.join(basename.split('_rep')[:-1]) + '_rep%05d.h5' % (reps + 1), reps + 1
             jan:         return basename + '_rep%05d.h5' % 1, 1
             jan:         
             jan:     def clean_h5_file(self, h5file, new_h5_file, repeat_number=0):
             jan:         try:
             jan:             with h5py.File(h5file,'r') as old_file:
             jan:                 with h5py.File(new_h5_file,'w') as new_file:
             jan:                     groups_to_copy = ['devices', 'calibrations', 'script', 'globals', 'connection table', 
             jan:                                       'labscriptlib', 'waits']
             jan:                     for group in groups_to_copy:
             jan:                         if group in old_file:
             jan:                             new_file.copy(old_file[group], group)
             jan:                     for name in old_file.attrs:
             jan:                         new_file.attrs[name] = old_file.attrs[name]
             jan:                     new_file.attrs['run repeat'] = repeat_number
             jan:         except Exception as e:
             jan:             #raise
             jan:             self._logger.exception('Clean H5 File Error.')
             jan:             return False
             jan:             
             jan:         return True
             jan:     
             jan:     @inmain_decorator(wait_for_return=True)    
             jan:     def is_in_queue(self,path):                
             jan:         item = self._model.findItems(path,column=FILEPATH_COLUMN)
             jan:         if item:
             jan:             return True
             jan:         else:
             jan:             return False
             jan: 
             jan:     @inmain_decorator(wait_for_return=True)
             jan:     def set_status(self, queue_status, shot_filepath=None):
             jan:         self._ui.queue_status.setText(str(queue_status))
             jan:         if shot_filepath is not None:
             jan:             self._ui.running_shot_name.setText('<b>%s</b>'% str(os.path.basename(shot_filepath)))
             jan:         else:
             jan:             self._ui.running_shot_name.setText('')
             jan:         
             jan:     @inmain_decorator(wait_for_return=True)
             jan:     def get_status(self):
             jan:         return self._ui.queue_status.text()
             jan:             
             jan:     @inmain_decorator(wait_for_return=True)
             jan:     def get_next_file(self):
             jan:         return str(self._model.takeRow(0)[0].text())
             jan:     
             jan:     @inmain_decorator(wait_for_return=True)    
             jan:     def transition_device_to_buffered(self, name, transition_list, h5file, restart_receiver):
             jan:         tab = self.BLACS.tablist[name]
             jan:         if self.get_device_error_state(name,self.BLACS.tablist):
             jan:             return False
             jan:         tab.connect_restart_receiver(restart_receiver)
             jan:         tab.transition_to_buffered(h5file,self.current_queue)
             jan:         transition_list[name] = tab
             jan:         return True
             jan:     
             jan:     @inmain_decorator(wait_for_return=True)
             jan:     def get_device_error_state(self,name,device_list):
             jan:         return device_list[name].error_message
             jan:        
             jan:      
             jan:     def manage(self):
             jan:         logger = logging.getLogger('BLACS.queue_manager.thread')   
             jan:         # While the program is running!
             jan:         logger.info('starting')
             jan:         
             jan:         # HDF5 prints lots of errors by default, for things that aren't
             jan:         # actually errors. These are silenced on a per thread basis,
             jan:         # and automatically silenced in the main thread when h5py is
             jan:         # imported. So we'll silence them in this thread too:
             jan:         h5py._errors.silence_errors()
             jan:         
             jan:         # This name stores the queue currently being used to
             jan:         # communicate with tabs, so that abort signals can be put
             jan:         # to it when those tabs never respond and are restarted by
             jan:         # the user.
             jan:         self.current_queue = queue.Queue()
             jan: 
             jan:         #TODO: put in general configuration
             jan:         timeout_limit = 300 #seconds
             jan:         self.set_status("Idle")
             jan:         
             jan:         while self.manager_running:
             jan:             # If the pause button is pushed in, sleep
             jan:             if self.manager_paused:
             jan:                 if self.get_status() == "Idle":
             jan:                     logger.info('Paused')
             jan:                     self.set_status("Queue paused") 
             jan:                 time.sleep(1)
             jan:                 continue
             jan:             
             jan:             # Get the top file
             jan:             try:
             jan:                 path = self.get_next_file()
             jan:                 self.set_status('Preparing shot...', path)
             jan:                 logger.info('Got a file: %s'%path)
             jan:             except:
             jan:                 # If no files, sleep for 1s,
             jan:                 self.set_status("Idle")
             jan:                 time.sleep(1)
             jan:                 continue
             jan:             
             jan:             devices_in_use = {}
             jan:             transition_list = {}   
             jan:             start_time = time.time()
             jan:             self.current_queue = queue.Queue()
             jan: 
             jan:             # Function to be run when abort button is clicked
             jan:             def abort_function():
             jan:                 try:
             jan:                     # Set device name to "Queue Manager" which will never be a labscript device name
             jan:                     # as it is not a valid python variable name (has a space in it!)
             jan:                     self.current_queue.put(['Queue Manager', 'abort'])
             jan:                 except Exception:
             jan:                     logger.exception('Could not send abort message to the queue manager')
             jan:         
             jan:             def restart_function(device_name):
             jan:                 try:
             jan:                     self.current_queue.put([device_name, 'restart'])
             jan:                 except Exception:
             jan:                     logger.exception('Could not send restart message to the queue manager for device %s'%device_name)
             jan:         
             jan:             ##########################################################################################################################################
             jan:             #                                                       transition to buffered                                                           #
             jan:             ########################################################################################################################################## 
             jan:             try:  
             jan:                 # A Queue for event-based notification when the tabs have
             jan:                 # completed transitioning to buffered:        
             jan:                 
             jan:                 timed_out = False
             jan:                 error_condition = False
             jan:                 abort = False
             jan:                 restarted = False
             jan:                 self.set_status("Transitioning to buffered...", path)
             jan:                 
             jan:                 # Enable abort button, and link in current_queue:
             jan:                 inmain(self._ui.queue_abort_button.clicked.connect,abort_function)
             jan:                 inmain(self._ui.queue_abort_button.setEnabled,True)
             jan:                                 
             jan:                 
             jan:                 with h5py.File(path,'r') as hdf5_file:
             jan:                     h5_file_devices = list(hdf5_file['devices/'].keys())
             jan: 
             jan:                 for name in h5_file_devices:
             jan:                     try:
             jan:                         # Connect restart signal from tabs to current_queue and transition the device to buffered mode
             jan:                         success = self.transition_device_to_buffered(name,transition_list,path,restart_function)
             jan:                         if not success:
             jan:                             logger.error('%s has an error condition, aborting run' % name)
             jan:                             error_condition = True
             jan:                             break
             jan:                     except Exception as e:
             jan:                         logger.exception('Exception while transitioning %s to buffered mode.'%(name))
             jan:                         error_condition = True
             jan:                         break
             jan:                         
             jan:                 devices_in_use = transition_list.copy()
             jan: 
             jan:                 while transition_list and not error_condition:
             jan:                     try:
             jan:                         # Wait for a device to transtition_to_buffered:
             jan:                         logger.debug('Waiting for the following devices to finish transitioning to buffered mode: %s'%str(transition_list))
             jan:                         device_name, result = self.current_queue.get(timeout=2)
             jan:                         
             jan:                         #Handle abort button signal
             jan:                         if device_name == 'Queue Manager' and result == 'abort':
             jan:                             # we should abort the run
             jan:                             logger.info('abort signal received from GUI')
             jan:                             abort = True
             jan:                             break
             jan:                             
             jan:                         if result == 'fail':
             jan:                             logger.info('abort signal received during transition to buffered of %s' % device_name)
             jan:                             error_condition = True
             jan:                             break
             jan:                         elif result == 'restart':
             jan:                             logger.info('Device %s was restarted, aborting shot.'%device_name)
             jan:                             restarted = True
             jan:                             break
             jan:                             
             jan:                         logger.debug('%s finished transitioning to buffered mode' % device_name)
             jan:                         
             jan:                         # The tab says it's done, but does it have an error condition?
             jan:                         if self.get_device_error_state(device_name,transition_list):
             jan:                             logger.error('%s has an error condition, aborting run' % device_name)
             jan:                             error_condition = True
             jan:                             break
             jan: 
             jan:                         del transition_list[device_name]
             jan:                     except queue.Empty:
             jan:                         # It's been 2 seconds without a device finishing
             jan:                         # transitioning to buffered. Is there an error?
             jan:                         for name in transition_list:
             jan:                             if self.get_device_error_state(name,transition_list):
             jan:                                 error_condition = True
             jan:                                 break
             jan:                                 
             jan:                         if error_condition:
             jan:                             break
             jan:                             
             jan:                         # Has programming timed out?
             jan:                         if time.time() - start_time > timeout_limit:
             jan:                             logger.error('Transitioning to buffered mode timed out')
             jan:                             timed_out = True
             jan:                             break
             jan: 
             jan:                 # Handle if we broke out of loop due to timeout or error:
             jan:                 if timed_out or error_condition or abort or restarted:
             jan:                     # Pause the queue, re add the path to the top of the queue, and set a status message!
             jan:                     # only if we aren't responding to an abort click
             jan:                     if not abort:
             jan:                         self.manager_paused = True
             jan:                         self.prepend(path)                
             jan:                     if timed_out:
             jan:                         self.set_status("Programming timed out\nQueue paused")
             jan:                     elif abort:
             jan:                         self.set_status("Aborted")
             jan:                     elif restarted:
             jan:                         self.set_status("Device restarted in transition to\nbuffered. Aborted. Queue paused.")
             jan:                     else:
             jan:                         self.set_status("Device(s) in error state\nQueue Paused")
             jan:                         
             jan:                     # Abort the run for all devices in use:
             jan:                     # need to recreate the queue here because we don't want to hear from devices that are still transitioning to buffered mode
             jan:                     self.current_queue = queue.Queue()
             jan:                     for tab in devices_in_use.values():                        
             jan:                         # We call abort buffered here, because if each tab is either in mode=BUFFERED or transition_to_buffered failed in which case
             jan:                         # it should have called abort_transition_to_buffered itself and returned to manual mode
             jan:                         # Since abort buffered will only run in mode=BUFFERED, and the state is not queued indefinitely (aka it is deleted if we are not in mode=BUFFERED)
             jan:                         # this is the correct method call to make for either case
             jan:                         tab.abort_buffered(self.current_queue)
             jan:                         # We don't need to check the results of this function call because it will either be successful, or raise a visible error in the tab.
             jan:                         
             jan:                         # disconnect restart signal from tabs
             jan:                         inmain(tab.disconnect_restart_receiver,restart_function)
             jan:                         
             jan:                     # disconnect abort button and disable
             jan:                     inmain(self._ui.queue_abort_button.clicked.disconnect,abort_function)
             jan:                     inmain(self._ui.queue_abort_button.setEnabled,False)
             jan:                     
             jan:                     # Start a new iteration
             jan:                     continue
             jan:                 
             jan:             
             jan:             
             jan:                 ##########################################################################################################################################
             jan:                 #                                                             SCIENCE!                                                                   #
             jan:                 ##########################################################################################################################################
             jan:             
             jan:                 # Get front panel data, but don't save it to the h5 file until the experiment ends:
             jan:                 states,tab_positions,window_data,plugin_data = self.BLACS.front_panel_settings.get_save_data()
             jan:                 self.set_status("Running (program time: %.3fs)..."%(time.time() - start_time), path)
             jan:                     
             jan:                 # A Queue for event-based notification of when the experiment has finished.
             jan:                 experiment_finished_queue = queue.Queue()
             jan:                 logger.debug('About to start the master pseudoclock')
             jan:                 run_time = time.localtime()
             jan:                 #TODO: fix potential race condition if BLACS is closing when this line executes?
             jan:                 self.BLACS.tablist[self.master_pseudoclock].start_run(experiment_finished_queue)
             jan:                 
             jan:                                                 
             jan:                 # Wait for notification of the end of run:
             jan:                 abort = False
             jan:                 restarted = False
             jan:                 done = False
             jan:                 while not (abort or restarted or done):
             jan:                     try:
             jan:                         done = experiment_finished_queue.get(timeout=0.5) == 'done'
             jan:                     except queue.Empty:
             jan:                         pass
             jan:                     try:
             jan:                         # Poll self.current_queue for abort signal from button or device restart
             jan:                         device_name, result = self.current_queue.get_nowait()
             jan:                         if (device_name == 'Queue Manager' and result == 'abort'):
             jan:                             abort = True
             jan:                         if result == 'restart':
             jan:                             restarted = True
             jan:                         # Check for error states in tabs
             jan:                         for device_name, tab in devices_in_use.items():
             jan:                             if self.get_device_error_state(device_name,devices_in_use):
             jan:                                 restarted = True
             jan:                     except queue.Empty:
             jan:                         pass
             jan:                         
             jan:                 if abort or restarted:
             jan:                     for devicename, tab in devices_in_use.items():
             jan:                         if tab.mode == MODE_BUFFERED:
             jan:                             tab.abort_buffered(self.current_queue)
             jan:                         # disconnect restart signal from tabs 
             jan:                         inmain(tab.disconnect_restart_receiver,restart_function)
             jan:                                             
             jan:                 # Disable abort button
             jan:                 inmain(self._ui.queue_abort_button.clicked.disconnect,abort_function)
             jan:                 inmain(self._ui.queue_abort_button.setEnabled,False)
             jan:                 
             jan:                 if restarted:                    
             jan:                     self.manager_paused = True
             jan:                     self.prepend(path)  
             jan:                     self.set_status("Device restarted during run.\nAborted. Queue paused")
             jan:                 elif abort:
             jan:                     self.set_status("Aborted")
             jan:                     
             jan:                 if abort or restarted:
             jan:                     # after disabling the abort button, we now start a new iteration
             jan:                     continue                
             jan:                 
             jan:                 logger.info('Run complete')
             jan:                 self.set_status("Saving data...", path)
             jan:             # End try/except block here
             jan:             except Exception:
             jan:                 logger.exception("Error in queue manager execution. Queue paused.")
             jan: 
             jan:                 # Raise the error in a thread for visibility
             jan:                 zprocess.raise_exception_in_thread(sys.exc_info())
             jan:                 # clean up the h5 file
             jan:                 self.manager_paused = True
             jan:                 # is this a repeat?
             jan:                 try:
             jan:                     with h5py.File(path, 'r') as h5_file:
             jan:                         repeat_number = h5_file.attrs.get('run repeat', 0)
             jan:                 except:
             jan:                     repeat_numer = 0
             jan:                 # clean the h5 file:
             jan:                 self.clean_h5_file(path, 'temp.h5', repeat_number=repeat_number)
             jan:                 try:
             jan:                     shutil.move('temp.h5', path)
             jan:                 except Exception:
chrisjbillington:                     msg = ('Couldn\'t delete failed run file %s, ' % path + 
chrisjbillington:                            'another process may be using it. Using alternate ' 
chrisjbillington:                            'filename for second attempt.')
chrisjbillington:                     logger.warning(msg, exc_info=True)
             jan:                     shutil.move('temp.h5', path.replace('.h5','_retry.h5'))
             jan:                     path = path.replace('.h5','_retry.h5')
             jan:                 # Put it back at the start of the queue:
             jan:                 self.prepend(path)
             jan:                 
             jan:                 # Need to put devices back in manual mode
             jan:                 self.current_queue = queue.Queue()
             jan:                 for devicename, tab in devices_in_use.items():
             jan:                     if tab.mode == MODE_BUFFERED or tab.mode == MODE_TRANSITION_TO_BUFFERED:
             jan:                         tab.abort_buffered(self.current_queue)
             jan:                     # disconnect restart signal from tabs 
             jan:                     inmain(tab.disconnect_restart_receiver,restart_function)
             jan:                 self.set_status("Error in queue manager\nQueue paused")
             jan: 
             jan:                 # disconnect and disable abort button
             jan:                 inmain(self._ui.queue_abort_button.clicked.disconnect,abort_function)
             jan:                 inmain(self._ui.queue_abort_button.setEnabled,False)
             jan:                 
             jan:                 # Start a new iteration
             jan:                 continue
             jan:                              
             jan:             ##########################################################################################################################################
             jan:             #                                                           SCIENCE OVER!                                                                #
             jan:             ##########################################################################################################################################
             jan:             
             jan:             
             jan:             
             jan:             ##########################################################################################################################################
             jan:             #                                                       Transition to manual                                                             #
             jan:             ##########################################################################################################################################
             jan:             # start new try/except block here                   
             jan:             try:
             jan:                 with h5py.File(path,'r+') as hdf5_file:
             jan:                     self.BLACS.front_panel_settings.store_front_panel_in_h5(hdf5_file,states,tab_positions,window_data,plugin_data,save_conn_table=False, save_queue_data=False)
             jan: 
             jan:                     data_group = hdf5_file['/'].create_group('data')
             jan:                     # stamp with the run time of the experiment
             jan:                     hdf5_file.attrs['run time'] = time.strftime('%Y%m%dT%H%M%S',run_time)
             jan:         
             jan:                 # A Queue for event-based notification of when the devices have transitioned to static mode:
             jan:                 # Shouldn't need to recreate the queue: self.current_queue = queue.Queue()
             jan: 
             jan:                 # TODO: unserialise this if everything is using zprocess.locking
             jan:                 # only transition one device to static at a time,
             jan:                 # since writing data to the h5 file can potentially
             jan:                 # happen at this stage:
             jan:                 error_condition = False
             jan:                 
             jan:                 # This is far more complicated than it needs to be once transition_to_manual is unserialised!
             jan:                 response_list = {}
             jan:                 for device_name, tab in devices_in_use.items():
             jan:                     if device_name not in response_list:
             jan:                         tab.transition_to_manual(self.current_queue)               
             jan:                         while True:
             jan:                             # TODO: make the call to current_queue.get() timeout 
             jan:                             # and periodically check for error condition on the tab
             jan:                             got_device_name, result = self.current_queue.get()
             jan:                             # if the response is not for this device, then save it for later!
             jan:                             if device_name != got_device_name:
             jan:                                 response_list[got_device_name] = result
             jan:                             else:
             jan:                                 break
             jan:                     else:
             jan:                         result = response_list[device_name]
             jan:                     # Check for abort signal from device restart
             jan:                     if result == 'fail':
             jan:                         error_condition = True
             jan:                     if result == 'restart':
             jan:                         error_condition = True
             jan:                     if self.get_device_error_state(device_name,devices_in_use):
             jan:                         error_condition = True
             jan:                     # Once device has transitioned_to_manual, disconnect restart signal
             jan:                     inmain(tab.disconnect_restart_receiver,restart_function)
             jan:                     
             jan:                 if error_condition:                
             jan:                     self.set_status("Error in transtion to manual\nQueue Paused")
             jan:                                        
             jan:             except Exception as e:
             jan:                 error_condition = True
             jan:                 logger.exception("Error in queue manager execution. Queue paused.")
             jan:                 self.set_status("Error in queue manager\nQueue paused")
             jan: 
             jan:                 # Raise the error in a thread for visibility
             jan:                 zprocess.raise_exception_in_thread(sys.exc_info())
             jan:                 
             jan:             if error_condition:                
             jan:                 # clean up the h5 file
             jan:                 self.manager_paused = True
             jan:                 # is this a repeat?
             jan:                 try:
             jan:                     with h5py.File(path, 'r') as h5_file:
             jan:                         repeat_number = h5_file.attrs.get('run repeat', 0)
             jan:                 except:
             jan:                     repeat_number = 0
             jan:                 # clean the h5 file:
             jan:                 self.clean_h5_file(path, 'temp.h5', repeat_number=repeat_number)
             jan:                 try:
             jan:                     shutil.move('temp.h5', path)
             jan:                 except Exception:
chrisjbillington:                     msg = ('Couldn\'t delete failed run file %s, ' % path + 
chrisjbillington:                            'another process may be using it. Using alternate ' 
chrisjbillington:                            'filename for second attempt.')
chrisjbillington:                     logger.warning(msg, exc_info=True)
             jan:                     shutil.move('temp.h5', path.replace('.h5','_retry.h5'))
             jan:                     path = path.replace('.h5','_retry.h5')
             jan:                 # Put it back at the start of the queue:
             jan:                 self.prepend(path)
             jan:                 
             jan:                 # Need to put devices back in manual mode. Since the experiment is over before this try/except block begins, we can 
             jan:                 # safely call transition_to_manual() on each device tab
             jan:                 # TODO: Not serialised...could be bad with older BIAS versions :(
             jan:                 self.current_queue = queue.Queue()
             jan:                 for devicename, tab in devices_in_use.items():
             jan:                     if tab.mode == MODE_BUFFERED:
             jan:                         tab.transition_to_manual(self.current_queue)
             jan:                     # disconnect restart signal from tabs 
             jan:                     inmain(tab.disconnect_restart_receiver,restart_function)
             jan:                 
             jan:                 continue
             jan:             
             jan:             ##########################################################################################################################################
             jan:             #                                                        Analysis Submission                                                             #
             jan:             ########################################################################################################################################## 
             jan:             logger.info('All devices are back in static mode.')  
             jan: 
             jan:             # check for analysis Filters in Plugins
             jan:             send_to_analysis = True
             jan:             for callback in self.get_callbacks('analysis_cancel_send'):
             jan:                 try:
             jan:                     if callback(path):
             jan:                         send_to_analysis = False
             jan:                         break
             jan:                 except Exception:
             jan:                     logger.exception("Plugin callback raised an exception")
             jan: 
             jan:             # Submit to the analysis server
             jan:             if send_to_analysis:
             jan:                 self.BLACS.analysis_submission.get_queue().put(['file', path])
             jan: 
             jan:             ##########################################################################################################################################
             jan:             #                                                        Plugin callbacks                                                                #
             jan:             ########################################################################################################################################## 
             jan:             for plugin in self.BLACS.plugins.values():
             jan:                 callbacks = plugin.get_callbacks()
             jan:                 if isinstance(callbacks, dict) and 'shot_complete' in callbacks:
             jan:                     try:
             jan:                         callbacks['shot_complete'](path)
             jan:                     except Exception:
             jan:                         logger.exception("Plugin callback raised an exception")
             jan: 
             jan:             ##########################################################################################################################################
             jan:             #                                                        Repeat Experiment?                                                              #
             jan:             ##########################################################################################################################################
             jan:             # check for repeat Filters in Plugins
             jan:             repeat_shot = self.manager_repeat
             jan:             for callback in self.get_callbacks('shot_ignore_repeat'):
             jan:                 try:
             jan:                     if callback(path):
             jan:                         repeat_shot = False
             jan:                         break
             jan:                 except Exception:
             jan:                     logger.exception("Plugin callback raised an exception")
             jan: 
             jan:             if repeat_shot:
             jan:                 if ((self.manager_repeat_mode == self.REPEAT_ALL) or
             jan:                     (self.manager_repeat_mode == self.REPEAT_LAST and inmain(self._model.rowCount) == 0)):
             jan:                     # Resubmit job to the bottom of the queue:
             jan:                     try:
             jan:                         message = self.process_request(path)
             jan:                     except Exception:
             jan:                         # TODO: make this error popup for the user
             jan:                         self.logger.exception('Failed to copy h5_file (%s) for repeat run'%s)
             jan:                     logger.info(message)      
             jan: 
             jan:             self.set_status("Idle")
             jan:         logger.info('Stopping')
             jan: 
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /front_panel_settings.py                                          #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
             jan: from __future__ import division, unicode_literals, print_function, absolute_import
             jan: from labscript_utils import PY2
             jan: from labscript_utils.numpy_dtype_workaround import dtype_workaround
             jan: if PY2:
             jan:     str = unicode
        pstarkey: 
        pstarkey: import os
        pstarkey: import logging
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
        pstarkey: 
        pstarkey: import labscript_utils.excepthook
        pstarkey: import numpy
        pstarkey: import labscript_utils.h5_lock, h5py
        pstarkey: from qtutils import *
        pstarkey: 
chrisjbillington: from labscript_utils.connections import ConnectionTable
        pstarkey: 
        pstarkey: logger = logging.getLogger('BLACS.FrontPanelSettings')  
        pstarkey: 
             jan: def _ensure_str(s):
             jan:     """convert bytestrings and numpy strings to python strings"""
             jan:     return s.decode() if isinstance(s, bytes) else str(s)
             jan: 
        pstarkey: class FrontPanelSettings(object):
        pstarkey:     def __init__(self,settings_path,connection_table):
        pstarkey:         self.settings_path = settings_path
        pstarkey:         self.connection_table = connection_table
        pstarkey:         with h5py.File(settings_path,'a') as h5file:
        pstarkey:             pass
        pstarkey:         
        pstarkey:     def setup(self,blacs):
        pstarkey:         self.tablist = blacs.tablist
        pstarkey:         self.attached_devices = blacs.attached_devices
        pstarkey:         self.notebook = blacs.tab_widgets
        pstarkey:         self.window = blacs.ui
        pstarkey:         self.panes = blacs.panes
        pstarkey:         self.blacs = blacs
        pstarkey: 
        pstarkey:     def restore(self):
        pstarkey:         
        pstarkey:         # Get list of DO/AO
        pstarkey:         # Does the object have a name?
        pstarkey:         #    yes: Then, find the device in the BLACS connection table that matches that name
        pstarkey:         #         Also Find the device in the saved connection table.
        pstarkey:         #         Do the connection table entries match?
        pstarkey:         #             yes: Restore as is
        pstarkey:         #             no:  Is it JUST the parent device and "connected to" that has changed?
        pstarkey:         #                      yes: Restore to new device
        pstarkey:         #                      no:  Show error that this device could not be restored
        pstarkey:         #    no: Ok, so it isn't in the saved connection table
        pstarkey:         #        Does this device/channel exist in the BLACS connection table?
        pstarkey:         #            yes: Don't restore, show error that this chanel is now in use by a new device
        pstarkey:         #                 Give option to restore anyway...
        pstarkey:         #            no: Restore as is
        pstarkey:         #
        pstarkey:         # Display errors, give option to cancel starting of BLACS so that the connection table can be edited
        pstarkey:         
        pstarkey:         # Create saved connection table
        pstarkey:         settings = {}
        pstarkey:         question = {}
        pstarkey:         error = {}
        pstarkey:         tab_data = {'BLACS settings':{}}
        pstarkey:         try:
chrisjbillington:             saved_ct = ConnectionTable(self.settings_path, logging_prefix='BLACS')
        pstarkey:             ct_match,error = self.connection_table.compare_to(saved_ct)
        pstarkey:             
        pstarkey:             with h5py.File(self.settings_path,'r') as hdf5_file:
        pstarkey:                 # Get Tab Data
        pstarkey:                 dataset = hdf5_file['/front_panel'].get('_notebook_data',[])
        pstarkey:                 
        pstarkey:                 for row in dataset:
             jan:                     tab_name = _ensure_str(row['tab_name'])
             jan:                     tab_data.setdefault(tab_name,{})
        pstarkey:                     try:
             jan:                         tab_data[tab_name] = {'notebook':row['notebook'], 'page':row['page'], 'visible':row['visible'], 'data':eval(_ensure_str(row['data']))}
        pstarkey:                     except:
             jan:                         logger.info("Could not load tab data for %s"%tab_name)
        pstarkey:                 
        pstarkey:                 #now get dataset attributes
        pstarkey:                 tab_data['BLACS settings'] = dict(dataset.attrs)
        pstarkey:                 
        pstarkey:                 # Get the front panel values
        pstarkey:                 if 'front_panel' in hdf5_file["/front_panel"]:
        pstarkey:                     dataset = hdf5_file["/front_panel"].get('front_panel', [])
        pstarkey:                     for row in dataset:
        pstarkey:                         result = self.check_row(row,ct_match,self.connection_table,saved_ct)
        pstarkey:                         columns = ['name', 'device_name', 'channel', 'base_value', 'locked', 'base_step_size', 'current_units']
        pstarkey:                         data_dict = {}
        pstarkey:                         for i in range(len(row)):
             jan:                             if isinstance(row[i], bytes) or isinstance(row[i], str):
             jan:                                 data_dict[columns[i]] = _ensure_str(row[i])
             jan:                             else:
             jan:                                 data_dict[columns[i]] = row[i]
        pstarkey:                         settings,question,error = self.handle_return_code(data_dict,result,settings,question,error)
        pstarkey:       
        pstarkey:                 # Else Legacy restore from GTK save data!
        pstarkey:                 else:
        pstarkey:                     # open Datasets
        pstarkey:                     type_list = ["AO", "DO", "DDS"]
        pstarkey:                     for key in type_list:
        pstarkey:                         dataset = hdf5_file["/front_panel"].get(key, [])
        pstarkey:                         for row in dataset:
        pstarkey:                             result = self.check_row(row,ct_match,self.connection_table,saved_ct)
        pstarkey:                             columns = ['name', 'device_name', 'channel', 'base_value', 'locked', 'base_step_size', 'current_units']
        pstarkey:                             data_dict = {}
        pstarkey:                             for i in range(len(row)):
        pstarkey:                                 data_dict[columns[i]] = row[i]
        pstarkey:                             settings,question,error = self.handle_return_code(data_dict,result,settings,question,error)
             jan:         except Exception as e:
        pstarkey:             logger.info("Could not load saved settings")
             jan:             logger.info(str(e))
        pstarkey:         return settings,question,error,tab_data
        pstarkey:     
        pstarkey:     def handle_return_code(self,row,result,settings,question,error):
        pstarkey:         # 1: Restore to existing device
        pstarkey:         # 2: Send to new device
        pstarkey:         # 3: Device now exists, use saved values from unnamed device?
        pstarkey:         #    Note that if 2 has happened, 3 will also happen
        pstarkey:         #    This is because we have the original channel, and the moved channel in the same place
        pstarkey:         #-1: Device no longer in the connection table, throw error
        pstarkey:         #-2: Device parameters not compatible, throw error
        pstarkey:         if type(result) == tuple:
        pstarkey:             connection = result[1]
        pstarkey:             result = result[0]
        pstarkey:         
        pstarkey:         if result == 1:
        pstarkey:             settings.setdefault(row['device_name'],{})
        pstarkey:             settings[row['device_name']][row['channel']] = row
        pstarkey:         elif result == 2:
        pstarkey:             settings.setdefault(connection.parent.name,{})
        pstarkey:             settings[connection.parent.name][connection.parent_port] = row
        pstarkey:         elif result == 3:
        pstarkey:             question.setdefault(connection.parent.name,{})
        pstarkey:             question[connection.parent.name][connection.parent_port] = row
        pstarkey:         elif result == -1:
        pstarkey:             error[row['device_name']+'_'+row['channel']] = row,"missing"
        pstarkey:         elif result == -2:
        pstarkey:             error[row['device_name']+'_'+row['channel']] = row,"changed"
        pstarkey:             
        pstarkey:         return settings,question,error
        pstarkey:     
        pstarkey:     def check_row(self,row,ct_match,blacs_ct,saved_ct):            
        pstarkey:         # If it has a name
        pstarkey:         if row[0] != "-":
        pstarkey:             if ct_match:
        pstarkey:                 # Restore
        pstarkey:                 return 1
        pstarkey:             else:
        pstarkey:                 # Find if this device is in the connection table
        pstarkey:                 connection = blacs_ct.find_by_name(row[0])
        pstarkey:                 connection2 = saved_ct.find_by_name(row[0])
        pstarkey:                 
        pstarkey:                 if connection:
        pstarkey:                     # compare the two connections, see what differs
        pstarkey:                     # if compare fails only on parent, connected to:
        pstarkey:                     #    send to new parent
        pstarkey:                     # else:
        pstarkey:                     #     show error, device parameters not compatible with saved data
        pstarkey:                     result,error = connection.compare_to(connection2)
        pstarkey:                     
        pstarkey:                     allowed_length = 0
        pstarkey:                     if "parent_port" in error:
        pstarkey:                         allowed_length += 1
        pstarkey:                         
        pstarkey:                     if len(error) > allowed_length:
        pstarkey:                         return -2 # failure, device parameters not compatible                        
        pstarkey:                     elif error == {} and connection.parent.name == connection2.parent.name:
        pstarkey:                         return 1 # All details about this device match
        pstarkey:                     else:
        pstarkey:                         return 2,connection # moved to new device
        pstarkey:                 else:
        pstarkey:                     # no longer in connection table, throw error
        pstarkey:                     return -1
        pstarkey:         else:
        pstarkey:             # It doesn't have a name
        pstarkey:             # Does the channel exist for this device in the connection table
        pstarkey:             connection = blacs_ct.find_child(row[1],row[2])
        pstarkey:             if connection:
        pstarkey:                 # throw error, device now exists, should we restore?
        pstarkey:                 return 3,connection
        pstarkey:             else:
        pstarkey:                 # restore to device
        pstarkey:                 return 1
        pstarkey:     
        pstarkey:     @inmain_decorator(wait_for_return=True)    
        pstarkey:     def get_save_data(self):
        pstarkey:         tab_data = {}
        pstarkey:         notebook_data = {}
        pstarkey:         window_data = {}
        pstarkey:         plugin_data = {}
        pstarkey:         
        pstarkey:         # iterate over all tabs
        pstarkey:         for device_name,tab in self.tablist.items():
        pstarkey:             tab_data[device_name] = {'front_panel':tab.settings['front_panel_settings'],
        pstarkey:                                      'save_data':tab.get_save_data() if hasattr(tab,'get_save_data') else {}
        pstarkey:                                   }
chrisjbillington:             tab_data[device_name]['save_data'].update(tab.get_builtin_save_data())
        pstarkey:             
        pstarkey:             # Find the notebook the tab is in
        pstarkey:             #            
        pstarkey:             # By default we assume it is in notebook0, on page 0. This way, if a tab gets lost somewhere, 
        pstarkey:             # and isn't found to be a child of any notebook we know about, 
        pstarkey:             # it will revert back to notebook 1 when the file is loaded upon program restart!
        pstarkey:             current_notebook_name = 0 
        pstarkey:             page = 0
        pstarkey:             visible = False
        pstarkey:             
        pstarkey:             for notebook_name,notebook in self.notebook.items():
        pstarkey:                 if notebook.indexOf(tab._ui) != -1:                
        pstarkey:                     current_notebook_name = notebook_name 
        pstarkey:                     page = notebook.indexOf(tab._ui) 
        pstarkey:                     visible = True if notebook.currentIndex() == page else False   
        pstarkey:                     break
        pstarkey:                                 
        pstarkey:             notebook_data[device_name] = {"notebook":current_notebook_name,"page":page, "visible":visible}
        pstarkey:         
        pstarkey:         # iterate over all plugins
        pstarkey:         for module_name, plugin in self.blacs.plugins.items():
        pstarkey:             try:
        pstarkey:                 plugin_data[module_name] = plugin.get_save_data()
        pstarkey:             except Exception as e:
        pstarkey:                 logger.error('Could not save data for plugin %s. Error was: %s'%(module_name,str(e)))
        pstarkey:         
        pstarkey:         # save window data
        pstarkey:         # Size of window       
        pstarkey:         window_data["_main_window"] = {"width":self.window.normalGeometry().width(), 
        pstarkey:                                        "height":self.window.normalGeometry().height(),
        pstarkey:                                        "xpos":self.window.normalGeometry().x(),
        pstarkey:                                        "ypos":self.window.normalGeometry().y(),
        pstarkey:                                        "maximized":self.window.isMaximized(),
        pstarkey:                                        "frame_height":abs(self.window.frameGeometry().height()-self.window.normalGeometry().height()),
        pstarkey:                                        "frame_width":abs(self.window.frameGeometry().width()-self.window.normalGeometry().width()),
        pstarkey:                                        "_analysis":self.blacs.analysis_submission.get_save_data(),
        pstarkey:                                        "_queue":self.blacs.queue.get_save_data(),
        pstarkey:                                       }
        pstarkey:         # Pane positions
        pstarkey:         for name,pane in self.panes.items():
        pstarkey:             window_data[name] = pane.sizes()
        pstarkey:         
        pstarkey:         return tab_data,notebook_data,window_data,plugin_data
        pstarkey:     
        pstarkey:     @inmain_decorator(wait_for_return=True)
        pstarkey:     def save_front_panel_to_h5(self,current_file,states,tab_positions,window_data,plugin_data,silent = {}, force_new_conn_table = False):        
        pstarkey:         # Save the front panel!
        pstarkey: 
        pstarkey:         # Does the file exist?            
        pstarkey:         #   Yes: Check connection table inside matches current connection table. Does it match?
        pstarkey:         #        Yes: Does the file have a front panel already saved in it?
        pstarkey:         #               Yes: Can we overwrite?
        pstarkey:         #                  Yes: Delete front_panel group, save new front panel
        pstarkey:         #                  No:  Create error dialog!
        pstarkey:         #               No: Save front panel in here
        pstarkey:         #   
        pstarkey:         #        No: Return
        pstarkey:         #   No: Create new file, place inside the connection table and front panel
        pstarkey:             
        pstarkey:         if os.path.isfile(current_file):
        pstarkey:             save_conn_table = True if force_new_conn_table else False
        pstarkey:             result = False
        pstarkey:             if not save_conn_table:
        pstarkey:                 try:
        pstarkey:                     new_conn = ConnectionTable(current_file)
        pstarkey:                     result,error = self.connection_table.compare_to(new_conn)
        pstarkey:                 except:
        pstarkey:                     # no connection table is present, so also save the connection table!
        pstarkey:                     save_conn_table = True
        pstarkey:             
        pstarkey:             # if save_conn_table is True, we don't bother checking to see if the connection tables match, because save_conn_table is only true when the connection table doesn't exist in the current file
        pstarkey:             # As a result, if save_conn_table is True, we ignore connection table checking, and save the connection table in the h5file.
        pstarkey:             
        pstarkey:             if save_conn_table or result:
        pstarkey:                 with h5py.File(current_file,'r+') as hdf5_file:
        pstarkey:                     if hdf5_file['/'].get('front_panel') != None:
        pstarkey:                         # Create a dialog to ask whether we can overwrite!
        pstarkey:                         overwrite = False
        pstarkey:                         if not silent:
        pstarkey:                             message = QMessageBox()
        pstarkey:                             message.setText("This file '%s' already contains a connection table."%current_file)
        pstarkey:                             message.setInformativeText("Do you wish to replace the existing front panel configuration in this file?")
        pstarkey:                             message.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        pstarkey:                             message.setDefaultButton(QMessageBox.No)
        pstarkey:                             message.setIcon(QMessageBox.Question)
        pstarkey:                             message.setWindowTitle("BLACS")
        pstarkey:                             resp = message.exec_()
        pstarkey:                                                 
        pstarkey:                             if resp == QMessageBox.Yes :
        pstarkey:                                 overwrite = True   
        pstarkey:                         else:
        pstarkey:                             overwrite = silent["overwrite"]
        pstarkey:                         
        pstarkey:                         if overwrite:
        pstarkey:                             # Delete Front panel group, save new front panel
        pstarkey:                             del hdf5_file['/front_panel']
        pstarkey:                             self.store_front_panel_in_h5(hdf5_file,states,tab_positions,window_data,plugin_data,save_conn_table)
        pstarkey:                         else:
        pstarkey:                             if not silent:                               
        pstarkey:                                 message = QMessageBox()
        pstarkey:                                 message.setText("Front Panel not saved.")
        pstarkey:                                 message.setIcon(QMessageBox.Information)
        pstarkey:                                 message.setWindowTitle("BLACS")
        pstarkey:                                 message.exec_()
        pstarkey:                             else:
        pstarkey:                                 logger.info("Front Panel not saved as it already existed in the h5 file '"+current_file+"'")
        pstarkey:                             return
        pstarkey:                     else: 
        pstarkey:                         # Save Front Panel in here
        pstarkey:                         self.store_front_panel_in_h5(hdf5_file,states,tab_positions,window_data,plugin_data,save_conn_table)
        pstarkey:             else:
        pstarkey:                 # Create Error dialog (invalid connection table)
        pstarkey:                 if not silent:
        pstarkey:                     message = QMessageBox()
        pstarkey:                     message.setText("The Front Panel was not saved as the file selected contains a connection table which is not a subset of the BLACS connection table.")
        pstarkey:                     message.setIcon(QMessageBox.Information)
        pstarkey:                     message.setWindowTitle("BLACS")
        pstarkey:                     message.exec_() 
        pstarkey:                 else:
        pstarkey:                     logger.info("Front Panel not saved as the connection table in the h5 file '"+current_file+"' didn't match the current connection table.")
        pstarkey:                 return
        pstarkey:         else:
        pstarkey:             with h5py.File(current_file,'w') as hdf5_file:
        pstarkey:                 # save connection table, save front panel                    
        pstarkey:                 self.store_front_panel_in_h5(hdf5_file,states,tab_positions,window_data,plugin_data,save_conn_table=True)
        pstarkey:     
        pstarkey:     @inmain_decorator(wait_for_return=True)
             jan:     def store_front_panel_in_h5(self, hdf5_file,tab_data,notebook_data,window_data,plugin_data,save_conn_table=False,save_queue_data=True):
        pstarkey:         if save_conn_table:
        pstarkey:             if 'connection table' in hdf5_file:
        pstarkey:                 del hdf5_file['connection table']
chrisjbillington:             hdf5_file.create_dataset('connection table', data=self.connection_table.raw_table)
        pstarkey:         
        pstarkey:         data_group = hdf5_file['/'].create_group('front_panel')
        pstarkey:         
        pstarkey:         front_panel_list = []
        pstarkey:         other_data_list = []       
             jan:         front_panel_dtype = dtype_workaround([('name','a256'),('device_name','a256'),('channel','a256'),('base_value',float),('locked',bool),('base_step_size',float),('current_units','a256')])
        pstarkey:         max_od_length = 2 # empty dictionary
        pstarkey:             
        pstarkey:         # Iterate over each device within a class
        pstarkey:         for device_name, device_state in tab_data.items():
        pstarkey:             logger.debug("saving front panel for device:" + device_name) 
        pstarkey:             # Insert front panel data into dataset
        pstarkey:             for hardware_name, data in device_state["front_panel"].items():
        pstarkey:                 if data != {}:
        pstarkey:                     front_panel_list.append((data['name'],
        pstarkey:                                              device_name,
        pstarkey:                                              hardware_name,
        pstarkey:                                              data['base_value'],
        pstarkey:                                              data['locked'],
        pstarkey:                                              data['base_step_size'] if 'base_step_size' in data else 0,
        pstarkey:                                              data['current_units'] if 'current_units' in data else ''
        pstarkey:                                             )
        pstarkey:                                            )               
        pstarkey:             
        pstarkey:             # Save "other data"
        pstarkey:             od = repr(device_state["save_data"])
        pstarkey:             other_data_list.append(od)            
        pstarkey:             max_od_length = len(od) if len(od) > max_od_length else max_od_length            
        pstarkey:         
        pstarkey:         # Create datasets
        pstarkey:         if front_panel_list:
        pstarkey:             front_panel_array = numpy.empty(len(front_panel_list),dtype=front_panel_dtype)
        pstarkey:             for i, row in enumerate(front_panel_list):
        pstarkey:                 front_panel_array[i] = row
        pstarkey:             data_group.create_dataset('front_panel',data=front_panel_array)
        pstarkey:                 
        pstarkey:         # Save tab data
        pstarkey:         i = 0
             jan:         tab_data = numpy.empty(len(notebook_data),dtype=dtype_workaround([('tab_name','a256'),('notebook','a2'),('page',int),('visible',bool),('data','a'+str(max_od_length))]))
        pstarkey:         for device_name,data in notebook_data.items():
        pstarkey:             tab_data[i] = (device_name,data["notebook"],data["page"],data["visible"],other_data_list[i])
        pstarkey:             i += 1
        pstarkey:             
        pstarkey:         # Save BLACS Main GUI Info
        pstarkey:         dataset = data_group.create_dataset("_notebook_data",data=tab_data)
        pstarkey:         dataset.attrs["window_width"] = window_data["_main_window"]["width"]
        pstarkey:         dataset.attrs["window_height"] = window_data["_main_window"]["height"]
        pstarkey:         dataset.attrs["window_xpos"] = window_data["_main_window"]["xpos"]
        pstarkey:         dataset.attrs["window_ypos"] = window_data["_main_window"]["ypos"]
        pstarkey:         dataset.attrs["window_maximized"] = window_data["_main_window"]["maximized"]
        pstarkey:         dataset.attrs["window_frame_height"] = window_data["_main_window"]["frame_height"]
        pstarkey:         dataset.attrs["window_frame_width"] = window_data["_main_window"]["frame_width"]
        pstarkey:         dataset.attrs['plugin_data'] = repr(plugin_data)
        pstarkey:         dataset.attrs['analysis_data'] = repr(window_data["_main_window"]["_analysis"])
             jan:         if save_queue_data:
             jan:             dataset.attrs['queue_data'] = repr(window_data["_main_window"]["_queue"])
        pstarkey:         for pane_name,pane_position in window_data.items():
        pstarkey:             if pane_name != "_main_window":
        pstarkey:                 dataset.attrs[pane_name] = pane_position
        pstarkey:         
        pstarkey:         # Save analysis server settings:
        pstarkey:         #dataset = data_group.create_group("analysis_server")
        pstarkey:         #dataset.attrs['send_for_analysis'] = self.blacs.analysis_submission.toggle_analysis.get_active()
        pstarkey:         #dataset.attrs['server'] = self.blacs.analysis_submission.analysis_host.get_text()
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /notifications.py                                                 #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: 
        pstarkey: import logging
        pstarkey: import os
        pstarkey: 
        pstarkey: from qtutils import UiLoader
chrisjbillington: from blacs import BLACS_DIR
        pstarkey: 
        pstarkey: logger = logging.getLogger('BLACS.NotificationManager') 
        pstarkey: 
        pstarkey: class Notifications(object):
        pstarkey:     def __init__(self, BLACS):
        pstarkey:         self._BLACS = BLACS
        pstarkey:         self._notifications = {}
        pstarkey:         self._widgets = {}
        pstarkey:         self._minimized_widgets = {}
        pstarkey:         self._closed_callbacks = {}
        pstarkey:         self._hidden_callbacks = {}
        pstarkey:         self._shown_callbacks = {}
        pstarkey:         
        pstarkey:     def add_notification(self, notification_class):
        pstarkey:         if notification_class in self._notifications:
        pstarkey:             return False        
        pstarkey:         
        pstarkey:         try:
        pstarkey:             # instantiate the notification class
        pstarkey:             # TODO: Do we need to pass anything in here?
        pstarkey:             self._notifications[notification_class] = notification_class(self._BLACS) 
        pstarkey:             
        pstarkey:             # get the widget
        pstarkey:             widget = self._notifications[notification_class].get_widget()
        pstarkey:           
        pstarkey:             # get details on whether the widget can be closed or hidden
        pstarkey:             properties = self._notifications[notification_class].get_properties()
        pstarkey:             
        pstarkey:             # Function shortcuts
        pstarkey:             show_func = lambda callback=False: self.show_notification(notification_class, callback)
        pstarkey:             hide_func = lambda callback=False: self.minimize_notification(notification_class, callback)
        pstarkey:             close_func = lambda callback=False: self.close_notification(notification_class, callback)
        pstarkey:             get_state = lambda: self.get_state(notification_class)
        pstarkey:             
        pstarkey:             # create layout/widget with appropriate buttons and the widget from the notification class
chrisjbillington:             ui = UiLoader().load(os.path.join(BLACS_DIR, 'notification_widget.ui'))            
        pstarkey:             ui.hide_button.setVisible(bool(properties['can_hide']))
        pstarkey:             ui.hide_button.clicked.connect(lambda: hide_func(True))
        pstarkey:             ui.close_button.setVisible(bool(properties['can_close']))
        pstarkey:             ui.close_button.clicked.connect(lambda: close_func(True))
        pstarkey:             ui.widget_layout.addWidget(widget)
        pstarkey:             #ui.hide()
        pstarkey:             
        pstarkey:             #save callbacks
        pstarkey:             if 'closed_callback' in properties and callable(properties['closed_callback']):
        pstarkey:                 self._closed_callbacks[notification_class] = properties['closed_callback']
        pstarkey:             elif 'closed_callback' in properties:
        pstarkey:                 logger.warning('"Closed" callback for notification class %s is not callable (and will not be called when the notification is closed. The callback specified was %s.'%(notification_class,properties['closed_callback']))
        pstarkey:             
        pstarkey:             if 'hidden_callback' in properties and callable(properties['hidden_callback']):
        pstarkey:                 self._hidden_callbacks[notification_class] = properties['hidden_callback']
        pstarkey:             elif 'hidden_callback' in properties:
        pstarkey:                 logger.warning('"Hidden" callback for notification class %s is not callable (and will not be called when the notification is closed. The callback specified was %s.'%(notification_class,properties['hidden_callback']))
        pstarkey:             
        pstarkey:             if 'shown_callback' in properties and callable(properties['shown_callback']):
        pstarkey:                 self._shown_callbacks[notification_class] = properties['shown_callback']
        pstarkey:             elif 'shown_callback' in properties:
        pstarkey:                 logger.warning('"Shown" callback for notification class %s is not callable (and will not be called when the notification is closed. The callback specified was %s.'%(notification_class,properties['shown_callback']))
        pstarkey:                         
        pstarkey:             
        pstarkey:             #TODO: Make the minimized widget
chrisjbillington:             ui2 = UiLoader().load(os.path.join(BLACS_DIR, 'notification_minimized_widget.ui'))
        pstarkey:             #ui2.hide()
        pstarkey:             if not hasattr(self._notifications[notification_class], 'name'):
        pstarkey:                 self._notifications[notification_class].name = notification_class.__name__
        pstarkey:             ui2.name.setText(self._notifications[notification_class].name)
        pstarkey:             ui2.show_button.setVisible(bool(properties['can_hide'])) #If you can hide, you can also show
        pstarkey:             ui2.show_button.clicked.connect(lambda: show_func(True))
        pstarkey:             ui2.close_button.setVisible(bool(properties['can_close']))
        pstarkey:             ui2.close_button.clicked.connect(lambda: close_func(True))
        pstarkey:             
        pstarkey:             # pass the show/hide/close functions to the notfication class
        pstarkey:             self._widgets[notification_class] = ui
        pstarkey:             self._minimized_widgets[notification_class] = ui2
        pstarkey:             self._notifications[notification_class].set_functions(show_func,hide_func,close_func,get_state)            
        pstarkey:             
        pstarkey:         except:
        pstarkey:             logger.exception('Failed to instantiate Notification class %s.'%notification_class)
        pstarkey:             # Cleanup 
        pstarkey:             # TODO: cleanup a little more
        pstarkey:             if notification_class in self._notifications:
        pstarkey:                 del self._notifications[notification_class]
        pstarkey:             return False
        pstarkey:         
        pstarkey:         # add the widgets, initially hidden
        pstarkey:         ui.setVisible(False)
        pstarkey:         ui2.setVisible(False)
        pstarkey:         self._BLACS['ui'].notifications.insertWidget(1,ui)
        pstarkey:         self._BLACS['ui'].notifications_minimized.insertWidget(0,ui2)
        pstarkey:         
        pstarkey:         return True
        pstarkey:     
        pstarkey:     def get_instance(self, notification_class):
        pstarkey:         if notification_class in self._notifications:
        pstarkey:             return self._notifications[notification_class]
        pstarkey:         return None
        pstarkey:     
        pstarkey:     def show_notification(self, notification_class, callback):
        pstarkey:         self._widgets[notification_class].setVisible(True)
        pstarkey:         self._minimized_widgets[notification_class].setVisible(False)
        pstarkey:         if callback and notification_class in self._shown_callbacks:
        pstarkey:             try:
        pstarkey:                 self._shown_callbacks[notification_class]()
        pstarkey:             except:
        pstarkey:                 logger.exception('Failed to run "shown" callback for notification class %s'%notification_class)
        pstarkey:         
        pstarkey:     def close_notification(self, notification_class, callback):
        pstarkey:         self._widgets[notification_class].setVisible(False)
        pstarkey:         self._minimized_widgets[notification_class].setVisible(False)
        pstarkey:         if callback and notification_class in self._closed_callbacks:
        pstarkey:             try:
        pstarkey:                 self._closed_callbacks[notification_class]()
        pstarkey:             except:
        pstarkey:                 logger.exception('Failed to run "closed" callback for notification class %s'%notification_class)
        pstarkey:         
        pstarkey:     def minimize_notification(self,notification_class, callback):
        pstarkey:         self._widgets[notification_class].setVisible(False)
        pstarkey:         self._minimized_widgets[notification_class].setVisible(True)
        pstarkey:         if callback and notification_class in self._hidden_callbacks:
        pstarkey:             try:
        pstarkey:                 self._hidden_callbacks[notification_class]()
        pstarkey:             except:
        pstarkey:                 logger.exception('Failed to run "hidden" callback for notification class %s'%notification_class)
        pstarkey:     
        pstarkey:     def get_state(self,notification_class):
        pstarkey:         if self._widgets[notification_class].isVisible():
        pstarkey:             return 'shown'
        pstarkey:         elif self._minimized_widgets[notification_class].isVisible():
        pstarkey:             return 'hidden'
        pstarkey:         else:
        pstarkey:             return 'closed'
        pstarkey:     
        pstarkey:     def close_all(self):
        pstarkey:         for notification in self._notifications:
        pstarkey:             try:
        pstarkey:                 notification.close()
        pstarkey:             except:
        pstarkey:                 pass
chrisjbillington:                 
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /hardware_interfaces/output_classes.py                            #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program BLACS, in the labscript suite    #
   pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   pstarkey: 
   pstarkey: import logging
   pstarkey: import math
   pstarkey: import sys
   pstarkey: 
janwerkmann: from qtutils.qt.QtCore import *
janwerkmann: from qtutils.qt.QtGui import *
janwerkmann: from qtutils.qt.QtWidgets import *
janwerkmann: 
   pstarkey: 
   pstarkey: from labscript_utils.qtwidgets.analogoutput import AnalogOutput
janwerkmann: from labscript_utils.qtwidgets.digitaloutput import DigitalOutput, InvertedDigitalOutput
   pstarkey: from labscript_utils.qtwidgets.ddsoutput import DDSOutput
   pstarkey: try:
   pstarkey:     from labscript_utils.unitconversions import *
   pstarkey: except Exception:
janwerkmann:     print('failed to import unit conversion classes')
janwerkmann: 
   pstarkey: 
   pstarkey: class AO(object):
   pstarkey:     def __init__(self, hardware_name, connection_name, device_name, program_function, settings, calib_class, calib_params, default_units, min, max, step, decimals):
   pstarkey:         self._connection_name = connection_name
   pstarkey:         self._hardware_name = hardware_name
   pstarkey:         self._device_name = device_name
   pstarkey:         
   pstarkey:         self._locked = False
   pstarkey:         self._comboboxmodel = QStandardItemModel()
   pstarkey:         self._widgets = []
   pstarkey:         self._current_units = default_units
   pstarkey:         self._base_unit = default_units
   pstarkey:         self._program_device = program_function
   pstarkey:         
   pstarkey:         # All of these are in base units ALWAYS
   pstarkey:         self._current_value = 0 # value in base units
   pstarkey:         self._current_step_size = step # step size in current units
   pstarkey:         self._step_size = step # step size in base units
   pstarkey:         self._limits = [min,max]
   pstarkey:         self._decimals = decimals
   pstarkey:                 
   pstarkey:         self._logger = logging.getLogger('BLACS.%s.%s'%(self._device_name,hardware_name)) 
   pstarkey:         
   pstarkey:         # Initialise Calibrations
   pstarkey:         self._comboboxmodel.appendRow(QStandardItem(self._base_unit))
   pstarkey:         if calib_class is not None:
   pstarkey:             if calib_class not in globals() or not isinstance(calib_params,dict) or globals()[calib_class].base_unit != default_units:
   pstarkey:                 # log an error:  
   pstarkey:                 reason = ''
   pstarkey:                 if calib_class not in globals():
   pstarkey:                     reason = 'The unit conversion class was not imported. Is it in the correct folder? Is it imported when you call "from unitconversions import *" from a python terminal?'
   pstarkey:                 elif not isinstance(calib_params,dict):
   pstarkey:                     reason = 'The parameters for the unit conversion class are not a dictionary. Check your connection table code for errors and recompile it'
   pstarkey:                 elif globals()[calib_class].base_unit != default_units:
   pstarkey:                     reason = 'The base unit of your unit conversion class does not match this hardware channel. The hardware channel has base units %s while your unit conversion class uses %s'%(globals()[calib_class].base_unit,default_units)
   pstarkey:                 self._logger.error('The unit conversion class (%s) could not be loaded. Reason: %s'%(calib_class,reason))   
   pstarkey:                 # Use default units
   pstarkey:                 self._calibration = None
   pstarkey:             else:
   pstarkey:                 try:
   pstarkey:                     # initialise calibration class
   pstarkey:                     self._calibration = globals()[calib_class](calib_params)  
   pstarkey:                     self._logger.debug('unit conversion class instantiated')                    
   pstarkey:                     for unit in self._calibration.derived_units:
   pstarkey:                         try:
   pstarkey:                             self._comboboxmodel.appendRow(QStandardItem(unit))
   pstarkey:                         except Exception:
   pstarkey:                              self._logger.exception('Error while trying to add unit "%s"'%unit)                    
   pstarkey:                 except Exception:
   pstarkey:                     self._logger.exception('Error while trying to instantiate unit conversion class')
   pstarkey:                     self._calibration = None
   pstarkey:         else:
   pstarkey:             # use default units
   pstarkey:             self._calibration = None
   pstarkey:             self._logger.debug('No unit conversion class specified')
   pstarkey:         
   pstarkey:         self._update_from_settings(settings,program=False)
   pstarkey:     
   pstarkey:     def _update_from_settings(self,settings,program=True):
   pstarkey:         # Build up the settings dictionary if it isn't already
   pstarkey:         if not isinstance(settings,dict):
   pstarkey:             settings = {}
   pstarkey:         if 'front_panel_settings' not in settings or not isinstance(settings['front_panel_settings'],dict):
   pstarkey:             settings['front_panel_settings'] = {}
   pstarkey:         if self._hardware_name not in settings['front_panel_settings'] or not isinstance(settings['front_panel_settings'][self._hardware_name],dict):
   pstarkey:             settings['front_panel_settings'][self._hardware_name] = {}
   pstarkey:         # Set default values if they are not already saved in the settings dictionary
   pstarkey:         if 'base_value' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['base_value'] = False
   pstarkey:         if 'locked' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['locked'] = False
   pstarkey:         if 'base_step_size' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['base_step_size'] = self._step_size
   pstarkey:         if 'current_units' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['current_units'] = self._base_unit
   pstarkey:         if 'name' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['name'] = self._connection_name
   pstarkey:         
   pstarkey:     
   pstarkey:         # only keep a reference to the part of the settings dictionary relevant to this DO
   pstarkey:         self._settings = settings['front_panel_settings'][self._hardware_name]
   pstarkey:     
   pstarkey:         # Update the state of the button
   pstarkey:         self.set_value(self._settings['base_value'],program=program)
   pstarkey: 
   pstarkey:         # Update the lock state
   pstarkey:         self._update_lock(self._settings['locked'])
   pstarkey:         
   pstarkey:         # Update the step size
   pstarkey:         self.set_step_size(self._settings['base_step_size'],self._base_unit)
   pstarkey:     
   pstarkey:         # Update the unit selection
   pstarkey:         if self._calibration and self._settings['current_units'] in self._calibration.derived_units:
   pstarkey:             self.change_unit(self._settings['current_units'],program=program)
   pstarkey:         else:
   pstarkey:             self.change_unit(self._base_unit,program=program)
   pstarkey:      
   pstarkey:     def convert_value_to_base(self, value, unit):
   pstarkey:         if unit != self._base_unit:
   pstarkey:             if self._calibration and unit in self._calibration.derived_units:
   pstarkey:                 return getattr(self._calibration,unit+"_to_base")(value)
   pstarkey:              
   pstarkey:             # TODO: include device name somehow, and also the calibration class name
   pstarkey:             raise RuntimeError('The value %s (%s) could not be converted to base units because the hardware channel %s, named %s, either does not have a unit conversion class or the unit specified was invalid'%(str(value),unit,self._hardware_name,self._connection_name))
   pstarkey:         else:
   pstarkey:             return value
   pstarkey:             
   pstarkey:     def convert_value_from_base(self, value, unit):  
   pstarkey:         if unit != self._base_unit:
   pstarkey:             if self._calibration and unit in self._calibration.derived_units:
   pstarkey:                 return getattr(self._calibration,unit+"_from_base")(value)
   pstarkey:         
   pstarkey:             # TODO: include device name somehow, and also the calibration class name
   pstarkey:             raise RuntimeError('The value %s (%s) could not be converted to base units because the hardware channel %s, named %s, either does not have a unit conversion class or the unit specified was invalid'%(str(value),unit,self._hardware_name,self._connection_name))
   pstarkey:         else:
   pstarkey:             return value
   pstarkey:             
   pstarkey:     # handles the conversion of a range centered on value in units to base units
   pstarkey:     # In other words, how big is "range" in base units assuming that you care about what range is
   pstarkey:     # between value-range/2 and value+range/2
   pstarkey:     #
   pstarkey:     # If value+range/2 or value-range/2 is outside of the limits, then we will shift the fraction of range
   pstarkey:     # used on the offending side of value
   pstarkey:     # If range is greater than the difference of the limits, we will return the difference between the limits
   pstarkey:     def convert_range_to_base(self,value,range,unit):
   pstarkey:         self._logger.debug('convert_range_to_base called. value: %f, range: %f, unit: %s'%(value,range,unit))
   pstarkey:         
   pstarkey:         # Do we need to convert the limits?
   pstarkey:         if unit != self._base_unit:
   pstarkey:             limits = [self.convert_value_from_base(self._limits[0],unit),self.convert_value_from_base(self._limits[1],unit)]
   pstarkey:             if limits[0] > limits[1]:
   pstarkey:                 limits[0],limits[1] = limits[1],limits[0]
   pstarkey:         else:
   pstarkey:             limits = self._limits
   pstarkey:         
   pstarkey:         self._logger.debug('limits in unit: %s), limits=[%f,%f]'%(unit,limits[0],limits[1]))
   pstarkey:         
   pstarkey:         # limits are now in the units given to the function!
   pstarkey:         # (As are range and value)
   pstarkey:             
   pstarkey:         # If range is bigger than the difference of the limits, return the difference of the limits
   pstarkey:         # in base units
   pstarkey:         if range >= abs(limits[0]-limits[1]):
   pstarkey:             limits = [self.convert_value_to_base(limits[0],unit),self.convert_value_to_base(limits[1],unit)]            
   pstarkey:             self._logger.debug('range bigger than range of limits, returning difference of limits') 
   pstarkey:             return abs(limits[0]-limits[1])
   pstarkey:           
   pstarkey:         # At this point, the range must fit inside the limits, so if we find we are out of bounds on one side, 
   pstarkey:         # we can be certain shifting the fractions will not cause us to go out of bounds on the other side
   pstarkey:         positive_fraction = range/2.0
   pstarkey:         negative_fraction = range/2.0
   pstarkey:         self._logger.debug('fractions are.... positive_fraction: %f, negative_fraction: %f'%(positive_fraction, negative_fraction))
   pstarkey:         
   pstarkey:         # If the value+range/2 is greater than the upper limit, shift the fraction 
   pstarkey:         if value+positive_fraction > limits[1]:           
   pstarkey:             positive_fraction = abs(limits[1]-value)
   pstarkey:             negative_fraction = abs(range-positive_fraction) 
   pstarkey:             self._logger.debug('outside upper limit. positive_fraction: %f, negative_fraction: %f'%(positive_fraction, negative_fraction))
   pstarkey:         # Similarly if value-range/2 is less than the lower limit, shift the fraction
   pstarkey:         elif value-negative_fraction < limits[0]:    
   pstarkey:             negative_fraction = abs(limits[0]-value)        
   pstarkey:             positive_fraction = abs(range-negative_fraction)
   pstarkey:             self._logger.debug('outside lower limit. positive_fraction: %f, negative_fraction: %f'%(positive_fraction, negative_fraction))
   pstarkey:         
   pstarkey:         self._logger.debug('converting values to base units')            
   pstarkey:         # Now do the conversion!
   pstarkey:         bound1 = self.convert_value_to_base(value+positive_fraction,unit)
   pstarkey:         bound2 = self.convert_value_to_base(value-negative_fraction,unit)
   pstarkey:         self._logger.debug('range in base units is: %f'%(abs(bound1-bound2)))
   pstarkey:         
   pstarkey:         return abs(bound1-bound2)
   pstarkey:     
   pstarkey:     # This does the reverse of teh above function, with the same rules
   pstarkey:     def convert_range_from_base(self,value,range,unit):
   pstarkey:         # limits are always in base units
   pstarkey:         limits = self._limits
   pstarkey:         
   pstarkey:         # limits are now in base units!
   pstarkey:         # (As are range and value)
   pstarkey:             
   pstarkey:         # If range is bigger than the difference of the limits, return the difference of the limits
   pstarkey:         # in the specified units units
   pstarkey:         if range >= abs(limits[0]-limits[1]):
   pstarkey:             limits = [self.convert_value_from_base(limits[0],unit),self.convert_value_from_base(limits[1],unit)]
   pstarkey:             return abs(limits[0]-limits[1])
   pstarkey:           
   pstarkey:         # At this point, the range must fit inside the limits, so if we find we are out of bounds on one side, 
   pstarkey:         # we can be certain shifting the fractions will not cause us to go out of bounds on the other side
   pstarkey:         positive_fraction = range/2.0
   pstarkey:         negative_fraction = range/2.0
   pstarkey:         # If the value+range/2 is greater than the upper limit, shift the fraction 
   pstarkey:         if value+positive_fraction > limits[1]:
   pstarkey:             positive_fraction = abs(limits[1]-value)
   pstarkey:             negative_fraction = abs(range-positive_fraction)
   pstarkey:         # Similarly if value-range/2 is less than the lower limit, shift the fraction
   pstarkey:         elif value-negative_fraction < limits[0]:    
   pstarkey:             negative_fraction = abs(limits[0]-value)        
   pstarkey:             positive_fraction = abs(range-negative_fraction)
   pstarkey:         
   pstarkey:         # Now do the conversion!
   pstarkey:         bound1 = self.convert_value_from_base(value+positive_fraction,unit)
   pstarkey:         bound2 = self.convert_value_from_base(value-negative_fraction,unit)
   pstarkey:         
   pstarkey:         return abs(bound1-bound2)
   pstarkey: 
   pstarkey:     def create_widget(self,display_name=None, horizontal_alignment=False, parent=None):
   pstarkey:         widget = AnalogOutput(self._hardware_name,self._connection_name,display_name, horizontal_alignment, parent)
   pstarkey:         self.add_widget(widget)
   pstarkey:         return widget
   pstarkey:         
   pstarkey:     def add_widget(self, widget):
   pstarkey:         if widget in self._widgets:
   pstarkey:             return False
   pstarkey:             
   pstarkey:         self._widgets.append(widget)
   pstarkey:     
   pstarkey:         # make sure the widget knows about this AO. 
   pstarkey:         widget.set_AO(self,notify_old_AO=True,notify_new_AO=False)
   pstarkey:         
   pstarkey:         # Now connect this widgets signal to the AO slot
   pstarkey:         widget.connect_value_change(self.set_value)
   pstarkey:         
   pstarkey:         # set the properties of the widgets...
   pstarkey:         # set comboboxmodel
   pstarkey:         widget.block_combobox_signals()
   pstarkey:         widget.set_combobox_model(self._comboboxmodel)
   pstarkey:         widget.unblock_combobox_signals()
   pstarkey:         # This will set the min/max/value/num.decimals/stepsie and current_unit of ALL widgets
   pstarkey:         # including the one just added!
   pstarkey:         self.change_unit(self._current_units,program=False) # don't need to program though!
   pstarkey:         # This will update the lock state of ALL widgets, including the one just added!
   pstarkey:         self._update_lock(self._locked)
   pstarkey:         
   pstarkey:         return True
   pstarkey:     
   pstarkey:     # If calling this method directly from outside the set_AO function in the analog widget
   pstarkey:     # you should NOT specify a value for new_AO.
   pstarkey:     def remove_widget(self,widget,call_set_AO = True,new_AO = None):
   pstarkey:         if widget not in self._widgets:
   pstarkey:             raise RuntimeError('The widget cannot be removed because it is not registered with this AO object')
   pstarkey:             #TODO: Make the above error message better!
   pstarkey:          
   pstarkey:         self._widgets.remove(widget)  
   pstarkey:         
   pstarkey:         if call_set_AO:
   pstarkey:             widget.set_AO(new_AO,True,True)
   pstarkey:             
   pstarkey:         # Further cleanup
   pstarkey:         widget.disconnect_value_change()
   pstarkey:         widget.set_combobox_model(QStandardItemModel())
   pstarkey:         
   pstarkey:     def change_unit(self,unit,program=True):     
   pstarkey:         # These values are always stored in base units!
   pstarkey:         property_value_list = [self._current_value,self._limits[0],self._limits[1]]
   pstarkey:         property_range_list = [self._step_size]
   pstarkey:         
   pstarkey:         self._logger.debug('changing unit to %s'%unit)
   pstarkey:         self._logger.debug('Values in base units are: value: %f, lower_limit: %f, upper_limit: %f'%(property_value_list[0],property_value_list[1],property_value_list[2]))
   pstarkey:         self._logger.debug('ranges in base units are: step_size: %f'%(property_range_list[0]))
   pstarkey:         
   pstarkey:         # Now convert to the new unit
   pstarkey:         if unit != self._base_unit:
   pstarkey:             for index,param in enumerate(property_value_list):
   pstarkey:                 #convert each to base units
   pstarkey:                 property_value_list[index] = self.convert_value_from_base(param,unit)
   pstarkey:             for index,param in enumerate(property_range_list):
   pstarkey:                 #convert each to base units
   pstarkey:                 property_range_list[index] = self.convert_range_from_base(self._current_value,param,unit)
   pstarkey:             
   pstarkey:             self._logger.debug('Values in new unit are: value: %f, lower_limit: %f, upper_limit: %f'%(property_value_list[0],property_value_list[1],property_value_list[2]))
   pstarkey:             self._logger.debug('ranges in new unit are: step_size: %f'%(property_range_list[0]))        
   pstarkey:             
   pstarkey:             # figure out how many decimal points we need in the new unit
   pstarkey:             smallest_step = 10**(-self._decimals)
   pstarkey:             self._logger.debug('Smallest step size in base units: %f'%smallest_step)
   pstarkey:             smallest_step_in_new_unit = self.convert_range_from_base(self._current_value+smallest_step,smallest_step,unit)
   pstarkey:             self._logger.debug('Smallest step size in new_unit: %f'%smallest_step_in_new_unit)
   pstarkey:             try:
   pstarkey:                 if smallest_step_in_new_unit > 1:
   pstarkey:                     if smallest_step_in_new_unit > 10:
   pstarkey:                         num_decimals = 0
   pstarkey:                     else:
   pstarkey:                         num_decimals = 1
   pstarkey:                 else:
   pstarkey:                     num_decimals = abs(math.floor(math.log10(smallest_step_in_new_unit))-2)
   pstarkey:             except:
   pstarkey:                 self._logger.warning('Failed to convert number of significant figures to new unit. Loss of precision likely (in manual mode) for this unit. Probably cause is a unit conversion class that imposes limits on the converted values.')
   pstarkey:                 num_decimals = self._decimals
   pstarkey:         else:
   pstarkey:             num_decimals = self._decimals
   pstarkey:         
   pstarkey:         # Store the current units
   pstarkey:         self._current_units = unit  
   pstarkey:         self._settings['current_units'] = unit    
   pstarkey:         
   pstarkey:         # Check to see if the upper/lower bound has switched
   pstarkey:         if property_value_list[1] > property_value_list[2]:
   pstarkey:             property_value_list[1], property_value_list[2] = property_value_list[2], property_value_list[1]
   pstarkey:         
   pstarkey:         # Now update all the widgets
   pstarkey:         for widget in self._widgets:
   pstarkey:             # Update the combo box
   pstarkey:             widget.block_combobox_signals()
   pstarkey:             widget.set_selected_unit(unit)
   pstarkey:             widget.unblock_combobox_signals()
   pstarkey:             
   pstarkey:             # block the spinbox from emitting a signal
   pstarkey:             widget.block_spinbox_signals()
   pstarkey:             # Update the limits
   pstarkey:             widget.set_limits(property_value_list[1],property_value_list[2])
   pstarkey:             # Update the step size
   pstarkey:             widget.set_step_size(property_range_list[0])
   pstarkey:             # Update the decimals
   pstarkey:             widget.set_num_decimals(num_decimals)
   pstarkey:             # Update the value - This should be the last thing you do, 
   pstarkey:             #                    otherwise it might get truncated or 
   pstarkey:             #                    limited in a bad way
   pstarkey:             widget.set_spinbox_value(property_value_list[0],unit)
   pstarkey:             # unblock the spinbox signals
   pstarkey:             widget.unblock_spinbox_signals()
   pstarkey:       
   pstarkey:     @property
   pstarkey:     def value(self):
   pstarkey:         return self._current_value
   pstarkey:         
   pstarkey:     def set_value(self, value, unit=None, program=True):
   pstarkey:         # conversion to float means a string can be passed in too:
   pstarkey:         value = float(value)
   pstarkey:         
   pstarkey:         if unit is not None and unit != self._base_unit:
   pstarkey:             self._current_value = self.convert_value_to_base(value,unit)
   pstarkey:         else:
   pstarkey:             self._current_value = value
   pstarkey:         
   pstarkey:         # Update the saved value in the settings dictionary
   pstarkey:         self._settings['base_value'] = self._current_value
   pstarkey:             
   pstarkey:         if program:
   pstarkey:             self._logger.debug('program device called')
   pstarkey:             self._program_device()
   pstarkey:             
   pstarkey:         for widget in self._widgets:
   pstarkey:             # block signals
   pstarkey:             widget.block_spinbox_signals()
   pstarkey:             # update widget
   pstarkey:             widget.set_spinbox_value(value,unit if unit is not None else self._base_unit)
   pstarkey:             # unblock signals            
   pstarkey:             widget.unblock_spinbox_signals()
   pstarkey:     
   pstarkey:     def set_step_size(self,step_size,unit):
   pstarkey:         self._logger.debug('set_step_size called. step_size: %f, unit: %s'%(step_size,unit))
   pstarkey:         if unit != self._base_unit:
   pstarkey:             # convert and store!
   pstarkey:             value = self.convert_value_from_base(self._current_value,unit)
   pstarkey:             self._step_size = self.convert_range_to_base(value,step_size,unit)
   pstarkey:         else:
   pstarkey:             # This check is usually performed when converting the range to base units
   pstarkey:             # But since we are already in base units we should do it here
   pstarkey:             if abs(self._limits[0]-self._limits[1]) <= step_size:
   pstarkey:                 step_size = abs(self._limits[0]-self._limits[1])
   pstarkey:             self._step_size = step_size
   pstarkey:         
   pstarkey:         self._logger.debug('step_size in base units: %f'%self._step_size)
   pstarkey:         
   pstarkey:         #self._current_step_size = self._step_size
   pstarkey:         self._settings['base_step_size'] = self._step_size
   pstarkey:         
   pstarkey:         # now convert to current units
   pstarkey:         self._current_step_size = self.get_step_size(self._current_units)        
   pstarkey:         self._logger.debug('step_size in current units (%s): %f'%(self._current_units,self._current_step_size))
   pstarkey:     
   pstarkey:         # Update the step size for all widgets
   pstarkey:         for widget in self._widgets:
   pstarkey:             widget.set_step_size(self._current_step_size)
   pstarkey:     
   pstarkey:     def get_step_size(self,unit):
   pstarkey:         if unit != self._base_unit:
   pstarkey:             # we should convert it
   pstarkey:             return self.convert_range_from_base(self._current_value,self._step_size,unit)
   pstarkey:         else:
   pstarkey:             return self._step_size
   pstarkey:     
   pstarkey:     def lock(self):
   pstarkey:         self._update_lock(True)
   pstarkey:         
   pstarkey:     def unlock(self):
   pstarkey:         self._update_lock(False)
   pstarkey:     
   pstarkey:     def _update_lock(self, locked):    
   pstarkey:         self._locked = locked        
   pstarkey:         self._settings['locked'] = locked
   pstarkey:         
   pstarkey:         # Lock all widgets if they are not already locked
   pstarkey:         for widget in self._widgets:
   pstarkey:             if locked:
   pstarkey:                 widget.lock(False)
   pstarkey:             else:
   pstarkey:                 widget.unlock(False)
   pstarkey: 
   pstarkey:     @property
   pstarkey:     def name(self):
   pstarkey:         return self._hardware_name + ' - ' + self._connection_name
   pstarkey:             
   pstarkey: class DO(object):
        jan:     def __init__(self, hardware_name, connection_name, device_name, program_function, settings):
   pstarkey:         self._hardware_name = hardware_name
   pstarkey:         self._connection_name = connection_name
   pstarkey:         self._widget_list = []
   pstarkey:         
   pstarkey:         self._device_name = device_name
        jan:         self._logger = logging.getLogger('BLACS.%s.%s'%(self._device_name,hardware_name))
        jan: 
   pstarkey:         # Note that while we could store self._current_state and self._locked in the
   pstarkey:         # settings dictionary, this dictionary is available to other parts of BLACS
   pstarkey:         # and using separate variables avoids those parts from being able to directly
   pstarkey:         # influence behaviour (the worst they can do is change the value used on initialisation)
   pstarkey:         self._locked = False
   pstarkey:         self._current_state = False
   pstarkey:         self._program_device = program_function
   pstarkey:         self._update_from_settings(settings)
   pstarkey:     
   pstarkey:     def _update_from_settings(self,settings):
   pstarkey:         # Build up the settings dictionary if it isn't already
   pstarkey:         if not isinstance(settings,dict):
   pstarkey:             settings = {}
   pstarkey:         if 'front_panel_settings' not in settings or not isinstance(settings['front_panel_settings'],dict):
   pstarkey:             settings['front_panel_settings'] = {}
   pstarkey:         if self._hardware_name not in settings['front_panel_settings'] or not isinstance(settings['front_panel_settings'][self._hardware_name],dict):
   pstarkey:             settings['front_panel_settings'][self._hardware_name] = {}
   pstarkey:         # Set default values if they are not already saved in the settings dictionary
   pstarkey:         if 'base_value' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['base_value'] = False
   pstarkey:         if 'locked' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['locked'] = False
   pstarkey:         if 'name' not in settings['front_panel_settings'][self._hardware_name]:
   pstarkey:             settings['front_panel_settings'][self._hardware_name]['name'] = self._connection_name
   pstarkey:         
   pstarkey:     
   pstarkey:         # only keep a reference to the part of the settings dictionary relevant to this DO
   pstarkey:         self._settings = settings['front_panel_settings'][self._hardware_name]
   pstarkey:     
   pstarkey:         # Update the state of the button
   pstarkey:         self.set_value(self._settings['base_value'],program=False)
   pstarkey: 
   pstarkey:         # Update the lock state
   pstarkey:         self._update_lock(self._settings['locked'])
        jan: 
        jan:     def create_widget(self, *args, **kwargs):
        jan:         inverted = kwargs.pop("inverted", False)
        jan:         if not inverted:
janwerkmann:             widget = DigitalOutput('%s\n%s'%(self._hardware_name,self._connection_name),*args,**kwargs)
janwerkmann:         else:
janwerkmann:             widget = InvertedDigitalOutput('%s\n%s'%(self._hardware_name,self._connection_name),*args,**kwargs)
        jan:         self.add_widget(widget, inverted=inverted)
   pstarkey:         return widget
        jan: 
        jan:     def add_widget(self, widget, inverted=False):
   pstarkey:         if widget not in self._widget_list:
   pstarkey:             widget.set_DO(self,True,False)
        jan:             widget.toggled.connect(self.set_value if not inverted else lambda state: self.set_value(not state))
   pstarkey:             self._widget_list.append(widget)
   pstarkey:             self.set_value(self._current_state,False)
   pstarkey:             self._update_lock(self._locked)
   pstarkey:             return True
   pstarkey:         return False
   pstarkey:         
   pstarkey:     def remove_widget(self,widget):
   pstarkey:         if widget not in self._widget_list:
   pstarkey:             # TODO: Make this error better!
   pstarkey:             raise RuntimeError('The widget specified was not part of the DO object')
   pstarkey:         widget.toggled.disconnect(self.set_value)
   pstarkey:         self._widget_list.remove(widget)
   pstarkey:         
   pstarkey:     @property  
   pstarkey:     def value(self):
   pstarkey:         return bool(self._current_state)
   pstarkey:     
   pstarkey:     def lock(self):
   pstarkey:         self._update_lock(True)
   pstarkey:         
   pstarkey:     def unlock(self):
   pstarkey:         self._update_lock(False)
   pstarkey:     
   pstarkey:     def _update_lock(self,locked):
   pstarkey:         self._locked = locked
   pstarkey:         for widget in self._widget_list:
   pstarkey:             if locked:
   pstarkey:                 widget.lock(False)
   pstarkey:             else:
   pstarkey:                 widget.unlock(False)
   pstarkey:         
   pstarkey:         # update the settings dictionary if it exists, to maintain continuity on tab restarts
   pstarkey:         self._settings['locked'] = locked
   pstarkey:             
   pstarkey:     def set_value(self,state,program=True):
   pstarkey:         # conversion to integer, then bool means we can safely pass in
   pstarkey:         # either a string '1' or '0', True or False or 1 or 0
        jan:         state = bool(int(state))
        jan: 
   pstarkey:         # We are programatically setting the state, so break the check lock function logic
   pstarkey:         self._current_state = state
   pstarkey:         
   pstarkey:         # update the settings dictionary if it exists, to maintain continuity on tab restarts
   pstarkey:         self._settings['base_value'] = state
   pstarkey:         
   pstarkey:         if program:            
   pstarkey:             self._logger.debug('program device called')
   pstarkey:             self._program_device()
   pstarkey:             
   pstarkey:         for widget in self._widget_list:
   pstarkey:             if state != widget.state:
   pstarkey:                 widget.blockSignals(True)
   pstarkey:                 widget.state = state
   pstarkey:                 widget.blockSignals(False)
   pstarkey:    
   pstarkey:     @property
   pstarkey:     def name(self):
   pstarkey:         return self._hardware_name + ' - ' + self._connection_name
   pstarkey:    
   pstarkey: class DDS(object):
   pstarkey:     def __init__(self, hardware_name, connection_name, output_list):
   pstarkey:         self._hardware_name = hardware_name
   pstarkey:         self._connection_name = connection_name
   pstarkey:         self._sub_channel_list = ['freq','amp','phase','gate']
   pstarkey:         self._widget_list = []
   pstarkey:         for subchnl in self._sub_channel_list:
   pstarkey:             value = None
   pstarkey:             if subchnl in output_list:
   pstarkey:                 value = output_list[subchnl]
   pstarkey:             
   pstarkey:                 setattr(self,subchnl,value)
   pstarkey:             
   pstarkey:     def create_widget(self,*args,**kwargs):
   pstarkey:         widget = DDSOutput(self._hardware_name,self._connection_name,*args,**kwargs)
   pstarkey:         self.add_widget(widget)
   pstarkey:         return widget
   pstarkey:     
   pstarkey:     def add_widget(self, widget):
   pstarkey:         if widget in self._widget_list:
   pstarkey:             return False
   pstarkey:             
   pstarkey:         # Check that the widget has a method for getting/showin/hiding subwidgets        
   pstarkey:         try:
   pstarkey:             for subchnl in self._sub_channel_list:
   pstarkey:                 widget.get_sub_widget(subchnl)
   pstarkey:                 widget.hide_sub_widget(subchnl)
   pstarkey:                 widget.show_sub_widget(subchnl)
   pstarkey:         except:
   pstarkey:             raise
   pstarkey:             return False
   pstarkey:             
   pstarkey:         self._widget_list.append(widget)
   pstarkey:         
   pstarkey:         for subchnl in self._sub_channel_list:
   pstarkey:             if hasattr(self,subchnl):
   pstarkey:                 getattr(self,subchnl).add_widget(widget.get_sub_widget(subchnl))            
   pstarkey:                 widget.show_sub_widget(subchnl)
   pstarkey:             else:
   pstarkey:                 widget.hide_sub_widget(subchnl)
   pstarkey:         
   pstarkey:         return True
   pstarkey:         
   pstarkey:     def remove_widget(self,widget):
   pstarkey:         if widget not in self._widget_list:
   pstarkey:             # TODO: Make this error better!
   pstarkey:             raise RuntimeError('The widget specified was not part of the DDS object')
   pstarkey:         
   pstarkey:         for subchnl in self._sub_channel_list:
   pstarkey:             if hasattr(self,subchnl):
   pstarkey:                 getattr(self,subchnl).remove_widget(widget.get_sub_widget(subchnl))  
   pstarkey:         
   pstarkey:         self._widget_list.remove(widget)
   pstarkey:     
   pstarkey:     def get_subchnl_list(self):
   pstarkey:         subchnls = []
   pstarkey:         for subchnl in self._sub_channel_list:
   pstarkey:             if hasattr(self,subchnl):
   pstarkey:                 subchnls.append(subchnl)
   pstarkey:                 
   pstarkey:         return subchnls
   pstarkey:         
   pstarkey:     def get_unused_subchnl_list(self):
   pstarkey:         return list(set(self._sub_channel_list).difference(set(self.get_subchnl_list())))
   pstarkey:     
   pstarkey:     @property
   pstarkey:     def value(self):
   pstarkey:         value = {}
   pstarkey:         for subchnl in self._sub_channel_list:
   pstarkey:             if hasattr(self,subchnl):
   pstarkey:                 value[subchnl] = getattr(self,subchnl).value
   pstarkey:         return value
   pstarkey:         
   pstarkey:     def set_value(self,value,program=True):
   pstarkey:         for subchnl in self._sub_channel_list:
   pstarkey:             if subchnl in value:
   pstarkey:                 if hasattr(self,subchnl):
   pstarkey:                     getattr(self,subchnl).set_value(value[subchnl],program=program)
   pstarkey:                     
   pstarkey:     @property
   pstarkey:     def name(self):
   pstarkey:         return self._hardware_name + ' - ' + self._connection_name
   pstarkey:         
   pstarkey: if __name__ == '__main__':
   pstarkey:     from labscript_utils.qtwidgets.toolpalette import ToolPaletteGroup
   pstarkey:     import sys
   pstarkey:     
   pstarkey:     qapplication = QApplication(sys.argv)
   pstarkey:     
   pstarkey:     window = QWidget()
   pstarkey:     layout = QVBoxLayout(window)
   pstarkey:     widget = QWidget()
   pstarkey:     layout.addWidget(widget)
   pstarkey:     tpg = ToolPaletteGroup(widget)
   pstarkey:     toolpalette = tpg.append_new_palette('Digital Outputs')    
   pstarkey:     toolpalette2 = tpg.append_new_palette('Analog Outputs')    
   pstarkey:     layout.addItem(QSpacerItem(0,0,QSizePolicy.Minimum,QSizePolicy.MinimumExpanding))
   pstarkey:     
   pstarkey:     # create settings dictionary
   pstarkey:     settings = {'front_panel_settings':{
   pstarkey:                     'do0':{
   pstarkey:                         'base_value':False,
   pstarkey:                         'locked':False,
   pstarkey:                         },
   pstarkey:                     'ao0':{
   pstarkey:                         'base_value':3.0,
   pstarkey:                         'locked':False,
   pstarkey:                         'base_step_size':0.1,
   pstarkey:                         'current_units':'V',
   pstarkey:                         }
   pstarkey:                 }
   pstarkey:         }
   pstarkey:     
   pstarkey:     def print_something():
janwerkmann:         print('program_function called')
janwerkmann: 
   pstarkey:     # Create a DO object
   pstarkey:     my_DO = DO(hardware_name='do0', connection_name='my first digital output', program_function=print_something, settings=settings)
   pstarkey:     
   pstarkey:     # Link in two DO widgets
   pstarkey:     button1 = DigitalOutput('do0\nmy first digital output')
   pstarkey:     button2 = DigitalOutput('a linked do0')
   pstarkey:     toolpalette.addWidget(button1)
   pstarkey:     toolpalette.addWidget(button2)
   pstarkey:     my_DO.add_widget(button1)
   pstarkey:     my_DO.add_widget(button2)
   pstarkey:     
   pstarkey:     # Create an AO object
   pstarkey:     my_AO = AO(hardware_name = 'ao0', connection_name='my ao', device_name='ni_blah',
   pstarkey:                 program_function=print_something, settings=settings, 
   pstarkey:                 calib_class=None, calib_params=None, default_units='V', 
   pstarkey:                 min=-10.0, max=10.0, step=0.01, decimals=3)
   pstarkey:     
   pstarkey:     # link in two AO widgets
   pstarkey:     analog1 = AnalogOutput('AO1')
   pstarkey:     analog2 = AnalogOutput('AO1 copy')
   pstarkey:     my_AO.add_widget(analog1)
   pstarkey:     my_AO.add_widget(analog2)
   pstarkey:     toolpalette2.addWidget(analog1)
   pstarkey:     toolpalette2.addWidget(analog2)
   pstarkey:     
   pstarkey:     # TODO: Add in test case for DDS
   pstarkey:     
   pstarkey:     
   pstarkey:     window.show()
   pstarkey:     sys.exit(qapplication.exec_())
janwerkmann:     
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /plugins/__init__.py                                              #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: 
        pstarkey: import os
        cbilling: import sys
        cbilling: import logging
        cbilling: import importlib
             jan: from labscript_utils.labconfig import LabConfig
chrisjbillington: from blacs import BLACS_DIR
chrisjbillington: PLUGINS_DIR = os.path.join(BLACS_DIR, 'plugins')
        cbilling: 
chrisjbillington: default_plugins = ['connection_table', 'general', 'theme']
             jan: 
        cbilling: logger = logging.getLogger('BLACS.plugins')
        cbilling: 
             jan: exp_config = LabConfig()
             jan: if not exp_config.has_section('BLACS/plugins'):
             jan:     exp_config.add_section('BLACS/plugins')
             jan: 
        cbilling: modules = {}
chrisjbillington: for module_name in os.listdir(PLUGINS_DIR):
             jan:     if os.path.isdir(os.path.join(PLUGINS_DIR, module_name)) and module_name != '__pycache__':
             jan:         # is it a new plugin?
             jan:         # If so lets add it to the config
chrisjbillington:         if not module_name in [name for name, val in exp_config.items('BLACS/plugins')]:
             jan:             exp_config.set('BLACS/plugins', module_name, str(module_name in default_plugins))
             jan: 
             jan:         # only load activated plugins
             jan:         if exp_config.getboolean('BLACS/plugins', module_name):
             jan:             try:
             jan:                 module = importlib.import_module('blacs.plugins.'+module_name)
             jan:             except Exception:
             jan:                 logger.exception('Could not import plugin \'%s\'. Skipping.'%module_name)
             jan:             else:
             jan:                 modules[module_name] = module
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /plugins/connection_table/__init__.py                             #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
        pstarkey: 
        pstarkey: import logging
        pstarkey: import os
        pstarkey: import subprocess
        pstarkey: import sys
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
        pstarkey: 
        cbilling: from blacs.compile_and_restart import CompileAndRestart
        pstarkey: from labscript_utils.filewatcher import FileWatcher
        pstarkey: from qtutils import *
chrisjbillington: from blacs.plugins import PLUGINS_DIR
        pstarkey: 
        pstarkey: FILEPATH_COLUMN = 0
        pstarkey: name = "Connection Table"
        pstarkey: module = "connection_table" # should be folder name
        pstarkey: logger = logging.getLogger('BLACS.plugin.%s'%module)
        pstarkey: 
        pstarkey: class Plugin(object):
        pstarkey:     def __init__(self,initial_settings):
        pstarkey:         self.menu = None
        pstarkey:         self.notifications = {}
        pstarkey:         self.initial_settings = initial_settings
        pstarkey:         self.BLACS = None
        pstarkey:         
        pstarkey:     def get_menu_class(self):
        pstarkey:         return Menu
        pstarkey:         
        pstarkey:     def get_notification_classes(self):
             jan:         return [RecompileNotification, BrokenDevicesNotification]
             jan: 
        pstarkey:     def get_setting_classes(self):
        pstarkey:         return [Setting]
        pstarkey:         
        pstarkey:     def get_callbacks(self):
             jan:         return {'settings_changed':self.notifications[RecompileNotification].setup_filewatching}
             jan: 
        pstarkey:     def set_menu_instance(self,menu):
        pstarkey:         self.menu = menu
        pstarkey:         
        pstarkey:     def set_notification_instances(self,notifications):
        pstarkey:         self.notifications = notifications
        pstarkey:         
        pstarkey:     def plugin_setup_complete(self, BLACS):
        pstarkey:         self.BLACS = BLACS
        pstarkey:         modified_times = self.initial_settings['modified_times'] if 'modified_times' in self.initial_settings else None
             jan:         self.notifications[RecompileNotification].setup_filewatching(modified_times)
             jan:         self.menu.close_notification_func = self.notifications[RecompileNotification]._close
             jan:         failed_devices = list(self.BLACS['experiment_queue'].BLACS.failed_device_settings.keys())
             jan:         if ('visible' in self.initial_settings and self.initial_settings['visible']) or len(failed_devices) > 0:
             jan:             self.notifications[RecompileNotification]._show()
             jan:             if len(failed_devices) > 0:
             jan:                 self.notifications[BrokenDevicesNotification].set_broken_devices(failed_devices)
             jan:                 self.notifications[BrokenDevicesNotification]._show()
             jan: 
        pstarkey:     def get_save_data(self):
             jan:         return self.notifications[RecompileNotification].get_save_data()
             jan: 
        pstarkey:     def close(self):
             jan:         self.notifications[RecompileNotification].close()
             jan:         self.notifications[BrokenDevicesNotification].close()
        pstarkey: 
        pstarkey: class Menu(object):
        pstarkey:     def __init__(self,BLACS):
        pstarkey:         self.BLACS = BLACS
        pstarkey:         self.close_notification_func = None
        pstarkey:         
        pstarkey:     def get_menu_items(self):
        pstarkey:         return {'name':name,        
        pstarkey:                 'menu_items':[{'name':'Edit',
chrisjbillington:                                'action':self.on_edit_connection_table,
chrisjbillington:                                'icon': ':/qtutils/fugue/document--pencil'
        pstarkey:                               },
        pstarkey:                               {'name':'Select Globals',
chrisjbillington:                                'action':self.on_select_globals,
chrisjbillington:                                'icon': ':/qtutils/fugue/table--pencil'
        pstarkey:                               },
        pstarkey:                               {'name':'Recompile',
chrisjbillington:                                'action':self.on_recompile_connection_table,
chrisjbillington:                                'icon': ':/qtutils/fugue/arrow-circle'
        pstarkey:                               }
        pstarkey:                              ]                                
        pstarkey:                }
        pstarkey:     
        pstarkey:     def on_select_globals(self,*args,**kwargs):
     janwerkmann:         print('aaaaaa')
        pstarkey:         self.BLACS['settings'].create_dialog(goto_page=Setting)
        pstarkey:       
        pstarkey:     def on_edit_connection_table(self,*args,**kwargs):
        pstarkey:         # get path to text editor
        pstarkey:         editor_path = self.BLACS['exp_config'].get('programs','text_editor')
        pstarkey:         editor_args = self.BLACS['exp_config'].get('programs','text_editor_arguments')
        pstarkey:         if editor_path:  
        pstarkey:             if '{file}' in editor_args:
        pstarkey:                 editor_args = editor_args.replace('{file}', self.BLACS['exp_config'].get('paths','connection_table_py'))
        pstarkey:             else:
        pstarkey:                 editor_args = self.BLACS['exp_config'].get('paths','connection_table_py') + " " + editor_args            
        pstarkey:             try:
        pstarkey:                 subprocess.Popen([editor_path,editor_args])
        pstarkey:             except Exception:
        pstarkey:                 QMessageBox.information(self.BLACS['ui'],"Error","Unable to launch text editor. Check the path is valid in the experiment config file (%s) (you must restart BLACS if you edit this file)"%self.BLACS['exp_config'].config_path)
        pstarkey:         else:
        pstarkey:             QMessageBox.information(self.BLACS['ui'],"Error","No text editor path was specified in the experiment config file (%s) (you must restart BLACS if you edit this file)"%self.BLACS['exp_config'].config_path)
        pstarkey:     
        pstarkey:     def on_recompile_connection_table(self,*args,**kwargs):
        pstarkey:         logger.info('recompile connection table called')
        pstarkey:         # get list of globals
        pstarkey:         globals_files = self.BLACS['settings'].get_value(Setting,'globals_list')
        pstarkey:         # Remove unicode encoding so that zprocess.locking doesn't crash
        pstarkey:         for i in range(len(globals_files)):
        pstarkey:             globals_files[i] = str(globals_files[i])
        pstarkey:         CompileAndRestart(self.BLACS, globals_files, self.BLACS['exp_config'].get('paths','connection_table_py'), self.BLACS['exp_config'].get('paths','connection_table_h5'),close_notification_func=self.close_notification_func)
             jan: 
             jan: 
             jan: class BrokenDevicesNotification(object):
             jan:     name = 'Device initialization failed'
             jan:     def __init__(self, BLACS):
             jan:         # Create the widget
             jan:         self._ui = UiLoader().load(os.path.join(PLUGINS_DIR, module, 'broken_device_notification.ui'))
             jan: 
             jan:     def get_widget(self):
             jan:         return self._ui
             jan: 
             jan:     def set_broken_devices(self, device_names):
             jan:         self._ui.label.setText('''<html><head/><body><span style=" font-weight:600; color:#ff0000;">BLACS failed to initialize some of your devices.
             jan:             It is advised that you solve this problem before using BLACS.
             jan:             The devices causing problems were: {}</span></body></html>'''.format(', '.join(device_names)))
             jan: 
             jan:     def get_properties(self):
             jan:         return {'can_hide':False, 'can_close':False}
             jan: 
             jan:     def set_functions(self,show_func,hide_func,close_func,get_state):
             jan:         self._show = show_func
             jan:         self._hide = hide_func
             jan:         self._close = close_func
             jan:         self._get_state = get_state
             jan: 
             jan:     def get_save_data(self):
             jan:         return {}
             jan: 
             jan:     def close(self):
             jan:         pass
             jan: 
             jan: 
             jan: class RecompileNotification(object):
        pstarkey:     name = name
        pstarkey:     def __init__(self, BLACS):
        pstarkey:         # set up the file watching
        pstarkey:         self.BLACS = BLACS
        pstarkey:         self.filewatcher = None
        pstarkey:         
        pstarkey:         # Create the widget
chrisjbillington:         self._ui = UiLoader().load(os.path.join(PLUGINS_DIR, module, 'notification.ui'))
        pstarkey:         self._ui.button.clicked.connect(self.on_recompile_connection_table)
        pstarkey:         #self._ui.hide()
        pstarkey:             
        pstarkey:     def get_widget(self):
        pstarkey:         return self._ui
        pstarkey:         
        pstarkey:     def get_properties(self):
        pstarkey:         return {'can_hide':True, 'can_close':False}
        pstarkey:         
        pstarkey:     def set_functions(self,show_func,hide_func,close_func,get_state):
        pstarkey:         self._show = show_func
        pstarkey:         self._hide = hide_func
        pstarkey:         self._close = close_func
        pstarkey:         self._get_state = get_state
        pstarkey:                 
        pstarkey:     def on_recompile_connection_table(self,*args,**kwargs):
        pstarkey:         self.BLACS['plugins'][module].menu.on_recompile_connection_table()
        pstarkey:         
        pstarkey:     def setup_filewatching(self,modified_times = None):
        pstarkey:         folder_list = []
        pstarkey:         file_list = [self.BLACS['connection_table_labscript'], self.BLACS['connection_table_h5file']]
        pstarkey:         
        pstarkey:         # append the list of globals
        pstarkey:         file_list += self.BLACS['settings'].get_value(Setting,'globals_list')
        pstarkey:         # iterate over list, split folders off from files!
        pstarkey:         calibration_list = self.BLACS['settings'].get_value(Setting,'calibrations_list')
        pstarkey:         for path in calibration_list:
        pstarkey:             if os.path.isdir(path):
        pstarkey:                 folder_list.append(path)
        pstarkey:             else:
        pstarkey:                 file_list.append(path)
        pstarkey:         
        pstarkey:         if modified_times is None:
        pstarkey:             modified_times = {}
        pstarkey:         
        pstarkey:         # stop watching if we already were
        pstarkey:         if self.filewatcher:
        pstarkey:             self.filewatcher.stop()
        pstarkey:             modified_times = self.filewatcher.get_modified_times()
        pstarkey:             
        pstarkey:         # Start the file watching!
        pstarkey:         self.filewatcher = FileWatcher(lambda f,m: inmain(self._show),file_list,folder_list,modified_times=modified_times)
        pstarkey:     
        pstarkey:     def get_save_data(self):
        pstarkey:         state = True if self._get_state() == 'hidden' or self._get_state() == 'shown' else False
        pstarkey:         return {'modified_times':self.filewatcher.get_modified_times() if self.filewatcher else {}, 'visible':state}
        pstarkey:     
        pstarkey:     def close(self):
        pstarkey:         self.filewatcher.stop()
        pstarkey:     
        pstarkey: class Setting(object):
        pstarkey:     name = name
        pstarkey: 
        pstarkey:     def __init__(self,data):
        pstarkey:         # This is our data store!
        pstarkey:         self.data = data
        pstarkey:         
        pstarkey:         self.stores_list = ['globals','calibrations']
        pstarkey:         
        pstarkey:         for store in self.stores_list:
        pstarkey:             if '%s_list'%store not in self.data:
        pstarkey:                 self.data['%s_list'%store] = []
        pstarkey:                 
        pstarkey:             #set the default sort order if it wasn't previousl saved
        pstarkey:             if '%s_sort_order'%store not in self.data:
        pstarkey:                 self.data['%s_sort_order'%store] = 'ASC'
        pstarkey:         
        pstarkey:     # Create the page, return the page and an icon to use on the label (the class name attribute will be used for the label text)   
        pstarkey:     def create_dialog(self,notebook):
chrisjbillington:         ui = UiLoader().load(os.path.join(PLUGINS_DIR, module, 'connection_table.ui'))
        pstarkey:         
        pstarkey:         # Create the models, get the views, and link them!!
        pstarkey:         self.models = {}
        pstarkey:         self.views = {}
        pstarkey:         self.models['globals'] = QStandardItemModel()
        pstarkey:         self.models['globals'].setHorizontalHeaderItem(FILEPATH_COLUMN, QStandardItem('Filepath'))
        pstarkey:         self.views['globals'] = ui.h5_treeview
        pstarkey:         self.views['globals'].setModel(self.models['globals'])
        pstarkey:         
        pstarkey:         self.models['calibrations'] = QStandardItemModel()
        pstarkey:         self.models['calibrations'].setHorizontalHeaderItem(FILEPATH_COLUMN, QStandardItem('Filepath'))
        pstarkey:         self.views['calibrations'] = ui.unit_conversion_treeview
        pstarkey:         self.views['calibrations'].setModel(self.models['calibrations'])
        pstarkey:         
        pstarkey:         # Setup the buttons
        pstarkey:         ui.add_h5_file.clicked.connect(self.add_global_file)
        pstarkey:         ui.delete_h5_file.clicked.connect(self.delete_selected_globals_file)
        pstarkey:         ui.add_unitconversion_file.clicked.connect(self.add_calibration_file)
        pstarkey:         ui.add_unitconversion_folder.clicked.connect(self.add_calibration_folder)
        pstarkey:         ui.delete_unitconversion.clicked.connect(self.delete_selected_conversion_file)
        pstarkey:         
        pstarkey:         # setup sort indicator changed signals
        pstarkey:         self.views['globals'].header().sortIndicatorChanged.connect(self.global_sort_indicator_changed)
        pstarkey:         self.views['calibrations'].header().sortIndicatorChanged.connect(self.calibrations_sort_indicator_changed)
        pstarkey:         
        pstarkey:         #iterate over the two listores
        pstarkey:         for store in self.stores_list:
        pstarkey:             # If we have saved data in the data store, then load it into the list store
        pstarkey:             if '%s_list'%store in self.data:
        pstarkey:                 for path in self.data['%s_list'%store]:
        pstarkey:                     self.models[store].appendRow(QStandardItem(path))
        pstarkey:             # otherwise add an empty list to our data store, and leave the liststore empty
        pstarkey:             else:
        pstarkey:                 self.data['%s_list'%store] = []
        pstarkey:             
        pstarkey:             self.views[store].sortByColumn(FILEPATH_COLUMN,self.order_to_enum(self.data['%s_sort_order'%store]))
        pstarkey:         
        pstarkey:         return ui,None
        pstarkey:     
        pstarkey:     def global_sort_indicator_changed(self):
        pstarkey:         if 'PySide' in sys.modules.copy():
        pstarkey:             if self.views['globals'].header().sortIndicatorOrder() == Qt.SortOrder.AscendingOrder:
        pstarkey:                 order = 'ASC'
        pstarkey:             else:
        pstarkey:                 order = 'DESC'
        pstarkey:         else:
        pstarkey:             if self.views['globals'].header().sortIndicatorOrder() == Qt.AscendingOrder:
        pstarkey:                 order = 'ASC'
        pstarkey:             else:
        pstarkey:                 order = 'DESC'
        pstarkey:         self.data['globals_sort_order'] = self.enum_to_order(self.views['globals'].header().sortIndicatorOrder())
        pstarkey:         
        pstarkey:     def calibrations_sort_indicator_changed(self):
        pstarkey:         self.data['calibrations_sort_order'] = self.enum_to_order(self.views['calibrations'].header().sortIndicatorOrder())
        pstarkey:     
        pstarkey:     def order_to_enum(self, order):
        pstarkey:         # if we are accidnetally passed an enum, just return it
        pstarkey:         if order not in ['ASC', 'DESC']:
        pstarkey:             return order
        pstarkey:     
        pstarkey:         if 'PySide' in sys.modules.copy():
        pstarkey:             if order == 'ASC':
        pstarkey:                 enum = Qt.SortOrder.AscendingOrder
        pstarkey:             else:
        pstarkey:                 enum = Qt.SortOrder.DescendingOrder
        pstarkey:         else:
        pstarkey:             if order == 'ASC':
        pstarkey:                 enum = Qt.AscendingOrder
        pstarkey:             else:
        pstarkey:                 enum = Qt.DescendingOrder
        pstarkey:         
        pstarkey:         return enum
        pstarkey:         
        pstarkey:     def enum_to_order(self, enum):
        pstarkey:         if 'PySide' in sys.modules.copy():
        pstarkey:             if enum == Qt.SortOrder.AscendingOrder:
        pstarkey:                 order = 'ASC'
        pstarkey:             else:
        pstarkey:                 order = 'DESC'
        pstarkey:         else:
        pstarkey:             if enum == Qt.AscendingOrder:
        pstarkey:                 order = 'ASC'
        pstarkey:             else:
        pstarkey:                 order = 'DESC'
        pstarkey:         
        pstarkey:         return order
        pstarkey:     
        pstarkey:     def get_value(self,name):
        pstarkey:         if name in self.data:
        pstarkey:             return self.data[name]
        pstarkey:         
        pstarkey:         return None
        pstarkey:     
        pstarkey:     def save(self):
        pstarkey:         # transfer the contents of the list store into the data store, and then return the data store
        pstarkey:         for store in self.stores_list:
        pstarkey:             # clear the existing list
        pstarkey:             self.data['%s_list'%store] = []
        pstarkey:             for row_index in range(self.models[store].rowCount()):
        pstarkey:                 self.data['%s_list'%store].append(str(self.models[store].item(row_index).text()))
        pstarkey:         
        pstarkey:         return self.data
        pstarkey:         
        pstarkey:     def close(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def add_global_file(self,*args,**kwargs):
        pstarkey:         # create file chooser dialog
        pstarkey:         dialog = QFileDialog(None,"select globals files", "C:\\", "HDF5 files (*.h5 *.hdf5)")
        pstarkey:         dialog.setViewMode(QFileDialog.Detail)
        pstarkey:         dialog.setFileMode(QFileDialog.ExistingFiles)
        pstarkey:         
        pstarkey:         if dialog.exec_():
        pstarkey:             selected_files = dialog.selectedFiles()
        pstarkey:             for filepath in selected_files:
        pstarkey:                 filepath = str(filepath)
        pstarkey:                 # Qt has this weird behaviour where if you type in the name of a file that exists
        pstarkey:                 # but does not have the extension you have limited the dialog to, the OK button is greyed out
        pstarkey:                 # but you can hit enter and the file will be selected. 
        pstarkey:                 # So we must check the extension of each file here!
        pstarkey:                 if filepath.endswith('.h5') or filepath.endswith('.hdf5'):
        pstarkey:                     # make sure the path isn't already in the list
        pstarkey:                     if not self.is_filepath_in_store(filepath,'globals'):
        pstarkey:                         self.models['globals'].appendRow(QStandardItem(filepath))
        pstarkey:          
        pstarkey:             self.views['globals'].sortByColumn(FILEPATH_COLUMN,self.order_to_enum(self.data['globals_sort_order']))
        pstarkey:             
        pstarkey:         dialog.deleteLater()
        pstarkey:             
        pstarkey:     def is_filepath_in_store(self,filepath,store):
        pstarkey:         for row_index in range(self.models[store].rowCount()):
        pstarkey:             if str(filepath) == str(self.models[store].item(row_index).text()):
        pstarkey:                 return True
        pstarkey:         return False
        pstarkey:     
        pstarkey:     def delete_selected_globals_file(self):
        pstarkey:         index_list = self.views['globals'].selectedIndexes()
        pstarkey:         while index_list:
        pstarkey:             self.models['globals'].takeRow(index_list[0].row())
        pstarkey:             index_list = self.views['globals'].selectedIndexes()
        pstarkey:         
        pstarkey:         self.views['globals'].sortByColumn(FILEPATH_COLUMN,self.order_to_enum(self.data['globals_sort_order']))
        pstarkey:             
        pstarkey:     def add_calibration_file(self):
        pstarkey:         # create file chooser dialog
        pstarkey:         dialog = QFileDialog(None,"Select unit conversion scripts", "C:\\", "Python files (*.py *.pyw)")
        pstarkey:         dialog.setViewMode(QFileDialog.Detail)
        pstarkey:         dialog.setFileMode(QFileDialog.ExistingFiles)
        pstarkey:         
        pstarkey:         if dialog.exec_():
        pstarkey:             selected_files = dialog.selectedFiles()
        pstarkey:             for filepath in selected_files:
        pstarkey:                 filepath = str(filepath)
        pstarkey:                 # Qt has this weird behaviour where if you type in the name of a file that exists
        pstarkey:                 # but does not have the extension you have limited the dialog to, the OK button is greyed out
        pstarkey:                 # but you can hit enter and the file will be selected. 
        pstarkey:                 # So we must check the extension of each file here!
        pstarkey:                 if filepath.endswith('.py') or filepath.endswith('.pyw'):
        pstarkey:                     # make sure the path isn't already in the list
        pstarkey:                     if not self.is_filepath_in_store(filepath,'calibrations'):
        pstarkey:                         self.models['calibrations'].appendRow(QStandardItem(filepath))
        pstarkey:          
        pstarkey:             self.views['calibrations'].sortByColumn(FILEPATH_COLUMN,self.order_to_enum(self.data['calibrations_sort_order']))
        pstarkey:         
        pstarkey:         dialog.deleteLater()
        pstarkey:         
        pstarkey:     def add_calibration_folder(self):
        pstarkey:         # create file chooser dialog
        pstarkey:         dialog = QFileDialog(None,"Select unit conversion folder", "C:\\", "")
        pstarkey:         dialog.setViewMode(QFileDialog.Detail)
        pstarkey:         dialog.setFileMode(QFileDialog.Directory)
        pstarkey:         
        pstarkey:         if dialog.exec_():
        pstarkey:             selected_files = dialog.selectedFiles()
        pstarkey:             for filepath in selected_files:
        pstarkey:                 # make sure the path isn't already in the list
        pstarkey:                 if not self.is_filepath_in_store(filepath,'calibrations'):
        pstarkey:                     self.models['calibrations'].appendRow(QStandardItem(filepath))
        pstarkey:          
        pstarkey:             self.views['calibrations'].sortByColumn(FILEPATH_COLUMN,self.order_to_enum(self.data['calibrations_sort_order']))
        pstarkey:         
        pstarkey:         dialog.deleteLater()
        pstarkey:     
        pstarkey:     def delete_selected_conversion_file(self):
        pstarkey:         index_list = self.views['calibrations'].selectedIndexes()
        pstarkey:         while index_list:
        pstarkey:             self.models['calibrations'].takeRow(index_list[0].row())
        pstarkey:             index_list = self.views['calibrations'].selectedIndexes()
        pstarkey:         
        pstarkey:         self.views['calibrations'].sortByColumn(FILEPATH_COLUMN,self.order_to_enum(self.data['calibrations_sort_order']))
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # /plugins/delete_repeated_shots/__init__.py                        #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2017, JQI                                               #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the program BLACS, in the labscript suite    #
chrisjbillington: # (see http://labscriptsuite.org), and is licensed under the        #
chrisjbillington: # Simplified BSD License. See the license.txt file in the root of   #
chrisjbillington: # the project for the full license.                                 #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
             jan: from __future__ import division, unicode_literals, print_function, absolute_import
             jan: from labscript_utils import PY2
             jan: if PY2:
             jan:     from Queue import Queue
             jan: else:
             jan:     from queue import Queue
chrisjbillington: 
chrisjbillington: import logging
chrisjbillington: import os
chrisjbillington: import subprocess
chrisjbillington: import threading
chrisjbillington: import sys
chrisjbillington: 
chrisjbillington: from qtutils import UiLoader
chrisjbillington: 
chrisjbillington: from labscript_utils.shared_drive import path_to_agnostic
chrisjbillington: import zprocess.locking
chrisjbillington: from blacs.plugins import PLUGINS_DIR
chrisjbillington: 
chrisjbillington: name = "Delete repeated shots"
chrisjbillington: module = "delete_repeated_shots" # should be folder name
chrisjbillington: logger = logging.getLogger('BLACS.plugin.%s'%module)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: KEEP_ALL_SHOTS = 0
chrisjbillington: 
chrisjbillington: class Plugin(object):
chrisjbillington:     def __init__(self, initial_settings):
chrisjbillington:         self.menu = None
chrisjbillington:         self.notifications = {}
chrisjbillington:         self.initial_settings = initial_settings
chrisjbillington:         self.BLACS = None
chrisjbillington:         self.ui = None
chrisjbillington:         self.n_shots_to_keep = initial_settings.get('n_shots_to_keep', KEEP_ALL_SHOTS)
chrisjbillington:         self.delete_queue = initial_settings.get('delete_queue', [])
chrisjbillington:         self.event_queue = Queue()
chrisjbillington:         self.delete_queue_lock = threading.Lock()
chrisjbillington:         self.mainloop_thread = threading.Thread(target=self.mainloop)
chrisjbillington:         self.mainloop_thread.daemon = True
chrisjbillington:         self.mainloop_thread.start()
chrisjbillington:         
chrisjbillington:     def plugin_setup_complete(self, BLACS):
chrisjbillington:         self.BLACS = BLACS
chrisjbillington: 
chrisjbillington:         # Add our controls to the BLACS UI:
chrisjbillington:         self.ui = UiLoader().load(os.path.join(PLUGINS_DIR, module, 'controls.ui'))
chrisjbillington:         BLACS['ui'].queue_controls_frame.layout().addWidget(self.ui)
chrisjbillington: 
chrisjbillington:         # Restore settings to the GUI controls:
chrisjbillington:         self.ui.spinBox.setValue(self.n_shots_to_keep)
chrisjbillington: 
chrisjbillington:         # Connect signals:
chrisjbillington:         self.ui.spinBox.valueChanged.connect(self.on_spinbox_value_changed)
chrisjbillington:         self.ui.reset_button.clicked.connect(self.on_reset_button_clicked)
chrisjbillington:         BLACS['ui'].queue_repeat_button.toggled.connect(self.ui.setEnabled)
chrisjbillington: 
chrisjbillington:         # Our control is only enabled when repeat mode is active:
chrisjbillington:         self.ui.setEnabled(BLACS['ui'].queue_repeat_button.isChecked())
chrisjbillington: 
chrisjbillington:     def on_spinbox_value_changed(self, value):
chrisjbillington:         with self.delete_queue_lock:
chrisjbillington:             self.n_shots_to_keep = value
chrisjbillington:             # If the user reduces the number of shots to keep, but we had a
chrisjbillington:             # larger list of shots awaiting deletion, remove shots from the
chrisjbillington:             # deletion queue (without deleting them) until the queue is the
chrisjbillington:             # same size as the number of shots we are now keeping. This means
chrisjbillington:             # that if we set to keep 100 shots, and then we go ahead and run a
chrisjbillington:             # hundred shots, if we then set it to keep 5 shots it won't delete
chrisjbillington:             # the 95 oldest shots in the queue. Rather it will only delete the
chrisjbillington:             # most recent 5 (and not immediately - over the next 5 shots).
chrisjbillington:             while len(self.delete_queue) > self.n_shots_to_keep:
chrisjbillington:                 self.delete_queue.pop(0)
chrisjbillington: 
chrisjbillington:     def on_reset_button_clicked(self):
chrisjbillington:         self.ui.spinBox.setValue(KEEP_ALL_SHOTS)
chrisjbillington: 
chrisjbillington:     def get_save_data(self):
chrisjbillington:         return {'n_shots_to_keep': self.n_shots_to_keep,
chrisjbillington:                 'delete_queue': self.delete_queue}
chrisjbillington:     
chrisjbillington:     def get_callbacks(self):
chrisjbillington:         return {'shot_complete': self.on_shot_complete}
chrisjbillington:         
chrisjbillington:     def on_shot_complete(self, h5_filepath):
chrisjbillington: 
chrisjbillington:         # If we're keeping all shots, then there's nothing to do here:
chrisjbillington:         if self.n_shots_to_keep == KEEP_ALL_SHOTS:
chrisjbillington:             return
chrisjbillington: 
chrisjbillington:         # Is the file a repeated shot?
chrisjbillington:         basename, ext = os.path.splitext(os.path.basename(h5_filepath))
chrisjbillington:         if '_rep' in basename and ext == '.h5':
chrisjbillington:             repno = basename.split('_rep')[-1]
chrisjbillington:             try:
chrisjbillington:                 int(repno)
chrisjbillington:             except ValueError:
chrisjbillington:                 # not a rep:
chrisjbillington:                 return
chrisjbillington:             else:
chrisjbillington:                 # Yes, it is a rep. Queue it for deletion:
chrisjbillington:                 self.delete_queue.append(h5_filepath)
chrisjbillington:                 self.event_queue.put('shot complete')
chrisjbillington: 
chrisjbillington:     def mainloop(self):
chrisjbillington:         # We delete shots in a separate thread so that we don't slow down the queue waiting on
chrisjbillington:         # network communication to acquire the lock, 
chrisjbillington:         while True:
chrisjbillington:             try:
chrisjbillington:                 event = self.event_queue.get()
chrisjbillington:                 if event == 'close':
chrisjbillington:                     break
chrisjbillington:                 elif event == 'shot complete':
chrisjbillington:                     while len(self.delete_queue) > self.n_shots_to_keep:
chrisjbillington:                         with self.delete_queue_lock:
chrisjbillington:                             h5_filepath = self.delete_queue.pop(0)
chrisjbillington:                         # Acquire a lock on the file so that we don't
chrisjbillington:                         # delete it whilst someone else has it open:
chrisjbillington:                         with zprocess.locking.Lock(path_to_agnostic(h5_filepath)):
chrisjbillington:                             try:
chrisjbillington:                                 os.unlink(h5_filepath)
chrisjbillington:                                 logger.info("Deleted repeated shot file %s" % h5_filepath)
chrisjbillington:                             except OSError:
chrisjbillington:                                 logger.exception("Couldn't delete shot file %s" % h5_filepath)
chrisjbillington:                 else:
chrisjbillington:                     raise ValueError(event)
chrisjbillington:             except Exception:
chrisjbillington:                 logger.exception("Exception in repeated shot deletion loop, ignoring.")
chrisjbillington:     
chrisjbillington: 
chrisjbillington:     def close(self):
chrisjbillington:         self.event_queue.put('close')
chrisjbillington:         self.mainloop_thread.join()
chrisjbillington: 
chrisjbillington: 
chrisjbillington:     # The rest of these are boilerplate:
chrisjbillington:     def get_menu_class(self):
chrisjbillington:         return None
chrisjbillington:         
chrisjbillington:     def get_notification_classes(self):
chrisjbillington:         return []
chrisjbillington:         
chrisjbillington:     def get_setting_classes(self):
chrisjbillington:         return []
chrisjbillington:     
chrisjbillington:     def set_menu_instance(self, menu):
chrisjbillington:         self.menu = menu
chrisjbillington:         
chrisjbillington:     def set_notification_instances(self, notifications):
chrisjbillington:         self.notifications = notifications
chrisjbillington:         
             jan:     
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /plugins/general/__init__.py                                      #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
        pstarkey: 
        pstarkey: import os
        pstarkey: 
        pstarkey: from qtutils import UiLoader
chrisjbillington: from blacs.plugins import PLUGINS_DIR
chrisjbillington: 
        cbilling: class Plugin(object):
        cbilling:     def __init__(self, initial_settings):
        pstarkey:         self.menu = None
        pstarkey:         self.notifications = {}
        pstarkey:         self.BLACS = None
        pstarkey:         
        pstarkey:     def get_menu_class(self):
        pstarkey:         return None
        pstarkey:         
        pstarkey:     def get_notification_classes(self):
        pstarkey:         return []
        pstarkey:         
        pstarkey:     def get_setting_classes(self):
        pstarkey:         return [Setting]
        pstarkey:         
        pstarkey:     def get_callbacks(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def set_menu_instance(self,menu):
        pstarkey:         self.menu = menu
        pstarkey:         
        pstarkey:     def set_notification_instances(self,notifications):
        pstarkey:         self.notifications = notifications
        pstarkey: 
        pstarkey:     def plugin_setup_complete(self, BLACS):
        pstarkey:         self.BLACS = BLACS
        pstarkey:         
        pstarkey:     def get_save_data(self):
        pstarkey:         return {}
        pstarkey:         
        pstarkey:     def close(self):
        cbilling:         pass
        cbilling:         
        pstarkey: # class Menu(object):
        pstarkey:     # pass
        pstarkey:     
        pstarkey: # class Notification(object):
        pstarkey:     # pass
        pstarkey: 
        pstarkey: 
        pstarkey: class Setting(object):
        pstarkey:     name = "General"
        pstarkey: 
        pstarkey:     def __init__(self,data):
        pstarkey:         # This is our data store!
        pstarkey:         self.data = data
        pstarkey:         
        pstarkey:         self.var_list = [('ct_editor','','text','setText')]
        pstarkey:         for var in self.var_list:
        pstarkey:             if var[0] not in self.data:
        pstarkey:                 data[var[0]] = var[1]
        pstarkey:         
        pstarkey:     # Create the GTK page, return the page and an icon to use on the label (the class name attribute will be used for the label text)   
        pstarkey:     def create_dialog(self,notebook):
chrisjbillington:         ui = UiLoader().load(os.path.join(PLUGINS_DIR, 'general', 'general.ui'))
        pstarkey:         
        pstarkey:         # get the widgets!
        pstarkey:         self.widgets = {}
        pstarkey:         for var in self.var_list:            
        pstarkey:             self.widgets[var[0]] = getattr(ui,var[0])
        pstarkey:             getattr(self.widgets[var[0]],var[3])(self.data[var[0]])
        pstarkey:         
        pstarkey:         return ui,None
        pstarkey:     
        pstarkey:     def get_value(self,name):
        pstarkey:         if name in self.data:
        pstarkey:             return self.data[name]
        pstarkey:         
        pstarkey:         return None
        pstarkey:     
        pstarkey:     def save(self):
        pstarkey:         # transfer the contents of the list store into the data store, and then return the data store
        pstarkey:         for var in self.var_list:
        pstarkey:             # TODO: Make more general than forcing type to string
        pstarkey:             self.data[var[0]] = str(getattr(self.widgets[var[0]],var[2])())
        pstarkey:         
        pstarkey:         return self.data
        pstarkey:         
        pstarkey:     def close(self):
        pstarkey:         pass
        pstarkey:         
        cbilling:     
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /plugins/memory/__init__.py                                       #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
        pstarkey: 
chrisjbillington: import os
        pstarkey: import logging
        pstarkey: import gc
chrisjbillington: from blacs import BLACS_DIR
chrisjbillington: from labscript_utils import memprof, check_version
chrisjbillington: check_version('labscript_utils', '2.6.2', '3')
        pstarkey: 
        pstarkey: FILEPATH_COLUMN = 0
        pstarkey: name = "Memory Profile"
        pstarkey: module = "memory" # should be folder name
        pstarkey: logger = logging.getLogger('BLACS.plugin.%s'%module)
        pstarkey: 
        pstarkey: class Plugin(object):
        pstarkey:     def __init__(self,initial_settings):
        pstarkey:         self.menu = None
        pstarkey:         self.notifications = {}
        pstarkey:         self.initial_settings = initial_settings
        pstarkey:         self.BLACS = None
        pstarkey:         
        pstarkey:     def get_menu_class(self):
        pstarkey:         return Menu
        pstarkey:         
        pstarkey:     def get_notification_classes(self):
        pstarkey:         return []
        pstarkey:         
        pstarkey:     def get_setting_classes(self):
        pstarkey:         return []
        pstarkey:         
        pstarkey:     def get_callbacks(self):
        pstarkey:         {}
        pstarkey:         
        pstarkey:     def set_menu_instance(self,menu):
        pstarkey:         self.menu = menu
        pstarkey:         
        pstarkey:     def set_notification_instances(self,notifications):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     def plugin_setup_complete(self, BLACS):
        pstarkey:         self.BLACS = BLACS
        pstarkey:         
        pstarkey:     def get_save_data(self):
        pstarkey:         return {}
        pstarkey:     
        pstarkey:     def close(self):
        pstarkey:         pass
        pstarkey: 
        pstarkey: class Menu(object):
        pstarkey:     def __init__(self,BLACS):
        pstarkey:         self.BLACS = BLACS
        pstarkey:         self.close_notification_func = None
chrisjbillington:         memprof.start(filepath=os.path.join(BLACS_DIR, 'memprof.txt'))        
        pstarkey:         
        pstarkey:     def get_menu_items(self):
        pstarkey:         return {'name':name,        
        pstarkey:                 'menu_items':[{'name':'Garbage collect',
chrisjbillington:                                'action':gc.collect,
chrisjbillington:                                'icon': ':/qtutils/fugue/memory'
        pstarkey:                               },
        pstarkey:                               {'name':'Reset profiler',
chrisjbillington:                                'action':memprof.start,
chrisjbillington:                                'icon': ':/qtutils/fugue/counter-reset'
        pstarkey:                               },
        pstarkey:                               {'name':'Diff memory usage',
chrisjbillington:                                'action':memprof.check,
chrisjbillington:                                'icon': ':/qtutils/fugue/tables'
        pstarkey:                               }
        pstarkey:                              ]                                
        pstarkey:                }
chrisjbillington:     
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /plugins/theme/__init__.py                                        #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
        pstarkey: 
        pstarkey: import logging
        pstarkey: import os
        pstarkey: 
        pstarkey: from qtutils import *
        pstarkey: 
chrisjbillington: from blacs.plugins import PLUGINS_DIR
chrisjbillington: 
        pstarkey: name = "GUI Theme"
        pstarkey: module = "theme" # should be folder name
        pstarkey: logger = logging.getLogger('BLACS.plugin.%s'%module)
        pstarkey: 
           Chris: 
chrisjbillington: DEFAULT_STYLESHEET = """DigitalOutput {
           Chris:     font-size: 12px;
chrisjbillington:     background-color: rgb(50,100,50,255);
chrisjbillington:     border: 1px solid rgb(50,100,50,128);
           Chris:     border-radius: 3px;
           Chris:     padding: 2px;
chrisjbillington:     color: #202020;
           Chris: }
           Chris: 
           Chris: DigitalOutput:hover {
chrisjbillington:     background-color: rgb(50,130,50);
           Chris:     border: None;
           Chris: }
chrisjbillington: 
chrisjbillington: DigitalOutput:disabled{
chrisjbillington:    background-color: rgb(50,100,50,128);
chrisjbillington:    color: #505050;
chrisjbillington: }
chrisjbillington: 
           Chris: DigitalOutput:checked {
           Chris:     background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
chrisjbillington:                                       stop: 0 rgb(32,200,32), stop: 1 rgb(32,255,32));
           Chris:     border: 1px solid #8f8f91;
           Chris:     color: #000000;
           Chris: }
chrisjbillington: 
           Chris: DigitalOutput:hover:checked {
           Chris:     background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
chrisjbillington:                                       stop: 0 rgb(32,200,32), stop: 1 rgb(120,255,120));
           Chris:     border: 1px solid #8f8f91;
           Chris: }
chrisjbillington: 
chrisjbillington: DigitalOutput:checked:disabled{
chrisjbillington:    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
chrisjbillington:                                       stop: 0 rgba(32,200,32,128), stop: 1 rgba(32,255,32,128));
chrisjbillington:    color: #606060;
chrisjbillington: }
chrisjbillington: 
     janwerkmann: InvertedDigitalOutput {
     janwerkmann:     font-size: 12px;
chrisjbillington:     background-color: rgb(70,100,170,255);
chrisjbillington:     border: 1px solid rgb(70,100,170,128);
     janwerkmann:     border-radius: 3px;
     janwerkmann:     padding: 2px;
     janwerkmann:     color: #202020;
     janwerkmann: }
     janwerkmann: 
     janwerkmann: InvertedDigitalOutput:hover {
chrisjbillington:     background-color: rgb(70, 130, 220);
     janwerkmann:     border: None;
     janwerkmann: }
     janwerkmann: 
     janwerkmann: InvertedDigitalOutput:disabled{
chrisjbillington:    background-color: rgba(70,100,170,128);
     janwerkmann:    color: #505050;
     janwerkmann: }
     janwerkmann: 
     janwerkmann: InvertedDigitalOutput:checked {
     janwerkmann:     background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
chrisjbillington:                                       stop: 0 rgb(50,150,221), stop: 1 rgb(32,192,255));
     janwerkmann:     border: 1px solid #8f8f91;
     janwerkmann:     color: #000000;
     janwerkmann: }
     janwerkmann: 
     janwerkmann: InvertedDigitalOutput:hover:checked {
     janwerkmann:     background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
chrisjbillington:                                       stop: 0 rgb(50,150,221), stop: 1 rgb(120,192,255));
     janwerkmann:     border: 1px solid #8f8f91;
     janwerkmann: }
     janwerkmann: 
     janwerkmann: InvertedDigitalOutput:checked:disabled{
     janwerkmann:    background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
chrisjbillington:                                       stop: 0 rgba(50,150,221,128), stop: 1 rgba(32,192,255,128));
     janwerkmann:    color: #606060;
chrisjbillington: }
           Chris:  """
           Chris: 
           Chris: 
chrisjbillington: def is_default_stylesheet(stylesheet):
chrisjbillington:     """Return whether a stylesheet is the same as the default stylesheet, modulo whitespace"""
chrisjbillington: 
chrisjbillington:     def no_whitespace(s):
chrisjbillington:         return "".join(s.split())
chrisjbillington: 
chrisjbillington:     return no_whitespace(str(stylesheet)) == no_whitespace(DEFAULT_STYLESHEET) 
chrisjbillington: 
chrisjbillington: 
        pstarkey: class Plugin(object):
        pstarkey:     def __init__(self,initial_settings):
        pstarkey:         self.menu = None
        pstarkey:         self.notifications = {}
        pstarkey:         self.BLACS = None
        pstarkey:         self.initial_settings = initial_settings
        pstarkey:         
        pstarkey:     def get_menu_class(self):
        pstarkey:         return None
        pstarkey:         
        pstarkey:     def get_notification_classes(self):
        pstarkey:         return []
        pstarkey:         
        pstarkey:     def get_setting_classes(self):
        pstarkey:         return [Setting]
        pstarkey:         
        pstarkey:     def get_callbacks(self):
        pstarkey:         return {'settings_changed':self.update_stylesheet}
        pstarkey:         
        pstarkey:     def update_stylesheet(self):
chrisjbillington:         if self.BLACS is not None:
chrisjbillington:             # show centralwidget as a workaround to fix stylsheets
chrisjbillington:             # not beeing applied under PyQt5 on first draw
     janwerkmann:             self.BLACS['ui'].centralwidget.show()
        pstarkey:             stylesheet_settings = self.BLACS['settings'].get_value(Setting,"stylesheet")
           Chris:             self.BLACS['ui'].centralwidget.setStyleSheet(self.unmodified_stylesheet + stylesheet_settings)
        pstarkey:         
        pstarkey:     def set_menu_instance(self,menu):
        pstarkey:         self.menu = menu
        pstarkey:                 
        pstarkey:     def set_notification_instances(self,notifications):
        pstarkey:         self.notifications = notifications
        pstarkey:         
        pstarkey:     def plugin_setup_complete(self, BLACS):
        pstarkey:         self.BLACS = BLACS
           Chris:         self.unmodified_stylesheet = self.BLACS['ui'].centralwidget.styleSheet()
        pstarkey:         self.update_stylesheet()
        pstarkey:     
        pstarkey:     def get_save_data(self):
        pstarkey:         return {}
        pstarkey:     
        pstarkey:     def close(self):
        pstarkey:         pass
        pstarkey:         
        pstarkey:     
        pstarkey: class Setting(object):
        pstarkey:     name = name
        pstarkey: 
        pstarkey:     def __init__(self,data):
        pstarkey:         # This is our data store!
        pstarkey:         self.data = data
        pstarkey:         
chrisjbillington:         if 'stylesheet' not in self.data or not self.data['stylesheet']:
chrisjbillington:             # If it's absent or an empty string, use the default stylesheet:
           Chris:             self.data['stylesheet'] = DEFAULT_STYLESHEET
        pstarkey:     
        pstarkey:     def on_set_green_button_theme(self):
           Chris:         self.widgets['stylesheet'].appendPlainText(DEFAULT_STYLESHEET)
        pstarkey:         
        pstarkey:     # Create the page, return the page and an icon to use on the label (the class name attribute will be used for the label text)   
        pstarkey:     def create_dialog(self,notebook):
chrisjbillington:         ui = UiLoader().load(os.path.join(PLUGINS_DIR, module, 'theme.ui'))
        pstarkey:         
        pstarkey:         # restore current stylesheet
        pstarkey:         ui.stylesheet_text.setPlainText(self.data['stylesheet'])
        pstarkey:         ui.example_button.clicked.connect(self.on_set_green_button_theme)
        pstarkey:         
        pstarkey:         # save reference to widget
        pstarkey:         self.widgets = {}
        pstarkey:         self.widgets['stylesheet'] = ui.stylesheet_text
        pstarkey:         self.widgets['example_button'] = ui.example_button
        pstarkey:         
        pstarkey:         return ui,None
        pstarkey:     
        pstarkey:     def get_value(self,name):
        pstarkey:         if name in self.data:
        pstarkey:             return self.data[name]
        pstarkey:         
        pstarkey:         return None
        pstarkey:     
        pstarkey:     def save(self):
chrisjbillington:         stylesheet = str(self.widgets['stylesheet'].toPlainText())
chrisjbillington:         if not stylesheet.endswith('\n'):
chrisjbillington:             # This is a way to distinguish between an intentionally blank
chrisjbillington:             # stylesheet, and an empty string, which used to be what was
chrisjbillington:             # stored When the user had made no changes, which now we take to
chrisjbillington:             # imply that they want to use the default stylesheet:
chrisjbillington:             stylesheet += '\n'
chrisjbillington:         self.data['stylesheet'] = stylesheet
chrisjbillington:         data = self.data.copy()
chrisjbillington:         if is_default_stylesheet(stylesheet):
chrisjbillington:             # Only save if it is not the default stylesheet:
chrisjbillington:             del data['stylesheet']
chrisjbillington:         return data
        pstarkey:         
        pstarkey:     def close(self):
        pstarkey:         self.widgets['example_button'].clicked.disconnect(self.on_set_green_button_theme)
        pstarkey:         
        pstarkey:     
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /standalone_device.py                                             #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program BLACS, in the labscript suite    #
   pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   pstarkey: 
   pstarkey: import gtk
   pstarkey: import sys
   pstarkey: import socket
   pstarkey: from labscript_utils.labconfig import LabConfig
   pstarkey: # Connection Table Code
   pstarkey: from connections import ConnectionTable
   pstarkey: 
   pstarkey: from hardware_interfaces import *
   pstarkey: for device in device_list:    
   pstarkey:     exec("from hardware_interfaces."+device+" import "+device)
   pstarkey:     
   pstarkey:     
   pstarkey: if __name__ == "__main__":
   pstarkey:     gtk.gdk.threads_init()
   pstarkey:     
   pstarkey:     # Load the experiment config file, and verify that the necessary parameters are there"
   pstarkey:     config_path = r'C:\labconfig\\'+socket.gethostname()+r'.ini'
   pstarkey:     settings_path = r'C:\labconfig\\'+socket.gethostname()+r'_BLACS.h5'
   pstarkey:     required_config_params = {"DEFAULT":["experiment_name"],
   pstarkey:                               "programs":["text_editor",
   pstarkey:                                           "text_editor_arguments",
   pstarkey:                                          ],
   pstarkey:                               "paths":["shared_drive",
   pstarkey:                                        "connection_table_h5",
   pstarkey:                                        "connection_table_py",                                       
   pstarkey:                                       ],
   pstarkey:                               "ports":["BLACS"],
   pstarkey:                              }
   pstarkey:     exp_config = LabConfig(config_path,required_config_params)    
   pstarkey:     
   pstarkey:     #
   pstarkey:     # Load Connection Table
   pstarkey:     #
   pstarkey:     # Get file paths (used for file watching later)           
   pstarkey:     connection_table_h5file = exp_config.get('paths','connection_table_h5')
   pstarkey:     connection_table_labscript = exp_config.get('paths','connection_table_py')
   pstarkey:     
   pstarkey:     # Create Connection Table object
   pstarkey:     try:
   pstarkey:         connection_table = ConnectionTable(connection_table_h5file)
   pstarkey:     except Exception as e:
janwerkmann:         print(e)
   pstarkey:         dialog = gtk.MessageDialog(None,gtk.DIALOG_MODAL,gtk.MESSAGE_ERROR,gtk.BUTTONS_NONE,"The connection table in '%s' is not valid. Please check the compilation of the connection table for errors\n\n"%connection_table_h5file)
   pstarkey:              
   pstarkey:         dialog.run()
   pstarkey:         dialog.destroy()
   pstarkey:         sys.exit("Invalid Connection Table")
   pstarkey:         
   pstarkey:     
   pstarkey:     window = gtk.Window()
   pstarkey:     notebook = gtk.Notebook()
   pstarkey:     window.add(notebook)
   pstarkey:     
   pstarkey:     ni_card = ni_pci_6733(object,notebook,{"device_name":"ni_pci_6733_0", "connection_table":connection_table})
   pstarkey:     
   pstarkey:     notebook.show()
   pstarkey:     window.show()
   pstarkey:     
   pstarkey:     with gtk.gdk.lock:
janwerkmann:         gtk.main()
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /tab_base_classes.py                                              #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program BLACS, in the labscript suite    #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann:     import Queue as queue
             jan:     import cPickle as pickle
     janwerkmann: else:
     janwerkmann:     import queue
             jan:     import pickle
        pstarkey: 
        pstarkey: from zprocess import Process
        pstarkey: import time
        pstarkey: import sys
        pstarkey: import threading
        pstarkey: import traceback
        pstarkey: import logging
        pstarkey: import cgi
        pstarkey: import os
        pstarkey: from types import GeneratorType
        pstarkey: 
     janwerkmann: # import labscript_utils.excepthook
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
        pstarkey: 
        pstarkey: from qtutils import *
chrisjbillington: from qtutils.outputbox import OutputBox
chrisjbillington: import qtutils.icons
chrisjbillington: 
chrisjbillington: from labscript_utils.qtwidgets.elide_label import elide_label
chrisjbillington: from blacs import BLACS_DIR
chrisjbillington: 
        pstarkey: class Counter(object):
        pstarkey:     """A class with a single method that 
        pstarkey:     returns a different integer each time it's called."""
        pstarkey:     def __init__(self):
        pstarkey:         self.i = 0
        pstarkey:     def get(self):
        pstarkey:         self.i += 1
        pstarkey:         return self.i
        pstarkey:         
        pstarkey:         
        pstarkey: MODE_MANUAL = 1
        pstarkey: MODE_TRANSITION_TO_BUFFERED = 2
        pstarkey: MODE_TRANSITION_TO_MANUAL = 4
        pstarkey: MODE_BUFFERED = 8  
        pstarkey:             
        pstarkey: class StateQueue(object):
        pstarkey:     # NOTE:
        pstarkey:     #
        pstarkey:     # It is theoretically possible to remove the dependency on the Qt Mainloop (remove inmain decorators and fnuction calls)
        pstarkey:     # by introducing a local lock object instead. However, be aware that right now, the Qt inmain lock is preventing the 
        pstarkey:     # statemachine loop (Tab.mainloop) from getting any states uot of the queue until after the entire tab is initialised 
        pstarkey:     # and the Qt mainloop starts.
        pstarkey:     #
        pstarkey:     # This is particularly important because we exploit this behaviour to make sure that Tab._initialise_worker is placed at the
        pstarkey:     # start of the StateQueue, and so the Tab.mainloop method is guaranteed to get this initialisation method as the first state 
        pstarkey:     # regardless of whether the mainloop is started before the state is inserted (the state should always be inserted as part of  
        pstarkey:     # the call to Tab.create_worker, in DeviceTab.initialise_workers in DeviceTab.__init__ )
        pstarkey:     #
        pstarkey:     
        pstarkey:     def __init__(self,device_name):
        pstarkey:         self.logger = logging.getLogger('BLACS.%s.state_queue'%(device_name))
        pstarkey:         self.logging_enabled = False
        pstarkey:         if self.logging_enabled:
        pstarkey:             self.logger.debug("started")
        pstarkey:         
        pstarkey:         self.list_of_states = []
        pstarkey:         self._last_requested_state = None
        pstarkey:         # A queue that blocks the get(requested_state) method until an entry in the queue has a state that matches the requested_state
     janwerkmann:         self.get_blocking_queue = queue.Queue()
     janwerkmann: 
        pstarkey:     @property
        pstarkey:     @inmain_decorator(True)    
        pstarkey:     # This is always done in main so that we avoid a race condition between the get method and
        pstarkey:     # the put method accessing this property
        pstarkey:     def last_requested_state(self):
        pstarkey:         return self._last_requested_state
        pstarkey:     
        pstarkey:     @last_requested_state.setter
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def last_requested_state(self, value):
        pstarkey:         self._last_requested_state = value
        pstarkey:      
        pstarkey:     def log_current_states(self):
        pstarkey:         if self.logging_enabled:
        pstarkey:             self.logger.debug('Current items in the state queue: %s'%str(self.list_of_states))
        pstarkey:      
        pstarkey:     # this should only happen in the main thread, as my implementation is not thread safe!
        pstarkey:     @inmain_decorator(True)   
        pstarkey:     def put(self,allowed_states,queue_state_indefinitely,delete_stale_states,data,prepend=False):
        pstarkey:         if prepend:
        pstarkey:             self.list_of_states.insert(0,[allowed_states,queue_state_indefinitely,delete_stale_states,data]) 
        pstarkey:         else:
        pstarkey:             self.list_of_states.append([allowed_states,queue_state_indefinitely,delete_stale_states,data]) 
        pstarkey:         # if this state is one the get command is waiting for, notify it!
        pstarkey:         if self.last_requested_state is not None and allowed_states&self.last_requested_state:
        pstarkey:             self.get_blocking_queue.put('new item')
        pstarkey:         
        pstarkey:         if self.logging_enabled:
        pstarkey:             if not isinstance(data[0],str):
        pstarkey:                 self.logger.debug('New state queued up. Allowed modes: %d, queue state indefinitely: %s, delete stale states: %s, function: %s'%(allowed_states,str(queue_state_indefinitely),str(delete_stale_states),data[0].__name__))
        pstarkey:         self.log_current_states()
        pstarkey:     
        pstarkey:     # this should only happen in the main thread, as my implementation is not thread safe!
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def check_for_next_item(self,state):
        pstarkey:         # We reset the queue here, as we are about to traverse the tree, which contains any new items that
        pstarkey:         # are described in messages in this queue, so let's not keep those messages around anymore.
        pstarkey:         # Put another way, we want to block until a new item is added, if we don't find an item in this function
        pstarkey:         # So it's best if the queue is empty now!
        pstarkey:         if self.logging_enabled:
        pstarkey:             self.logger.debug('Re-initialsing self._get_blocking_queue')
     janwerkmann:         self.get_blocking_queue = queue.Queue()
     janwerkmann: 
        pstarkey:         # traverse the list
        pstarkey:         delete_index_list = []
        pstarkey:         success = False
        pstarkey:         for i,item in enumerate(self.list_of_states):
        pstarkey:             allowed_states,queue_state_indefinitely,delete_stale_states,data = item
        pstarkey:             if self.logging_enabled:
        pstarkey:                 self.logger.debug('iterating over states in queue')
        pstarkey:             if allowed_states&state:
        pstarkey:                 # We have found one! Remove it from the list
        pstarkey:                 delete_index_list.append(i)
        pstarkey:                 
        pstarkey:                 if self.logging_enabled:
        pstarkey:                     self.logger.debug('requested state found in queue')
        pstarkey:                 
        pstarkey:                 # If we are to delete stale states, see if the next state is the same statefunction.
        pstarkey:                 # If it is, use that one, or whichever is the latest entry without encountering a different statefunction,
        pstarkey:                 # and delete the rest
        pstarkey:                 if delete_stale_states:
        pstarkey:                     state_function = data[0]
        pstarkey:                     i+=1
        pstarkey:                     while i < len(self.list_of_states) and state_function == self.list_of_states[i][3][0]:
        pstarkey:                         if self.logging_enabled:
        pstarkey:                             self.logger.debug('requesting deletion of stale state')
        pstarkey:                         allowed_states,queue_state_indefinitely,delete_stale_states,data = self.list_of_states[i]
        pstarkey:                         delete_index_list.append(i)
        pstarkey:                         i+=1
        pstarkey:                 
        pstarkey:                 success = True
        pstarkey:                 break
        pstarkey:             elif not queue_state_indefinitely:
        pstarkey:                 if self.logging_enabled:
        pstarkey:                     self.logger.debug('state should not be queued indefinitely')
        pstarkey:                 delete_index_list.append(i)
        pstarkey:         
        pstarkey:         # do this in reverse order so that the first delete operation doesn't mess up the indices of subsequent ones
        pstarkey:         for index in reversed(sorted(delete_index_list)):
        pstarkey:             if self.logging_enabled:
        pstarkey:                 self.logger.debug('deleting state')
        pstarkey:             del self.list_of_states[index]
        pstarkey:             
        pstarkey:         if not success:
        pstarkey:             data = None
        pstarkey:         return success,data    
        pstarkey:         
        pstarkey:     # this method should not be called in the main thread, because it will block until something is found...
        pstarkey:     # Please, only have one thread ever accessing this...I have no idea how it will behave if multiple threads are trying to get
        pstarkey:     # items from the queue...
        pstarkey:     #
        pstarkey:     # This method will block until a item found in the queue is found to be allowed during the specified 'state'.
        pstarkey:     def get(self,state):
        pstarkey:         if self.last_requested_state:
        pstarkey:             raise Exception('You have multiple threads trying to get from this queue at the same time. I won\'t allow it!')
        pstarkey:     
        pstarkey:         self.last_requested_state = state
        pstarkey:         while True:
        pstarkey:             if self.logging_enabled:
        pstarkey:                 self.logger.debug('requesting next item in queue with mode %d'%state)
        pstarkey:                 inmain(self.log_current_states)
        pstarkey:             status,data = self.check_for_next_item(state)
        pstarkey:             if not status:
        pstarkey:                 # we didn't find anything useful, so we'll wait until a useful state is added!
        pstarkey:                 self.get_blocking_queue.get()
        pstarkey:             else:
        pstarkey:                 self.last_requested_state = None
        pstarkey:                 return data
        pstarkey:                 
        pstarkey:                     
        pstarkey:         
        pstarkey: # Make this function available globally:       
        pstarkey: get_unique_id = Counter().get
        pstarkey: 
        pstarkey: def define_state(allowed_modes,queue_state_indefinitely,delete_stale_states=False):
        pstarkey:     def wrap(function):
     janwerkmann:         if PY2:
     janwerkmann:             unescaped_name = function.__name__
     janwerkmann:             escapedname = b'_' + function.__name__
     janwerkmann:         else:
     janwerkmann:             unescaped_name = function.__name__
     janwerkmann:             escapedname = '_' + function.__name__
        pstarkey:         if allowed_modes < 1 or allowed_modes > 15:
        pstarkey:             raise RuntimeError('Function %s has been set to run in unknown states. Please make sure allowed states is one or more of MODE_MANUAL,'%unescaped_name+
        pstarkey:             'MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL and MODE_BUFFERED (or-ed together using the | symbol, eg MODE_MANUAL|MODE_BUFFERED')
        pstarkey:         def f(self,*args,**kwargs):
        pstarkey:             function.__name__ = escapedname
        pstarkey:             #setattr(self,escapedname,function)
        pstarkey:             self.event_queue.put(allowed_modes,queue_state_indefinitely,delete_stale_states,[function,[args,kwargs]])
        pstarkey:         f.__name__ = unescaped_name
        pstarkey:         f._allowed_modes = allowed_modes
        pstarkey:         return f        
        pstarkey:     return wrap
        pstarkey:     
        pstarkey:         
        pstarkey: class Tab(object):
chrisjbillington: 
chrisjbillington:     ICON_OK = ':/qtutils/fugue/tick'
chrisjbillington:     ICON_BUSY = ':/qtutils/fugue/hourglass'
chrisjbillington:     ICON_ERROR = ':/qtutils/fugue/exclamation'
chrisjbillington:     ICON_FATAL_ERROR = ':/qtutils/fugue/exclamation-red'
chrisjbillington: 
        pstarkey:     def __init__(self,notebook,settings,restart=False):  
        pstarkey:         # Store important parameters
        pstarkey:         self.notebook = notebook
        pstarkey:         self.settings = settings
        pstarkey:         self._device_name = self.settings["device_name"]
        pstarkey:         
        pstarkey:         # Setup logging
        pstarkey:         self.logger = logging.getLogger('BLACS.%s'%(self.device_name))   
        pstarkey:         self.logger.debug('Started')          
        pstarkey:         
        pstarkey:         # Setup the timer for updating that tab text label when the tab is not 
        pstarkey:         # actively part of a notebook
           Chris:         self._tab_icon_and_colour_timer = QTimer()
chrisjbillington:         self._tab_icon_and_colour_timer.timeout.connect(self.set_tab_icon_and_colour)
chrisjbillington:         self._tab_icon = self.ICON_OK
           Chris:         self._tab_text_colour = 'black'
           Chris: 
        pstarkey:         # Create instance variables
        pstarkey:         self._not_responding_error_message = ''
        pstarkey:         self._error = ''
        pstarkey:         self._state = ''
        pstarkey:         self._time_of_last_state_change = time.time()
        pstarkey:         self.not_responding_for = 0
        pstarkey:         self.hide_not_responding_error_until = 0
        pstarkey:         self._timeouts = set()
        pstarkey:         self._timeout_ids = {}
        pstarkey:         self._force_full_buffered_reprogram = True
        pstarkey:         self.event_queue = StateQueue(self.device_name)
        pstarkey:         self.workers = {}
        pstarkey:         self._supports_smart_programming = False
        pstarkey:         self._restart_receiver = []
        pstarkey:         
        pstarkey:         # Load the UI
chrisjbillington:         self._ui = UiLoader().load(os.path.join(BLACS_DIR, 'tab_frame.ui'))
        pstarkey:         self._layout = self._ui.device_layout
        pstarkey:         self._device_widget = self._ui.device_controls
        pstarkey:         self._changed_widget = self._ui.changed_widget
        pstarkey:         self._changed_layout = self._ui.changed_layout
        pstarkey:         self._changed_widget.hide()        
        pstarkey:         self.BLACS_connection = self.settings['connection_table'].find_by_name(self.device_name).BLACS_connection
chrisjbillington:         self._ui.device_name.setText("<b>%s</b> [conn: %s]"%(str(self.device_name),str(self.BLACS_connection)))
chrisjbillington:         elide_label(self._ui.device_name, self._ui.horizontalLayout, Qt.ElideRight)
chrisjbillington:         elide_label(self._ui.state_label, self._ui.state_label_layout, Qt.ElideRight)
chrisjbillington: 
chrisjbillington:         # Insert an OutputBox into the splitter, initially hidden:
chrisjbillington:         self._output_box = OutputBox(self._ui.splitter)
chrisjbillington:         self._ui.splitter.setCollapsible(self._ui.splitter.count() - 2, True)
chrisjbillington:         self._output_box.output_textedit.hide()
chrisjbillington: 
        pstarkey:         # connect signals
           Chris:         self._ui.button_clear_smart_programming.clicked.connect(self.on_force_full_buffered_reprogram)
           Chris:         self._ui.button_clear_smart_programming.setEnabled(False)
        pstarkey:         self.force_full_buffered_reprogram = True
chrisjbillington:         self._ui.button_show_terminal.toggled.connect(self.set_terminal_visible)
        pstarkey:         self._ui.button_close.clicked.connect(self.hide_error)
        pstarkey:         self._ui.button_restart.clicked.connect(self.restart)        
chrisjbillington:         self._update_error_and_tab_icon()
        pstarkey:         self.supports_smart_programming(False)
        pstarkey:         
chrisjbillington:         # Restore settings:
chrisjbillington:         self.restore_builtin_save_data(self.settings.get('saved_data', {}))
chrisjbillington: 
        pstarkey:         # This should be done beofre the main_loop starts or else there is a race condition as to whether the 
        pstarkey:         # self._mode variable is even defined!
        pstarkey:         # However it must be done after the UI is created!
        pstarkey:         self.mode = MODE_MANUAL
        pstarkey:         self.state = 'idle'
        pstarkey:         
        pstarkey:         # Setup the not responding timeout
        pstarkey:         self._timeout = QTimer()
        pstarkey:         self._timeout.timeout.connect(self.check_time)
        pstarkey:         self._timeout.start(1000)
        pstarkey:                 
        pstarkey:         # Launch the mainloop
        pstarkey:         self._mainloop_thread = threading.Thread(target = self.mainloop)
        pstarkey:         self._mainloop_thread.daemon = True
        pstarkey:         self._mainloop_thread.start()
        pstarkey:                 
        pstarkey:         # Add the tab to the notebook
        pstarkey:         self.notebook.addTab(self._ui,self.device_name)
        pstarkey:         self._ui.show()
        pstarkey:     
chrisjbillington:     def get_builtin_save_data(self):
chrisjbillington:         """Get builtin settings to be restored like whether the terminal is
chrisjbillington:         visible. Not to be overridden."""
chrisjbillington:         return {'_terminal_visible': self._ui.button_show_terminal.isChecked(),
chrisjbillington:                 '_splitter_sizes': self._ui.splitter.sizes()}
chrisjbillington: 
chrisjbillington:     def restore_builtin_save_data(self, data):
chrisjbillington:         """Restore builtin settings to be restored like whether the terminal is
chrisjbillington:         visible. Not to be overridden."""
chrisjbillington:         self.set_terminal_visible(data.get('_terminal_visible', False))
chrisjbillington:         if '_splitter_sizes' in data:
chrisjbillington:             self._ui.splitter.setSizes(data['_splitter_sizes'])
chrisjbillington: 
chrisjbillington:     def update_from_settings(self, settings):
chrisjbillington:         self.restore_builtin_save_data(settings['saved_data'])
chrisjbillington: 
        pstarkey:     def supports_smart_programming(self,support):
        pstarkey:         self._supports_smart_programming = bool(support)
        pstarkey:         if self._supports_smart_programming:
           Chris:             self._ui.button_clear_smart_programming.show()
        pstarkey:         else:
           Chris:             self._ui.button_clear_smart_programming.hide()
        pstarkey:     
           Chris:     def on_force_full_buffered_reprogram(self):
           Chris:         self.force_full_buffered_reprogram = True
           Chris: 
        pstarkey:     @property
        pstarkey:     def force_full_buffered_reprogram(self):
        pstarkey:         return self._force_full_buffered_reprogram
        pstarkey:         
        pstarkey:     @force_full_buffered_reprogram.setter
        pstarkey:     def force_full_buffered_reprogram(self,value):
        pstarkey:         self._force_full_buffered_reprogram = bool(value)
           Chris:         self._ui.button_clear_smart_programming.setEnabled(not bool(value))
        pstarkey:     
        pstarkey:     @property
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def error_message(self):
        pstarkey:         return self._error
        pstarkey:     
        pstarkey:     @error_message.setter
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def error_message(self,message):
        pstarkey:         #print message
        pstarkey:         #print self._error
        pstarkey:         if message != self._error:
        pstarkey:             self._error = message
chrisjbillington:             self._update_error_and_tab_icon()
        pstarkey:     
        pstarkey:     @inmain_decorator(True)
chrisjbillington:     def _update_error_and_tab_icon(self):
chrisjbillington:         """Udate and show the error message for the tab, and update the icon
chrisjbillington:         and text colour on the tab"""
        pstarkey:         prefix = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">\n<html><head><meta name="qrichtext" content="1" /><style type="text/css">\np, li { white-space: pre-wrap; }\n</style></head><body style=" font-family:"MS Shell Dlg 2"; font-size:7.8pt; font-weight:400; font-style:normal;">'
        pstarkey:         suffix = '</body></html>'
        pstarkey:         #print threading.current_thread().name
        pstarkey:         self._ui.error_message.setHtml(prefix+self._not_responding_error_message+self._error+suffix)
        pstarkey:         if self._error or self._not_responding_error_message:
        pstarkey:             self._ui.notresponding.show()
           Chris:             self._tab_text_colour = 'red'
chrisjbillington:             if self.error_message:
chrisjbillington:                 if self.state == 'fatal error':
chrisjbillington:                     self._tab_icon = self.ICON_FATAL_ERROR
chrisjbillington:                 else: 
chrisjbillington:                     self._tab_icon = self.ICON_ERROR
        pstarkey:         else:
        pstarkey:             self._ui.notresponding.hide()
           Chris:             self._tab_text_colour = 'black'
chrisjbillington:             if self.state == 'idle':
chrisjbillington:                 self._tab_icon = self.ICON_OK
chrisjbillington:             else:
chrisjbillington:                 self._tab_icon = self.ICON_BUSY
chrisjbillington:         self.set_tab_icon_and_colour()
        pstarkey:     
        pstarkey:     @inmain_decorator(True)
chrisjbillington:     def set_tab_icon_and_colour(self):
chrisjbillington:         """Set the tab icon and the colour of its text to the values of
chrisjbillington:         self._tab_icon and self._tab_text_colour respectively"""
chrisjbillington:         if self._ui.parentWidget() is None:
chrisjbillington:             return
chrisjbillington:         self.notebook = self._ui.parentWidget().parentWidget()
chrisjbillington:         currentpage = None
chrisjbillington:         if self.notebook is not None:
chrisjbillington:             #currentpage = self.notebook.get_current_page()
chrisjbillington:             currentpage = self.notebook.indexOf(self._ui)
chrisjbillington:         if self.notebook is not None and currentpage != -1:
chrisjbillington:             icon = QIcon(self._tab_icon)
chrisjbillington:             self.notebook.tabBar().setTabIcon(currentpage, icon)
chrisjbillington:             self.notebook.tabBar().setTabTextColor(currentpage, QColor(self._tab_text_colour))
chrisjbillington:             self._tab_icon_and_colour_timer.stop()
chrisjbillington:         elif not self._tab_icon_and_colour_timer.isActive():
chrisjbillington:             self._tab_icon_and_colour_timer.start(100)
        pstarkey:     
        pstarkey:     def get_tab_layout(self):
        pstarkey:         return self._layout
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def device_name(self):
        pstarkey:         return self._device_name
        pstarkey:     
        pstarkey:     # sets the mode, switches between MANUAL, BUFFERED, TRANSITION_TO_BUFFERED and TRANSITION_TO_STATIC
        pstarkey:     @property
        pstarkey:     def mode(self):
        pstarkey:         return self._mode
        pstarkey:     
        pstarkey:     @mode.setter
        pstarkey:     def mode(self,mode):
        pstarkey:         self._mode = mode
        pstarkey:         self._update_state_label()
        pstarkey:         
        pstarkey:     @property
        pstarkey:     def state(self):
        pstarkey:         return self._state
        pstarkey:         
        pstarkey:     @state.setter
        pstarkey:     def state(self,state):
        pstarkey:         self._state = state        
        pstarkey:         self._time_of_last_state_change = time.time()
        pstarkey:         self._update_state_label()
chrisjbillington:         self._update_error_and_tab_icon()
        pstarkey:     
        pstarkey:     @inmain_decorator(True)
        pstarkey:     def _update_state_label(self):
        pstarkey:         if self.mode == 1:
        pstarkey:             mode = 'Manual'
        pstarkey:         elif self.mode == 2:
        pstarkey:             mode = 'Transitioning to buffered'
        pstarkey:         elif self.mode == 4:
        pstarkey:             mode = 'Transitioning to manual'
        pstarkey:         elif self.mode == 8:
        pstarkey:             mode = 'Buffered'
        pstarkey:         else:
        pstarkey:             raise RuntimeError('self.mode for device %s is invalid. It must be one of MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL or MODE_BUFFERED'%(self.device_name))
        pstarkey:     
        pstarkey:         self._ui.state_label.setText('<b>%s mode</b> - State: %s'%(mode,self.state))
        pstarkey:         
        pstarkey:         # Todo: Update icon in tab
        pstarkey:     
        pstarkey:     def create_worker(self,name,WorkerClass,workerargs={}):
        pstarkey:         if name in self.workers:
        pstarkey:             raise Exception('There is already a worker process with name: %s'%name) 
        pstarkey:         if name == 'GUI':
        pstarkey:             # This is here so that we can display "(GUI)" in the status bar and have the user confident this is actually happening in the GUI,
        pstarkey:             # not in a worker process named GUI
        pstarkey:             raise Exception('You cannot call a worker process "GUI". Why would you want to? Your worker process cannot interact with the BLACS GUI directly, so you are just trying to confuse yourself!')
        pstarkey:         
chrisjbillington:         worker = WorkerClass(output_redirection_port=self._output_box.port)
        pstarkey:         to_worker, from_worker = worker.start(name, self.device_name, workerargs)
        pstarkey:         self.workers[name] = (worker,to_worker,from_worker)
        pstarkey:         self.event_queue.put(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True,False,[Tab._initialise_worker,[(name,),{}]],prepend=True)
        pstarkey:        
        pstarkey:     def _initialise_worker(self, worker_name):
        pstarkey:         yield(self.queue_work(worker_name,'init'))
        pstarkey:                 
        pstarkey:         if self.error_message:
        pstarkey:             raise Exception('Device failed to initialise')
        pstarkey:                
        pstarkey:     @define_state(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True)  
        pstarkey:     def _timeout_add(self,delay,execute_timeout):
        pstarkey:         QTimer.singleShot(delay,execute_timeout)
        pstarkey:     
        pstarkey:     def statemachine_timeout_add(self,delay,statefunction,*args,**kwargs):
        pstarkey:         # Add the timeout to our set of registered timeouts. Timeouts
        pstarkey:         # can thus be removed by the user at ay time by calling
        pstarkey:         # self.timeouts.remove(function)
        pstarkey:         self._timeouts.add(statefunction)
        pstarkey:         # Here's a function which executes the timeout once, then queues
        pstarkey:         # itself up again after a delay:
        pstarkey:         def execute_timeout():
        pstarkey:             # queue up the state function, but only if it hasn't been
        pstarkey:             # removed from self.timeouts:
        pstarkey:             if statefunction in self._timeouts and self._timeout_ids[statefunction] == unique_id:
        pstarkey:                 # Only queue up the state if we are in an allowed mode
        pstarkey:                 if statefunction._allowed_modes&self.mode:
        pstarkey:                     statefunction(*args, **kwargs)
        pstarkey:                 # queue up another call to this function (execute_timeout)
        pstarkey:                 # after the delay time:
        pstarkey:                 self._timeout_add(delay,execute_timeout)
        pstarkey:             
        pstarkey:         # Store a unique ID for this timeout so that we don't confuse 
        pstarkey:         # other timeouts for this one when checking to see that this
        pstarkey:         # timeout hasn't been removed:
        pstarkey:         unique_id = get_unique_id()
        pstarkey:         self._timeout_ids[statefunction] = unique_id
        pstarkey:         # queue the first run:
        pstarkey:         #QTimer.singleShot(delay,execute_timeout)    
        pstarkey:         execute_timeout()
        pstarkey:         
        pstarkey:     # Returns True if the timeout was removed
        pstarkey:     def statemachine_timeout_remove(self,statefunction):
        pstarkey:         if statefunction in self._timeouts:
        pstarkey:             self._timeouts.remove(statefunction)
        pstarkey:             return True
        pstarkey:         return False
        pstarkey:     
        pstarkey:     # returns True if at least one timeout was removed, else returns False
        pstarkey:     def statemachine_timeout_remove_all(self):
        pstarkey:         # As a consistency check, we overwrite self._timeouts to an empty set always
        pstarkey:         # This must be done after the check to see if it is empty (if self._timeouts) so do not refactor this code!
        pstarkey:         if self._timeouts:
        pstarkey:             self._timeouts = set()
        pstarkey:             return True
        pstarkey:         else:
        pstarkey:             self._timeouts = set()
        pstarkey:             return False        
        pstarkey:     
        pstarkey:     # def set_state(self,state):
        pstarkey:         # ready = self.tab_label_widgets['ready']
        pstarkey:         # working = self.tab_label_widgets['working']
        pstarkey:         # error = self.tab_label_widgets['error']
        pstarkey:         # self.logger.info('State changed to %s'% state)
        pstarkey:         # self.state = state
        pstarkey:         # if state == 'idle':
        pstarkey:             # working.hide()
        pstarkey:             # if self.error:
        pstarkey:                 # error.show()
        pstarkey:             # else:
        pstarkey:                 # ready.show()
        pstarkey:                 # error.hide()
        pstarkey:         # elif state == 'fatal error':
        pstarkey:             # working.hide()
        pstarkey:             # error.show()
        pstarkey:             # ready.hide()
        pstarkey:         # else:
        pstarkey:             # ready.hide()
        pstarkey:             # working.show()
        pstarkey:         # self._time_of_last_state_change = time.time()
        pstarkey:         # self.statusbar.push(self.context_id, state)
        pstarkey:     
        pstarkey:     def close_tab(self,*args):
        pstarkey:         self.logger.info('close_tab called')
        pstarkey:         self._timeout.stop()
           Chris:         self._tab_icon_and_colour_timer.stop()
        pstarkey:         for name,worker_data in self.workers.items():            
        pstarkey:             worker_data[0].terminate()
        pstarkey:             # The mainloop is blocking waiting for something out of the
        pstarkey:             # from_worker queue or the event_queue. Closing the queues doesn't
        pstarkey:             # seem to raise an EOF for them, likely because it only closes
        pstarkey:             # them from our end, and an EOFError would only be raised if it
        pstarkey:             # was closed from the other end, which we can't make happen. But
        pstarkey:             # we can instruct it to quit by telling it to do so through the
        pstarkey:             # queue itself. That way we don't leave extra threads running
        pstarkey:             # (albeit doing nothing) that we don't need:
        pstarkey:             if self._mainloop_thread.is_alive():
        pstarkey:                 worker_data[2].put((False,'quit',None))
        pstarkey:                 self.event_queue.put(MODE_MANUAL|MODE_BUFFERED|MODE_TRANSITION_TO_BUFFERED|MODE_TRANSITION_TO_MANUAL,True,False,['_quit',None],prepend=True)
        pstarkey:         self.notebook = self._ui.parentWidget().parentWidget()
        pstarkey:         currentpage = None
        pstarkey:         if self.notebook:
        pstarkey:             #currentpage = self.notebook.get_current_page()
        pstarkey:             currentpage = self.notebook.indexOf(self._ui)
          philip:             self.notebook.removeTab(currentpage)
          philip:             temp_widget = QWidget()
          philip:             self.notebook.insertTab(currentpage, temp_widget, self.device_name)
          philip:             self.notebook.setCurrentWidget(temp_widget)  
        pstarkey:         return currentpage
        pstarkey:     
        pstarkey:     def connect_restart_receiver(self,function):
        pstarkey:         if function not in self._restart_receiver:
        pstarkey:             self._restart_receiver.append(function)
        pstarkey:             
        pstarkey:     def disconnect_restart_receiver(self,function):
        pstarkey:         if function in self._restart_receiver:
        pstarkey:             self._restart_receiver.remove(function)
        pstarkey:     
        pstarkey:     def restart(self,*args):
        pstarkey:         # notify all connected receivers:
        pstarkey:         for f in self._restart_receiver:
        pstarkey:             try:
        pstarkey:                 f(self.device_name)
        pstarkey:             except:
        pstarkey:                 self.logger.exception('Could not notify a connected receiver function')
        pstarkey:                 
        pstarkey:         currentpage = self.close_tab()
        pstarkey:         self.logger.info('***RESTART***')
        pstarkey:         self.settings['saved_data'] = self.get_save_data()
          philip:         self._restart_thread = inthread(self.wait_for_mainloop_to_stop, currentpage)
        pstarkey:         
        pstarkey:     def wait_for_mainloop_to_stop(self, currentpage):
        pstarkey:         self._mainloop_thread.join()
          philip:         inmain(self.clean_ui_on_restart)
        pstarkey:         inmain(self.finalise_restart, currentpage)
        pstarkey:         
          philip:     def clean_ui_on_restart(self):
        pstarkey:         # Clean up UI
        pstarkey:         ui = self._ui
        pstarkey:         self._ui = None
        pstarkey:         ui.setParent(None)
          philip:         ui.deleteLater()
        pstarkey:         del ui
        pstarkey:         
          philip:     def finalise_restart(self, currentpage):
          philip:         widget = self.notebook.widget(currentpage)
          philip:         widget.setParent(None)
          philip:         widget.deleteLater()
          philip:         del widget
          philip:     
        pstarkey:         # Note: the following function call will break if the user hasn't
        pstarkey:         # overridden the __init__ function to take these arguments. So
        pstarkey:         # make sure you do that!
        pstarkey:         self.__init__(self.notebook, self.settings,restart=True)
        pstarkey:         
        pstarkey:         # The init method is going to place this device tab at the end of the notebook specified
        pstarkey:         # Let's remove it from there, and place it the poition it used to be!
        pstarkey:         self.notebook = self._ui.parentWidget().parentWidget()
        pstarkey:         self.notebook.removeTab(self.notebook.indexOf(self._ui))
        pstarkey:         self.notebook.insertTab(currentpage,self._ui,self.device_name)
        pstarkey:         self.notebook.setCurrentWidget(self._ui)
        pstarkey:             
        pstarkey:         # If BLACS is waiting on this tab for something, tell it to abort!
        pstarkey:         # self.BLACS.current_queue.put('abort')
        pstarkey:     
        pstarkey:     def queue_work(self,worker_process,worker_function,*args,**kwargs):
        pstarkey:         return worker_process,worker_function,args,kwargs
chrisjbillington:         
chrisjbillington:     def set_terminal_visible(self, visible):
chrisjbillington:         if visible:
chrisjbillington:             self._output_box.output_textedit.show()
chrisjbillington:         else:
chrisjbillington:             self._output_box.output_textedit.hide()
chrisjbillington:         self._ui.button_show_terminal.setChecked(visible)
chrisjbillington: 
        pstarkey:     def hide_error(self):
        pstarkey:         # dont show the error again until the not responding time has doubled:
        pstarkey:         self.hide_not_responding_error_until = 2*self.not_responding_for
        pstarkey:         self._ui.notresponding.hide()  
           Chris:         self.error_message = ''
           Chris:         self._tab_text_colour = 'black'
chrisjbillington:         self.set_tab_icon_and_colour()
        pstarkey:         #self.tab_label_widgets['error'].hide()
        pstarkey:         #if self.state == 'idle':
        pstarkey:         #    self.tab_label_widgets['ready'].show()
        pstarkey:             
        pstarkey:     def check_time(self):
        pstarkey:         if self.state in ['idle','fatal error']:
        pstarkey:             self.not_responding_for = 0
        pstarkey:             if self._not_responding_error_message:
        pstarkey:                 self._not_responding_error_message = ''
chrisjbillington:                 self._update_error_and_tab_icon()
        pstarkey:         else:
        pstarkey:             self.not_responding_for = time.time() - self._time_of_last_state_change
        pstarkey:         if self.not_responding_for > 5 + self.hide_not_responding_error_until:
        pstarkey:             self.hide_not_responding_error_for = 0
        pstarkey:             self._ui.notresponding.show()
        pstarkey:             hours, remainder = divmod(int(self.not_responding_for), 3600)
        pstarkey:             minutes, seconds = divmod(remainder, 60)
        pstarkey:             if hours:
        pstarkey:                 s = '%s hours'%hours
        pstarkey:             elif minutes:
        pstarkey:                 s = '%s minutes'%minutes
        pstarkey:             else:
        pstarkey:                 s = '%s seconds'%seconds
        pstarkey:             self._not_responding_error_message = 'The hardware process has not responded for %s.<br /><br />'%s
chrisjbillington:             self._update_error_and_tab_icon()
        pstarkey:         return True
        pstarkey:         
        pstarkey:     def mainloop(self):
        pstarkey:         logger = logging.getLogger('BLACS.%s.mainloop'%(self.settings['device_name']))   
        pstarkey:         logger.debug('Starting')
        pstarkey:         
        pstarkey:         # Store a reference to the state queue and workers, this way if the tab is restarted, we won't ever get access to the new state queue created then
        pstarkey:         event_queue = self.event_queue
        pstarkey:         workers = self.workers
        pstarkey:         
        pstarkey:         try:
        pstarkey:             while True:
        pstarkey:                 # Get the next task from the event queue:
        pstarkey:                 logger.debug('Waiting for next event')
        pstarkey:                 func, data = event_queue.get(self.mode)
        pstarkey:                 if func == '_quit':
        pstarkey:                     # The user has requested a restart:
        pstarkey:                     logger.debug('Received quit signal')
        pstarkey:                     break
        pstarkey:                 args,kwargs = data
        pstarkey:                 logger.debug('Processing event %s' % func.__name__)
        pstarkey:                 self.state = '%s (GUI)'%func.__name__
        pstarkey:                 # Run the task with the GUI lock, catching any exceptions:
        pstarkey:                 #func = getattr(self,funcname)
        pstarkey:                 # run the function in the Qt main thread
        pstarkey:                 generator = inmain(func,self,*args,**kwargs)
        pstarkey:                 # Do any work that was queued up:(we only talk to the worker if work has been queued up through the yield command)
        pstarkey:                 if type(generator) == GeneratorType:
        pstarkey:                     # We need to call next recursively, queue up work and send the results back until we get a StopIteration exception
        pstarkey:                     generator_running = True
        pstarkey:                     break_main_loop = False
        pstarkey:                     # get the data from the first yield function
     janwerkmann:                     if PY2:
     janwerkmann:                         worker_process,worker_function,worker_args,worker_kwargs = inmain(generator.next)
     janwerkmann:                     else:
     janwerkmann:                         worker_process,worker_function,worker_args,worker_kwargs = inmain(generator.__next__)
        pstarkey:                     # Continue until we get a StopIteration exception, or the user requests a restart
        pstarkey:                     while generator_running:
        pstarkey:                         try:
        pstarkey:                             logger.debug('Instructing worker %s to do job %s'%(worker_process,worker_function) )
        pstarkey:                             worker_arg_list = (worker_function,worker_args,worker_kwargs)
        pstarkey:                             # This line is to catch if you try to pass unpickleable objects.
        pstarkey:                             try:
             jan:                                 pickle.dumps(worker_arg_list)
        pstarkey:                             except:
        pstarkey:                                 self.error_message += 'Attempt to pass unserialisable object to child process:'
        pstarkey:                                 raise
        pstarkey:                             # Send the command to the worker
        pstarkey:                             to_worker = workers[worker_process][1]
        pstarkey:                             from_worker = workers[worker_process][2]
        pstarkey:                             to_worker.put(worker_arg_list)
        pstarkey:                             self.state = '%s (%s)'%(worker_function,worker_process)
        pstarkey:                             # Confirm that the worker got the message:
        pstarkey:                             logger.debug('Waiting for worker to acknowledge job request')
        pstarkey:                             success, message, results = from_worker.get()
        pstarkey:                             if not success:
        pstarkey:                                 if message == 'quit':
        pstarkey:                                     # The user has requested a restart:
        pstarkey:                                     logger.debug('Received quit signal')
        pstarkey:                                     # This variable is set so we also break out of the toplevel main loop
        pstarkey:                                     break_main_loop = True
        pstarkey:                                     break
        pstarkey:                                 logger.info('Worker reported failure to start job')
        pstarkey:                                 raise Exception(message)
        pstarkey:                             # Wait for and get the results of the work:
        pstarkey:                             logger.debug('Worker reported job started, waiting for completion')
        pstarkey:                             success,message,results = from_worker.get()
        pstarkey:                             if not success and message == 'quit':
        pstarkey:                                 # The user has requested a restart:
        pstarkey:                                 logger.debug('Received quit signal')
        pstarkey:                                 # This variable is set so we also break out of the toplevel main loop
        pstarkey:                                 break_main_loop = True
        pstarkey:                                 break
        pstarkey:                             if not success:
        pstarkey:                                 logger.info('Worker reported exception during job')
        pstarkey:                                 now = time.strftime('%a %b %d, %H:%M:%S ',time.localtime())
             jan:                                 if PY2:
             jan:                                     now = now.decode('utf-8')
        pstarkey:                                 self.error_message += ('Exception in worker - %s:<br />' % now +
        pstarkey:                                                '<FONT COLOR=\'#ff0000\'>%s</FONT><br />'%cgi.escape(message).replace(' ','&nbsp;').replace('\n','<br />'))
        pstarkey:                             else:
        pstarkey:                                 logger.debug('Job completed')
        pstarkey:                             
        pstarkey:                             # Reset the hide_not_responding_error_until, since we have now heard from the child                        
        pstarkey:                             self.hide_not_responding_error_until = 0
        pstarkey:                                 
        pstarkey:                             # Send the results back to the GUI function
        pstarkey:                             logger.debug('returning worker results to function %s' % func.__name__)
        pstarkey:                             self.state = '%s (GUI)'%func.__name__
        pstarkey:                             next_yield = inmain(generator.send,results) 
        pstarkey:                             # If there is another yield command, put the data in the required variables for the next loop iteration
        pstarkey:                             if next_yield:
        pstarkey:                                 worker_process,worker_function,worker_args,worker_kwargs = next_yield
        pstarkey:                         except StopIteration:
        pstarkey:                             # The generator has finished. Ignore the error, but stop the loop
        pstarkey:                             logger.debug('Finalising function')
        pstarkey:                             generator_running = False
        pstarkey:                     # Break out of the main loop if the user requests a restart
        pstarkey:                     if break_main_loop:
        pstarkey:                         logger.debug('Breaking out of main loop')
        pstarkey:                         break
        pstarkey:                 self.state = 'idle'
        pstarkey:         except:
        pstarkey:             # Some unhandled error happened. Inform the user, and give the option to restart
        pstarkey:             message = traceback.format_exc()
        pstarkey:             logger.critical('A fatal exception happened:\n %s'%message)
        pstarkey:             now = time.strftime('%a %b %d, %H:%M:%S ',time.localtime())
             jan:             if PY2:
             jan:                 now = now.decode('utf-8')
        pstarkey:             self.error_message += ('Fatal exception in main process - %s:<br /> '%now +
        pstarkey:                            '<FONT COLOR=\'#ff0000\'>%s</FONT><br />'%cgi.escape(message).replace(' ','&nbsp;').replace('\n','<br />'))
        pstarkey:                             
        pstarkey:             self.state = 'fatal error'
        pstarkey:             # do this in the main thread
        pstarkey:             inmain(self._ui.button_close.setEnabled,False)
        pstarkey:         logger.info('Exiting')
        pstarkey:         
        pstarkey:         
        pstarkey: class Worker(Process):
        pstarkey:     def init(self):
        pstarkey:         # To be overridden by subclasses
        pstarkey:         pass
        pstarkey:     
        pstarkey:     def run(self, worker_name, device_name, extraargs):
        pstarkey:         self.worker_name = worker_name
        pstarkey:         self.device_name = device_name
        pstarkey:         for argname in extraargs:
        pstarkey:             setattr(self,argname,extraargs[argname])
        pstarkey:         # Total fudge, should be replaced with zmq logging in future:
          rander:         from labscript_utils.setup_logging import setup_logging
          rander:         setup_logging('BLACS')
        pstarkey:         log_name = 'BLACS.%s_%s.worker'%(self.device_name,self.worker_name)
        pstarkey:         self.logger = logging.getLogger(log_name)
        pstarkey:         self.logger.debug('Starting')
        pstarkey:         import zprocess.locking, labscript_utils.h5_lock
        pstarkey:         zprocess.locking.set_client_process_name(log_name)
        pstarkey:         #self.init()
        pstarkey:         self.mainloop()
        pstarkey: 
        pstarkey:     def mainloop(self):
        pstarkey:         while True:
        pstarkey:             # Get the next task to be done:
        pstarkey:             self.logger.debug('Waiting for next job request')
        pstarkey:             funcname, args, kwargs = self.from_parent.get()
        pstarkey:             self.logger.debug('Got job request %s' % funcname)
        pstarkey:             try:
        pstarkey:                 # See if we have a method with that name:
        pstarkey:                 func = getattr(self,funcname)
        pstarkey:                 success = True
        pstarkey:                 message = ''
        pstarkey:             except AttributeError:
        pstarkey:                 success = False
        pstarkey:                 message = traceback.format_exc()
        pstarkey:                 self.logger.error('Couldn\'t start job:\n %s'%message)
        pstarkey:             # Report to the parent whether method lookup was successful or not:
        pstarkey:             self.to_parent.put((success,message,None))
        pstarkey:             if success:
        pstarkey:                 # Try to do the requested work:
        pstarkey:                 self.logger.debug('Starting job %s'%funcname)
        pstarkey:                 try:
        pstarkey:                     results = func(*args,**kwargs)
        pstarkey:                     success = True
        pstarkey:                     message = ''
        pstarkey:                     self.logger.debug('Job complete')
        pstarkey:                 except:
        pstarkey:                     results = None
        pstarkey:                     success = False
        pstarkey:                     traceback_lines = traceback.format_exception(*sys.exc_info())
        pstarkey:                     del traceback_lines[1]
        pstarkey:                     message = ''.join(traceback_lines)
        pstarkey:                     self.logger.error('Exception in job:\n%s'%message)
        pstarkey:                 # Check if results object is serialisable:
        pstarkey:                 try:
             jan:                     pickle.dumps(results)
        pstarkey:                 except:
        pstarkey:                     message = traceback.format_exc()
        pstarkey:                     self.logger.error('Job returned unserialisable datatypes, cannot pass them back to parent.\n' + message)
        pstarkey:                     message = 'Attempt to pass unserialisable object %s to parent process:\n' % str(results) + message
        pstarkey:                     success = False
        pstarkey:                     results = None
        pstarkey:                 # Report to the parent whether work was successful or not,
        pstarkey:                 # and what the results were:
        pstarkey:                 self.to_parent.put((success,message,results))
        pstarkey:  
        pstarkey:  
        pstarkey:  
        pstarkey:      
        pstarkey: # Example code! Two classes are defined below, which are subclasses
        pstarkey: # of the ones defined above.  They show how to make a Tab class,
        pstarkey: # and a Worker class, and get the Tab to request work to be done by
        pstarkey: # the worker in response to GUI events.
        pstarkey: class MyTab(Tab):
        pstarkey:     def __init__(self,notebook,settings,restart=False): # restart will be true if __init__ was called due to a restart
        pstarkey:         Tab.__init__(self,notebook,settings,restart) # Make sure to call this first in your __init__!
        pstarkey:         
        pstarkey:         self.create_worker('My worker',MyWorker,{'x':7})
        pstarkey:         
        pstarkey:         # foobutton = gtk.Button('foo, 10 seconds!')
        pstarkey:         # barbutton = gtk.Button('bar, 10 seconds, then error!')
        pstarkey:         # bazbutton = gtk.Button('baz, 0.5 seconds!')
        pstarkey:         # addbazbutton = gtk.Button('add 2 second timeout to baz')
        pstarkey:         # removebazbutton = gtk.Button('remove baz timeout')
        pstarkey:         # bazunpickleable= gtk.Button('try to pass baz a multiprocessing.Lock()')
        pstarkey:         # fatalbutton = gtk.Button('fatal error, forgot to add @define_state to callback!')
        pstarkey:         # self.checkbutton=gtk.CheckButton('have baz\nreturn a Queue')
        pstarkey:         # self.toplevel = gtk.VBox()
        pstarkey:         # self.toplevel.pack_start(foobutton)
        pstarkey:         # self.toplevel.pack_start(barbutton)
        pstarkey:         # hbox = gtk.HBox()
        pstarkey:         # self.toplevel.pack_start(hbox)
        pstarkey:         # hbox.pack_start(bazbutton)
        pstarkey:         # hbox.pack_start(addbazbutton)
        pstarkey:         # hbox.pack_start(removebazbutton)
        pstarkey:         # hbox.pack_start(bazunpickleable)
        pstarkey:         # hbox.pack_start(self.checkbutton)
        pstarkey:         
        pstarkey:         # self.toplevel.pack_start(fatalbutton)
        pstarkey:         
        pstarkey:         # foobutton.connect('clicked', self.foo)
        pstarkey:         # barbutton.connect('clicked', self.bar)
        pstarkey:         # bazbutton.connect('clicked', self.baz)
        pstarkey:         # fatalbutton.connect('clicked',self.fatal )
        pstarkey:         # addbazbutton.connect('clicked',self.add_baz_timeout)
        pstarkey:         # removebazbutton.connect('clicked',self.remove_baz_timeout)
        pstarkey:         # bazunpickleable.connect('clicked', self.baz_unpickleable)
        pstarkey:         # # These two lines are required to top level widget (buttonbox
        pstarkey:         # # in this case) to the existing GUI:
        pstarkey:         # self.viewport.add(self.toplevel) 
        pstarkey:         # self.toplevel.show_all()    
        pstarkey: 
        pstarkey:         self.initUI()
        pstarkey:         
        pstarkey:     def initUI(self):
        pstarkey:         self.layout = self.get_tab_layout()
        pstarkey:         
        pstarkey:         foobutton = QPushButton('foo, 10 seconds!')
        pstarkey:         barbutton = QPushButton('bar, 10 seconds, then error!')
        pstarkey:         bazbutton = QPushButton('baz, 0.5 seconds!')
        pstarkey:         addbazbutton = QPushButton('add 2 second timeout to baz')
        pstarkey:         removebazbutton = QPushButton('remove baz timeout')
        pstarkey:         bazunpickleable= QPushButton('try to pass baz a threading.Lock()')
        pstarkey:         fatalbutton = QPushButton('fatal error, forgot to add @define_state to callback!')
        pstarkey:         
        pstarkey:         self.checkbutton = QPushButton('have baz\nreturn a Queue')
        pstarkey:         self.checkbutton.setCheckable(True)
        pstarkey:         
        pstarkey:         #self.device_widget.addWidget(layout)
        pstarkey:         self.layout.addWidget(foobutton)
        pstarkey:         self.layout.addWidget(barbutton)
        pstarkey:         self.layout.addWidget(bazbutton)
        pstarkey:         self.layout.addWidget(addbazbutton)
        pstarkey:         self.layout.addWidget(removebazbutton)
        pstarkey:         self.layout.addWidget(bazunpickleable)
        pstarkey:         self.layout.addWidget(fatalbutton)
        pstarkey:         self.layout.addWidget(self.checkbutton)
        pstarkey:         
        pstarkey:         foobutton.clicked.connect(self.foo)
        pstarkey:         barbutton.clicked.connect(self.bar)
        pstarkey:         bazbutton.clicked.connect(self.baz)
        pstarkey:         fatalbutton.clicked.connect(self.fatal )
        pstarkey:         addbazbutton.clicked.connect(self.add_baz_timeout)
        pstarkey:         removebazbutton.clicked.connect(self.remove_baz_timeout)
        pstarkey:         bazunpickleable.clicked.connect(self.baz_unpickleable)
        pstarkey: 
        pstarkey:         
        pstarkey:     # It is critical that you decorate your callbacks with @define_state
        pstarkey:     # as below. This makes the function get queued up and executed
        pstarkey:     # in turn by our state machine instead of immediately by the
        pstarkey:     # GTK mainloop. Only don't decorate if you're certain that your
        pstarkey:     # callback can safely happen no matter what state the system is
        pstarkey:     # in (for example, adjusting the axis range of a plot, or other
        pstarkey:     # appearance settings). You should never be calling queue_work
        pstarkey:     # or do_after from un undecorated callback.
        pstarkey:     @define_state(MODE_MANUAL,True)  
        pstarkey:     def foo(self):
        pstarkey:         self.logger.debug('entered foo')
        pstarkey:         #self.toplevel.set_sensitive(False)
        pstarkey:         # Here's how you instruct the worker process to do
        pstarkey:         # something. When this callback returns, the worker will be
        pstarkey:         # requested to do whatever you ask in queue_work (in this
        pstarkey:         # case, MyWorker.foo(5,6,7,x='x') ). Then, no events will
        pstarkey:         # be processed until that work is done. Once the work is
        pstarkey:         # done, whatever has been set with do_after will be executed
        pstarkey:         # (in this case self.leave_foo(1,2,3,bar=baz) ).
        pstarkey:         results = yield(self.queue_work('My worker','foo', 5,6,7,x='x'))
        pstarkey: 
        pstarkey:         #self.toplevel.set_sensitive(True)
        pstarkey:         self.logger.debug('leaving foo')
        pstarkey:     
        pstarkey:     # Here's what's NOT to do: forgetting to decorate a callback with @define_state
        pstarkey:     # when it's not something that can safely be done asynchronously
        pstarkey:     # to the state machine:
        pstarkey:     def fatal(self):
        pstarkey:         # This bug could be hard to track because nothing will happen
        pstarkey:         # when you click the button -- only once you do some other,
        pstarkey:         # correcly decorated callback will it become apparant that
        pstarkey:         # something is wrong. So don't make this mistake!
        pstarkey:         self.queue_work('My worker','foo', 5,6,7,x='x')
        pstarkey:         
        pstarkey:     @define_state(MODE_MANUAL,True)  
        pstarkey:     def bar(self):
        pstarkey:         self.logger.debug('entered bar')
        pstarkey:         results = yield(self.queue_work('My worker','bar', 5,6,7,x=5))
        pstarkey:       
        pstarkey:         self.logger.debug('leaving bar')
        pstarkey:         
        pstarkey:     @define_state(MODE_MANUAL,True)  
        pstarkey:     def baz(self, button=None):
     janwerkmann:         print(threading.current_thread().name)
        pstarkey:         self.logger.debug('entered baz')
        pstarkey:         results = yield(self.queue_work('My worker','baz', 5,6,7,x='x',return_queue=self.checkbutton.isChecked()))
     janwerkmann:         print(results)
     janwerkmann:         print(threading.current_thread().name)
        pstarkey:         results = yield(self.queue_work('My worker','baz', 4,6,7,x='x',return_queue=self.checkbutton.isChecked()))
     janwerkmann:         print(results)
     janwerkmann:         print(threading.current_thread().name)
        pstarkey:         self.logger.debug('leaving baz')
        pstarkey:         
        pstarkey:     # This event shows what happens if you try to send a unpickleable
        pstarkey:     # event through a queue to the subprocess:
        pstarkey:     @define_state(MODE_MANUAL,True)  
        pstarkey:     def baz_unpickleable(self):
        pstarkey:         self.logger.debug('entered baz_unpickleable')
        pstarkey:         results = yield(self.queue_work('My worker','baz', 5,6,7,x=threading.Lock()))
        pstarkey:         self.logger.debug('leaving baz_unpickleable')
        pstarkey:     
        pstarkey:     # You don't need to decorate with @define_state if all you're
        pstarkey:     # doing is adding a timeout -- adding a timeout can safely be done
        pstarkey:     # asynchronously. But you can still decorate if you want, and you
        pstarkey:     # should if you're doing other work in the same function call which
        pstarkey:     # can't be done asynchronously.
        pstarkey:     def add_baz_timeout(self):
        pstarkey:         self.statemachine_timeout_add(2000,self.baz)
        pstarkey:     
        pstarkey:     # Similarly, no @define_state is required here -- same applies as above.    
        pstarkey:     def remove_baz_timeout(self):
        pstarkey:         self.statemachine_timeout_remove(self.baz)
        pstarkey:     
        pstarkey:         
        pstarkey: class MyWorker(Worker):
        pstarkey:     def init(self):
        pstarkey:         # You read correctly, this isn't __init__, it's init. It's the
        pstarkey:         # first thing that will be called in the new process. You should
        pstarkey:         # do imports here, define instance variables, that sort of thing. You
        pstarkey:         # shouldn't import the hardware modules at the top of your file,
        pstarkey:         # because then they will be imported in both the parent and
        pstarkey:         # the child processes and wont be cleanly restarted when the subprocess
        pstarkey:         # is restarted. Since we're inside a method call though, you'll
        pstarkey:         # have to use global statements for the module imports, as shown
        pstarkey:         # below. Either that or you can make them instance variables, ie:
        pstarkey:         # import module; self.module = module. Up to you, I prefer
        pstarkey:         # the former.
        pstarkey:         global serial; import serial
        pstarkey:         self.logger.info('got x! %d' % self.x)
chrisjbillington:         raise Exception('bad import!')
        pstarkey:         
        pstarkey:     # Here's a function that will be called when requested by the parent
        pstarkey:     # process. There's nothing special about it really. Its return
        pstarkey:     # value will be passed as a keyword argument _results to the
        pstarkey:     # function which was queued with do_after, if there was one.
        pstarkey:     def foo(self,*args,**kwargs):
        pstarkey:         self.logger.debug('working on foo!')
        pstarkey:         time.sleep(10)
        pstarkey:         return 'results!!!'
        pstarkey:         
        pstarkey:     def bar(self,*args,**kwargs):
        pstarkey:         self.logger.debug('working on bar!')
        pstarkey:         time.sleep(10)
        pstarkey:         raise Exception('error!')
        pstarkey:         return 'results!!!'
        pstarkey:         
        pstarkey:     def baz(self,zzz,*args,**kwargs):
        pstarkey:         self.logger.debug('working on baz: time is %s'%repr(time.time()))
        pstarkey:         time.sleep(0.5)
        pstarkey:         if kwargs['return_queue']:
     janwerkmann:             return queue.Queue()
        pstarkey:         return 'results%d!!!'%zzz
        pstarkey: 
        pstarkey: if __name__ == '__main__':
        pstarkey:     import sys
        pstarkey:     import logging.handlers
        pstarkey:     # Setup logging:
        pstarkey:     logger = logging.getLogger('BLACS')
chrisjbillington:     handler = logging.handlers.RotatingFileHandler(os.path.join(BLACS_DIR, 'BLACS.log'), maxBytes=1024**2, backupCount=0)
        pstarkey:     formatter = logging.Formatter('%(asctime)s %(levelname)s %(name)s: %(message)s')
        pstarkey:     handler.setFormatter(formatter)
        pstarkey:     handler.setLevel(logging.DEBUG)
        pstarkey:     logger.addHandler(handler)
     janwerkmann:     if sys.stdout is not None and sys.stdout.isatty():
        pstarkey:         terminalhandler = logging.StreamHandler(sys.stdout)
        pstarkey:         terminalhandler.setFormatter(formatter)
        pstarkey:         terminalhandler.setLevel(logging.INFO)
        pstarkey:         logger.addHandler(terminalhandler)
        pstarkey:     else:
        pstarkey:         sys.stdout = sys.stderr = open(os.devnull)
        pstarkey:     logger.setLevel(logging.DEBUG)
        pstarkey:     #labscript_utils.excepthook.set_logger(logger)
        pstarkey:     logger.info('\n\n===============starting===============\n')
        pstarkey: 
        pstarkey: if __name__ == '__main__':
        pstarkey:     from labscript_utils.qtwidgets.dragdroptab import DragDropTabWidget
        pstarkey:     app = QApplication(sys.argv)
        pstarkey:     window = QWidget()
        pstarkey:     layout = QVBoxLayout(window)
        pstarkey:     notebook = DragDropTabWidget()
        pstarkey:     layout.addWidget(notebook)
        pstarkey:     
        pstarkey:     class FakeConnection(object):
        pstarkey:         def __init__(self):
        pstarkey:             self.BLACS_connection = 'None'
        pstarkey:     class FakeConnectionTable(object):
        pstarkey:         def __init__(self):
        pstarkey:             pass
        pstarkey:         
        pstarkey:         def find_by_name(self, device_name):
        pstarkey:             return FakeConnection()
        pstarkey:     
        pstarkey:     connection_table = FakeConnectionTable()
        pstarkey:     
        pstarkey:     tab1 = MyTab(notebook,settings = {'device_name': 'Example', 'connection_table':connection_table})
        pstarkey:     tab2 = MyTab(notebook,settings = {'device_name': 'Example2', 'connection_table':connection_table})
        pstarkey:     
        pstarkey:     window.show()
        pstarkey:     #notebook.show()
        pstarkey:     def run():
        pstarkey:         app.exec_()
        pstarkey:         tab1.close_tab()
        pstarkey:         tab2.close_tab()
        pstarkey:     sys.exit(run())
        pstarkey: 
        pstarkey:     # Run the demo!:
        pstarkey:     # gtk.gdk.threads_init() 
        pstarkey:     # window = gtk.Window() 
        pstarkey:     # notebook = gtk.Notebook()
        pstarkey:     # window.connect('destroy',lambda widget: gtk.main_quit())  
        pstarkey:     # window.add(notebook)
        pstarkey:     # notebook.show()
        pstarkey:     # window.show()  
        pstarkey:     # window.resize(800,600)
        pstarkey:     # with gtk.gdk.lock:
        pstarkey:         # gtk.main()
pstarkey: #####################################################################
pstarkey: #                                                                   #
pstarkey: # /virtual_devices/__init__.py                                      #
pstarkey: #                                                                   #
pstarkey: # Copyright 2013, Monash University                                 #
pstarkey: #                                                                   #
pstarkey: # This file is part of the program BLACS, in the labscript suite    #
pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
pstarkey: # the project for the full license.                                 #
pstarkey: #                                                                   #
pstarkey: #####################################################################
pstarkey: 
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /virtual_devices/shutter.py                                       #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program BLACS, in the labscript suite    #
   pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   pstarkey: 
   pstarkey: from hardware_interfaces.output_types.DO import *
   pstarkey: from hardware_interfaces.output_types.AO import *
   pstarkey: import gobject
   pstarkey: import pygtk
   pstarkey: import gtk
   pstarkey: 
   pstarkey: class shutter(object):
   pstarkey: 
   pstarkey:     def __init__(self,do_array):
   pstarkey:     
   pstarkey:         # Load the glade file, and build the interface
   pstarkey:         self.builder = gtk.Builder()
   pstarkey:         self.builder.add_from_file('virtual_Devices/shutter.glade')
   pstarkey:         
   pstarkey:         # Save the topleve object in the tab variable.
   pstarkey:         # This is IMPORTANT, as whatever is in self.tab is appended to the notebook
   pstarkey:         # The toplevel item in your glade file should be a hBox or a vBox, and it's name
   pstarkey:         # (under the general tab in glade) should be toplevel
   pstarkey:         self.tab = self.builder.get_object('toplevel')
   pstarkey:         
   pstarkey:         # Save the DO objects in an array for later use
   pstarkey:         self.do_array = do_array
   pstarkey:         
   pstarkey:         # Capabilities definitions (internal class use only)
   pstarkey:         self.num_shutters = 4
   pstarkey:         
   pstarkey:         #programatically rename GUI based on do_array
   pstarkey:         self.digital_widgets = []
   pstarkey:         for i in range(0,self.num_shutters):
   pstarkey:             # save the digital toggle widget in a list, so we can access it later
   pstarkey:             self.digital_widgets.append(self.builder.get_object("do_toggle_"+str(i+1)))
   pstarkey:             
   pstarkey:             # Programatically change the labels on each of our toggle widgets, so they match
   pstarkey:             # those stored in the DO object (both real hardware name, and physical name)
   pstarkey:             temp1 = self.builder.get_object("do_channel_label_"+str(i+1))
   pstarkey:             temp2 = self.builder.get_object("do_name_label_"+str(i+1))
   pstarkey:             temp1.set_text(self.do_array[i].hardware_name)
   pstarkey:             temp2.set_text(self.do_array[i].real_name)
   pstarkey:             
   pstarkey:             # register callback function
   pstarkey:             # This function is called when the digital output is updated somewhere else in the program
   pstarkey:             self.do_array[i].add_callback(self.update_value)
   pstarkey:             
   pstarkey:         # Need to connect gtk GUI signals!
   pstarkey:         self.builder.connect_signals(self)
   pstarkey:         
   pstarkey:     def update_value(self,output):        
   pstarkey:         # find the digital out in our array, so we know which GUI element to change
   pstarkey:         channel = None
   pstarkey:         for i in range(0,self.num_shutters):
   pstarkey:             if output == self.do_array[i]:
   pstarkey:                 channel = i
   pstarkey:                 break
   pstarkey:                 
   pstarkey:         # if the GUI element is not in the correct state, fix it!
   pstarkey:         if self.digital_widgets[channel].get_active() != output.state:
   pstarkey:             self.digital_widgets[channel].set_active(output.state)
   pstarkey:     
   pstarkey:     # This is the function called when the buttons are toggled
   pstarkey:     # The function name is defined within the glade file, under signals, for each button
   pstarkey:     def update_shutter(self,widget):
   pstarkey:         # find the widget in our array, which has been toggled
   pstarkey:         for i in range(0,self.num_shutters):
   pstarkey:             if self.digital_widgets[i] == widget:
   pstarkey:                 # send to update signal to the DO object, which will then trigger 
   pstarkey:                 # update calls for matching GUI objects in other parts of the program
   pstarkey:                 self.do_array[i].update_value(widget.get_active())
   pstarkey:                 return
janwerkmann:                 
