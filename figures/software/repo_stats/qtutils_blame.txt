pstarkey: # -*- coding: utf-8 -*-
pstarkey: #
pstarkey: # qtutils documentation build configuration file, created by
pstarkey: # sphinx-quickstart on Mon Jan 29 11:06:51 2018.
pstarkey: #
pstarkey: # This file is execfile()d with the current directory set to its
pstarkey: # containing dir.
pstarkey: #
pstarkey: # Note that not all possible configuration values are present in this
pstarkey: # autogenerated file.
pstarkey: #
pstarkey: # All configuration values have a default; values that are commented out
pstarkey: # serve to show the default.
pstarkey: 
pstarkey: # If extensions (or modules to document with autodoc) are in another directory,
pstarkey: # add these directories to sys.path here. If the directory is relative to the
pstarkey: # documentation root, use os.path.abspath to make it absolute, like shown here.
pstarkey: #
pstarkey: import os
pstarkey: import sys
pstarkey: sys.path.insert(0, os.path.abspath('..'))
pstarkey: 
pstarkey: # Mock Qt Library
pstarkey: import mock 
pstarkey: MOCK_MODULES = ['sip', 'PyQt5', 'PyQt5.QtGui', 'PyQt5.QtCore', 'PyQt5.QtWidgets', 'PyQt5.uic']
pstarkey: sys.modules.update((mod_name, mock.MagicMock()) for mod_name in MOCK_MODULES)
pstarkey: 
pstarkey: # import qtutils version
pstarkey: from qtutils import __version__
pstarkey: 
pstarkey: 
pstarkey: # -- General configuration ------------------------------------------------
pstarkey: 
pstarkey: # If your documentation needs a minimal Sphinx version, state it here.
pstarkey: #
pstarkey: # needs_sphinx = '1.0'
pstarkey: 
pstarkey: # Add any Sphinx extension module names here, as strings. They can be
pstarkey: # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
pstarkey: # ones.
pstarkey: extensions = ['sphinx.ext.autodoc',
pstarkey:     'sphinx.ext.mathjax',
pstarkey:     'sphinx.ext.napoleon',
pstarkey:     'sphinx.ext.viewcode']
pstarkey: 
pstarkey: # Add any paths that contain templates here, relative to this directory.
pstarkey: templates_path = ['_templates']
pstarkey: 
pstarkey: # The suffix(es) of source filenames.
pstarkey: # You can specify multiple suffix as a list of string:
pstarkey: #
pstarkey: # source_suffix = ['.rst', '.md']
pstarkey: source_suffix = '.rst'
pstarkey: 
pstarkey: # The master toctree document.
pstarkey: master_doc = 'index'
pstarkey: 
pstarkey: # General information about the project.
pstarkey: project = u'qtutils'
pstarkey: copyright = u'2013, Christopher Billington, Philip Starkey'
pstarkey: author = u'Christopher Billington, Philip Starkey'
pstarkey: 
pstarkey: # The version info for the project you're documenting, acts as replacement for
pstarkey: # |version| and |release|, also used in various other places throughout the
pstarkey: # built documents.
pstarkey: #
pstarkey: # The short X.Y version.
pstarkey: version = __version__
pstarkey: # The full version, including alpha/beta/rc tags.
pstarkey: release = version
pstarkey: 
pstarkey: # The language for content autogenerated by Sphinx. Refer to documentation
pstarkey: # for a list of supported languages.
pstarkey: #
pstarkey: # This is also used if you do content translation via gettext catalogs.
pstarkey: # Usually you set "language" from the command line for these cases.
pstarkey: language = None
pstarkey: 
pstarkey: # List of patterns, relative to source directory, that match files and
pstarkey: # directories to ignore when looking for source files.
pstarkey: # This patterns also effect to html_static_path and html_extra_path
pstarkey: exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
pstarkey: 
pstarkey: # The name of the Pygments (syntax highlighting) style to use.
pstarkey: pygments_style = 'sphinx'
pstarkey: 
pstarkey: # If true, `todo` and `todoList` produce output, else they produce nothing.
pstarkey: todo_include_todos = False
pstarkey: 
pstarkey: 
pstarkey: # -- Options for HTML output ----------------------------------------------
pstarkey: 
pstarkey: # The theme to use for HTML and HTML Help pages.  See the documentation for
pstarkey: # a list of builtin themes.
pstarkey: #
pstarkey: html_theme = 'default'
pstarkey: 
pstarkey: # Theme options are theme-specific and customize the look and feel of a theme
pstarkey: # further.  For a list of options available for each theme, see the
pstarkey: # documentation.
pstarkey: #
pstarkey: # html_theme_options = {}
pstarkey: 
pstarkey: # Add any paths that contain custom static files (such as style sheets) here,
pstarkey: # relative to this directory. They are copied after the builtin static files,
pstarkey: # so a file named "default.css" will overwrite the builtin "default.css".
pstarkey: html_static_path = ['_static']
pstarkey: 
pstarkey: # Custom sidebar templates, must be a dictionary that maps document names
pstarkey: # to template names.
pstarkey: #
pstarkey: # This is required for the alabaster theme
pstarkey: # refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars
pstarkey: # html_sidebars = {
pstarkey:     # '**': [
pstarkey:         # 'about.html',
pstarkey:         # 'navigation.html',
pstarkey:         # 'relations.html',  # needs 'show_related': True theme option to display
pstarkey:         # 'searchbox.html',
pstarkey:         # 'donate.html',
pstarkey:     # ]
pstarkey: # }
pstarkey: 
pstarkey: 
pstarkey: # -- Options for HTMLHelp output ------------------------------------------
pstarkey: 
pstarkey: # Output file base name for HTML help builder.
pstarkey: htmlhelp_basename = 'qtutilsdoc'
pstarkey: 
pstarkey: 
pstarkey: # -- Options for LaTeX output ---------------------------------------------
pstarkey: 
pstarkey: latex_elements = {
pstarkey:     # The paper size ('letterpaper' or 'a4paper').
pstarkey:     #
pstarkey:     # 'papersize': 'letterpaper',
pstarkey: 
pstarkey:     # The font size ('10pt', '11pt' or '12pt').
pstarkey:     #
pstarkey:     # 'pointsize': '10pt',
pstarkey: 
pstarkey:     # Additional stuff for the LaTeX preamble.
pstarkey:     #
pstarkey:     # 'preamble': '',
pstarkey: 
pstarkey:     # Latex figure (float) alignment
pstarkey:     #
pstarkey:     # 'figure_align': 'htbp',
pstarkey: }
pstarkey: 
pstarkey: # Grouping the document tree into LaTeX files. List of tuples
pstarkey: # (source start file, target name, title,
pstarkey: #  author, documentclass [howto, manual, or own class]).
pstarkey: latex_documents = [
pstarkey:     (master_doc, 'qtutils.tex', u'qtutils Documentation',
pstarkey:      u'Christopher Billington, Philip Starkey', 'manual'),
pstarkey: ]
pstarkey: 
pstarkey: 
pstarkey: # -- Options for manual page output ---------------------------------------
pstarkey: 
pstarkey: # One entry per manual page. List of tuples
pstarkey: # (source start file, name, description, authors, manual section).
pstarkey: man_pages = [
pstarkey:     (master_doc, 'qtutils', u'qtutils Documentation',
pstarkey:      [author], 1)
pstarkey: ]
pstarkey: 
pstarkey: 
pstarkey: # -- Options for Texinfo output -------------------------------------------
pstarkey: 
pstarkey: # Grouping the document tree into Texinfo files. List of tuples
pstarkey: # (source start file, target name, title, author,
pstarkey: #  dir menu entry, description, category)
pstarkey: texinfo_documents = [
pstarkey:     (master_doc, 'qtutils', u'qtutils Documentation',
pstarkey:      author, 'qtutils', 'One line description of project.',
pstarkey:      'Miscellaneous'),
pstarkey: ]
pstarkey: 
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # UiLoader.py                                                       #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Christopher Billington, Philip Starkey            #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the qtutils project                          #
   pstarkey: # (see https://bitbucket.org/philipstarkey/qtutils )                #
   pstarkey: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
   pstarkey: # See the license.txt file in the root of the project               #
   pstarkey: # for the full license.                                             #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: import sys
janwerkmann: PY2 = sys.version_info[0] == 2
janwerkmann: 
janwerkmann: import qtutils.qt
   pstarkey: 
janwerkmann: 
   pstarkey: class UiLoaderPromotionException(Exception):
   pstarkey:     pass
   pstarkey: 
janwerkmann: 
   pstarkey: class UiLoaderUnknownWidgetException(Exception):
   pstarkey:     pass
janwerkmann: 
janwerkmann: 
janwerkmann: if qtutils.qt.QT_ENV == qtutils.qt.PYSIDE:
   pstarkey:     from PySide.QtUiTools import QUiLoader
janwerkmann: 
   pstarkey:     class UiLoader(QUiLoader):
   pstarkey:         """
   pstarkey:         Class UiLoader
janwerkmann: 
   pstarkey:         This class subclasses QtUiTools.QUiLoader to implement custom promotion of
janwerkmann:         widgets at runtime. This functionality also allows you to promote a
   pstarkey:         QMainWindow to your own class (which you cannot do in QtDesigner).
janwerkmann: 
janwerkmann:         When widgets are created, custom promotions are checked first, then
janwerkmann:         promotions in Qt designer. If neither of these apply, standard Qt widgets
   pstarkey:         are created.
janwerkmann: 
   pstarkey:         """
janwerkmann: 
   pstarkey:         def __init__(self, parent=None):
   pstarkey:             QUiLoader.__init__(self, parent)
   pstarkey:             self._store = []
   pstarkey:             if parent is not None:
   pstarkey:                 self._store.append(parent)
   pstarkey:             self._custom_widgets = {}
   pstarkey:             self._promotions = {}
   pstarkey:             self.toplevel_instance = None
   pstarkey: 
   pstarkey:         def registerCustomWidget(self, class_):
   pstarkey:             """
   pstarkey:             Register a class with the UiLoader that has been used with Qt Designers
   pstarkey:             "promote to" functionality.
   pstarkey:             """
   pstarkey:             self._custom_widgets[class_.__name__] = class_
janwerkmann:             QUiLoader.registerCustomWidget(self, class_)
janwerkmann: 
   pstarkey:         def registerCustomPromotion(self, name, class_):
   pstarkey:             """
janwerkmann:             Register a widget (name) that you wish to promote to the specified
   pstarkey:             class. This takes precedence over widgets promoted in Qt Designer
   pstarkey:             """
   pstarkey:             if name in self._promotions:
janwerkmann:                 raise UiLoaderPromotionException("The widget '%s' has already had a promotion registered" % name)
   pstarkey:             self._promotions[name] = class_
janwerkmann: 
janwerkmann:         def createWidget(self, class_name, parent=None, name=""):
   pstarkey:             if self.toplevel_instance is not None and parent is None:
   pstarkey:                 widget = self.toplevel_instance
   pstarkey:             elif name in self._promotions:
janwerkmann:                 widget = self._promotions[name](parent)
   pstarkey:                 if parent is None:
   pstarkey:                     # widgets with no parents must be saved or else Python crashes
   pstarkey:                     self._store.append(widget)
   pstarkey:             elif class_name in self._custom_widgets:
   pstarkey:                 widget = self._custom_widgets[class_name](parent)
   pstarkey:             else:
   pstarkey:                 if class_name in self.availableWidgets():
   pstarkey:                     widget = QUiLoader.createWidget(self, class_name, parent, name)
   pstarkey:                 else:
janwerkmann:                     raise UiLoaderUnknownWidgetException("Widget '%s' has unknown class '%s'" % (name, class_name))
janwerkmann: 
   pstarkey:             return widget
janwerkmann: 
   pstarkey:         def load(self, uifile, toplevel_instance=None):
   pstarkey:             """
   pstarkey:             Load the .ui file specified in ui_file
   pstarkey:             If toplevel_instance is specified, it will be returned as the toplevel widget instead of letting the QUiLoader creating a new one
   pstarkey:             """
   pstarkey:             self.toplevel_instance = toplevel_instance
   pstarkey:             return QUiLoader.load(self, uifile)
janwerkmann: 
   pstarkey: else:
   pstarkey:     from types import ModuleType
janwerkmann:     if qtutils.qt.QT_ENV == qtutils.qt.PYQT4:
janwerkmann:         from PyQt4 import uic
janwerkmann:     elif qtutils.qt.QT_ENV == qtutils.qt.PYQT5:
janwerkmann:         from PyQt5 import uic
janwerkmann: 
   pstarkey:     class UiLoader(object):
   pstarkey:         def __init__(self):
   pstarkey:             # dummy module
janwerkmann:             self.module = sys.modules['qtutils.widgets'] = ModuleType(b'widgets' if PY2 else 'widgets')
janwerkmann: 
   pstarkey:         def registerCustomWidget(self, class_):
   pstarkey:             self.registerCustomPromotion(class_.__name__, class_)
janwerkmann: 
   pstarkey:         def registerCustomPromotion(self, name, class_):
janwerkmann:             if hasattr(self.module, name):
janwerkmann:                 raise UiLoaderPromotionException("The widget '%s' has already had a promotion registered" % name)
   pstarkey:             setattr(self.module, name, class_)
janwerkmann: 
   pstarkey:         def load(self, *args, **kwargs):
   pstarkey:             return uic.loadUi(*args, **kwargs)
janwerkmann: 
janwerkmann: 
   pstarkey: if __name__ == "__main__":
   pstarkey:     loader = UiLoader()
   pstarkey:     loader.registerCustomWidget(MyWidgetClassSpecifiedInQtDesignerPromoteTo)
janwerkmann:     loader.registerCustomPromotion("myWidgetNameInQtDesigner", ClassToPromoteTo)
janwerkmann:     ui = loader.load('myUiFile.ui')
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # __init__.py                                                       #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Christopher Billington, Philip Starkey            #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the qtutils project                          #
   pstarkey: # (see https://bitbucket.org/philipstarkey/qtutils )                #
   pstarkey: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
   pstarkey: # See the license.txt file in the root of the project               #
   pstarkey: # for the full license.                                             #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: import sys
janwerkmann: PY2 = sys.version_info[0] == 2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   cbilling: 
   pstarkey: try:
janwerkmann:     from .__version__ import __version__
   pstarkey: except ImportError:
   pstarkey:     # Version file has not been autogenerated from build process:
   pstarkey:     __version__ = None
   pstarkey: 
janwerkmann: from qtutils.qt.QtCore import qInstallMessageHandler
janwerkmann: from qtutils.locking import qtlock
janwerkmann: 
   pstarkey: qtlock.enforce()
   pstarkey: 
   cbilling: from qtutils.invoke_in_main import inmain, inmain_later, inthread, inmain_decorator
   pstarkey: 
   cbilling: from qtutils.qsettings_wrapper import QSettingsWrapper
   cbilling: from qtutils.disconnect_contextmanager import DisconnectContextManager
   cbilling: from qtutils.UiLoader import UiLoader
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: import sys
janwerkmann: PY2 = sys.version_info[0] == 2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   cbilling: import weakref
   cbilling: 
janwerkmann: from qtutils.qt.QtCore import *
janwerkmann: from qtutils.qt.QtGui import *
janwerkmann: from qtutils.qt.QtWidgets import *
   cbilling: 
   cbilling: # These are weakref dictionarys so that we do not hold references
   cbilling: # to the scrollbars after nobody else does:
   cbilling: _is_scrolled_to_bottom = weakref.WeakKeyDictionary()
   cbilling: _callbacks = weakref.WeakKeyDictionary()
   cbilling: 
   cbilling: 
   cbilling: def set_auto_scroll_to_end(scrollbar):
   cbilling:     """Configures any scrollbar to always  scroll to the end when its range is increased,
   cbilling:     if it was already scrolled to the end before the range increased."""
janwerkmann: 
   cbilling:     def on_scrollbar_value_changed(value=None):
   cbilling:         if scrollbar.value() == scrollbar.maximum():
   cbilling:             _is_scrolled_to_bottom[scrollbar] = True
   cbilling:         else:
   cbilling:             _is_scrolled_to_bottom[scrollbar] = False
janwerkmann: 
   cbilling:     def on_scrollbar_range_changed(minval, maxval):
   cbilling:         if _is_scrolled_to_bottom[scrollbar]:
   cbilling:             scrollbar.setValue(maxval)
janwerkmann: 
   cbilling:     scrollbar.valueChanged.connect(on_scrollbar_value_changed)
   cbilling:     scrollbar.rangeChanged.connect(on_scrollbar_range_changed)
   cbilling:     # Call this to add the scrollbar to the dictionary and store whether it is initially at the end or not:
   cbilling:     on_scrollbar_value_changed(scrollbar)
   cbilling:     # Store the callbacks for disconnection:
   cbilling:     _callbacks[scrollbar] = on_scrollbar_value_changed, on_scrollbar_range_changed
janwerkmann: 
janwerkmann: 
   cbilling: def unset_auto_scroll_to_end(scrollbar):
   cbilling:     on_scrollbar_value_changed, on_scrollbar_range_changed = _callbacks[scrollbar]
   cbilling:     scrollbar.valueChanged.disconnect(on_scrollbar_value_changed)
   cbilling:     scrollbar.rangeChanged.disconnect(on_scrollbar_range_changed)
   cbilling: 
janwerkmann: 
   cbilling: if __name__ == '__main__':
   cbilling:     # test. Should auto scroll to the bottom until the
   cbilling:     # 50th item, and then not auto scroll any more.
   cbilling:     app = QApplication(sys.argv)
   cbilling:     window = QWidget()
   cbilling:     layout = QVBoxLayout(window)
   cbilling:     view = QListView(window)
   cbilling:     model = QStandardItemModel()
   cbilling:     view.setModel(model)
   cbilling:     layout.addWidget(view)
   cbilling: 
   cbilling:     window.show()
   cbilling:     window.resize(200, 200)
   cbilling: 
   cbilling:     i = 0
janwerkmann: 
   cbilling:     def add_line():
   cbilling:         global i
   cbilling:         model.appendRow(QStandardItem(str(i)))
   cbilling:         i += 1
   cbilling:         if i == 50:
janwerkmann:             unset_auto_scroll_to_end(view.verticalScrollBar())
janwerkmann: 
   cbilling:     timer = QTimer()
   cbilling:     timer.timeout.connect(add_line)
   cbilling:     timer.start(100)
janwerkmann: 
   cbilling:     set_auto_scroll_to_end(view.verticalScrollBar())
   cbilling:     app.exec_()
   cbilling: #####################################################################
   cbilling: #                                                                   #
janwerkmann: # disconnect_contextmanager.py                                      #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Christopher Billington, Philip Starkey            #
   cbilling: #                                                                   #
   cbilling: # This file is part of the qtutils project                          #
   cbilling: # (see https://bitbucket.org/philipstarkey/qtutils )                #
   cbilling: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
   cbilling: # See the license.txt file in the root of the project               #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
   cbilling: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: 
   cbilling: class DisconnectContextManager(object):
   cbilling:     def __init__(self, signal, slot):
   cbilling:         self.signal = signal
   cbilling:         self.slot = slot
janwerkmann: 
   cbilling:     def __enter__(self):
   cbilling:         self.signal.disconnect(self.slot)
janwerkmann: 
   cbilling:     def __exit__(self, *exc_info):
   cbilling:         self.signal.connect(self.slot)
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: import qtutils.qt
janwerkmann: if qtutils.qt.QT_ENV == qtutils.qt.PYSIDE:
   cbilling:     import qtutils.icons._icons_pyside
janwerkmann: elif qtutils.qt.QT_ENV == qtutils.qt.PYQT4:
janwerkmann:     import qtutils.icons._icons_pyqt4
janwerkmann: elif qtutils.qt.QT_ENV == qtutils.qt.PYQT5:
janwerkmann:     import qtutils.icons._icons_pyqt5
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
   cbilling: import os
   cbilling: import subprocess
   cbilling: 
   cbilling: this_folder = os.path.dirname(os.path.realpath(__file__))
   cbilling: qrc_filename = os.path.join(this_folder, 'icons.qrc')
janwerkmann: py_filename_pyqt5 = os.path.join(this_folder, '_icons_pyqt5.py')
   cbilling: py_filename_pyqt4 = os.path.join(this_folder, '_icons_pyqt4.py')
   cbilling: py_filename_pyside = os.path.join(this_folder, '_icons_pyside.py')
   cbilling: icon_folders = ['custom', 'fugue']
   cbilling: 
janwerkmann: 
   cbilling: def make_qrc_file():
janwerkmann:     header = "<!DOCTYPE RCC><RCC version=\"1.0\">\n    <qresource  prefix=\"/qtutils\">\n"
janwerkmann:     footer = "    </qresource>\n</RCC>"
janwerkmann:     line_format_string = "     <file>%s</file>\n"
janwerkmann:     with open(qrc_filename, 'w') as outfile:
janwerkmann:         outfile.write(header)
janwerkmann:         for folder in icon_folders:
janwerkmann:             for filename in os.listdir(os.path.join(this_folder, folder)):
janwerkmann:                 relative_path = '%s/%s' % (folder, filename)  # Has to be forward slash, not system specific path separator
janwerkmann:                 outfile.write(line_format_string % relative_path)
janwerkmann:         outfile.write(footer)
janwerkmann: 
janwerkmann: 
janwerkmann: def find_pyrcc5():
janwerkmann:     import PyQt5
janwerkmann:     # If we're on Windows, it's probably in the pyqt4 directory:
janwerkmann:     if os.name == 'nt':
janwerkmann:         pyqt5_dir = os.path.abspath(os.path.dirname(PyQt5.__file__))
janwerkmann:         pyrcc5 = os.path.join(pyqt5_dir, 'pyrcc5.exe')
janwerkmann:         if os.path.exists(pyrcc5):
janwerkmann:             return pyrcc5
janwerkmann:     # Otherwise, or if it was not found there, check if it's in the PATH:
janwerkmann:     pyrcc5 = 'pyrcc5'
janwerkmann:     try:
janwerkmann:         subprocess.call([pyrcc5], stdout=open(os.devnull), stderr=open(os.devnull))
janwerkmann:         return pyrcc5
janwerkmann:     except OSError:
janwerkmann:         # Still no?
janwerkmann:         msg = """
janwerkmann:                 Cannot find pyrcc5, the PyQt5 utility for building resource
janwerkmann:                 files. This module was configured to find it in the PyQt5
janwerkmann:                 directory on Windows, which is where it is for the Anaconda
janwerkmann:                 Python distribution. This module should also find pyrcc5 if it
janwerkmann:                 in in the PATH, on any OS. Please find pyrcc5 and put it in your
janwerkmann:                 PATH. On Debian based systems it is available in the pyqt5-dev-
janwerkmann:                 tools package. If you want to install qtutils without PyQt5
janwerkmann:                 support, simply run:
janwerkmann:                 python setup.py install NO_PYQT5"""
janwerkmann:         import textwrap
janwerkmann:         raise OSError(textwrap.dedent(msg).strip())
janwerkmann: 
janwerkmann: 
   cbilling: def find_pyrcc4():
janwerkmann:     import PyQt4
janwerkmann:     # If we're on Windows, it's probably in the pyqt4 directory:
janwerkmann:     if os.name == 'nt':
janwerkmann:         pyqt4_dir = os.path.abspath(os.path.dirname(PyQt4.__file__))
janwerkmann:         pyrcc4 = os.path.join(pyqt4_dir, 'pyrcc4.exe')
janwerkmann:         if os.path.exists(pyrcc4):
janwerkmann:             return pyrcc4
janwerkmann:     # Otherwise, or if it was not found there, check if it's in the PATH:
janwerkmann:     pyrcc4 = 'pyrcc4'
janwerkmann:     try:
janwerkmann:         subprocess.call([pyrcc4], stdout=open(os.devnull), stderr=open(os.devnull))
janwerkmann:         return pyrcc4
janwerkmann:     except OSError:
janwerkmann:         # Still no?
janwerkmann:         msg = """
   cbilling:               Cannot find pyrcc4, the PyQt4 utility for building resource
   cbilling:               files. This module was configured to find it in the PyQt4
   cbilling:               directory on Windows, which is where it is for the Anaconda
   cbilling:               Python distribution. This module should also find pyrcc4 if it
   cbilling:               in in the PATH, on any OS. Please find pyrcc4 and put it in your
   cbilling:               PATH. On Debian based systems it is available in the pyqt4-dev-
   cbilling:               tools package. If you want to install qtutils without PyQt4
   cbilling:               support, simply run:
   cbilling:               python setup.py install NO_PYQT4"""
janwerkmann:         import textwrap
janwerkmann:         raise OSError(textwrap.dedent(msg).strip())
janwerkmann: 
   cbilling: 
   cbilling: def find_pyside_rcc():
janwerkmann:     import PySide
janwerkmann:     # If we're on Windows, it's probably in the PySide directory:
janwerkmann:     if os.name == 'nt':
janwerkmann:         pyside_dir = os.path.abspath(os.path.dirname(PySide.__file__))
janwerkmann:         pyside_rcc = os.path.join(pyside_dir, 'pyside-rcc.exe')
janwerkmann:         if os.path.exists(pyside_rcc):
janwerkmann:             return pyside_rcc
janwerkmann:     # Otherwise, or if it was not found there, check if it's in the PATH:
janwerkmann:     pyside_rcc = 'pyside-rcc'
janwerkmann:     try:
janwerkmann:         subprocess.call([pyside_rcc], stdout=open(os.devnull), stderr=open(os.devnull))
janwerkmann:         return pyside_rcc
janwerkmann:     except OSError:
janwerkmann:         # Still no?
janwerkmann:         msg = """
   cbilling:               Cannot find pyside-rcc, the PySide utility for building
   cbilling:               resource files. This module was configured to find it in the
   cbilling:               PySide directory on Windows, which is where it is for the
   cbilling:               Anaconda Python distribution. This module should also find
   cbilling:               pyside-rcc if it in in the PATH, on any OS. Please find pyside-
   cbilling:               rcc and put it in your PATH. On Debian based systems it is
   cbilling:               available in the pyqt4-dev- tools package. If you want to
   cbilling:               install qtutils without PySide support, simply run:
   cbilling:               python setup.py install NO_PYSIDE"""
janwerkmann:         import textwrap
janwerkmann:         raise OSError(textwrap.dedent(msg).strip())
janwerkmann: 
janwerkmann: 
janwerkmann: def make_py_file_pyqt5():
janwerkmann:     pyrcc5 = find_pyrcc5()
janwerkmann:     child = subprocess.Popen([pyrcc5, '-o', py_filename_pyqt5, qrc_filename])
janwerkmann:     stdoutdata, stderrdata = child.communicate()
janwerkmann:     if child.returncode != 0:
janwerkmann:         raise OSError(stderrdata)
janwerkmann: 
janwerkmann: 
   cbilling: def make_py_file_pyqt4():
janwerkmann:     pyrcc4 = find_pyrcc4()
janwerkmann:     child = subprocess.Popen([pyrcc4, '-py3', '-o', py_filename_pyqt4, qrc_filename])
janwerkmann:     stdoutdata, stderrdata = child.communicate()
janwerkmann:     if child.returncode != 0:
janwerkmann:         raise OSError(stderrdata)
janwerkmann: 
janwerkmann: 
   cbilling: def make_py_file_pyside():
janwerkmann:     pyside_rcc = find_pyside_rcc()
janwerkmann:     child = subprocess.Popen([pyside_rcc, '-py3', '-o', py_filename_pyside, qrc_filename])
janwerkmann:     stdoutdata, stderrdata = child.communicate()
janwerkmann:     if child.returncode != 0:
janwerkmann:         raise OSError(stderrdata)
janwerkmann: 
janwerkmann: 
janwerkmann: def pyqt5():
janwerkmann:     if not os.path.exists(py_filename_pyqt5):
janwerkmann:         make_py_file_pyqt5()
janwerkmann: 
janwerkmann: 
   cbilling: def pyqt4():
janwerkmann:     if not os.path.exists(py_filename_pyqt4):
janwerkmann:         make_py_file_pyqt4()
janwerkmann: 
janwerkmann: 
   cbilling: def pyside():
janwerkmann:     if not os.path.exists(py_filename_pyside):
janwerkmann:         make_py_file_pyside()
   cbilling: 
janwerkmann: 
   cbilling: if not os.path.exists(qrc_filename):
janwerkmann:     make_qrc_file()
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # invoke_in_main.py                                                 #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Christopher Billington, Philip Starkey            #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the qtutils project                          #
        pstarkey: # (see https://bitbucket.org/philipstarkey/qtutils )                #
        pstarkey: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
        pstarkey: # See the license.txt file in the root of the project               #
        pstarkey: # for the full license.                                             #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
        pstarkey: 
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: import sys
     janwerkmann: PY2 = sys.version_info[0] == 2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
chrisjbillington:     from Queue import Queue
        cbilling: else:
chrisjbillington:     from queue import Queue
     janwerkmann: 
        pstarkey: import threading
        pstarkey: import functools
        pstarkey: 
        pstarkey: from qtutils.qt.QtCore import QEvent, QObject, QCoreApplication, QTimer, QThread
        pstarkey: 
        pstarkey: 
chrisjbillington: def _reraise(exc_info):
chrisjbillington:     type, value, traceback = exc_info
chrisjbillington:     # handle python2/3 difference in raising exception        
chrisjbillington:     if PY2:
chrisjbillington:         exec('raise type, value, traceback', globals(), locals())
chrisjbillington:     else:
chrisjbillington:         raise value.with_traceback(traceback)
chrisjbillington: 
chrisjbillington: 
        pstarkey: class CallEvent(QEvent):
        pstarkey:     """An event containing a request for a function call."""
        pstarkey:     EVENT_TYPE = QEvent.Type(QEvent.registerEventType())
     janwerkmann: 
        pstarkey:     def __init__(self, queue, exceptions_in_main, fn, *args, **kwargs):
        pstarkey:         QEvent.__init__(self, self.EVENT_TYPE)
        pstarkey:         self.fn = fn
        pstarkey:         self.args = args
        pstarkey:         self.kwargs = kwargs
        pstarkey:         self._returnval = queue
        pstarkey:         # Whether to raise exceptions in the main thread or store them
        pstarkey:         # for raising in the calling thread:
        pstarkey:         self._exceptions_in_main = exceptions_in_main
     janwerkmann: 
        pstarkey: 
        pstarkey: class Caller(QObject):
        pstarkey:     """An event handler which calls the function held within a CallEvent."""
     janwerkmann: 
        pstarkey:     def event(self, event):
        pstarkey:         event.accept()
        pstarkey:         exception = None
        pstarkey:         try:
        pstarkey:             result = event.fn(*event.args, **event.kwargs)
        pstarkey:         except Exception:
        pstarkey:             # Store for re-raising the exception in the calling thread:
        pstarkey:             exception = sys.exc_info()
        pstarkey:             result = None
        pstarkey:             if event._exceptions_in_main:
        pstarkey:                 # Or, if nobody is listening for this exception,
        pstarkey:                 # better raise it here so it doesn't pass
        pstarkey:                 # silently:
        pstarkey:                 raise
        pstarkey:         finally:
     janwerkmann:             event._returnval.put([result, exception])
        pstarkey:         return True
     janwerkmann: 
     janwerkmann: 
        pstarkey: caller = Caller()
        pstarkey: 
     janwerkmann: 
        pstarkey: def inmain(fn, *args, **kwargs):
        pstarkey:     """Execute a function in the main thread. Wait for it to complete
        pstarkey:     and return its return value.
        pstarkey:     
        pstarkey:     This function queues up a custom :code:`QEvent` to the Qt event loop.
        pstarkey:     This event executes the specified function :code:`fn` in the Python 
        pstarkey:     MainThread with the specified arguments and keyword arguments, and returns the result to the calling thread.
        pstarkey:     
        pstarkey:     This function can be used from the MainThread, but such use will just directly call the function, bypassing the Qt event loop.
        pstarkey:     
        pstarkey:     Arguments:
        pstarkey:         fn: A reference to the function or method to run in the MainThread.
        pstarkey:         
        pstarkey:         *args: Any arguments to pass to :code:`fn` when it is called from the 
        pstarkey:                MainThread.
        pstarkey:         
        pstarkey:         **kwargs: Any keyword arguments to pass to :code:`fn` when it is called
        pstarkey:                   from the MainThread
        pstarkey:                   
        pstarkey:     Returns:
        pstarkey:         The result of executing :code:`fn(*args, **kwargs)`
        pstarkey:     """
        pstarkey:     if threading.current_thread().name == 'MainThread':
        pstarkey:         return fn(*args, **kwargs)
        pstarkey:     return get_inmain_result(_in_main_later(fn, False, *args, **kwargs))
     janwerkmann: 
     janwerkmann: 
        pstarkey: def inmain_later(fn, *args, **kwargs):
        pstarkey:     """Queue up the executing of a function in the main thread and return immediately.
        pstarkey:     
        pstarkey:     This function queues up a custom :code:`QEvent` to the Qt event loop.
        pstarkey:     This event executes the specified function :code:`fn` in the Python 
        pstarkey:     MainThread with the specified arguments and keyword arguments, and returns 
        pstarkey:     a Python Queue which will eventually hold the result from the executing of 
        pstarkey:     :code:`fn`. To access the result, use :func:`qtutils.invoke_in_main.get_inmain_result`.
        pstarkey:     
        pstarkey:     This function can be used from the MainThread, but such use will just directly call the function, bypassing the Qt event loop.
        pstarkey:     
        pstarkey:     Arguments:
        pstarkey:         fn: A reference to the function or method to run in the MainThread.
        pstarkey:         
        pstarkey:         *args: Any arguments to pass to :code:`fn` when it is called from the 
        pstarkey:                MainThread.
        pstarkey:         
        pstarkey:         **kwargs: Any keyword arguments to pass to :code:`fn` when it is called
        pstarkey:                   from the MainThread
        pstarkey:                   
        pstarkey:     Returns:
        pstarkey:        A Python Queue which will eventually hold the result 
        pstarkey:        :code:`(fn(*args, **kwargs), exception)` where 
        pstarkey:        :code:`exception=[type,value,traceback]`.
        pstarkey:     """
        pstarkey:     return _in_main_later(fn, True, *args, **kwargs)
     janwerkmann: 
     janwerkmann: 
        pstarkey: def _in_main_later(fn, exceptions_in_main, *args, **kwargs):
        pstarkey:     """Asks the mainloop to call a function when it has time. Immediately
        pstarkey:     returns the queue that was sent to the mainloop.  A call to queue.get()
        pstarkey:     will return a list of [result,exception] where exception=[type,value,traceback]
        pstarkey:     of the exception.  Functions are guaranteed to be called in the order
     janwerkmann:     they were requested."""
chrisjbillington:     queue = Queue()
        pstarkey:     QCoreApplication.postEvent(caller, CallEvent(queue, exceptions_in_main, fn, *args, **kwargs))
        pstarkey:     return queue
     janwerkmann: 
     janwerkmann: 
        pstarkey: def get_inmain_result(queue):
        pstarkey:     """ Processes the result of :func:`qtutils.invoke_in_main.inmain_later`.
        pstarkey:     
        pstarkey:     This function takes the queue returned by :code:`inmain_later` and blocks
        pstarkey:     until a result is obtained. If an exception occurred when executing the
        pstarkey:     function in the MainThread, it is raised again here (it is also raised in the
        pstarkey:     MainThread). If no exception was raised, the result from the execution of the
        pstarkey:     function is returned.
        pstarkey:     
        pstarkey:     Arguments:
        pstarkey:         queue: The Python Queue object returned by :code:`inmain_later`
        pstarkey:         
        pstarkey:     Returns:
        pstarkey:         The result from executing the function specified in the call to 
        pstarkey:         :code:`inmain_later`
        pstarkey:     
        pstarkey:     """
     janwerkmann:     result, exception = queue.get()
        pstarkey:     if exception is not None:
chrisjbillington:         _reraise(exception)
        pstarkey:     return result
        pstarkey: 
     janwerkmann: 
     janwerkmann: def inthread(f, *args, **kwargs):
        pstarkey:     """A convenience function for starting a Python thread.
        pstarkey:     
        pstarkey:     This function launches a Python thread in Daemon mode, and returns a 
        pstarkey:     reference to the running thread object.
        pstarkey:     
        pstarkey:     Arguments:
        pstarkey:         f: A reference to the target function to be executed in the Python thread.
        pstarkey:         
        pstarkey:         *args: Any arguments to pass to :code:`f` when it is executed in the 
        pstarkey:                new thread.
        pstarkey:         
        pstarkey:         **kwargs: Any keyword arguments to pass to :code:`f` when it is executed
        pstarkey:                   in the new thread.
        pstarkey:                   
        pstarkey:     Returns:
        pstarkey:         A reference to the (already running) Python thread object
        pstarkey:     """
        pstarkey:     thread = threading.Thread(target=f, args=args, kwargs=kwargs)
     janwerkmann:     thread.daemon = True
        pstarkey:     thread.start()
        pstarkey:     return thread
     janwerkmann: 
     janwerkmann: 
     janwerkmann: def inmain_decorator(wait_for_return=True, exceptions_in_main=True):
        pstarkey:     """ A decorator which enforces the execution of the decorated thread to occur in the MainThread.
        pstarkey:     
        pstarkey:     This decorator wraps the decorated function or method in either 
        pstarkey:     :func:`qtutils.invoke_in_main.inmain` or
        pstarkey:     :func:`qtutils.invoke_in_main.inmain_later`.
        pstarkey:     
        pstarkey:     Keyword Arguments:
        pstarkey:         wait_for_return: Specifies whether to use :code:`inmain` (if 
        pstarkey:                          :code:`True`) or :code:`inmain_later` (if
        pstarkey:                          :code:`False`).
        pstarkey:                          
        pstarkey:         exceptions_in_main: Specifies whether the exceptions should be raised
        pstarkey:                             in the main thread or not. This is ignored if
        pstarkey:                             :code:`wait_for_return=True`. If this is 
        pstarkey:                             :code:`False`, then exceptions may be silenced if
        pstarkey:                             you do not explicitly use
        pstarkey:                             :func:`qtutils.invoke_in_main.get_inmain_result`.
        pstarkey:                             
        pstarkey:     Returns:
        pstarkey:         The decorator returns a function that has wrapped the decorated function
        pstarkey:         in the appropriate call to :code:`inmain` or :code:`inmain_later` (if 
        pstarkey:         you are unfamiliar with how decorators work, please see the Python
        pstarkey:         documentation).
        pstarkey:         
        pstarkey:         When calling the decorated function, the result is either the result of 
        pstarkey:         the function executed in the MainThread (if :code:`wait_for_return=True`)
        pstarkey:         or a Python Queue to be used with 
        pstarkey:         :func:`qtutils.invoke_in_main.get_inmain_result` at a later time.
        pstarkey:         
        pstarkey:     """
        pstarkey:     def wrap(fn):
        pstarkey:         """A decorator which sets any function to always run in the main thread."""
        pstarkey:         @functools.wraps(fn)
     janwerkmann:         def f(*args, **kwargs):
        pstarkey:             if wait_for_return:
        pstarkey:                 return inmain(fn, *args, **kwargs)
        pstarkey:             return _in_main_later(fn, exceptions_in_main, *args, **kwargs)
        pstarkey:         return f
        pstarkey:     return wrap
     janwerkmann: 
     janwerkmann: 
     janwerkmann: if __name__ == '__main__':
        pstarkey:     import signal
     janwerkmann: 
        pstarkey:     def loop(index):
        pstarkey:         if index < 3:
     janwerkmann:             inthread(loop, index + 1)
        pstarkey:         while True:
        cbilling:             # print('MyThread-%d: %s'%(index,str(QThread.currentThread())))
        cbilling:             # print('MyThread-%d: %s'%(index,threading.current_thread().name))
     janwerkmann:             # another_function(index)
     janwerkmann:             inmain(myFunction, index)
     janwerkmann: 
        pstarkey:     def another_function(index):
     janwerkmann:         print('in thread-%d, running in thread: %s' % (index, threading.currentThread().name))
     janwerkmann: 
        pstarkey:     def myFunction(index):
     janwerkmann:         print('from thread-%d, running in thread: %s' % (index, threading.currentThread().name))
        pstarkey:         pass
     janwerkmann: 
        pstarkey:     def myFunction2():
     janwerkmann:         print('from MainThread, running in thread: %s' % (threading.currentThread().name))
     janwerkmann:         QTimer.singleShot(0, lambda: inmain(myFunction2))
        pstarkey: 
        pstarkey:     qapplication = QCoreApplication(sys.argv)
     janwerkmann: 
        pstarkey:     def sigint_handler(*args):
        pstarkey:         qapplication.quit()
     janwerkmann: 
        pstarkey:     signal.signal(signal.SIGINT, sigint_handler)
        pstarkey: 
        pstarkey:     thread = inthread(loop, 1)
     janwerkmann:     timer = QTimer.singleShot(0, lambda: inmain(myFunction2))
        pstarkey:     qapplication.exec_()
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # locking.py                                                        #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Christopher Billington, Philip Starkey            #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the qtutils project                          #
   pstarkey: # (see https://bitbucket.org/philipstarkey/qtutils )                #
   pstarkey: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
   pstarkey: # See the license.txt file in the root of the project               #
   pstarkey: # for the full license.                                             #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
   pstarkey: import threading
   pstarkey: 
   pstarkey: from qtutils.qt.QtCore import QEvent, QObject, QCoreApplication
janwerkmann: 
   pstarkey: 
   pstarkey: class BlockEvent(QEvent):
   pstarkey:     """An event requesting the mainloop to be blocked until further notice."""
   pstarkey:     EVENT_TYPE = QEvent.Type(QEvent.registerEventType())
janwerkmann: 
   pstarkey:     def __init__(self, blocked, unblock):
   pstarkey:         QEvent.__init__(self, self.EVENT_TYPE)
   pstarkey:         self.blocked = blocked
   pstarkey:         self.unblock = unblock
janwerkmann: 
janwerkmann: 
   pstarkey: class Blocker(QObject):
   pstarkey:     """An event handler which blocks until event.unblock is set."""
janwerkmann: 
   pstarkey:     def event(self, event):
   pstarkey:         event.blocked.set()
   pstarkey:         event.unblock.wait()
   pstarkey:         event.unblock.clear()
   pstarkey:         return True
janwerkmann: 
janwerkmann: 
   pstarkey: blocker = Blocker()
janwerkmann: 
janwerkmann: 
   pstarkey: class QtLock():
   pstarkey:     """A context manager which ensures that the Qt mainloop is doing
   pstarkey:     nothing. It does this by invoking a function call in the main thread
   pstarkey:     which simply blocks. Entering the context manager will block until
   pstarkey:     the main loop can be blocked, and exiting the context manager will
   pstarkey:     unblock the mainloop. If we are already in the main thread, the
   pstarkey:     context manager does nothing. Regardless of thread, it can be used
   pstarkey:     re-entrantly and is completely thread-safe."""
janwerkmann: 
   pstarkey:     def __init__(self):
   pstarkey:         # Thread local storage, to make our methods thread-safe without
   pstarkey:         # locking:
   pstarkey:         self.local = threading.local()
   pstarkey: 
   pstarkey:     def per_thread_init(self):
   pstarkey:         """Due to thread local storage, we couldn't initialise in __init__
   pstarkey:         for all threads. Each time a new thread is encountered by a
   pstarkey:         method, we create thread local attributes for it."""
   pstarkey:         if threading.current_thread().name == 'MainThread':
   pstarkey:             # The main thread does not need to block itself:
   pstarkey:             self.local.held = 1
   pstarkey:         else:
   pstarkey:             # Other threads will need to coordinate blocking the mainloop
   pstarkey:             # with threading.Event()s:
janwerkmann:             self.local.held = 0
   pstarkey:             self.local.blocked = threading.Event()
   pstarkey:             self.local.unblock = threading.Event()
janwerkmann: 
   pstarkey:     def held(self):
janwerkmann:         if not hasattr(self.local, 'held'):
   pstarkey:             self.per_thread_init()
   pstarkey:         return self.local.held
janwerkmann: 
   pstarkey:     def enforce(self, enable=True):
   pstarkey:         """Raises an exception when Qt method calls are made from a
   pstarkey:         non-main thread without the mainloop blocked. Only takes effect
   pstarkey:         on threads created after enforce() is called."""
   pstarkey:         def enforce(frame, event, func):
   pstarkey:             if event == 'c_call':
   pstarkey:                 if isinstance(func.__self__, QObject):
   pstarkey:                     if not self.held():
   pstarkey:                         message = 'qtlock was not acquired for this Qt call, and we are not in the main thread.'
   pstarkey:                         raise threading.ThreadError(message)
   pstarkey:         threading.setprofile(enforce if enable else None)
janwerkmann: 
   pstarkey:     def __enter__(self):
   pstarkey:         # Only block the mainloop if it is not already blocked:
   pstarkey:         if not self.held():
   pstarkey:             # Ask the mainloop to please process a BlockEvent when it gets the chance:
   pstarkey:             event = BlockEvent(self.local.blocked, self.local.unblock)
   pstarkey:             QCoreApplication.postEvent(blocker, event)
   pstarkey:             # Wait until the mainloop is blocked:
   pstarkey:             self.local.blocked.wait()
   pstarkey:             self.local.blocked.clear()
   pstarkey:         # Keep track of the re-entrance depth:
   pstarkey:         self.local.held += 1
janwerkmann: 
   cbilling:     def __exit__(self, *exc_info):
   pstarkey:         # Only unblock the mainloop if we've popped out of the outer-most
   pstarkey:         # context:
   pstarkey:         self.local.held -= 1
   pstarkey:         if not self.local.held:
   pstarkey:             self.local.unblock.set()
   pstarkey: 
janwerkmann: 
   pstarkey: qtlock = QtLock()
        cbilling: #####################################################################
        cbilling: #                                                                   #
        pstarkey: # outputbox.py                                                      #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Christopher Billington, Philip Starkey            #
        cbilling: #                                                                   #
        cbilling: # This file is part of the qtutils project                          #
        cbilling: # (see https://bitbucket.org/philipstarkey/qtutils )                #
        pstarkey: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
        cbilling: # See the license.txt file in the root of the project               #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: PY2 = sys.version_info[0] == 2
chrisjbillington: if PY2:
chrisjbillington:     chr = unichr
chrisjbillington: 
        cbilling: import threading
        cbilling: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
        cbilling: 
        cbilling: import zmq
        cbilling: from qtutils.auto_scroll_to_end import set_auto_scroll_to_end
        cbilling: from qtutils import *
chrisjbillington: import ast
        cbilling: 
chrisjbillington:     
        cbilling: # This should cover most platforms:
        cbilling: acceptable_fonts = ["Ubuntu mono",
        cbilling:                     "Courier 10 Pitch",
        cbilling:                     "Courier Std",
        cbilling:                     "Consolas",
        cbilling:                     "Courier",
        cbilling:                     "FreeMono",
        cbilling:                     "Nimbus Mono L",
        cbilling:                     "Courier New",
        cbilling:                     "monospace"]
        cbilling: 
        cbilling: 
chrisjbillington: GREY = GRAY = '#75715E' 
chrisjbillington: BACKGROUND = '#141411'
chrisjbillington: WHITE = '#FFFFFF'
chrisjbillington: RED = '#EF2020'
chrisjbillington: ORANGE = '#FD971F'
chrisjbillington: YELLOW = '#FCE94F'
chrisjbillington: GREEN = '#A6E22E'
chrisjbillington: BLUE = '#66D9EF'
chrisjbillington: PURPLE = '#AE81FF'
chrisjbillington: 
chrisjbillington: 
chrisjbillington: _charformats = {}
chrisjbillington: 
chrisjbillington: def charformats(charformat_repr):
chrisjbillington:     try:
chrisjbillington:         return _charformats[charformat_repr]
chrisjbillington:     except KeyError:
chrisjbillington:         pass
chrisjbillington:     try:
chrisjbillington:         color, bold, italic = ast.literal_eval(charformat_repr)
chrisjbillington:     except Exception:
chrisjbillington:         if charformat_repr == 'stderr':
chrisjbillington:             color, bold, italic = 'red', False, False
chrisjbillington:         else:
chrisjbillington:             # stdout, or invalid spec. Use plain font:
chrisjbillington:             color, bold, italic = WHITE, False, False
chrisjbillington:     try:
chrisjbillington:         qcolor = QColor(color)
chrisjbillington:     except Exception:
chrisjbillington:         # invalid color, use white:
chrisjbillington:         qcolor = QColor(WHITE)
chrisjbillington:     font = QFont("SomeMonoFont", 11)
chrisjbillington:     font.insertSubstitutions("SomeMonoFont", acceptable_fonts)
chrisjbillington:     font.setBold(bold)
chrisjbillington:     font.setItalic(italic)
chrisjbillington:     fmt = QTextCharFormat()
chrisjbillington:     fmt.setForeground(QBrush(qcolor))
chrisjbillington:     fmt.setFont(font)
chrisjbillington:     _charformats[color, bold, italic] = fmt
chrisjbillington:     return fmt
chrisjbillington: 
chrisjbillington: 
        cbilling: class OutputBox(object):
        cbilling: 
chrisjbillington:     def __init__(self, container, scrollback_lines=1000,
chrisjbillington:                  zmq_context=None, bind_address='tcp://127.0.0.1'):
chrisjbillington:         """Instantiate an outputBox and insert into container widget. Set the
chrisjbillington:         number of lines of scrollback to keep. Set a zmq_context for creating
chrisjbillington:         sockets, otherwise zmq.Context.instance() will be used. set
chrisjbillington:         bind_address, defaulting to the local interface."""
        cbilling:         self.output_textedit = QPlainTextEdit()
        cbilling:         container.addWidget(self.output_textedit)
        cbilling:         self.output_textedit.setReadOnly(True)
        cbilling:         palette = self.output_textedit.palette()
chrisjbillington:         palette.setColor(QPalette.Base, QColor(BACKGROUND))
        cbilling:         self.output_textedit.setPalette(palette)
        cbilling: 
        cbilling:         self.output_textedit.setBackgroundVisible(False)
        cbilling:         self.output_textedit.setWordWrapMode(QTextOption.WrapAnywhere)
        cbilling:         set_auto_scroll_to_end(self.output_textedit.verticalScrollBar())
        cbilling:         self.output_textedit.setMaximumBlockCount(scrollback_lines)
        cbilling: 
        cbilling:         # Keeping track of whether the output is in the middle of a line
        cbilling:         # or not:
        cbilling:         self.mid_line = False
        cbilling: 
chrisjbillington:         if zmq_context is None:
chrisjbillington:             zmq_context = zmq.Context.instance()
chrisjbillington:         self.zmq_context = zmq_context
chrisjbillington: 
chrisjbillington:         socket = self.zmq_context.socket(zmq.PULL)
        cbilling:         socket.setsockopt(zmq.LINGER, 0)
        cbilling: 
chrisjbillington:         self.port = socket.bind_to_random_port(bind_address)
        cbilling: 
        cbilling:         # Thread-local storage so we can have one push_sock per thread.
        cbilling:         # push_sock is for sending data to the output queue in a non-blocking
        cbilling:         # way from the same process as this object is instantiated in.
        cbilling:         # Providing the function OutputBox.output() for this is much easier
        cbilling:         # than expecting every thread to have its own push socket that the
        cbilling:         # user has to manage. Also we can't give callers direct access to the
        cbilling:         # output code, because then it matters whether they're in the GUI main
        cbilling:         # thread or not. We could decorate it with inmain_decorator, but it is
        cbilling:         # still useful for the all threads and processed to send to the same
        cbilling:         # zmq socket - it keeps messages in order, nobody 'jumps the queue' so
        cbilling:         # to speak.
        cbilling:         self.local = threading.local()
        cbilling: 
        cbilling:         self.mainloop = threading.Thread(target=self.mainloop, args=(socket,))
        cbilling:         self.mainloop.daemon = True
        cbilling:         self.mainloop.start()
        cbilling: 
        cbilling:     def new_socket(self):
        cbilling:         # One socket per thread, so we don't have to acquire a lock
        cbilling:         # to send:
chrisjbillington:         self.local.push_sock = self.zmq_context.socket(zmq.PUSH)
chrisjbillington:         self.local.push_sock.connect('tcp://127.0.0.1:%d' % self.port)
        cbilling: 
chrisjbillington:     def write(self, text, color=WHITE, bold=False, italic=False):
chrisjbillington:         """Write to the output box as if it were a file. Takes a string as
chrisjbillington:         does not append newlines or anything else. use OutputBox.print() for
chrisjbillington:         an interface more like the Python print() function."""
        cbilling:         if not hasattr(self.local, 'push_sock'):
        cbilling:             self.new_socket()
        cbilling:         # Queue the output on the socket:
chrisjbillington:         charformat = repr((color, bold, italic)).encode('utf8')
chrisjbillington:         self.local.push_sock.send_multipart([charformat, text.encode('utf8')])
chrisjbillington: 
chrisjbillington:     def print(self, *values, **kwargs):
chrisjbillington:         """Print to the output box. This method accepts the same arguments as
chrisjbillington:         the Python print function. If file=sys.stderr, the output will be red
chrisjbillington:         and bold. If it is absent or sys.stdout, it will be white. Anything
chrisjbillington:         else is an exception. The 'color' and 'bold' keyword arguments if
chrisjbillington:         provided will override the settings inferred from the file keyword
chrisjbillington:         argument."""
chrisjbillington: 
chrisjbillington:         sep = kwargs.pop('sep', None)
chrisjbillington:         end = kwargs.pop('end', None)
chrisjbillington:         file = kwargs.pop('file', None)
chrisjbillington: 
chrisjbillington:         if sep is None:
chrisjbillington:             sep = ' '
chrisjbillington:         if end is None:
chrisjbillington:             end = '\n'
chrisjbillington:         if file is None:
chrisjbillington:             file = sys.stdout
chrisjbillington: 
chrisjbillington:         
chrisjbillington: 
chrisjbillington:         if file is sys.stdout:
chrisjbillington:             color = WHITE
chrisjbillington:             bold = False
chrisjbillington:         elif file is sys.stderr:
chrisjbillington:             color = 'red'
chrisjbillington:             bold = False
chrisjbillington:         else:
chrisjbillington:             msg = 'file argument for OutputBox.print() must be stdout or stderr'
chrisjbillington:             raise ValueError(msg)
chrisjbillington:         bold = kwargs.pop('bold', bold)
chrisjbillington:         color = kwargs.pop('color', color)
chrisjbillington:         italic = kwargs.pop('italic', False)
chrisjbillington:         self.write(sep.join(str(s) for s in values) + end, color=color, bold=bold, italic=italic)
chrisjbillington: 
chrisjbillington:     def output(self, text, red=False):
chrisjbillington:         """Wrapper around write() with only option for normal text or bold red
chrisjbillington:         text, retained for backward compatibility but deprecated."""
chrisjbillington:         if red:
chrisjbillington:             color = 'red'
chrisjbillington:             bold = False
chrisjbillington:         else:
chrisjbillington:             color = WHITE
chrisjbillington:             bold = False
chrisjbillington:         self.write(text, color=color, bold=bold)
        cbilling: 
        cbilling:     def mainloop(self, socket):
        cbilling:         while True:
        cbilling:             messages = []
chrisjbillington:             current_charformat = None
        cbilling:             # Wait for messages
        cbilling:             socket.poll()
        cbilling:             # Get all messages waiting in the pipe, concatenate strings to
        cbilling:             # reduce the number of times we call add_text (which requires posting
        cbilling:             # to the qt main thread, which can be a bottleneck when there is a lot of output)
        cbilling:             while True:
        cbilling:                 try:
chrisjbillington:                     charformat_repr, text = socket.recv_multipart(zmq.NOBLOCK)
        cbilling:                 except zmq.Again:
        cbilling:                     break
chrisjbillington:                 if charformat_repr != current_charformat:
chrisjbillington:                     current_charformat = charformat_repr
        cbilling:                     current_message = []
chrisjbillington:                     messages.append((current_charformat, current_message))
        cbilling:                 current_message.append(text)
chrisjbillington:             for charformat_repr, message in messages:
chrisjbillington:                 text = b''.join(message).decode('utf8')
chrisjbillington:                 self.add_text(text, charformat_repr.decode('utf8'))
        cbilling: 
        cbilling:     @inmain_decorator(True)
chrisjbillington:     def add_text(self, text, charformat_repr):
        cbilling:         # The convoluted logic below is because we want a few things that
        cbilling:         # conflict slightly. Firstly, we want to take advantage of our
        cbilling:         # setMaximumBlockCount setting; Qt will automatically remove old
        cbilling:         # lines, but only if each line is a separate 'block'. So each line has
        cbilling:         # to be inserted with appendPlainText - this appends a new block.
        cbilling:         # However, we also want to support partial lines coming in, and we
        cbilling:         # want to print that partial line without waiting until we have the
        cbilling:         # full line. So we keep track (with the instance variable
        cbilling:         # self.mid_line) whether we are in the middle of a line or not, and if
        cbilling:         # we are we call insertText, which does *not* start a new block.
        cbilling:         cursor = self.output_textedit.textCursor()
        cbilling:         lines = text.split('\n')
        cbilling:         if self.mid_line:
        cbilling:             first_line = lines.pop(0)
        cbilling:             cursor = self.output_textedit.textCursor()
        cbilling:             cursor.movePosition(QTextCursor.End)
        cbilling:             cursor.insertText(first_line)
        cbilling:         for line in lines[:-1]:
        cbilling:             self.output_textedit.appendPlainText(line)
        cbilling:         if lines:
        cbilling:             last_line = lines[-1]
        cbilling:             if last_line:
        cbilling:                 self.output_textedit.appendPlainText(last_line)
        cbilling:                 self.mid_line = True
        cbilling:             else:
        cbilling:                 self.mid_line = False
        cbilling: 
        cbilling:         n_chars_printed = len(text)
        cbilling:         if not self.mid_line:
        cbilling:             n_chars_printed -= 1  # Because we didn't print the final newline character
        cbilling:         cursor.movePosition(QTextCursor.End)
        cbilling:         cursor.movePosition(QTextCursor.PreviousCharacter, n=n_chars_printed)
        cbilling:         cursor.movePosition(QTextCursor.End, mode=QTextCursor.KeepAnchor)
chrisjbillington:         cursor.setCharFormat(charformats(charformat_repr))
        cbilling: 
     janwerkmann: 
        cbilling: if __name__ == '__main__':
        cbilling:     import sys
        cbilling:     app = QApplication(sys.argv)
        cbilling:     window = QWidget()
        cbilling:     layout = QVBoxLayout(window)
        cbilling: 
        cbilling:     output_box = OutputBox(layout)
chrisjbillington: 
        cbilling:     for i in range(3):
chrisjbillington:         output_box.write('white, two line breaks.\n\n')
chrisjbillington:         output_box.write('white, no linebreak.')
chrisjbillington:         output_box.write('Red.\n', color='red')
chrisjbillington:         output_box.output('Red with the deprecated function.\n', red=True)
chrisjbillington:         output_box.write('More red, also bold.\n', color='red', bold=True)
chrisjbillington:         output_box.write('The \"quick white fox\" jumped over the \'lazy\' dog\n')
chrisjbillington:         output_box.write('<The bold, green, italic fox jumped over the lazy dog>\n', color=GREEN, bold=True, italic=True)
chrisjbillington:         output_box.write(b'Der schnelle braune Fuchs ist \xc3\xbcber den faulen Hund gesprungen\n'.decode('utf8'))
chrisjbillington: 
chrisjbillington:         output_box.print("print test")
chrisjbillington:         output_box.print("stderr", "test", 123, file=sys.stderr)
chrisjbillington: 
chrisjbillington:         output_box.print()
chrisjbillington: 
chrisjbillington:     for i in range(3):
chrisjbillington:         output_box.print('This is just some info from runmanager in bold blue', bold=True, italic=True, color=BLUE)
chrisjbillington:         output_box.print('Some more info in a subdued grey', italic=True, color=GREY)
chrisjbillington: 
chrisjbillington:     for i in range(2):
chrisjbillington:         output_box.print('\nthis is runmanager running your script in purple', color=PURPLE)
chrisjbillington:         for j in range(5):
chrisjbillington:             output_box.print('The \"quick white fox\" jumped over the \'lazy\' dog')
chrisjbillington:         if i:
chrisjbillington:             output_box.print("RunTimeError('your script broke')", file=sys.stderr)
chrisjbillington:             output_box.print('it failed in bold red', color=RED, bold=True, italic=True)
chrisjbillington:         else:
chrisjbillington:             output_box.print("Your script worked fine")
chrisjbillington:             output_box.print('it worked in green', color=GREEN, italic=True)
chrisjbillington:             output_box.print('submitting to BLACS in yellow...', color=YELLOW, italic=True, end='')
chrisjbillington:             output_box.print('success in bold green', color=GREEN, bold=True, italic=True)
chrisjbillington:             output_box.print('warning: queue is paused in orange', color=ORANGE, italic=True)
chrisjbillington:             
        cbilling: 
        cbilling:     def button_pushed(*args, **kwargs):
        cbilling:         import random
        cbilling:         uchars = [random.randint(0x20, 0x7e) for _ in range(random.randint(0, 50))]
        cbilling:         ustr = u''
        cbilling:         for uc in uchars:
chrisjbillington:             ustr += chr(uc)
        cbilling:         red = random.randint(0, 1)
        cbilling:         newline = random.randint(0, 1)
chrisjbillington:         hex = __builtins__.hex
chrisjbillington:         color = '#' + hex(random.randint(0, 0xffffff))[2:]
chrisjbillington:         bold = random.randint(0, 1)
chrisjbillington:         italic = random.randint(0, 1)
chrisjbillington:         output_box.write(ustr + ('\n' if newline else ''), color=color, bold=bold, italic=italic)
        cbilling: 
        cbilling:     button = QPushButton("push me to output random text")
        cbilling:     button.clicked.connect(button_pushed)
        cbilling:     layout.addWidget(button)
        cbilling: 
        cbilling:     window.show()
        cbilling:     window.resize(500, 500)
        cbilling: 
        cbilling:     def run():
        cbilling:         app.exec_()
        cbilling: 
        cbilling:     sys.exit(run())
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # qsettings_wrapper.py                                              #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Christopher Billington, Philip Starkey            #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the qtutils project                          #
   pstarkey: # (see https://bitbucket.org/philipstarkey/qtutils )                #
   pstarkey: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
   pstarkey: # See the license.txt file in the root of the project               #
   pstarkey: # for the full license.                                             #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
janwerkmann: from qtutils.qt.QtCore import QSettings
   cbilling: 
   pstarkey: import ast
   pstarkey: 
   cbilling: from qtutils import inmain_decorator
   cbilling: 
janwerkmann: 
   pstarkey: class type_with_properties(type):
   pstarkey:     """A metaclass to create properties for a class based on the contents
   pstarkey:     of its a class _fields. _fields should be a list of strings. At
   pstarkey:     class creation, property getters and setters will be created,
   pstarkey:     hooking each name up to _get and _set class methods."""
   pstarkey:     def __init__(cls, name, superclasses, attrs):
   pstarkey:         type.__init__(cls, name, superclasses, attrs)
   pstarkey:         for name in cls._fields:
   pstarkey:             method = property(lambda self, name=name: cls._get(self, name),
   pstarkey:                               lambda self, value, name=name: cls._set(self, name, value))
   pstarkey:             setattr(cls, name, method)
janwerkmann: 
janwerkmann: 
   pstarkey: class QSettingsWrapper(object):
   pstarkey:     """A class that wraps QSettings to provide automatic type conversion
   pstarkey:     and reduce the need for boilerplace code"""
   pstarkey:     __metaclass__ = type_with_properties
janwerkmann:     _fields = []  # to be overridden by subclasses
janwerkmann: 
   pstarkey:     def __init__(self, companyname, appname):
   pstarkey:         self._qsettings = QSettings(companyname, appname)
   pstarkey:         # set default values to None:
   pstarkey:         for name in self._fields:
   pstarkey:             if not self._qsettings.contains(name):
   pstarkey:                 self._set(name, None)
janwerkmann: 
   cbilling:     @inmain_decorator()
   pstarkey:     def _get(self, name):
   pstarkey:         valrepr = self._qsettings.value(name)
   pstarkey:         return ast.literal_eval(valrepr)
janwerkmann: 
   cbilling:     @inmain_decorator()
   pstarkey:     def _set(self, name, value):
   pstarkey:         valrepr = repr(value)
   pstarkey:         try:
   pstarkey:             assert value == ast.literal_eval(valrepr)
   pstarkey:         except (ValueError, AssertionError, SyntaxError):
   pstarkey:             raise ValueError('Value too complex to store. Can only store values for which x == ast.literal_eval(repr(x))')
   pstarkey:         self._qsettings.setValue(name, valrepr)
   pstarkey:         self._qsettings.sync()
janwerkmann: 
janwerkmann: 
   pstarkey: if __name__ == '__main__':
janwerkmann: 
   pstarkey:     # Test and example implementation
janwerkmann: 
   pstarkey:     class TestSettings(QSettingsWrapper):
   pstarkey:         _fields = ['test']
janwerkmann: 
   pstarkey:         def __init__(self):
   pstarkey:             QSettingsWrapper.__init__(self, 'test', 'test')
janwerkmann: 
   pstarkey:     s = TestSettings()
   pstarkey:     s.test = 5
   pstarkey:     assert s.test == 5
   pstarkey:     s.test += 2
   pstarkey:     assert s.test == 7
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # qt.py                                                             #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2017, Jan Werkmann                                      #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the qtutils project                          #
janwerkmann: # (see https://bitbucket.org/philipstarkey/qtutils )                #
janwerkmann: # and is licensed under the 2-clause, or 3-clause, BSD License.     #
janwerkmann: # See the license.txt file in the root of the project               #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: # The purpose of this wrapper is to provide a abstraction layer     #
janwerkmann: # around the different versions of QtGui, QtCore and QtWidgets.     #
janwerkmann: # The warpper is supposed to act like PyQt5, but might need         #
janwerkmann: # addition in some cases.                                           #
janwerkmann: #####################################################################
janwerkmann: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
janwerkmann: import sys
janwerkmann: 
janwerkmann: PYSIDE = 'PySide'
janwerkmann: PYQT4 = 'PyQt4'
janwerkmann: PYQT5 = 'PyQt5'
janwerkmann: QT_ENV = None
janwerkmann: 
janwerkmann: 
janwerkmann: def set_pyqt4_api():
janwerkmann:     import sip
janwerkmann:     # This must be done before importing PyQt4:
janwerkmann:     API_NAMES = ["QDate", "QDateTime", "QString", "QTextStream", "QTime", "QUrl", "QVariant"]
janwerkmann:     API_VERSION = 2
janwerkmann:     for name in API_NAMES:
janwerkmann:         try:
janwerkmann:             sip.setapi(name, API_VERSION)
janwerkmann:         except ValueError:
janwerkmann:             pass
janwerkmann: 
janwerkmann: 
janwerkmann: def check_pyqt4_api():
janwerkmann:     """If PyQt4 was already imported before we got a chance to set API version
janwerkmann:     2, ensure the API versions are either not set, or set to version 2.
janwerkmann:     Otherwise confusing errors may occur later - better to catch this now"""
janwerkmann:     import sip
janwerkmann:     API_NAMES = ["QDate", "QDateTime", "QString", "QTextStream", "QTime", "QUrl", "QVariant"]
janwerkmann:     API_VERSION = 2
janwerkmann:     for name in API_NAMES:
janwerkmann:         try:
janwerkmann:             if sip.getapi(name) != API_VERSION:
janwerkmann:                 msg = ("qtutils is only compatible with version 2 of the  PyQt4 API." +
janwerkmann:                        "Whilst you can import PyQt4 prior to importing qtutils (in order to tell qtutils " +
janwerkmann:                        "to use PyQt4), either set the API version to 2 yourself, or import qtutils " +
janwerkmann:                        "(which will set it for you) prior to importing QtGui or QtCore.")
janwerkmann:                 raise RuntimeError(msg)
janwerkmann:         except ValueError:
janwerkmann:             # API version not set yet.
janwerkmann:             pass
janwerkmann: 
janwerkmann: 
janwerkmann: libs = [PYQT5, PYQT4, PYSIDE]
janwerkmann: for lib in libs:
janwerkmann:     if lib in sys.modules:
janwerkmann:         QT_ENV = lib
janwerkmann:         if lib == PYQT4:
janwerkmann:             check_pyqt4_api()
janwerkmann:             set_pyqt4_api()
janwerkmann:         break
janwerkmann: else:
janwerkmann:     for lib in libs:
janwerkmann:         if lib == PYQT4:
janwerkmann:             # Have to set pyqt API v2 before importing PyQt4:
janwerkmann:             set_pyqt4_api()
janwerkmann:         try:
janwerkmann:             __import__(lib)
janwerkmann:             QT_ENV = lib
janwerkmann:             break
janwerkmann:         except ImportError:
janwerkmann:             pass
janwerkmann: 
janwerkmann: if QT_ENV is None:
janwerkmann:     raise Exception("No Qt Enviroment was detected!")
janwerkmann: 
janwerkmann: if QT_ENV == PYQT5:
janwerkmann:     from PyQt5 import QtGui, QtCore, QtWidgets
janwerkmann: else:
janwerkmann:     if QT_ENV == PYQT4:
janwerkmann:         from PyQt4 import QtGui, QtCore
janwerkmann: 
janwerkmann:     elif QT_ENV == PYSIDE:
janwerkmann:         from PySide import QtGui, QtCore
janwerkmann:         import PySide
janwerkmann:         QtCore.QT_VERSION_STR = PySide.QtCore.__version__
janwerkmann:         QtCore.PYQT_VERSION_STR = PySide.__version__
janwerkmann: 
janwerkmann:     # Allow the methods that have been renamed in Qt5 to be accessed by their
janwerkmann:     # Qt5 names:
janwerkmann:     QtGui.QHeaderView.setSectionsMovable = QtGui.QHeaderView.__dict__["setMovable"]
janwerkmann:     QtGui.QHeaderView.setSectionsClickable = QtGui.QHeaderView.__dict__["setClickable"]
janwerkmann:     QtGui.QHeaderView.setSectionResizeMode = QtGui.QHeaderView.__dict__["setResizeMode"]
janwerkmann: 
janwerkmann:     if QT_ENV == PYQT4:
janwerkmann:         # Pyside does not have the methods ending in "-AndFilter":
janwerkmann:         QtGui.QFileDialog.getOpenFileName = QtGui.QFileDialog.__dict__["getOpenFileNameAndFilter"]
janwerkmann:         QtGui.QFileDialog.getOpenFileNames = QtGui.QFileDialog.__dict__["getOpenFileNamesAndFilter"]
janwerkmann:         QtGui.QFileDialog.getSaveFileName = QtGui.QFileDialog.__dict__["getSaveFileNameAndFilter"]
janwerkmann: 
janwerkmann:     QtWidgets = QtGui
janwerkmann:     QtCore.QSortFilterProxyModel = QtGui.QSortFilterProxyModel
janwerkmann:     QtCore.QItemSelectionModel = QtGui.QItemSelectionModel
janwerkmann:     QtWidgets.QStyleOptionProgressBar = QtGui.QStyleOptionProgressBarV2
janwerkmann:     QtWidgets.QStyleOptionTab = QtGui.QStyleOptionTabV3
janwerkmann:     QtWidgets.QStyleOptionViewItem = QtGui.QStyleOptionViewItemV4
janwerkmann:     QtCore.qInstallMessageHandler = QtCore.qInstallMsgHandler
janwerkmann: 
janwerkmann: sys.modules['qtutils.qt.QtGui'] = QtGui
janwerkmann: sys.modules['qtutils.qt.QtWidgets'] = QtWidgets
janwerkmann: sys.modules['qtutils.qt.QtCore'] = QtCore
        pstarkey: #!/usr/bin/env python
        pstarkey: 
        pstarkey: # To upload a version to PyPI, run:
        pstarkey: #
        pstarkey: #    python setup.py sdist upload
        pstarkey: #
        pstarkey: # If the package is not registered with PyPI yet, do so with:
        pstarkey: #
        pstarkey: # python setup.py register
        pstarkey: 
        cbilling: from __future__ import absolute_import, print_function
        pstarkey: from distutils.core import setup
        cbilling: import sys
        pstarkey: import os
        pstarkey: 
     janwerkmann: BUILD_PYQT5_ICONS_RESOURCE = True
        cbilling: BUILD_PYQT4_ICONS_RESOURCE = True
        cbilling: BUILD_PYSIDE_ICONS_RESOURCE = True
        cbilling: 
        cbilling: if 'NO_PYSIDE' in sys.argv:
     janwerkmann:     sys.argv.remove('NO_PYSIDE')
     janwerkmann:     BUILD_PYSIDE_ICONS_RESOURCE = False
        cbilling: if 'NO_PYQT4' in sys.argv:
     janwerkmann:     BUILD_PYQT4_ICONS_RESOURCE = False
     janwerkmann:     sys.argv.remove('NO_PYQT4')
     janwerkmann: if 'NO_PYQT5' in sys.argv:
     janwerkmann:     BUILD_PYQT5_ICONS_RESOURCE = False
     janwerkmann:     sys.argv.remove('NO_PYQT5')
        cbilling: 
chrisjbillington: VERSION = '2.1.0'
        cbilling: 
        pstarkey: # conditional for readthedocs environment
        pstarkey: on_rtd = os.environ.get('READTHEDOCS') == 'True'
        pstarkey: if not on_rtd:
        pstarkey:     # Do the build process for icon resource files, this will only do anything
        pstarkey:     # if the files are not already present.  The idea is that someone like me
        pstarkey:     # will run this during sdist, upload the results to PyPI, and then the
        pstarkey:     # files should already be there for those installing via easy_install
        pstarkey:     # or pip. So those people will not require pyside-rcc or pyrcc4 on
        pstarkey:     # their systems in order to install icon support for both PyQt4 and
        pstarkey:     # Pyside. Those installing from an hg clone however will have to have
        pstarkey:     # pyside-rcc and pyrcc4 installed for the following to work, or they
        pstarkey:     # can disable one of the via the boolean flags at the top of this file.
        pstarkey:     print('building qt icon resource files ...')
        pstarkey:     sys.path.insert(0, 'qtutils/icons')
        pstarkey:     import _build
        pstarkey:     if BUILD_PYQT5_ICONS_RESOURCE:
        pstarkey:         _build.pyqt5()
        pstarkey:     if BUILD_PYQT4_ICONS_RESOURCE:
        pstarkey:         _build.pyqt4()
        pstarkey:     if BUILD_PYSIDE_ICONS_RESOURCE:
        pstarkey:         _build.pyside()
        pstarkey:     print('done')
        pstarkey: else:
        pstarkey:     print('Skipping icon building on readthedocs...')
        cbilling: 
        pstarkey: # Auto generate a __version__ package for the package to import
        pstarkey: with open(os.path.join('qtutils', '__version__.py'), 'w') as f:
     janwerkmann:     f.write("__version__ = '%s'\n" % VERSION)
        cbilling: 
        pstarkey: setup(name='qtutils',
        pstarkey:       version=VERSION,
        cbilling:       description='Utilities for providing concurrent access to Qt objects, simplified QSettings storage, and dynamic widget promotion when loading UI files, in Python Qt applications. Also includes the Fugue icon set, by Yusuke Kamiyamane',
        pstarkey:       author='Philip Starkey',
        pstarkey:       author_email='threepineapples@gmail.com',
        pstarkey:       url='https://bitbucket.org/philipstarkey/qtutils',
        pstarkey:       license="2-clause BSD, 3-clause BSD (see LICENSE.TXT for full conditions)",
        cbilling:       packages=['qtutils', 'qtutils.icons'],
        cbilling:       package_data={'qtutils.icons':
        cbilling:                     ['custom/*',
        cbilling:                      'fugue/*',
        cbilling:                      'icons.qrc',
        cbilling:                      'README.txt']}
     janwerkmann:       )
