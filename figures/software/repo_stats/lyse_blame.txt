        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /__init__.py                                                      #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program lyse, in the labscript suite     #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
        pstarkey: 
           Chris: from __future__ import division, unicode_literals, print_function, absolute_import
           Chris:     
           Chris: from lyse.dataframe_utilities import get_series_from_shot as _get_singleshot, dict_diff
        pstarkey: import os
        pstarkey: import socket
        pstarkey: import pickle as pickle
        pstarkey: import inspect
        pstarkey: import sys
        pstarkey: 
        pstarkey: import labscript_utils.h5_lock, h5py
     janwerkmann: from labscript_utils.labconfig import LabConfig
        pstarkey: import pandas
        cbilling: from numpy import array, ndarray
        pstarkey: import types
        pstarkey: 
        pstarkey: from zprocess import zmq_get
        pstarkey: 
           Chris: __version__ = '2.2.0'
        cbilling: 
          rander: try:
          rander:     from labscript_utils import check_version
          rander: except ImportError:
          rander:     raise ImportError('Require labscript_utils > 2.1.0')
          rander: 
          rander: # require pandas v0.15.0 up to the next major version
           Chris: check_version('pandas', '0.15.0', '1.0')
           Chris: check_version('zprocess', '2.2.0', '3.0')
chrisjbillington: check_version('labscript_utils', '2.6', '3.0')
           Chris: from labscript_utils import PY2
           Chris: if PY2:
           Chris:     str = unicode
          rander: 
        cbilling: # If running stand-alone, and not from within lyse, the below two variables
        cbilling: # will be as follows. Otherwise lyse will override them with spinning_top =
        cbilling: # True and path <name of hdf5 file being analysed>:
        cbilling: spinning_top = False
             jan: # data to be sent back to the lyse GUI if running within lyse
             jan: _updated_data = {}
        cbilling: 
     janwerkmann: # get port that lyse is using for communication
     janwerkmann: try:
     janwerkmann:     _labconfig = LabConfig(required_params={"ports": ["lyse"]})
     janwerkmann:     _lyse_port = int(_labconfig.get('ports', 'lyse'))
     janwerkmann: except Exception:
     janwerkmann:     _lyse_port = 42519
     janwerkmann: 
        cbilling: if len(sys.argv) > 1:
        cbilling:     path = sys.argv[1]
        cbilling: else:
        cbilling:     path = None
        cbilling: 
        cbilling: 
           Chris: class _RoutineStorage(object):
chrisjbillington:     """An empty object that analysis routines can store data in. It will
chrisjbillington:     persist from one run of an analysis routine to the next when the routine
chrisjbillington:     is being run from within lyse. No attempt is made to store data to disk,
chrisjbillington:     so if the routine is run multiple times from the command line instead of
chrisjbillington:     from lyse, or the lyse analysis subprocess is restarted, data will not be
chrisjbillington:     retained. An alternate method should be used to store data if desired in
chrisjbillington:     these cases."""
chrisjbillington:     pass
chrisjbillington: 
           Chris: routine_storage = _RoutineStorage()
chrisjbillington: 
chrisjbillington: 
     janwerkmann: def data(filepath=None, host='localhost', port=_lyse_port, timeout=5):
        pstarkey:     if filepath is not None:
        pstarkey:         return _get_singleshot(filepath)
        pstarkey:     else:
     janwerkmann:         df = zmq_get(port, host, 'get dataframe', timeout)
        pstarkey:         try:
        cbilling:             padding = ('',)*(df.columns.nlevels - 1)
          rander:             try:
          rander:                 integer_indexing = _labconfig.getboolean('lyse', 'integer_indexing')
          rander:             except (LabConfig.NoOptionError, LabConfig.NoSectionError):
          rander:                 integer_indexing = False
          rander:             if integer_indexing:
          rander:                 df.set_index(['sequence_index', 'run number', 'run repeat'], inplace=True, drop=False)
          rander:             else:
          rander:                 df.set_index([('sequence',) + padding,('run time',) + padding], inplace=True, drop=False)
          rander:                 df.index.names = ['sequence', 'run time']
        pstarkey:         except KeyError:
          rander:             # Empty DataFrame or index column not found, so fall back to RangeIndex instead
        pstarkey:             pass
        pstarkey:         df.sort_index(inplace=True)
        pstarkey:         return df
        pstarkey:         
        pstarkey: def globals_diff(run1, run2, group=None):
        pstarkey:     return dict_diff(run1.get_globals(group), run2.get_globals(group))
        pstarkey:  
        pstarkey: class Run(object):
        pstarkey:     def __init__(self,h5_path,no_write=False):
        pstarkey:         self.no_write = no_write
        pstarkey:         self.h5_path = h5_path
        pstarkey:         if not self.no_write:
        pstarkey:             with h5py.File(h5_path) as h5_file:
        pstarkey:                 if not 'results' in h5_file:
        pstarkey:                      h5_file.create_group('results')
        pstarkey:                      
        pstarkey:         try:
        pstarkey:             if not self.no_write:
        pstarkey:                 # The group were this run's results will be stored in the h5 file
        pstarkey:                 # will be the name of the python script which is instantiating
        pstarkey:                 # this Run object:
        pstarkey:                 frame = inspect.currentframe()
        pstarkey:                 __file__ = frame.f_back.f_locals['__file__']
           Chris:                 if PY2:
chrisjbillington:                     __file__ = __file__.decode(sys.getfilesystemencoding())
chrisjbillington:                     print(repr(__file__))
        pstarkey:                 self.group = os.path.basename(__file__).split('.py')[0]
        pstarkey:                 with h5py.File(h5_path) as h5_file:
        pstarkey:                     if not self.group in h5_file['results']:
        pstarkey:                          h5_file['results'].create_group(self.group)
        pstarkey:         except KeyError:
        pstarkey:             # sys.stderr.write('Warning: to write results, call '
        pstarkey:             # 'Run.set_group(groupname), specifying the name of the group '
        pstarkey:             # 'you would like to save results to. This normally comes from '
        pstarkey:             # 'the filename of your script, but since you\'re in interactive '
        pstarkey:             # 'mode, there is no scipt name. Opening in read only mode for '
        pstarkey:             # 'the moment.\n')
        pstarkey:             self.no_write = True
        pstarkey:             
        pstarkey:     def set_group(self, groupname):
        pstarkey:         self.group = groupname
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             if not self.group in h5_file['results']:
        pstarkey:                  h5_file['results'].create_group(self.group)
        pstarkey:         self.no_write = False
        pstarkey: 
        pstarkey:     def trace_names(self):
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             try:
chrisjbillington:                 return list(h5_file['data']['traces'].keys())
        pstarkey:             except KeyError:
        pstarkey:                 return []
        pstarkey: 
        pstarkey:     def get_trace(self,name):
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             if not name in h5_file['data']['traces']:
        pstarkey:                 raise Exception('The trace \'%s\' doesn not exist'%name)
        pstarkey:             trace = h5_file['data']['traces'][name]
        pstarkey:             return array(trace['t'],dtype=float),array(trace['values'],dtype=float)         
        pstarkey: 
        pstarkey:     def get_result_array(self,group,name):
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             if not group in h5_file['results']:
        pstarkey:                 raise Exception('The result group \'%s\' doesn not exist'%group)
        pstarkey:             if not name in h5_file['results'][group]:
        pstarkey:                 raise Exception('The result array \'%s\' doesn not exist'%name)
        pstarkey:             return array(h5_file['results'][group][name])
        pstarkey:             
        pstarkey:     def save_result(self, name, value, group=None, overwrite=True):
        pstarkey:         if self.no_write:
        pstarkey:             raise Exception('This run is read-only. '
        pstarkey:                             'You can\'t save results to runs through a '
        pstarkey:                             'Sequence object. Per-run analysis should be done '
        pstarkey:                             'in single-shot analysis routines, in which a '
        pstarkey:                             'single Run object is used')
        pstarkey:         with h5py.File(self.h5_path,'a') as h5_file:
        pstarkey:             if not group:
        pstarkey:                 # Save to analysis results group by default
        pstarkey:                 group = 'results/' + self.group
        pstarkey:             elif not group in h5_file:
        pstarkey:                 # Create the group if it doesn't exist
        pstarkey:                 h5_file.create_group(group) 
chrisjbillington:             if name in h5_file[group].attrs and not overwrite:
        pstarkey:                 raise Exception('Attribute %s exists in group %s. ' \
        pstarkey:                                 'Use overwrite=True to overwrite.' % (name, group))                   
           Chris:             h5_file[group].attrs[name] = value
             jan:             
             jan:         if spinning_top:
             jan:             if self.h5_path not in _updated_data:
             jan:                 _updated_data[self.h5_path] = {}
     janwerkmann:             _updated_data[self.h5_path][str(self.group), name] = value
     janwerkmann: 
        pstarkey:     def save_result_array(self, name, data, group=None, overwrite=True, keep_attrs=False):
        pstarkey:         if self.no_write:
        pstarkey:             raise Exception('This run is read-only. '
        pstarkey:                             'You can\'t save results to runs through a '
        pstarkey:                             'Sequence object. Per-run analysis should be done '
        pstarkey:                             'in single-shot analysis routines, in which a '
        pstarkey:                             'single Run object is used')
        pstarkey:         with h5py.File(self.h5_path, 'a') as h5_file:
        pstarkey:             attrs = {}
        pstarkey:             if not group:
        pstarkey:                 # Save dataset to results group by default
        pstarkey:                 group = 'results/' + self.group
        pstarkey:             elif not group in h5_file:
        pstarkey:                 # Create the group if it doesn't exist
        pstarkey:                 h5_file.create_group(group) 
        pstarkey:             if name in h5_file[group]:
        pstarkey:                 if overwrite:
        pstarkey:                     # Overwrite if dataset already exists
        pstarkey:                     if keep_attrs:
        pstarkey:                         attrs = dict(h5_file[group][name].attrs)
        pstarkey:                     del h5_file[group][name]
        pstarkey:                 else:
        pstarkey:                     raise Exception('Dataset %s exists. Use overwrite=True to overwrite.' % 
        pstarkey:                                      group + '/' + name)
        pstarkey:             h5_file[group].create_dataset(name, data=data)
        pstarkey:             for key, val in attrs.items():
        pstarkey:                 h5_file[group][name].attrs[key] = val
        pstarkey: 
        pstarkey:     def get_traces(self, *names):
        pstarkey:         traces = []
        pstarkey:         for name in names:
        pstarkey:             traces.extend(self.get_trace(name))
        pstarkey:         return traces
        pstarkey:              
        pstarkey:     def get_result_arrays(self, group, *names):
        pstarkey:         results = []
        pstarkey:         for name in names:
        pstarkey:             results.append(self.get_result_array(group, name))
        pstarkey:         return results
        pstarkey:         
        pstarkey:     def save_results(self, *args):
        pstarkey:         names = args[::2]
        pstarkey:         values = args[1::2]
        pstarkey:         for name, value in zip(names, values):
           Chris:             print('saving %s =' % name, value)
        pstarkey:             self.save_result(name, value)
        pstarkey:             
        pstarkey:     def save_results_dict(self, results_dict, uncertainties=False, **kwargs):
        pstarkey:         for name, value in results_dict.items():
        pstarkey:             if not uncertainties:
        pstarkey:                 self.save_result(name, value, **kwargs)
        pstarkey:             else:
        pstarkey:                 self.save_result(name, value[0], **kwargs)
        pstarkey:                 self.save_result('u_' + name, value[1], **kwargs)
        pstarkey: 
        pstarkey:     def save_result_arrays(self, *args):
        pstarkey:         names = args[::2]
        pstarkey:         values = args[1::2]
        pstarkey:         for name, value in zip(names, values):
        pstarkey:             self.save_result_array(name, value)
        pstarkey:     
        pstarkey:     def get_image(self,orientation,label,image):
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             if not 'images' in h5_file:
        pstarkey:                 raise Exception('File does not contain any images')
        pstarkey:             if not orientation in h5_file['images']:
        pstarkey:                 raise Exception('File does not contain any images with orientation \'%s\''%orientation)
        pstarkey:             if not label in h5_file['images'][orientation]:
        pstarkey:                 raise Exception('File does not contain any images with label \'%s\''%label)
        pstarkey:             if not image in h5_file['images'][orientation][label]:
        pstarkey:                 raise Exception('Image \'%s\' not found in file'%image)
        pstarkey:             return array(h5_file['images'][orientation][label][image])
        pstarkey:     
        pstarkey:     def get_images(self,orientation,label, *images):
        pstarkey:         results = []
        pstarkey:         for image in images:
        pstarkey:             results.append(self.get_image(orientation,label,image))
        pstarkey:         return results
        pstarkey:         
        pstarkey:     def get_all_image_labels(self):
        pstarkey:         images_list = {}
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             for orientation in h5_file['/images'].keys():
chrisjbillington:                 images_list[orientation] = list(h5_file['/images'][orientation].keys())               
        pstarkey:         return images_list                
        pstarkey:     
        pstarkey:     def get_image_attributes(self, orientation):
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             if not 'images' in h5_file:
        pstarkey:                 raise Exception('File does not contain any images')
        pstarkey:             if not orientation in h5_file['images']:
        pstarkey:                 raise Exception('File does not contain any images with orientation \'%s\''%orientation)
        pstarkey:             return dict(h5_file['images'][orientation].attrs)
        pstarkey:         
        pstarkey:     def get_globals(self,group=None):
        pstarkey:         if not group:
        pstarkey:             with h5py.File(self.h5_path) as h5_file:
        pstarkey:                 return dict(h5_file['globals'].attrs)
        pstarkey:         else:
        pstarkey:             try:
        pstarkey:                 with h5py.File(self.h5_path) as h5_file:
        pstarkey:                     return dict(h5_file['globals'][group].attrs)
        pstarkey:             except KeyError:
        pstarkey:                 return {}
        pstarkey: 
        pstarkey:     def get_globals_raw(self, group=None):
        pstarkey:         globals_dict = {}
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             if group == None:
        pstarkey:                 for obj in h5_file['globals'].values():
        pstarkey:                     temp_dict = dict(obj.attrs)
        pstarkey:                     for key, val in temp_dict.items():
        pstarkey:                         globals_dict[key] = val
        pstarkey:             else:
        pstarkey:                 globals_dict = dict(h5_file['globals'][group].attrs)
        pstarkey:         return globals_dict
        pstarkey:         
        pstarkey:     # def iterable_globals(self, group=None):
        pstarkey:         # raw_globals = self.get_globals_raw(group)
        pstarkey:         # print raw_globals.items()
        pstarkey:         # iterable_globals = {}
        pstarkey:         # for global_name, expression in raw_globals.items():
        pstarkey:             # print expression
        pstarkey:             # # try:
        pstarkey:                 # # sandbox = {}
        pstarkey:                 # # exec('from pylab import *',sandbox,sandbox)
        pstarkey:                 # # exec('from runmanager.functions import *',sandbox,sandbox)
        pstarkey:                 # # value = eval(expression,sandbox)
        pstarkey:             # # except Exception as e:
        pstarkey:                 # # raise Exception('Error parsing global \'%s\': '%global_name + str(e))
        pstarkey:             # # if isinstance(value,types.GeneratorType):
        pstarkey:                # # print global_name + ' is iterable.'
        pstarkey:                # # iterable_globals[global_name] = [tuple(value)]
        pstarkey:             # # elif isinstance(value, ndarray) or  isinstance(value, list):
        pstarkey:                # # print global_name + ' is iterable.'            
        pstarkey:                # # iterable_globals[global_name] = value
        pstarkey:             # # else:
        pstarkey:                 # # print global_name + ' is not iterable.'
        pstarkey:             # return raw_globals
        pstarkey:             
        pstarkey:     def get_globals_expansion(self):
        pstarkey:         expansion_dict = {}
        pstarkey:         def append_expansion(name, obj):
        pstarkey:             if 'expansion' in name:
        pstarkey:                 temp_dict = dict(obj.attrs)
        pstarkey:                 for key, val in temp_dict.items():
        pstarkey:                     if val:
        pstarkey:                         expansion_dict[key] = val
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             h5_file['globals'].visititems(append_expansion)
        pstarkey:         return expansion_dict
        pstarkey:                    
        pstarkey:     def get_units(self, group=None):
        pstarkey:         units_dict = {}
        pstarkey:         def append_units(name, obj):
        pstarkey:             if 'units' in name:
        pstarkey:                 temp_dict = dict(obj.attrs)
        pstarkey:                 for key, val in temp_dict.items():
        pstarkey:                     units_dict[key] = val
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             h5_file['globals'].visititems(append_units)
        pstarkey:         return units_dict
        pstarkey: 
        pstarkey:     def globals_groups(self):
        pstarkey:         with h5py.File(self.h5_path) as h5_file:
        pstarkey:             try:
chrisjbillington:                 return list(h5_file['globals'].keys())
        pstarkey:             except KeyError:
        pstarkey:                 return []   
        pstarkey:                 
        pstarkey:     def globals_diff(self, other_run, group=None):
        pstarkey:         return globals_diff(self, other_run, group)            
        pstarkey:     
        pstarkey:         
        pstarkey: class Sequence(Run):
        pstarkey:     def __init__(self,h5_path,run_paths):
        pstarkey:         if isinstance(run_paths, pandas.DataFrame):
        pstarkey:             run_paths = run_paths['filepath']
        pstarkey:         self.h5_path = h5_path
        pstarkey:         self.no_write = False
        pstarkey:         with h5py.File(h5_path) as h5_file:
        pstarkey:             if not 'results' in h5_file:
        pstarkey:                  h5_file.create_group('results')
        pstarkey:                  
        pstarkey:         self.runs = {path: Run(path,no_write=True) for path in run_paths}
        pstarkey:         
        pstarkey:         # The group were the results will be stored in the h5 file will
        pstarkey:         # be the name of the python script which is instantiating this
        pstarkey:         # Sequence object:
        pstarkey:         frame = inspect.currentframe()
        pstarkey:         try:
        pstarkey:             __file__ = frame.f_back.f_locals['__file__']
           Chris:             if PY2:
chrisjbillington:                 __file__ = __file__.decode(sys.getfilesystemencoding())
        pstarkey:             self.group = os.path.basename(__file__).split('.py')[0]
        pstarkey:             with h5py.File(h5_path) as h5_file:
        pstarkey:                 if not self.group in h5_file['results']:
        pstarkey:                      h5_file['results'].create_group(self.group)
        pstarkey:         except KeyError:
        pstarkey:             sys.stderr.write('Warning: to write results, call '
        pstarkey:             'Sequence.set_group(groupname), specifying the name of the group '
        pstarkey:             'you would like to save results to. This normally comes from '
        pstarkey:             'the filename of your script, but since you\'re in interactive '
        pstarkey:             'mode, there is no scipt name. Opening in read only mode for '
        pstarkey:             'the moment.\n')
        pstarkey:             self.no_write = True
        pstarkey:         
        pstarkey:     def get_trace(self,*args):
             jan:         return {path:run.get_trace(*args) for path,run in self.runs.items()}
        pstarkey:         
        pstarkey:     def get_result_array(self,*args):
             jan:         return {path:run.get_result_array(*args) for path,run in self.runs.items()}
        pstarkey:          
        pstarkey:     def get_traces(self,*args):
        pstarkey:         raise NotImplementedError('If you want to use this feature please ask me to implement it! -Chris')
        pstarkey:              
        pstarkey:     def get_result_arrays(self,*args):
        pstarkey:         raise NotImplementedError('If you want to use this feature please ask me to implement it! -Chris')
        pstarkey:      
        pstarkey:     def get_image(self,*args):
        pstarkey:         raise NotImplementedError('If you want to use this feature please ask me to implement it! -Chris')     
           Chris: 
           Chris: 
chrisjbillington: def figure_to_clipboard(figure=None, **kwargs):
           Chris:     """Copy a matplotlib figure to the clipboard as a png. If figure is None,
chrisjbillington:     the current figure will be copied. Copying the figure is implemented by
chrisjbillington:     calling figure.savefig() and then copying the image data from the
chrisjbillington:     resulting file. Any keyword arguments will be passed to the call to
            RbLi:     savefig(). If bbox_inches keyword arg is not provided,
            RbLi:     bbox_inches='tight' will be used"""
            RbLi:     
           Chris:     import matplotlib.pyplot as plt
chrisjbillington:     from zprocess import start_daemon
           Chris:     import tempfile
           Chris: 
            RbLi:     if not 'bbox_inches' in kwargs:
            RbLi:         kwargs['bbox_inches'] = 'tight'
            RbLi:                
           Chris:     if figure is None:
           Chris:         figure = plt.gcf()
           Chris: 
           Chris:     with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as f:
           Chris:         tempfile_name = f.name
chrisjbillington: 
chrisjbillington:     figure.savefig(tempfile_name, **kwargs)
chrisjbillington: 
chrisjbillington:     import lyse
chrisjbillington:     lyse_dir = os.path.dirname(os.path.abspath(lyse.__file__))
chrisjbillington:     tempfile2clipboard = os.path.join(lyse_dir, 'tempfile2clipboard.py')
chrisjbillington:     start_daemon([sys.executable, tempfile2clipboard, '--delete', tempfile_name])
        cbilling: from __future__ import division, unicode_literals, print_function, absolute_import  # Ease the transition to Python 3
        cbilling: 
        cbilling: # stdlib imports
        cbilling: 
        cbilling: import os
        cbilling: import sys
        cbilling: import socket
        cbilling: import logging
        cbilling: import threading
        cbilling: import signal
        cbilling: import subprocess
        cbilling: import time
           Chris: import traceback
     janwerkmann: import pprint
     janwerkmann: import ast
        cbilling: 
        cbilling: # Turn on our error catching for all subsequent imports
        cbilling: import labscript_utils.excepthook
        cbilling: 
        cbilling: 
        cbilling: # 3rd party imports:
        cbilling: 
        cbilling: import numpy as np
        cbilling: import labscript_utils.h5_lock
        cbilling: import h5py
        cbilling: import pandas
        cbilling: 
        cbilling: try:
        cbilling:     from labscript_utils import check_version
        cbilling: except ImportError:
          rander:     raise ImportError('Require labscript_utils > 2.1.0')
        cbilling: 
chrisjbillington: check_version('qtutils', '2.1.0', '3.0.0')
        cbilling: 
        cbilling: import zprocess.locking
        cbilling: from zprocess import ZMQServer
        cbilling: 
        cbilling: from labscript_utils.labconfig import LabConfig, config_prefix
        cbilling: from labscript_utils.setup_logging import setup_logging
        cbilling: from labscript_utils.qtwidgets.headerview_with_widgets import HorizontalHeaderViewWithWidgets
        cbilling: import labscript_utils.shared_drive as shared_drive
        cbilling: 
        cbilling: from lyse.dataframe_utilities import (concat_with_padding,
        cbilling:                                       get_dataframe_from_shot,
        cbilling:                                       replace_with_padding)
        cbilling: 
     janwerkmann: from qtutils.qt import QtCore, QtGui, QtWidgets
     janwerkmann: from qtutils.qt.QtCore import pyqtSignal as Signal
chrisjbillington: from qtutils import inmain_decorator, inmain, UiLoader, DisconnectContextManager
        cbilling: from qtutils.outputbox import OutputBox
        cbilling: from qtutils.auto_scroll_to_end import set_auto_scroll_to_end
        cbilling: import qtutils.icons
        cbilling: 
           Chris: from labscript_utils import PY2
           Chris: if PY2:
           Chris:     str = unicode
           Chris:     import Queue as queue
           Chris: else:
           Chris:     import queue
           Chris: 
        cbilling: # Set working directory to lyse folder, resolving symlinks
        cbilling: lyse_dir = os.path.dirname(os.path.realpath(__file__))
        cbilling: os.chdir(lyse_dir)
        cbilling: 
        cbilling: # Set a meaningful name for zprocess.locking's client id:
        cbilling: zprocess.locking.set_client_process_name('lyse')
        cbilling: 
        cbilling: 
        cbilling: def set_win_appusermodel(window_id):
        cbilling:     from labscript_utils.winshell import set_appusermodel, appids, app_descriptions
        cbilling:     icon_path = os.path.abspath('lyse.ico')
        cbilling:     executable = sys.executable.lower()
        cbilling:     if not executable.endswith('w.exe'):
        cbilling:         executable = executable.replace('.exe', 'w.exe')
        cbilling:     relaunch_command = executable + ' ' + os.path.abspath(__file__.replace('.pyc', '.py'))
        cbilling:     relaunch_display_name = app_descriptions['lyse']
        cbilling:     set_appusermodel(window_id, appids['lyse'], icon_path, relaunch_command, relaunch_display_name)
        cbilling: 
        cbilling: 
        cbilling: @inmain_decorator()
        cbilling: def error_dialog(message):
     janwerkmann:     QtWidgets.QMessageBox.warning(app.ui, 'lyse', message)
        cbilling: 
        cbilling: 
        cbilling: @inmain_decorator()
        cbilling: def question_dialog(message):
     janwerkmann:     reply = QtWidgets.QMessageBox.question(app.ui, 'lyse', message,
     janwerkmann:                                        QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
     janwerkmann:     return (reply == QtWidgets.QMessageBox.Yes)
        cbilling: 
        cbilling: 
        cbilling: def scientific_notation(x, sigfigs=4, mode='eng'):
        cbilling:     """Returns a unicode string of the float f in scientific notation"""
        cbilling: 
        cbilling:     times = u'\u00d7'
        cbilling:     thinspace = u'\u2009'
        cbilling:     hairspace = u'\u200a'
        cbilling:     sups = {u'-': u'\u207b',
        cbilling:             u'0': u'\u2070',
        cbilling:             u'1': u'\xb9',
        cbilling:             u'2': u'\xb2',
        cbilling:             u'3': u'\xb3',
        cbilling:             u'4': u'\u2074',
        cbilling:             u'5': u'\u2075',
        cbilling:             u'6': u'\u2076',
        cbilling:             u'7': u'\u2077',
        cbilling:             u'8': u'\u2078',
        cbilling:             u'9': u'\u2079'}
        cbilling: 
        cbilling:     prefixes = {
        cbilling:         -24: u"y",
        cbilling:         -21: u"z",
        cbilling:         -18: u"a",
        cbilling:         -15: u"f",
        cbilling:         -12: u"p",
        cbilling:         -9: u"n",
        cbilling:         -6: u"\u03bc",
        cbilling:         -3: u"m",
        cbilling:         0: u"",
        cbilling:         3: u"k",
        cbilling:         6: u"M",
        cbilling:         9: u"G",
        cbilling:         12: u"T",
        cbilling:         15: u"P",
        cbilling:         18: u"E",
        cbilling:         21: u"Z",
        cbilling:         24: u"Y"
        cbilling:     }
        cbilling: 
        cbilling:     if not isinstance(x, float):
        cbilling:         raise TypeError('x must be floating point number')
        cbilling:     if np.isnan(x) or np.isinf(x):
        cbilling:         return str(x)
        cbilling:     if x != 0:
        cbilling:         exponent = int(np.floor(np.log10(np.abs(x))))
        cbilling:         # Only multiples of 10^3
        cbilling:         exponent = int(np.floor(exponent / 3) * 3)
        cbilling:     else:
        cbilling:         exponent = 0
        cbilling: 
        cbilling:     significand = x / 10 ** exponent
        cbilling:     pre_decimal, post_decimal = divmod(significand, 1)
        cbilling:     digits = sigfigs - len(str(int(pre_decimal)))
        cbilling:     significand = round(significand, digits)
        cbilling:     result = str(significand)
        cbilling:     if exponent:
        cbilling:         if mode == 'exponential':
        cbilling:             superscript = ''.join(sups.get(char, char) for char in str(exponent))
        cbilling:             result += thinspace + times + thinspace + '10' + superscript
        cbilling:         elif mode == 'eng':
        shjohnst:             try:
        shjohnst:                 # If our number has an SI prefix then use it
        shjohnst:                 prefix = prefixes[exponent]
        shjohnst:                 result += hairspace + prefix
chrisjbillington:             except KeyError:
        shjohnst:                 # Otherwise display in scientific notation
        shjohnst:                 superscript = ''.join(sups.get(char, char) for char in str(exponent))
        shjohnst:                 result += thinspace + times + thinspace + '10' + superscript
        cbilling:     return result
        cbilling: 
        cbilling: 
chrisjbillington: def get_screen_geometry():
chrisjbillington:     """Return the a list of the geometries of each screen: each a tuple of
chrisjbillington:     left, top, width and height"""
chrisjbillington:     geoms = []
chrisjbillington:     desktop = qapplication.desktop()
chrisjbillington:     for i in range(desktop.screenCount()):
chrisjbillington:         sg = desktop.screenGeometry(i)
chrisjbillington:         geoms.append((sg.left(), sg.top(), sg.width(), sg.height()))
chrisjbillington:     return geoms
chrisjbillington: 
chrisjbillington: 
        cbilling: class WebServer(ZMQServer):
        cbilling: 
        cbilling:     def handler(self, request_data):
        cbilling:         logger.info('WebServer request: %s' % str(request_data))
        cbilling:         if request_data == 'hello':
        cbilling:             return 'hello'
        cbilling:         elif request_data == 'get dataframe':
        cbilling:             # convert_objects() picks fixed datatypes for columns that are
        cbilling:             # compatible with fixed datatypes, dramatically speeding up
        cbilling:             # pickling. But we don't impose fixed datatypes earlier than now
        cbilling:             # because the user is free to use mixed datatypes in a column, and
        cbilling:             # we won't want to prevent values of a different type being added
        cbilling:             # in the future. All kwargs False because we don't want to coerce
        cbilling:             # strings to numbers or anything - just choose the correct
        cbilling:             # datatype for columns that are already a single datatype:
        cbilling:             return app.filebox.shots_model.dataframe.convert_objects(
        cbilling:                        convert_dates=False, convert_numeric=False, convert_timedeltas=False)
        cbilling:         elif isinstance(request_data, dict):
        cbilling:             if 'filepath' in request_data:
        cbilling:                 h5_filepath = shared_drive.path_to_local(request_data['filepath'])
chrisjbillington:                 if isinstance(h5_filepath, bytes):
chrisjbillington:                     h5_filepath = h5_filepath.decode('utf8')
chrisjbillington:                 if not isinstance(h5_filepath, str):
chrisjbillington:                     raise AssertionError(str(type(h5_filepath)) + ' is not str or bytes')
        cbilling:                 app.filebox.incoming_queue.put(h5_filepath)
        cbilling:                 return 'added successfully'
        cbilling:         return ("error: operation not supported. Recognised requests are:\n "
        cbilling:                 "'get dataframe'\n 'hello'\n {'filepath': <some_h5_filepath>}")
        cbilling: 
        cbilling: 
     janwerkmann: class LyseMainWindow(QtWidgets.QMainWindow):
     janwerkmann:     # A signal to show that the window is shown and painted.
     janwerkmann:     firstPaint = Signal()
     janwerkmann: 
        cbilling:     # A signal for when the window manager has created a new window for this widget:
        cbilling:     newWindow = Signal(int)
        cbilling: 
     janwerkmann:     def __init__(self, *args, **kwargs):
           Chris:         QtWidgets.QMainWindow.__init__(self, *args, **kwargs)
     janwerkmann:         self._previously_painted = False
     janwerkmann: 
     janwerkmann:     def closeEvent(self, event):
     janwerkmann:         if app.on_close_event():
           Chris:             return QtWidgets.QMainWindow.closeEvent(self, event)
     janwerkmann:         else:
     janwerkmann:             event.ignore()
     janwerkmann: 
        cbilling:     def event(self, event):
     janwerkmann:         result = QtWidgets.QMainWindow.event(self, event)
        cbilling:         if event.type() == QtCore.QEvent.WinIdChange:
        cbilling:             self.newWindow.emit(self.effectiveWinId())
        cbilling:         return result
        cbilling: 
     janwerkmann:     def paintEvent(self, event):
           Chris:         result = QtWidgets.QMainWindow.paintEvent(self, event)
     janwerkmann:         if not self._previously_painted:
     janwerkmann:             self._previously_painted = True
     janwerkmann:             self.firstPaint.emit()
     janwerkmann:         return result
     janwerkmann: 
     janwerkmann: 
        cbilling: class AnalysisRoutine(object):
        cbilling: 
     janwerkmann:     def __init__(self, filepath, model, output_box_port, checked=QtCore.Qt.Checked):
        cbilling:         self.filepath = filepath
        cbilling:         self.shortname = os.path.basename(self.filepath)
        cbilling:         self.model = model
        cbilling:         self.output_box_port = output_box_port
        cbilling:         
        cbilling:         self.COL_ACTIVE = RoutineBox.COL_ACTIVE
        cbilling:         self.COL_STATUS = RoutineBox.COL_STATUS
        cbilling:         self.COL_NAME = RoutineBox.COL_NAME
        cbilling:         self.ROLE_FULLPATH = RoutineBox.ROLE_FULLPATH
        cbilling:         
        cbilling:         self.error = False
        cbilling:         self.done = False
        cbilling:         
        cbilling:         self.to_worker, self.from_worker, self.worker = self.start_worker()
        cbilling:         
        cbilling:         # Make a row to put into the model:
        cbilling:         active_item =  QtGui.QStandardItem()
        cbilling:         active_item.setCheckable(True)
     janwerkmann:         active_item.setCheckState(checked)
        cbilling:         info_item = QtGui.QStandardItem()
        cbilling:         name_item = QtGui.QStandardItem(self.shortname)
        cbilling:         name_item.setToolTip(self.filepath)
        cbilling:         name_item.setData(self.filepath, self.ROLE_FULLPATH)
        cbilling:         self.model.appendRow([active_item, info_item, name_item])
        cbilling:             
        cbilling:         self.exiting = False
        cbilling:         
        cbilling:     def start_worker(self):
        cbilling:         # Start a worker process for this analysis routine:
        cbilling:         child_handles = zprocess.subprocess_with_queues('analysis_subprocess.py', self.output_box_port)
        cbilling:         to_worker, from_worker, worker = child_handles
        cbilling:         # Tell the worker what script it with be executing:
        cbilling:         to_worker.put(self.filepath)
        cbilling:         return to_worker, from_worker, worker
        cbilling:         
        cbilling:     def do_analysis(self, filepath):
        cbilling:         self.to_worker.put(['analyse', filepath])
        cbilling:         signal, data = self.from_worker.get()
        cbilling:         if signal == 'error':
             jan:             return False, data
        cbilling:         elif signal == 'done':
             jan:             return True, data
        cbilling:         else:
        cbilling:             raise ValueError('invalid signal %s'%str(signal))
        cbilling:         
        cbilling:     @inmain_decorator()
        cbilling:     def set_status(self, status):
        cbilling:         index = self.get_row_index()
        cbilling:         if index is None:
        cbilling:             # Yelp, we've just been deleted. Nothing to do here.
        cbilling:             return
        cbilling:         status_item = self.model.item(index, self.COL_STATUS)
        cbilling:         if status == 'done':
        cbilling:             status_item.setIcon(QtGui.QIcon(':/qtutils/fugue/tick'))
        cbilling:             self.done = True
        cbilling:             self.error = False
        cbilling:         elif status == 'working':
        cbilling:             status_item.setIcon(QtGui.QIcon(':/qtutils/fugue/hourglass'))
        cbilling:             self.done = False
        cbilling:             self.error = False
        cbilling:         elif status == 'error':
        cbilling:             status_item.setIcon(QtGui.QIcon(':/qtutils/fugue/exclamation'))
        cbilling:             self.error = True
        cbilling:             self.done = False
        cbilling:         elif status == 'clear':
        cbilling:             status_item.setData(None, QtCore.Qt.DecorationRole)
        cbilling:             self.done = False
        cbilling:             self.error = False
        cbilling:         else:
        cbilling:             raise ValueError(status)
        cbilling:         
        cbilling:     @inmain_decorator()
        cbilling:     def enabled(self):
        cbilling:         index = self.get_row_index()
        cbilling:         if index is None:
        cbilling:             # Yelp, we've just been deleted.
        cbilling:             return False
        cbilling:         enabled_item = self.model.item(index, self.COL_ACTIVE)
        cbilling:         return (enabled_item.checkState() == QtCore.Qt.Checked)
        cbilling:         
        cbilling:     def get_row_index(self):
        cbilling:         """Returns the row index for this routine's row in the model"""
        cbilling:         for row in range(self.model.rowCount()):
        cbilling:             name_item = self.model.item(row, self.COL_NAME)
        cbilling:             fullpath = name_item.data(self.ROLE_FULLPATH)
        cbilling:             if fullpath == self.filepath:
        cbilling:                 return row
        cbilling: 
        cbilling:     def restart(self):
        cbilling:         # TODO set status to 'restarting' or an icon or something, and gray out the item?
        cbilling:         self.end_child(restart=True)
        cbilling:         
        cbilling:     def remove(self):
        cbilling:         """End the child process and remove from the treeview"""
        cbilling:         self.end_child()
        cbilling:         index = self.get_row_index()
        cbilling:         if index is None:
        cbilling:             # Already gone
        cbilling:             return
        cbilling:         self.model.removeRow(index)
        cbilling:          
        cbilling:     def end_child(self, restart=False):
        cbilling:         self.to_worker.put(['quit',None])
        cbilling:         timeout_time = time.time() + 2
        cbilling:         self.exiting = True
        cbilling:         QtCore.QTimer.singleShot(50,
        cbilling:             lambda: self.check_child_exited(self.worker, timeout_time, kill=False, restart=restart))
        cbilling: 
        cbilling:     def check_child_exited(self, worker, timeout_time, kill=False, restart=False):
        cbilling:         worker.poll()
        cbilling:         if worker.returncode is None and time.time() < timeout_time:
        cbilling:             QtCore.QTimer.singleShot(50,
        cbilling:                 lambda: self.check_child_exited(worker, timeout_time, kill, restart))
        cbilling:             return
        cbilling:         elif worker.returncode is None:
        cbilling:             if not kill:
        cbilling:                 worker.terminate()
        cbilling:                 app.output_box.output('%s worker not responding.\n'%self.shortname)
        cbilling:                 timeout_time = time.time() + 2
        cbilling:                 QtCore.QTimer.singleShot(50,
        cbilling:                     lambda: self.check_child_exited(worker, timeout_time, kill=True, restart=restart))
        cbilling:                 return
        cbilling:             else:
        cbilling:                 worker.kill()
        cbilling:                 app.output_box.output('%s worker killed\n'%self.shortname, red=True)
        cbilling:         elif kill:
        cbilling:             app.output_box.output('%s worker terminated\n'%self.shortname, red=True)
        cbilling:         else:
        cbilling:             app.output_box.output('%s worker exited cleanly\n'%self.shortname)
        cbilling:         
chrisjbillington:         # if analysis was running notify analysisloop that analysis has failed
chrisjbillington:         self.from_worker.put(('error', {}))
             jan: 
        cbilling:         if restart:
        cbilling:             self.to_worker, self.from_worker, self.worker = self.start_worker()
        cbilling:             app.output_box.output('%s worker restarted\n'%self.shortname)
        cbilling:         self.exiting = False
     janwerkmann: 
        cbilling: 
     janwerkmann: class TreeView(QtWidgets.QTreeView):
        cbilling:     leftClicked = Signal(QtCore.QModelIndex)
        cbilling:     doubleLeftClicked = Signal(QtCore.QModelIndex)
        cbilling:     """A QTreeView that emits a custom signal leftClicked(index) after a left
        cbilling:     click on a valid index, and doubleLeftClicked(index) (in addition) on
        cbilling:     double click."""
        cbilling: 
        cbilling:     def __init__(self, *args):
     janwerkmann:         QtWidgets.QTreeView.__init__(self, *args)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling: 
        cbilling:     def mousePressEvent(self, event):
     janwerkmann:         result = QtWidgets.QTreeView.mousePressEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid():
        cbilling:             self._pressed_index = self.indexAt(event.pos())
        cbilling:         return result
        cbilling: 
        cbilling:     def leaveEvent(self, event):
     janwerkmann:         result = QtWidgets.QTreeView.leaveEvent(self, event)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         return result
        cbilling: 
        cbilling:     def mouseDoubleClickEvent(self, event):
        cbilling:         # Ensure our left click event occurs regardless of whether it is the
        cbilling:         # second click in a double click or not
     janwerkmann:         result = QtWidgets.QTreeView.mouseDoubleClickEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid():
        cbilling:             self._pressed_index = self.indexAt(event.pos())
        cbilling:             self._double_click = True
        cbilling:         return result
        cbilling: 
        cbilling:     def mouseReleaseEvent(self, event):
     janwerkmann:         result = QtWidgets.QTreeView.mouseReleaseEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid() and index == self._pressed_index:
        cbilling:             self.leftClicked.emit(index)
        cbilling:             if self._double_click:
        cbilling:                 self.doubleLeftClicked.emit(index)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         return result
        cbilling: 
        cbilling:         
        cbilling: class RoutineBox(object):
        cbilling:     
        cbilling:     COL_ACTIVE = 0
        cbilling:     COL_STATUS = 1
        cbilling:     COL_NAME = 2
        cbilling:     ROLE_FULLPATH = QtCore.Qt.UserRole + 1
        cbilling:     # This data (stored in the name item) does not necessarily match
        cbilling:     # the position in the model. It will be set just
        cbilling:     # prior to sort() being called with this role as the sort data.
        cbilling:     # This is how we will reorder the model's rows instead of
        cbilling:     # using remove/insert.
        cbilling:     ROLE_SORTINDEX = QtCore.Qt.UserRole + 2
        cbilling:     
        cbilling:     def __init__(self, container, exp_config, filebox, from_filebox, to_filebox, output_box_port, multishot=False):
        cbilling:         self.multishot = multishot
        cbilling:         self.filebox = filebox
        cbilling:         self.exp_config = exp_config
        cbilling:         self.from_filebox = from_filebox
        cbilling:         self.to_filebox = to_filebox
        cbilling:         self.output_box_port = output_box_port
        cbilling:         
        cbilling:         self.logger = logging.getLogger('lyse.RoutineBox.%s'%('multishot' if multishot else 'singleshot'))  
        cbilling:         
        cbilling:         loader = UiLoader()
        cbilling:         loader.registerCustomWidget(TreeView)
        cbilling:         self.ui = loader.load('routinebox.ui')
        cbilling:         container.addWidget(self.ui)
        cbilling: 
        cbilling:         if multishot:
        cbilling:             self.ui.groupBox.setTitle('Multishot routines')
        cbilling:         else:
        cbilling:             self.ui.groupBox.setTitle('Singleshot routines')
        cbilling: 
        cbilling:         self.model = UneditableModel()
        cbilling:         self.header = HorizontalHeaderViewWithWidgets(self.model)
        cbilling:         self.ui.treeView.setHeader(self.header)
        cbilling:         self.ui.treeView.setModel(self.model)
        cbilling:         
        cbilling:         active_item = QtGui.QStandardItem()
        cbilling:         active_item.setToolTip('Whether the analysis routine should run')
        cbilling:         status_item = QtGui.QStandardItem()
        cbilling:         status_item.setIcon(QtGui.QIcon(':qtutils/fugue/information'))
        cbilling:         status_item.setToolTip('The status of this analyis routine\'s execution')
        cbilling:         name_item = QtGui.QStandardItem('name')
        cbilling:         name_item.setToolTip('The name of the python script for the analysis routine')
     janwerkmann: 
     janwerkmann:         self.select_all_checkbox = QtWidgets.QCheckBox()
        cbilling:         self.select_all_checkbox.setToolTip('whether the analysis routine should run')
        cbilling:         self.header.setWidget(self.COL_ACTIVE, self.select_all_checkbox)
        cbilling:         self.header.setStretchLastSection(True)
        cbilling:         self.select_all_checkbox.setTristate(False)
        cbilling:         
        cbilling:         self.model.setHorizontalHeaderItem(self.COL_ACTIVE, active_item)
        cbilling:         self.model.setHorizontalHeaderItem(self.COL_STATUS, status_item)
        cbilling:         self.model.setHorizontalHeaderItem(self.COL_NAME, name_item)
        cbilling:         self.model.setSortRole(self.ROLE_SORTINDEX)
        cbilling:         
        cbilling:         self.ui.treeView.resizeColumnToContents(self.COL_ACTIVE)
        cbilling:         self.ui.treeView.resizeColumnToContents(self.COL_STATUS)
        cbilling:         self.ui.treeView.setColumnWidth(self.COL_NAME, 200)
        cbilling:         
        cbilling:         self.ui.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        cbilling:         # Make the actions for the context menu:
     janwerkmann:         self.action_set_selected_active = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box'), 'set selected routines active',  self.ui)
     janwerkmann:         self.action_set_selected_inactive = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box-uncheck'), 'set selected routines inactive',  self.ui)
     janwerkmann:         self.action_restart_selected = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/arrow-circle'), 'restart worker process for selected routines',  self.ui)
     janwerkmann:         self.action_remove_selected = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/minus'), 'Remove selected routines',  self.ui)
        cbilling:         self.last_opened_routine_folder = self.exp_config.get('paths', 'analysislib')
        cbilling:         
        cbilling:         self.routines = []
        cbilling:         
        cbilling:         self.connect_signals()
        cbilling: 
        cbilling:         self.analysis = threading.Thread(target = self.analysis_loop)
        cbilling:         self.analysis.daemon = True
        cbilling:         self.analysis.start()
        cbilling:         
        cbilling:     def connect_signals(self):
        cbilling:         self.ui.toolButton_add_routines.clicked.connect(self.on_add_routines_clicked)
        cbilling:         self.ui.toolButton_remove_routines.clicked.connect(self.on_remove_selection)
        cbilling:         self.model.itemChanged.connect(self.on_model_item_changed)
        cbilling:         self.ui.treeView.doubleLeftClicked.connect(self.on_treeview_double_left_clicked)
        cbilling:         # A context manager with which we can temporarily disconnect the above connection.
        cbilling:         self.model_item_changed_disconnected = DisconnectContextManager(
        cbilling:             self.model.itemChanged, self.on_model_item_changed)
        cbilling:         self.select_all_checkbox.stateChanged.connect(self.on_select_all_state_changed)
        cbilling:         self.select_all_checkbox_state_changed_disconnected = DisconnectContextManager(
        cbilling:             self.select_all_checkbox.stateChanged, self.on_select_all_state_changed)
        cbilling:         self.ui.treeView.customContextMenuRequested.connect(self.on_treeView_context_menu_requested)
        cbilling:         self.action_set_selected_active.triggered.connect(
        cbilling:             lambda: self.on_set_selected_triggered(QtCore.Qt.Checked))
        cbilling:         self.action_set_selected_inactive.triggered.connect(
        cbilling:             lambda: self.on_set_selected_triggered(QtCore.Qt.Unchecked))
        cbilling:         self.action_restart_selected.triggered.connect(self.on_restart_selected_triggered)
        cbilling:         self.action_remove_selected.triggered.connect(self.on_remove_selection)
        cbilling:         self.ui.toolButton_move_to_top.clicked.connect(self.on_move_to_top_clicked)
        cbilling:         self.ui.toolButton_move_up.clicked.connect(self.on_move_up_clicked)
        cbilling:         self.ui.toolButton_move_down.clicked.connect(self.on_move_down_clicked)
        cbilling:         self.ui.toolButton_move_to_bottom.clicked.connect(self.on_move_to_bottom_clicked)
        cbilling: 
        cbilling:     def on_add_routines_clicked(self):
     janwerkmann:         routine_files = QtWidgets.QFileDialog.getOpenFileNames(self.ui,
        cbilling:                                                            'Select analysis routines',
        cbilling:                                                            self.last_opened_routine_folder,
        cbilling:                                                            "Python scripts (*.py)")
     janwerkmann:         if type(routine_files) is tuple:
     janwerkmann:             routine_files, _ = routine_files
     janwerkmann: 
        cbilling:         if not routine_files:
        cbilling:             # User cancelled selection
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
        cbilling:         routine_files = [os.path.abspath(routine_file) for routine_file in routine_files]
        cbilling: 
        cbilling:         # Save the containing folder for use next time we open the dialog box:
        cbilling:         self.last_opened_routine_folder = os.path.dirname(routine_files[0])
     janwerkmann:         self.add_routines([(routine_file, QtCore.Qt.Checked) for routine_file in routine_files])
     janwerkmann: 
     janwerkmann:     def add_routines(self, routine_files, clear_existing=False):
     janwerkmann:         """Add routines to the routine box, where routine_files is a list of
     janwerkmann:         tuples containing the filepath and whether the routine is enabled or
     janwerkmann:         not when it is added. if clear_existing == True, then any existing
     janwerkmann:         analysis routines will be cleared before the new ones are added."""
     janwerkmann:         if clear_existing:
     janwerkmann:             for routine in self.routines[:]:
     janwerkmann:                 routine.remove()
     janwerkmann:                 self.routines.remove(routine)
     janwerkmann: 
        cbilling:         # Queue the files to be opened:
     janwerkmann:         for filepath, checked in routine_files:
        cbilling:             if filepath in [routine.filepath for routine in self.routines]:
        cbilling:                 app.output_box.output('Warning: Ignoring duplicate analysis routine %s\n'%filepath, red=True)
        cbilling:                 continue
     janwerkmann:             routine = AnalysisRoutine(filepath, self.model, self.output_box_port, checked)
        cbilling:             self.routines.append(routine)
        cbilling:         self.update_select_all_checkstate()
        cbilling:         
        cbilling:     def on_treeview_double_left_clicked(self, index):
        cbilling:         # If double clicking on the the name item, open
        cbilling:         # the routine in the specified text editor:
        cbilling:         if index.column() != self.COL_NAME:
        cbilling:             return
        cbilling:         name_item = self.model.item(index.row(), self.COL_NAME)
        cbilling:         routine_filepath = name_item.data(self.ROLE_FULLPATH)
        cbilling:         # get path to text editor
        cbilling:         editor_path = self.exp_config.get('programs', 'text_editor')
        cbilling:         editor_args = self.exp_config.get('programs', 'text_editor_arguments')
        cbilling:         # Get the current labscript file:
        cbilling:         if not editor_path:
        cbilling:             error_dialog("No editor specified in the labconfig.")
        cbilling:         if '{file}' in editor_args:
        cbilling:             # Split the args on spaces into a list, replacing {file} with the labscript file
        cbilling:             editor_args = [arg if arg != '{file}' else routine_filepath for arg in editor_args.split()]
        cbilling:         else:
        cbilling:             # Otherwise if {file} isn't already in there, append it to the other args:
        cbilling:             editor_args = [routine_filepath] + editor_args.split()
        cbilling:         try:
        cbilling:             subprocess.Popen([editor_path] + editor_args)
        cbilling:         except Exception as e:
        cbilling:             error_dialog("Unable to launch text editor specified in %s. Error was: %s" %
        cbilling:                          (self.exp_config.config_path, str(e)))
        cbilling:                          
        cbilling:     def on_remove_selection(self):
chrisjbillington:         self.remove_selection()
chrisjbillington: 
chrisjbillington:     def remove_selection(self, confirm=True):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         if not selected_rows:
        cbilling:             return
           Chris:         if confirm and not question_dialog("Remove %d routines?" % len(selected_rows)):
        cbilling:             return
        cbilling:         name_items = [self.model.item(row, self.COL_NAME) for row in selected_rows]
        cbilling:         filepaths = [item.data(self.ROLE_FULLPATH) for item in name_items]
        cbilling:         for routine in self.routines[:]:
        cbilling:             if routine.filepath in filepaths:
        cbilling:                 routine.remove()
        cbilling:                 self.routines.remove(routine)
        cbilling:         self.update_select_all_checkstate()
        cbilling:         
        cbilling:     def on_model_item_changed(self, item):
        cbilling:         if item.column() == self.COL_ACTIVE:
        cbilling:             self.update_select_all_checkstate()
        cbilling:         
        cbilling:     def on_select_all_state_changed(self, state):
        cbilling:         with self.select_all_checkbox_state_changed_disconnected:
        cbilling:             # Do not allow a switch *to* a partially checked state:
        cbilling:             self.select_all_checkbox.setTristate(False)
        cbilling:         state = self.select_all_checkbox.checkState()
        cbilling:         with self.model_item_changed_disconnected:
        cbilling:             for row in range(self.model.rowCount()):
        cbilling:                 active_item = self.model.item(row, self.COL_ACTIVE)
        cbilling:                 active_item.setCheckState(state)
        cbilling:         
        cbilling:     def on_treeView_context_menu_requested(self, point):
     janwerkmann:         menu = QtWidgets.QMenu(self.ui.treeView)
        cbilling:         menu.addAction(self.action_set_selected_active)
        cbilling:         menu.addAction(self.action_set_selected_inactive)
        cbilling:         menu.addAction(self.action_restart_selected)
        cbilling:         menu.addAction(self.action_remove_selected)
        cbilling:         menu.exec_(QtGui.QCursor.pos())
        cbilling:         
        cbilling:     def on_set_selected_triggered(self, active):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         for row in selected_rows:
        cbilling:             active_item = self.model.item(row, self.COL_ACTIVE)
        cbilling:             active_item.setCheckState(active)
        cbilling:         self.update_select_all_checkstate()
        cbilling: 
        cbilling:     def on_move_to_top_clicked(self):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         n = self.model.rowCount()
        cbilling:         i_selected = 0
        cbilling:         i_unselected = len(selected_rows)
        cbilling:         order = []
        cbilling:         for i in range(n):
        cbilling:             if i in selected_rows:
        cbilling:                 order.append(i_selected)
        cbilling:                 i_selected += 1
        cbilling:             else:
        cbilling:                 order.append(i_unselected)
        cbilling:                 i_unselected += 1
        cbilling:         self.reorder(order)
        cbilling:         
        cbilling:     def on_move_up_clicked(self):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         n = self.model.rowCount()
        cbilling:         order = []
        cbilling:         last_unselected_index = None
        cbilling:         for i in range(n):
        cbilling:             if i in selected_rows:
        cbilling:                 if last_unselected_index is None:
        cbilling:                     order.append(i)
        cbilling:                 else:
        cbilling:                     order.append(i - 1)
        cbilling:                     order[last_unselected_index] += 1
        cbilling:             else:
        cbilling:                 last_unselected_index = i
        cbilling:                 order.append(i)
        cbilling:         self.reorder(order)
        cbilling:         
        cbilling:     def on_move_down_clicked(self):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         n = self.model.rowCount()
        cbilling:         order = []
        cbilling:         last_unselected_index = None
        cbilling:         for i in reversed(range(n)):
        cbilling:             if i in selected_rows:
        cbilling:                 if last_unselected_index is None:
        cbilling:                     order.insert(0, i)
        cbilling:                 else:
        cbilling:                     order.insert(0, i + 1)
        cbilling:                     order[last_unselected_index - n] -= 1
        cbilling:             else:
        cbilling:                 last_unselected_index = i
        cbilling:                 order.insert(0, i)
        cbilling:         self.reorder(order)
        cbilling:         
        cbilling:     def on_move_to_bottom_clicked(self):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         n = self.model.rowCount()
        cbilling:         i_selected = n - len(selected_rows)
        cbilling:         i_unselected = 0
        cbilling:         order = []
        cbilling:         for i in range(n):
        cbilling:             if i in selected_rows:
        cbilling:                 order.append(i_selected)
        cbilling:                 i_selected += 1
        cbilling:             else:
        cbilling:                 order.append(i_unselected)
        cbilling:                 i_unselected += 1
        cbilling:         self.reorder(order)
        cbilling:         
        cbilling:     def on_restart_selected_triggered(self):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         name_items = [self.model.item(row, self.COL_NAME) for row in selected_rows]
        cbilling:         filepaths = [item.data(self.ROLE_FULLPATH) for item in name_items]
        cbilling:         for routine in self.routines:
        cbilling:             if routine.filepath in filepaths:
        cbilling:                 routine.restart()
        cbilling:         self.update_select_all_checkstate()
        cbilling:        
        cbilling:     def analysis_loop(self):
        cbilling:         while True:
        cbilling:             filepath = self.from_filebox.get()
        cbilling:             if self.multishot:
        cbilling:                 assert filepath is None
        cbilling:                 # TODO: get the filepath of the output h5 file: 
        cbilling:                 # filepath = self.filechooserentry.get_text()
        cbilling:             self.logger.info('got a file to process: %s'%filepath)
        cbilling:             self.do_analysis(filepath)
        cbilling:     
        cbilling:     def todo(self):
        cbilling:         """How many analysis routines are not done?"""
        cbilling:         return len([r for r in self.routines if r.enabled() and not r.done])
        cbilling:         
        cbilling:     def do_analysis(self, filepath):
        cbilling:         """Run all analysis routines once on the given filepath,
        cbilling:         which is a shot file if we are a singleshot routine box"""
        cbilling:         for routine in self.routines:
        cbilling:             routine.set_status('clear')
        cbilling:         remaining = self.todo()
        cbilling:         error = False
             jan:         updated_data = {}
        cbilling:         while remaining:
        cbilling:             self.logger.debug('%d routines left to do'%remaining)
        cbilling:             for routine in self.routines:
        cbilling:                 if routine.enabled() and not routine.done:
        cbilling:                     break
        cbilling:             else:
        cbilling:                 routine = None
        cbilling:             if routine is not None:
        cbilling:                 self.logger.info('running analysis routine %s'%routine.shortname)
        cbilling:                 routine.set_status('working')
             jan:                 success, updated_data = routine.do_analysis(filepath)
        cbilling:                 if success:
        cbilling:                     routine.set_status('done')
        cbilling:                     self.logger.debug('success')
        cbilling:                 else:
        cbilling:                     routine.set_status('error')
        cbilling:                     self.logger.debug('failure')
        cbilling:                     error = True
        cbilling:                     break
        cbilling:             # Race conditions here, but it's only for reporting percent done
        cbilling:             # so it doesn't matter if it's wrong briefly:
        cbilling:             remaining = self.todo()
        cbilling:             total = len([r for r in self.routines if r.enabled()])
        cbilling:             done = total - remaining
        cbilling:             try:
        cbilling:                 status_percent = 100*float(done)/(remaining + done)
        cbilling:             except ZeroDivisionError:
        cbilling:                 # All routines got deleted mid-analysis, we're done here:
        cbilling:                 status_percent = 100.0
             jan:             self.to_filebox.put(['progress', status_percent, updated_data])
        cbilling:         if error:
             jan:             self.to_filebox.put(['error', None, updated_data])
        cbilling:         else:
     janwerkmann:             self.to_filebox.put(['done', 100.0, {}])
        cbilling:         self.logger.debug('completed analysis of %s'%filepath)
        cbilling:             
        cbilling:     def reorder(self, order):
        cbilling:         assert len(order) == len(set(order)), 'ordering contains non-unique elements'
        cbilling:         # Apply the reordering to the liststore:
        cbilling:         for old_index, new_index in enumerate(order):
        cbilling:             name_item = self.model.item(old_index, self.COL_NAME)
        cbilling:             name_item.setData(new_index, self.ROLE_SORTINDEX)
        cbilling:         self.ui.treeView.sortByColumn(self.COL_NAME, QtCore.Qt.AscendingOrder)
        cbilling:         # Apply new order to our list of routines too:
chrisjbillington:         self.routines = [self.routines[order.index(i)] for i in range(len(order))]
        cbilling: 
        cbilling:     def update_select_all_checkstate(self):
        cbilling:         with self.select_all_checkbox_state_changed_disconnected:
        cbilling:             all_states = []
        cbilling:             for row in range(self.model.rowCount()):
        cbilling:                 active_item = self.model.item(row, self.COL_ACTIVE)
        cbilling:                 all_states.append(active_item.checkState())
        cbilling:             if all(state == QtCore.Qt.Checked for state in all_states):
        cbilling:                 self.select_all_checkbox.setCheckState(QtCore.Qt.Checked)
        cbilling:             elif all(state == QtCore.Qt.Unchecked for state in all_states):
        cbilling:                 self.select_all_checkbox.setCheckState(QtCore.Qt.Unchecked)
        cbilling:             else:
        cbilling:                 self.select_all_checkbox.setCheckState(QtCore.Qt.PartiallyChecked)
        cbilling:                 
        cbilling:    # TESTING ONLY REMOVE IN PRODUCTION
        cbilling:     def queue_dummy_routines(self):
        cbilling:         folder = os.path.abspath('test_routines')
        cbilling:         for filepath in ['hello.py', 'test.py']:
        cbilling:             routine = AnalysisRoutine(os.path.join(folder, filepath), self.model, self.output_box_port)
        cbilling:             self.routines.append(routine)
        cbilling:         self.update_select_all_checkstate()
     janwerkmann: 
     janwerkmann: 
     janwerkmann: class EditColumnsDialog(QtWidgets.QDialog):
        cbilling:     # A signal for when the window manager has created a new window for this widget:
        cbilling:     newWindow = Signal(int)
        cbilling:     close_signal = Signal()
        cbilling: 
        cbilling:     def __init__(self):
     janwerkmann:         QtWidgets.QDialog.__init__(self, None, QtCore.Qt.WindowSystemMenuHint | QtCore.Qt.WindowTitleHint)
        cbilling: 
        cbilling:     def event(self, event):
     janwerkmann:         result = QtWidgets.QDialog.event(self, event)
        cbilling:         if event.type() == QtCore.QEvent.WinIdChange:
        cbilling:             self.newWindow.emit(self.effectiveWinId())
        cbilling:         return result
        cbilling: 
        cbilling:     def closeEvent(self, event):
        cbilling:         self.close_signal.emit()
        cbilling:         event.ignore()
        cbilling: 
        cbilling: 
        cbilling: class EditColumns(object):
        cbilling:     ROLE_SORT_DATA = QtCore.Qt.UserRole + 1
        cbilling:     COL_VISIBLE = 0
        cbilling:     COL_NAME = 1
        cbilling: 
        cbilling:     def __init__(self, filebox, column_names, columns_visible):
        cbilling:         self.filebox = filebox
        cbilling:         self.column_names = column_names.copy()
        cbilling:         self.columns_visible = columns_visible.copy()
        cbilling:         self.old_columns_visible = columns_visible.copy()
        cbilling: 
        cbilling:         loader = UiLoader()
        cbilling:         self.ui = loader.load('edit_columns.ui', EditColumnsDialog())
        cbilling: 
        cbilling:         self.model = UneditableModel()
        cbilling:         self.header = HorizontalHeaderViewWithWidgets(self.model)
     janwerkmann:         self.select_all_checkbox = QtWidgets.QCheckBox()
        cbilling:         self.select_all_checkbox.setTristate(False)
        cbilling:         self.ui.treeView.setHeader(self.header)
     janwerkmann:         self.proxy_model = QtCore.QSortFilterProxyModel()
        cbilling:         self.proxy_model.setSourceModel(self.model)
        cbilling:         self.proxy_model.setFilterCaseSensitivity(QtCore.Qt.CaseInsensitive)
        cbilling:         self.proxy_model.setFilterKeyColumn(self.COL_NAME)
        cbilling:         self.ui.treeView.setSortingEnabled(True)
        cbilling:         self.header.setStretchLastSection(True)
        cbilling:         self.proxy_model.setSortRole(self.ROLE_SORT_DATA)
        cbilling:         self.ui.treeView.setModel(self.proxy_model)
        cbilling:         self.ui.setWindowModality(QtCore.Qt.ApplicationModal)
        cbilling: 
        cbilling:         self.ui.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        cbilling:         # Make the actions for the context menu:
     janwerkmann:         self.action_set_selected_visible = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box'), 'Show selected columns',  self.ui)
     janwerkmann:         self.action_set_selected_hidden = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box-uncheck'), 'Hide selected columns',  self.ui)
        cbilling: 
        cbilling:         self.connect_signals()
        cbilling:         self.populate_model(column_names, self.columns_visible)
        cbilling: 
        cbilling:     def connect_signals(self):
        cbilling:         if os.name == 'nt':
        cbilling:             self.ui.newWindow.connect(set_win_appusermodel)
        cbilling:         self.ui.close_signal.connect(self.close)
        cbilling:         self.ui.lineEdit_filter.textEdited.connect(self.on_filter_text_edited)
        cbilling:         self.ui.pushButton_make_it_so.clicked.connect(self.make_it_so)
        cbilling:         self.ui.pushButton_cancel.clicked.connect(self.cancel)
        cbilling:         self.model.itemChanged.connect(self.on_model_item_changed)
        cbilling:         # A context manager with which we can temporarily disconnect the above connection.
        cbilling:         self.model_item_changed_disconnected = DisconnectContextManager(
        cbilling:             self.model.itemChanged, self.on_model_item_changed)
        cbilling:         self.select_all_checkbox.stateChanged.connect(self.on_select_all_state_changed)
        cbilling:         self.select_all_checkbox_state_changed_disconnected = DisconnectContextManager(
        cbilling:             self.select_all_checkbox.stateChanged, self.on_select_all_state_changed)
        cbilling:         self.ui.treeView.customContextMenuRequested.connect(self.on_treeView_context_menu_requested)
        cbilling:         self.action_set_selected_visible.triggered.connect(
        cbilling:             lambda: self.on_set_selected_triggered(QtCore.Qt.Checked))
        cbilling:         self.action_set_selected_hidden.triggered.connect(
        cbilling:             lambda: self.on_set_selected_triggered(QtCore.Qt.Unchecked))
        cbilling: 
        cbilling:     def populate_model(self, column_names, columns_visible):
        cbilling:         self.model.clear()
        cbilling:         self.model.setHorizontalHeaderLabels(['', 'Name'])
        cbilling:         self.header.setWidget(self.COL_VISIBLE, self.select_all_checkbox)
        cbilling:         self.ui.treeView.resizeColumnToContents(self.COL_VISIBLE)
        cbilling:         # Which indices in self.columns_visible the row numbers correspond to
        cbilling:         self.column_indices = {}
chrisjbillington: 
chrisjbillington:         # Remove our special columns from the dict of column names by keeping only tuples:
chrisjbillington:         column_names = {i: name for i, name in column_names.items() if isinstance(name, tuple)}
chrisjbillington: 
chrisjbillington:         # Sort the column names as comma separated values, converting to lower case:
chrisjbillington:         sortkey = lambda item: ', '.join(item[1]).lower().strip(', ')
chrisjbillington: 
chrisjbillington:         for column_index, name in sorted(column_names.items(), key=sortkey):
        cbilling:             visible = columns_visible[column_index]
        cbilling:             visible_item = QtGui.QStandardItem()
        cbilling:             visible_item.setCheckable(True)
        cbilling:             if visible:
        cbilling:                 visible_item.setCheckState(QtCore.Qt.Checked)
        cbilling:                 visible_item.setData(QtCore.Qt.Checked, self.ROLE_SORT_DATA)
        cbilling:             else:
        cbilling:                 visible_item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:                 visible_item.setData(QtCore.Qt.Unchecked, self.ROLE_SORT_DATA)
        cbilling:             name_as_string = ', '.join(name).strip(', ')
        cbilling:             name_item = QtGui.QStandardItem(name_as_string)
chrisjbillington:             name_item.setData(sortkey((column_index, name)), self.ROLE_SORT_DATA)
        cbilling:             self.model.appendRow([visible_item, name_item])
        cbilling:             self.column_indices[self.model.rowCount() - 1] = column_index
        cbilling: 
        cbilling:         self.ui.treeView.resizeColumnToContents(self.COL_NAME)
        cbilling:         self.update_select_all_checkstate()
        cbilling:         self.ui.treeView.sortByColumn(self.COL_NAME, QtCore.Qt.AscendingOrder)
        cbilling: 
        cbilling:     def on_treeView_context_menu_requested(self, point):
     janwerkmann:         menu = QtWidgets.QMenu(self.ui)
        cbilling:         menu.addAction(self.action_set_selected_visible)
        cbilling:         menu.addAction(self.action_set_selected_hidden)
        cbilling:         menu.exec_(QtGui.QCursor.pos())
        cbilling: 
        cbilling:     def on_set_selected_triggered(self, visible):
        cbilling:         selected_indexes = self.ui.treeView.selectedIndexes()
        cbilling:         selected_rows = set(self.proxy_model.mapToSource(index).row() for index in selected_indexes)
        cbilling:         for row in selected_rows:
        cbilling:             visible_item = self.model.item(row, self.COL_VISIBLE)
        cbilling:             self.update_visible_state(visible_item, visible)
        cbilling:         self.update_select_all_checkstate()
        cbilling:         self.do_sort()
        cbilling:         self.filebox.set_columns_visible(self.columns_visible)
        cbilling: 
        cbilling:     def on_filter_text_edited(self, text):
        cbilling:         self.proxy_model.setFilterWildcard(text)
        cbilling: 
        cbilling:     def on_select_all_state_changed(self, state):
        cbilling:         with self.select_all_checkbox_state_changed_disconnected:
        cbilling:             # Do not allow a switch *to* a partially checked state:
        cbilling:             self.select_all_checkbox.setTristate(False)
        cbilling:         state = self.select_all_checkbox.checkState()
        cbilling:         for row in range(self.model.rowCount()):
        cbilling:             visible_item = self.model.item(row, self.COL_VISIBLE)
        cbilling:             self.update_visible_state(visible_item, state)
        cbilling:         self.do_sort()
        cbilling:         
        cbilling:         self.filebox.set_columns_visible(self.columns_visible)
        cbilling: 
        cbilling:     def update_visible_state(self, item, state):
        cbilling:         assert item.column() == self.COL_VISIBLE, "unexpected column"
        cbilling:         row = item.row()
        cbilling:         with self.model_item_changed_disconnected:
        cbilling:             item.setCheckState(state)
        cbilling:             item.setData(state, self.ROLE_SORT_DATA)
        cbilling:             if state == QtCore.Qt.Checked:
        cbilling:                 self.columns_visible[self.column_indices[row]] = True
        cbilling:             else:
        cbilling:                 self.columns_visible[self.column_indices[row]] = False
        cbilling: 
        cbilling:     def update_select_all_checkstate(self):
        cbilling:         with self.select_all_checkbox_state_changed_disconnected:
        cbilling:             all_states = []
        cbilling:             for row in range(self.model.rowCount()):
        cbilling:                 visible_item = self.model.item(row, self.COL_VISIBLE)
        cbilling:                 all_states.append(visible_item.checkState())
        cbilling:             if all(state == QtCore.Qt.Checked for state in all_states):
        cbilling:                 self.select_all_checkbox.setCheckState(QtCore.Qt.Checked)
        cbilling:             elif all(state == QtCore.Qt.Unchecked for state in all_states):
        cbilling:                 self.select_all_checkbox.setCheckState(QtCore.Qt.Unchecked)
        cbilling:             else:
        cbilling:                 self.select_all_checkbox.setCheckState(QtCore.Qt.PartiallyChecked)
        cbilling: 
        cbilling:     def on_model_item_changed(self, item):
        cbilling:         state = item.checkState()
        cbilling:         self.update_visible_state(item, state)
        cbilling:         self.update_select_all_checkstate()
        cbilling:         self.do_sort()
        cbilling:         self.filebox.set_columns_visible(self.columns_visible)
        cbilling: 
        cbilling:     def do_sort(self):
        cbilling:         header = self.ui.treeView.header()
        cbilling:         sort_column = header.sortIndicatorSection()
        cbilling:         sort_order = header.sortIndicatorOrder()
        cbilling:         self.ui.treeView.sortByColumn(sort_column, sort_order)
        cbilling: 
        cbilling:     def update_columns(self, column_names, columns_visible):
           Chris: 
           Chris:         # Index/name mapping may have changed. Get a mapping by *name* of
           Chris:         # which columns were previously visible, so we can update our by-index
           Chris:         # mapping in a moment:
           Chris:         old_columns_visible_by_name = {}
           Chris:         for old_column_number, visible in self.old_columns_visible.items():
           Chris:             column_name = self.column_names[old_column_number]
           Chris:             old_columns_visible_by_name[column_name] = visible
           Chris: 
        cbilling:         self.columns_visible = columns_visible.copy()
        cbilling:         self.column_names = column_names.copy()
           Chris: 
           Chris:         # Update the by-index mapping of which columns were visible before editing:
           Chris:         self.old_columns_visible = {}
           Chris:         for index, name in self.column_names.items():
           Chris:             try:
           Chris:                 self.old_columns_visible[index] = old_columns_visible_by_name[name]
           Chris:             except KeyError:
           Chris:                 # A new column. If editing is cancelled, any new columns
           Chris:                 # should be set to visible:
        cbilling:                 self.old_columns_visible[index] = True
        cbilling:         self.populate_model(column_names, self.columns_visible)
        cbilling: 
        cbilling:     def show(self):
        cbilling:         self.old_columns_visible = self.columns_visible.copy()
        cbilling:         self.ui.show()
        cbilling: 
        cbilling:     def close(self):
        cbilling:         self.columns_visible = self.old_columns_visible.copy()
        cbilling:         self.filebox.set_columns_visible(self.columns_visible)
        cbilling:         self.populate_model(self.column_names, self.columns_visible)
        cbilling:         self.ui.hide()
        cbilling: 
        cbilling:     def cancel(self):
        cbilling:         self.ui.close()
        cbilling: 
        cbilling:     def make_it_so(self):
        cbilling:         self.ui.hide()
        cbilling: 
        cbilling: 
     janwerkmann: class ItemDelegate(QtWidgets.QStyledItemDelegate):
        cbilling: 
        cbilling:     """An item delegate with a fixed height and a progress bar in one column"""
        cbilling:     EXTRA_ROW_HEIGHT = 2
        cbilling: 
        cbilling:     def __init__(self, view, model, col_status, role_status_percent):
        cbilling:         self.view = view
        cbilling:         self.model = model
        cbilling:         self.COL_STATUS = col_status
        cbilling:         self.ROLE_STATUS_PERCENT = role_status_percent
     janwerkmann:         QtWidgets.QStyledItemDelegate.__init__(self)
        cbilling: 
        cbilling:     def sizeHint(self, *args):
        cbilling:         fontmetrics = QtGui.QFontMetrics(self.view.font())
        cbilling:         text_height = fontmetrics.height()
        cbilling:         row_height = text_height + self.EXTRA_ROW_HEIGHT
     janwerkmann:         size = QtWidgets.QStyledItemDelegate.sizeHint(self, *args)
        cbilling:         return QtCore.QSize(size.width(), row_height)
        cbilling: 
        cbilling:     def paint(self, painter, option, index):
        cbilling:         if index.column() == self.COL_STATUS:
        cbilling:             status_percent = self.model.data(index, self.ROLE_STATUS_PERCENT)
        cbilling:             if status_percent == 100:
        cbilling:                 # Render as a normal item - this shows whatever icon is set instead of a progress bar.
     janwerkmann:                 return QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
        cbilling:             else:
        cbilling:                 # Method of rendering a progress bar into the view copied from
        cbilling:                 # Qt's 'network-torrent' example:
        cbilling:                 # http://qt-project.org/doc/qt-4.8/network-torrent-torrentclient-cpp.html
        cbilling: 
        cbilling:                 # Set up a QStyleOptionProgressBar to precisely mimic the
        cbilling:                 # environment of a progress bar.
     janwerkmann:                 progress_bar_option = QtWidgets.QStyleOptionProgressBar()
     janwerkmann:                 progress_bar_option.state = QtWidgets.QStyle.State_Enabled
        cbilling:                 progress_bar_option.direction = qapplication.layoutDirection()
        cbilling:                 progress_bar_option.rect = option.rect
        cbilling:                 progress_bar_option.fontMetrics = qapplication.fontMetrics()
        cbilling:                 progress_bar_option.minimum = 0
        cbilling:                 progress_bar_option.maximum = 100
        cbilling:                 progress_bar_option.textAlignment = QtCore.Qt.AlignCenter
        cbilling:                 progress_bar_option.textVisible = True
        cbilling: 
        cbilling:                 # Set the progress and text values of the style option.
        cbilling:                 progress_bar_option.progress = status_percent
        cbilling:                 progress_bar_option.text = '%d%%' % status_percent
        cbilling: 
        cbilling:                 # Draw the progress bar onto the view.
     janwerkmann:                 qapplication.style().drawControl(QtWidgets.QStyle.CE_ProgressBar, progress_bar_option, painter)
        cbilling:         else:
     janwerkmann:             return QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
        cbilling: 
        cbilling: 
        cbilling: class UneditableModel(QtGui.QStandardItemModel):
        cbilling: 
        cbilling:     def flags(self, index):
        cbilling:         """Return flags as normal except that the ItemIsEditable
        cbilling:         flag is always False"""
        cbilling:         result = QtGui.QStandardItemModel.flags(self, index)
        cbilling:         return result & ~QtCore.Qt.ItemIsEditable
        cbilling: 
        cbilling: 
     janwerkmann: class TableView(QtWidgets.QTableView):
        cbilling:     leftClicked = Signal(QtCore.QModelIndex)
        cbilling:     doubleLeftClicked = Signal(QtCore.QModelIndex)
        cbilling:     """A QTableView that emits a custom signal leftClicked(index) after a left
        cbilling:     click on a valid index, and doubleLeftClicked(index) (in addition) on
        cbilling:     double click. Multiple inheritance of QObjects is not possible, so we
        cbilling:     are forced to duplicate code instead of sharing code with the extremely
        cbilling:     similar TreeView class in this module"""
        cbilling: 
        cbilling:     def __init__(self, *args):
     janwerkmann:         QtWidgets.QTableView.__init__(self, *args)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling: 
        cbilling:     def mousePressEvent(self, event):
     janwerkmann:         result = QtWidgets.QTableView.mousePressEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid():
        cbilling:             self._pressed_index = self.indexAt(event.pos())
        cbilling:         return result
        cbilling: 
        cbilling:     def leaveEvent(self, event):
     janwerkmann:         result = QtWidgets.QTableView.leaveEvent(self, event)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         return result
        cbilling: 
        cbilling:     def mouseDoubleClickEvent(self, event):
        cbilling:         # Ensure our left click event occurs regardless of whether it is the
        cbilling:         # second click in a double click or not
     janwerkmann:         result = QtWidgets.QTableView.mouseDoubleClickEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid():
        cbilling:             self._pressed_index = self.indexAt(event.pos())
        cbilling:             self._double_click = True
        cbilling:         return result
        cbilling: 
        cbilling:     def mouseReleaseEvent(self, event):
     janwerkmann:         result = QtWidgets.QTableView.mouseReleaseEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid() and index == self._pressed_index:
        cbilling:             self.leftClicked.emit(index)
        cbilling:             if self._double_click:
        cbilling:                 self.doubleLeftClicked.emit(index)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         return result
        cbilling:         
        cbilling:         
        cbilling: class DataFrameModel(QtCore.QObject):
        cbilling: 
        cbilling:     COL_STATUS = 0
        cbilling:     COL_FILEPATH = 1
        cbilling: 
        cbilling:     ROLE_STATUS_PERCENT = QtCore.Qt.UserRole + 1
           Chris:     ROLE_DELETED_OFF_DISK = QtCore.Qt.UserRole + 2
        cbilling:     
        cbilling:     columns_changed = Signal()
        cbilling: 
        cbilling:     def __init__(self, view, exp_config):
        cbilling:         QtCore.QObject.__init__(self)
        cbilling:         self._view = view
        cbilling:         self.exp_config = exp_config
        cbilling:         self._model = UneditableModel()
chrisjbillington:         self.row_number_by_filepath = {}
chrisjbillington:         self._previous_n_digits = 0
        cbilling: 
        cbilling:         headerview_style = """
        cbilling:                            QHeaderView {
        cbilling:                              font-size: 8pt;
        cbilling:                              color: black;
        cbilling:                            }
        cbilling:                            QHeaderView::section{
        cbilling:                              font-size: 8pt;
        cbilling:                              color: black;
        cbilling:                            }
        cbilling:                            """
        cbilling:                            
        cbilling:         self._header = HorizontalHeaderViewWithWidgets(self._model)
     janwerkmann:         self._vertheader = QtWidgets.QHeaderView(QtCore.Qt.Vertical)
     janwerkmann:         self._vertheader.setSectionResizeMode(QtWidgets.QHeaderView.Fixed)
        cbilling:         self._vertheader.setStyleSheet(headerview_style)
        cbilling:         self._header.setStyleSheet(headerview_style)
        cbilling:         self._vertheader.setHighlightSections(True)
     janwerkmann:         self._vertheader.setSectionsClickable(True)
        cbilling:         self._view.setModel(self._model)
        cbilling:         self._view.setHorizontalHeader(self._header)
        cbilling:         self._view.setVerticalHeader(self._vertheader)
        cbilling:         self._delegate = ItemDelegate(self._view, self._model, self.COL_STATUS, self.ROLE_STATUS_PERCENT)
        cbilling:         self._view.setItemDelegate(self._delegate)
     janwerkmann:         self._view.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        cbilling:         self._view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        cbilling: 
          rander:         # Check if integer indexing is to be used
          rander:         try:
          rander:             self.integer_indexing = self.exp_config.getboolean('lyse', 'integer_indexing')
          rander:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
          rander:             self.integer_indexing = False
          rander: 
        cbilling:         # This dataframe will contain all the scalar data
        cbilling:         # from the shot files that are currently open:
        cbilling:         index = pandas.MultiIndex.from_tuples([('filepath', '')])
        cbilling:         self.dataframe = pandas.DataFrame({'filepath': []}, columns=index)
        cbilling:         # How many levels the dataframe's multiindex has:
        cbilling:         self.nlevels = self.dataframe.columns.nlevels
        cbilling: 
        cbilling:         status_item = QtGui.QStandardItem()
        cbilling:         status_item.setIcon(QtGui.QIcon(':qtutils/fugue/information'))
        cbilling:         status_item.setToolTip('status/progress of single-shot analysis')
        cbilling:         self._model.setHorizontalHeaderItem(self.COL_STATUS, status_item)
        cbilling: 
        cbilling:         filepath_item = QtGui.QStandardItem('filepath')
        cbilling:         filepath_item.setToolTip('filepath')
        cbilling:         self._model.setHorizontalHeaderItem(self.COL_FILEPATH, filepath_item)
        cbilling: 
        cbilling:         self._view.setColumnWidth(self.COL_STATUS, 70)
        cbilling:         self._view.setColumnWidth(self.COL_FILEPATH, 100)
        cbilling: 
        cbilling:         # Column indices to names and vice versa for fast lookup:
        cbilling:         self.column_indices = {'__status': self.COL_STATUS, ('filepath', ''): self.COL_FILEPATH}
        cbilling:         self.column_names = {self.COL_STATUS: '__status', self.COL_FILEPATH: ('filepath', '')}
        cbilling:         self.columns_visible = {self.COL_STATUS: True, self.COL_FILEPATH: True}
        cbilling: 
           Chris:         # Whether or not a deleted column was visible at the time it was deleted (by name):
           Chris:         self.deleted_columns_visible = {}
           Chris:         
        cbilling:         # Make the actions for the context menu:
     janwerkmann:         self.action_remove_selected = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/minus'), 'Remove selected shots',  self._view)
        cbilling: 
        cbilling:         self.connect_signals()
        cbilling: 
        cbilling:     def connect_signals(self):
        cbilling:         self._view.customContextMenuRequested.connect(self.on_view_context_menu_requested)
        cbilling:         self.action_remove_selected.triggered.connect(self.on_remove_selection)
        cbilling: 
        cbilling:     def on_remove_selection(self):
chrisjbillington:         self.remove_selection()
chrisjbillington: 
chrisjbillington:     def remove_selection(self, confirm=True):
        cbilling:         selection_model = self._view.selectionModel()
        cbilling:         selected_indexes = selection_model.selectedRows()
        cbilling:         selected_name_items = [self._model.itemFromIndex(index) for index in selected_indexes]
        cbilling:         if not selected_name_items:
        cbilling:             return
           Chris:         if confirm and not question_dialog("Remove %d shots?" % len(selected_name_items)):
        cbilling:             return
        cbilling:         # Remove from DataFrame first:
        cbilling:         self.dataframe = self.dataframe.drop(index.row() for index in selected_indexes)
        cbilling:         self.dataframe.index = pandas.Index(range(len(self.dataframe)))
        cbilling:         # Delete one at a time from Qt model:
        cbilling:         for name_item in selected_name_items:
        cbilling:             row = name_item.row()
        cbilling:             self._model.removeRow(row)
           Chris:         self.renumber_rows()
        cbilling: 
        cbilling:     def mark_selection_not_done(self):
        cbilling:         selected_indexes = self._view.selectedIndexes()
        cbilling:         selected_rows = set(index.row() for index in selected_indexes)
        cbilling:         for row in selected_rows:
        cbilling:             status_item = self._model.item(row, self.COL_STATUS)
chrisjbillington:             if status_item.data(self.ROLE_DELETED_OFF_DISK):
chrisjbillington:                 # If the shot was previously not readable on disk, check to
chrisjbillington:                 # see if it's readable now. It may have been undeleted or
chrisjbillington:                 # perhaps it being unreadable before was due to a network
chrisjbillington:                 # glitch or similar.
chrisjbillington:                 filepath = self._model.item(row, self.COL_FILEPATH).text()
chrisjbillington:                 if not os.path.exists(filepath):
chrisjbillington:                     continue
chrisjbillington:                 # Shot file is accesible again:
chrisjbillington:                 status_item.setData(False, self.ROLE_DELETED_OFF_DISK)
chrisjbillington:                 status_item.setIcon(QtGui.QIcon(':qtutils/fugue/tick'))
chrisjbillington:                 status_item.setToolTip(None)
chrisjbillington: 
        cbilling:             status_item.setData(0, self.ROLE_STATUS_PERCENT)
        cbilling:         
        cbilling:     def on_view_context_menu_requested(self, point):
     janwerkmann:         menu = QtWidgets.QMenu(self._view)
        cbilling:         menu.addAction(self.action_remove_selected)
        cbilling:         menu.exec_(QtGui.QCursor.pos())
        cbilling: 
        cbilling:     def on_double_click(self, index):
        cbilling:         filepath_item = self._model.item(index.row(), self.COL_FILEPATH)
        cbilling:         shot_filepath = filepath_item.text()
        cbilling:         
        cbilling:         # get path to text editor
        cbilling:         viewer_path = self.exp_config.get('programs', 'hdf5_viewer')
        cbilling:         viewer_args = self.exp_config.get('programs', 'hdf5_viewer_arguments')
        cbilling:         # Get the current labscript file:
        cbilling:         if not viewer_path:
        cbilling:             error_dialog("No hdf5 viewer specified in the labconfig.")
        cbilling:         if '{file}' in viewer_args:
        cbilling:             # Split the args on spaces into a list, replacing {file} with the labscript file
        cbilling:             viewer_args = [arg if arg != '{file}' else shot_filepath for arg in viewer_args.split()]
        cbilling:         else:
        cbilling:             # Otherwise if {file} isn't already in there, append it to the other args:
        cbilling:             viewer_args = [shot_filepath] + viewer_args.split()
        cbilling:         try:
        cbilling:             subprocess.Popen([viewer_path] + viewer_args)
        cbilling:         except Exception as e:
        cbilling:             error_dialog("Unable to launch hdf5 viewer specified in %s. Error was: %s" %
        cbilling:                          (self.exp_config.config_path, str(e)))
        cbilling:         
        cbilling:     def set_columns_visible(self, columns_visible):
        cbilling:         self.columns_visible = columns_visible
        cbilling:         for column_index, visible in columns_visible.items():
        cbilling:             self._view.setColumnHidden(column_index, not visible)
        cbilling: 
        cbilling:     def update_column_levels(self):
        cbilling:         """Pads the keys and values of our lists of column names so that
        cbilling:         they still match those in the dataframe after the number of
        cbilling:         levels in its multiindex has increased"""
        cbilling:         extra_levels = self.dataframe.columns.nlevels - self.nlevels
        cbilling:         if extra_levels > 0:
        cbilling:             self.nlevels = self.dataframe.columns.nlevels
        cbilling:             column_indices = {}
        cbilling:             column_names = {}
        cbilling:             for column_name in self.column_indices:
        cbilling:                 if not isinstance(column_name, tuple):
        cbilling:                     # It's one of our special columns
        cbilling:                     new_column_name = column_name
        cbilling:                 else:
        cbilling:                     new_column_name = column_name + ('',) * extra_levels
        cbilling:                 column_index = self.column_indices[column_name]
        cbilling:                 column_indices[new_column_name] = column_index
        cbilling:                 column_names[column_index] = new_column_name
        cbilling:             self.column_indices = column_indices
        cbilling:             self.column_names = column_names
        cbilling: 
        cbilling:     @inmain_decorator()
           Chris:     def mark_as_deleted_off_disk(self, filepath):
           Chris:         # Confirm the shot hasn't been removed from lyse (we are in the main
           Chris:         # thread so there is no race condition in checking first)
           Chris:         if not filepath in self.dataframe['filepath'].values:
           Chris:             # Shot has been removed from FileBox, nothing to do here:
           Chris:             return
           Chris: 
chrisjbillington:         row_number = self.row_number_by_filepath[filepath]
chrisjbillington:         status_item = self._model.item(row_number, self.COL_STATUS)
           Chris:         already_marked_as_deleted = status_item.data(self.ROLE_DELETED_OFF_DISK)
           Chris:         if already_marked_as_deleted:
           Chris:             return
           Chris:         # Icon only displays if percent completion is 100. This is also
           Chris:         # important so that the shot is not picked up as analysis
           Chris:         # incomplete and analysis re-attempted on it.
           Chris:         status_item.setData(True, self.ROLE_DELETED_OFF_DISK)
           Chris:         status_item.setData(100, self.ROLE_STATUS_PERCENT)
           Chris:         status_item.setToolTip("Shot has been deleted off disk or is unreadable")
           Chris:         status_item.setIcon(QtGui.QIcon(':qtutils/fugue/drive--minus'))
           Chris:         app.output_box.output('Warning: Shot deleted from disk or no longer readable %s\n' % filepath, red=True)
           Chris: 
           Chris:     @inmain_decorator()
             jan:     def update_row(self, filepath, dataframe_already_updated=False, status_percent=None, new_row_data=None, updated_row_data=None):
        cbilling:         """"Updates a row in the dataframe and Qt model
        cbilling:         to the data in the HDF5 file for that shot. Also sets the percent done, if specified"""
     janwerkmann:         # To speed things up block signals to the model during update
     janwerkmann:         self._model.blockSignals(True)
     janwerkmann: 
        cbilling:         # Update the row in the dataframe first:
             jan:         if (new_row_data is None) == (updated_row_data is None) and not dataframe_already_updated:
             jan:             raise ValueError('Exactly one of new_row_data or updated_row_data must be provided')
             jan: 
        cbilling:         try:
chrisjbillington:             row_number = self.row_number_by_filepath[filepath]
chrisjbillington:         except KeyError:
        cbilling:             # Row has been deleted, nothing to do here:
        cbilling:             return
     janwerkmann: 
chrisjbillington:         filepath_colname = ('filepath',) + ('',) * (self.nlevels - 1)
chrisjbillington:         assert filepath == self.dataframe.get_value(row_number, filepath_colname)
chrisjbillington: 
     janwerkmann:         if updated_row_data is not None and not dataframe_already_updated:
     janwerkmann:             for group, name in updated_row_data:
           Chris:                 column_name = (group, name) + ('',) * (self.nlevels - 2)
           Chris:                 value = updated_row_data[group, name]
           Chris:                 try:
chrisjbillington:                     self.dataframe.set_value(row_number, column_name, value)
           Chris:                 except ValueError:
           Chris:                     # did the column not already exist when we tried to set an iterable?
           Chris:                     if not column_name in self.dataframe.columns:
           Chris:                         # create it with a non-iterable and then overwrite with the iterable value:
chrisjbillington:                         self.dataframe.set_value(row_number, column_name, None)
           Chris:                     else:
           Chris:                         # Incompatible datatype - convert the datatype of the column to
           Chris:                         # 'object'
           Chris:                         self.dataframe[column_name] = self.dataframe[column_name].astype('object')
           Chris:                     # Now that the column exists and has dtype object, we can set the value:
chrisjbillington:                     self.dataframe.set_value(row_number, column_name, value)
           Chris: 
     janwerkmann:             dataframe_already_updated = True
     janwerkmann: 
        cbilling:         if not dataframe_already_updated:
        cbilling:             if new_row_data is None:
           Chris:                 raise ValueError("If dataframe_already_updated is False, then new_row_data, as returned "
           Chris:                                  "by dataframe_utils.get_dataframe_from_shot(filepath) must be provided.")
chrisjbillington:             self.dataframe = replace_with_padding(self.dataframe, new_row_data, row_number)
        cbilling:             self.update_column_levels()
        cbilling: 
        cbilling:         # Check and create necessary new columns in the Qt model:
        cbilling:         new_column_names = set(self.dataframe.columns) - set(self.column_names.values())
        cbilling:         new_columns_start = self._model.columnCount()
        cbilling:         self._model.insertColumns(new_columns_start, len(new_column_names))
        cbilling:         for i, column_name in enumerate(sorted(new_column_names)):
        cbilling:             # Set the header label of the new column:
        cbilling:             column_number = new_columns_start + i
        cbilling:             self.column_names[column_number] = column_name
        cbilling:             self.column_indices[column_name] = column_number
           Chris:             if column_name in self.deleted_columns_visible:
           Chris:                 # Restore the former visibility of this column if we've
           Chris:                 # seen one with its name before:
           Chris:                 visible = self.deleted_columns_visible[column_name]
           Chris:                 self.columns_visible[column_number] = visible
           Chris:                 self._view.setColumnHidden(column_number, not visible)
           Chris:             else:
           Chris:                 # new columns are visible by default:
           Chris:                 self.columns_visible[column_number] = True
        cbilling:             column_name_as_string = '\n'.join(column_name).strip()
        cbilling:             header_item = QtGui.QStandardItem(column_name_as_string)
        cbilling:             header_item.setToolTip(column_name_as_string)
        cbilling:             self._model.setHorizontalHeaderItem(column_number, header_item)
           Chris:         if new_column_names:
           Chris:             # Update the visibility state of new columns, in case some new columns are hidden:
           Chris:             self.set_columns_visible
        cbilling: 
           Chris:         # Check and remove any no-longer-needed columns in the Qt model:
           Chris:         defunct_column_names = (set(self.column_names.values()) - set(self.dataframe.columns)
           Chris:                                 - {self.column_names[self.COL_STATUS], self.column_names[self.COL_FILEPATH]})
           Chris:         defunct_column_indices = [self.column_indices[column_name] for column_name in defunct_column_names]
           Chris:         for column_number in sorted(defunct_column_indices, reverse=True):
           Chris:             # Remove columns from the Qt model. In reverse order so that
           Chris:             # removals do not change the position of columns yet to be
           Chris:             # removed.
           Chris:             self._model.removeColumn(column_number)
           Chris:             # Save whether or not the column was visible when it was
           Chris:             # removed (so that if it is re-added the visibility will be retained):
           Chris:             self.deleted_columns_visible[self.column_names[column_number]] = self.columns_visible[column_number]
           Chris:             del self.column_names[column_number]
           Chris:             del self.columns_visible[column_number]
           Chris: 
           Chris:         if defunct_column_indices:
           Chris:             # Renumber the keys of self.columns_visible and self.column_names to reflect deletions:
           Chris:             self.column_names = {newindex: name for newindex, (oldindex, name) in enumerate(sorted(self.column_names.items()))}
           Chris:             self.columns_visible = {newindex: visible for newindex, (oldindex, visible) in enumerate(sorted(self.columns_visible.items()))}
           Chris:             # Update the inverse mapping of self.column_names:
           Chris:             self.column_indices = {name: index for index, name in self.column_names.items()}
        cbilling: 
        cbilling:         # Update the data in the Qt model:
chrisjbillington:         dataframe_row = self.dataframe.iloc[row_number].to_dict()
        cbilling:         for column_number, column_name in self.column_names.items():
        cbilling:             if not isinstance(column_name, tuple):
        cbilling:                 # One of our special columns, does not correspond to a column in the dataframe:
        cbilling:                 continue
     janwerkmann:             if updated_row_data is not None and column_name not in updated_row_data:
     janwerkmann:                 continue
        cbilling:             value = dataframe_row[column_name]
        cbilling:             if isinstance(value, float):
        cbilling:                 value_str = scientific_notation(value)
        cbilling:             else:
        cbilling:                 value_str = str(value)
        cbilling:             lines = value_str.splitlines()
        cbilling:             if len(lines) > 1:
        cbilling:                 short_value_str = lines[0] + ' ...'
        cbilling:             else:
        cbilling:                 short_value_str = value_str
chrisjbillington: 
chrisjbillington:             item = self._model.item(row_number, column_number)
chrisjbillington:             if item is None:
chrisjbillington:                 # This is the first time we've written a value to this part of the model:
chrisjbillington:                 item = QtGui.QStandardItem(short_value_str)
chrisjbillington:                 item.setData(QtCore.Qt.AlignCenter, QtCore.Qt.TextAlignmentRole)
chrisjbillington:                 self._model.setItem(row_number, column_number, item)
chrisjbillington:             else:
chrisjbillington:                 item.setText(short_value_str)
        cbilling:             item.setToolTip(repr(value))
        cbilling: 
        cbilling:         for i, column_name in enumerate(sorted(new_column_names)):
        cbilling:             # Resize any new columns to fit contents:
        cbilling:             column_number = new_columns_start + i
        cbilling:             self._view.resizeColumnToContents(column_number)
        cbilling: 
        cbilling:         if status_percent is not None:
chrisjbillington:             status_item = self._model.item(row_number, self.COL_STATUS)
        cbilling:             status_item.setData(status_percent, self.ROLE_STATUS_PERCENT)
        cbilling:             
           Chris:         if new_column_names or defunct_column_names:
        cbilling:             self.columns_changed.emit()
        cbilling: 
     janwerkmann:         # unblock signals to the model and tell it to update
     janwerkmann:         self._model.blockSignals(False)
     janwerkmann:         self._model.layoutChanged.emit()
     janwerkmann: 
        cbilling:     def new_row(self, filepath):
        cbilling:         status_item = QtGui.QStandardItem()
        cbilling:         status_item.setData(0, self.ROLE_STATUS_PERCENT)
        cbilling:         status_item.setIcon(QtGui.QIcon(':qtutils/fugue/tick'))
        cbilling:         name_item = QtGui.QStandardItem(filepath)
        cbilling:         return [status_item, name_item]
        cbilling: 
chrisjbillington:     def renumber_rows(self, add_from=0):
chrisjbillington:         """Add/update row indices - the rows are numbered in simple sequential
chrisjbillington:         order for easy comparison with the dataframe. add_from allows you to
chrisjbillington:         only add numbers for new rows from the given index as a performance
chrisjbillington:         optimisation, though if the number of digits changes, all rows will
chrisjbillington:         still be renumbered. add_from should not be used if rows have been
chrisjbillington:         deleted."""
           Chris:         n_digits = len(str(self._model.rowCount()))
chrisjbillington:         if n_digits != self._previous_n_digits:
chrisjbillington:             # All labels must be updated:
chrisjbillington:             add_from = 0
chrisjbillington:         self._previous_n_digits = n_digits
chrisjbillington: 
chrisjbillington:         if add_from == 0:
chrisjbillington:             self.row_number_by_filepath = {}
chrisjbillington: 
chrisjbillington:         for row_number in range(add_from, self._model.rowCount()):
           Chris:             vertical_header_item = self._model.verticalHeaderItem(row_number)
           Chris:             row_number_str = str(row_number).rjust(n_digits)
          rander:             vert_header_text = '{}. |'.format(row_number_str)
chrisjbillington:             filepath_item = self._model.item(row_number, self.COL_FILEPATH)
chrisjbillington:             filepath = filepath_item.text()
chrisjbillington:             self.row_number_by_filepath[filepath] = row_number
          rander:             if self.integer_indexing:
          rander:                 header_cols = ['sequence_index', 'run number', 'run repeat']
          rander:                 header_strings = []
          rander:                 for col in header_cols:
          rander:                     try:
          rander:                         val = self.dataframe[col].values[row_number]
          rander:                         header_strings.append(' {:04d}'.format(val))
          rander:                     except (KeyError, ValueError):
          rander:                         header_strings.append('----')
          rander:                 vert_header_text += ' |'.join(header_strings)
          rander:             else:
          rander:                 basename = os.path.splitext(os.path.basename(filepath))[0]
          rander:                 vert_header_text += ' ' + basename
           Chris:             vertical_header_item.setText(vert_header_text)
           Chris:     
        cbilling:     @inmain_decorator()
           Chris:     def add_files(self, filepaths, new_row_data):
           Chris:         """Add files to the dataframe model. New_row_data should be a
           Chris:         dataframe containing the new rows."""
           Chris: 
        cbilling:         to_add = []
           Chris: 
           Chris:         # Check for duplicates:
        cbilling:         for filepath in filepaths:
chrisjbillington:             if filepath in self.row_number_by_filepath or filepath in to_add:
        cbilling:                 app.output_box.output('Warning: Ignoring duplicate shot %s\n' % filepath, red=True)
        cbilling:                 if new_row_data is not None:
        cbilling:                     df_row_index = np.where(new_row_data['filepath'].values == filepath)
        cbilling:                     new_row_data = new_row_data.drop(df_row_index[0])
        cbilling:                     new_row_data.index = pandas.Index(range(len(new_row_data)))
        cbilling:             else:
        cbilling:                 to_add.append(filepath)
           Chris: 
           Chris:         assert len(new_row_data) == len(to_add)
           Chris: 
chrisjbillington:         if to_add:
chrisjbillington:             # Update the dataframe:
chrisjbillington:             self.dataframe = concat_with_padding(self.dataframe, new_row_data)
chrisjbillington:             self.update_column_levels()
chrisjbillington: 
chrisjbillington:         app.filebox.set_add_shots_progress(None, None, "updating filebox")
chrisjbillington: 
        cbilling:         for filepath in to_add:
chrisjbillington:             # Add the new rows to the Qt model:
        cbilling:             self._model.appendRow(self.new_row(filepath))
           Chris:             vert_header_item = QtGui.QStandardItem('...loading...')
           Chris:             self._model.setVerticalHeaderItem(self._model.rowCount() - 1, vert_header_item)
        cbilling:             self._view.resizeRowToContents(self._model.rowCount() - 1)
chrisjbillington: 
chrisjbillington:         self.renumber_rows(add_from=self._model.rowCount()-len(to_add))
           Chris: 
chrisjbillington:         # Update the Qt model:
chrisjbillington:         for filepath in to_add:
chrisjbillington:             self.update_row(filepath, dataframe_already_updated=True)
chrisjbillington:             
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def get_first_incomplete(self):
        cbilling:         """Returns the filepath of the first shot in the model that has not
        cbilling:         been analysed"""
        cbilling:         for row in range(self._model.rowCount()):
        cbilling:             status_item = self._model.item(row, self.COL_STATUS)
        cbilling:             if status_item.data(self.ROLE_STATUS_PERCENT) != 100:
        cbilling:                 filepath_item = self._model.item(row, self.COL_FILEPATH)
        cbilling:                 return filepath_item.text()
        cbilling:         
        cbilling:         
        cbilling: class FileBox(object):
        cbilling: 
        cbilling:     def __init__(self, container, exp_config, to_singleshot, from_singleshot, to_multishot, from_multishot):
        cbilling: 
        cbilling:         self.exp_config = exp_config
        cbilling:         self.to_singleshot = to_singleshot
        cbilling:         self.to_multishot = to_multishot
        cbilling:         self.from_singleshot = from_singleshot
        cbilling:         self.from_multishot = from_multishot
        cbilling: 
        cbilling:         self.logger = logging.getLogger('lyse.FileBox')
        cbilling:         self.logger.info('starting')
        cbilling: 
        cbilling:         loader = UiLoader()
        cbilling:         loader.registerCustomWidget(TableView)
        cbilling:         self.ui = loader.load('filebox.ui')
        cbilling:         self.ui.progressBar_add_shots.hide()
        cbilling:         container.addWidget(self.ui)
        cbilling:         self.shots_model = DataFrameModel(self.ui.tableView, self.exp_config)
        cbilling:         set_auto_scroll_to_end(self.ui.tableView.verticalScrollBar())
        cbilling:         self.edit_columns_dialog = EditColumns(self, self.shots_model.column_names, self.shots_model.columns_visible)
        cbilling: 
        cbilling:         self.last_opened_shots_folder = self.exp_config.get('paths', 'experiment_shot_storage')
        cbilling: 
        cbilling:         self.connect_signals()
        cbilling: 
        cbilling:         self.analysis_paused = False
        cbilling:         self.multishot_required = False
        cbilling:         
        cbilling:         # An Event to let the analysis thread know to check for shots that
        cbilling:         # need analysing, rather than using a time.sleep:
        cbilling:         self.analysis_pending = threading.Event()
        cbilling: 
        cbilling:         # The folder that the 'add shots' dialog will open to:
        cbilling:         self.current_folder = self.exp_config.get('paths', 'experiment_shot_storage')
        cbilling: 
        cbilling:         # A queue for storing incoming files from the ZMQ server so
        cbilling:         # the server can keep receiving files even if analysis is slow
        cbilling:         # or paused:
           Chris:         self.incoming_queue = queue.Queue()
        cbilling: 
        cbilling:         # Start the thread to handle incoming files, and store them in
        cbilling:         # a buffer if processing is paused:
        cbilling:         self.incoming = threading.Thread(target=self.incoming_buffer_loop)
        cbilling:         self.incoming.daemon = True
        cbilling:         self.incoming.start()
        cbilling: 
        cbilling:         self.analysis = threading.Thread(target = self.analysis_loop)
        cbilling:         self.analysis.daemon = True
        cbilling:         self.analysis.start()
        cbilling: 
        cbilling:     def connect_signals(self):
        cbilling:         self.ui.pushButton_edit_columns.clicked.connect(self.on_edit_columns_clicked)
        cbilling:         self.shots_model.columns_changed.connect(self.on_columns_changed)
        cbilling:         self.ui.toolButton_add_shots.clicked.connect(self.on_add_shot_files_clicked)
        cbilling:         self.ui.toolButton_remove_shots.clicked.connect(self.shots_model.on_remove_selection)
        cbilling:         self.ui.tableView.doubleLeftClicked.connect(self.shots_model.on_double_click)
        cbilling:         self.ui.pushButton_analysis_running.toggled.connect(self.on_analysis_running_toggled)
        cbilling:         self.ui.pushButton_mark_as_not_done.clicked.connect(self.on_mark_selection_not_done_clicked)
        cbilling:         self.ui.pushButton_run_multishot_analysis.clicked.connect(self.on_run_multishot_analysis_clicked)
        cbilling:         
        cbilling:     def on_edit_columns_clicked(self):
        cbilling:         self.edit_columns_dialog.show()
        cbilling: 
        cbilling:     def on_columns_changed(self):
        cbilling:         column_names = self.shots_model.column_names
        cbilling:         columns_visible = self.shots_model.columns_visible
        cbilling:         self.edit_columns_dialog.update_columns(column_names, columns_visible)
        cbilling: 
        cbilling:     def on_add_shot_files_clicked(self):
     janwerkmann:         shot_files = QtWidgets.QFileDialog.getOpenFileNames(self.ui,
        cbilling:                                                         'Select shot files',
        cbilling:                                                         self.last_opened_shots_folder,
        cbilling:                                                         "HDF5 files (*.h5)")
     janwerkmann:         if type(shot_files) is tuple:
     janwerkmann:             shot_files, _ = shot_files
     janwerkmann: 
        cbilling:         if not shot_files:
        cbilling:             # User cancelled selection
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
        cbilling:         shot_files = [os.path.abspath(shot_file) for shot_file in shot_files]
        cbilling: 
        cbilling:         # Save the containing folder for use next time we open the dialog box:
        cbilling:         self.last_opened_shots_folder = os.path.dirname(shot_files[0])
        cbilling:         # Queue the files to be opened:
        cbilling:         for filepath in shot_files:
        cbilling:             self.incoming_queue.put(filepath)
        cbilling: 
        cbilling:     def on_analysis_running_toggled(self, pressed):
        cbilling:         if pressed:
        cbilling:             self.analysis_paused = True
        cbilling:             self.ui.pushButton_analysis_running.setIcon(QtGui.QIcon(':qtutils/fugue/control'))
        cbilling:             self.ui.pushButton_analysis_running.setText('Analysis paused')
        cbilling:         else:
        cbilling:             self.analysis_paused = False
        cbilling:             self.ui.pushButton_analysis_running.setIcon(QtGui.QIcon(':qtutils/fugue/control'))
        cbilling:             self.ui.pushButton_analysis_running.setText('Analysis running')
        cbilling:             self.analysis_pending.set()
        cbilling:      
        cbilling:     def on_mark_selection_not_done_clicked(self):
        cbilling:         self.shots_model.mark_selection_not_done()
        cbilling:         # Let the analysis loop know to look for these shots:
        cbilling:         self.analysis_pending.set()
        cbilling:         
        cbilling:     def on_run_multishot_analysis_clicked(self):
        cbilling:          self.multishot_required = True
        cbilling:          self.analysis_pending.set()
        cbilling:         
        cbilling:     def set_columns_visible(self, columns_visible):
        cbilling:         self.shots_model.set_columns_visible(columns_visible)
        cbilling: 
        cbilling:     @inmain_decorator()
chrisjbillington:     def set_add_shots_progress(self, completed, total, message):
chrisjbillington:         self.ui.progressBar_add_shots.setFormat("Adding shots: [{}] %v/%m (%p%)".format(message))
chrisjbillington:         if completed == total and message is None:
        cbilling:             self.ui.progressBar_add_shots.hide()
        cbilling:         else:
chrisjbillington:             if total is not None:
chrisjbillington:                 self.ui.progressBar_add_shots.setMaximum(total)
chrisjbillington:             if completed is not None:
chrisjbillington:                 self.ui.progressBar_add_shots.setValue(completed)
        cbilling:             if self.ui.progressBar_add_shots.isHidden():
        cbilling:                 self.ui.progressBar_add_shots.show()
chrisjbillington:         if completed is None and total is None and message is not None:
chrisjbillington:             # Ensure a repaint when only the message changes:
chrisjbillington:             self.ui.progressBar_add_shots.repaint()
        cbilling: 
        cbilling:     def incoming_buffer_loop(self):
        cbilling:         """We use a queue as a buffer for incoming shots. We don't want to hang and not
        cbilling:         respond to a client submitting shots, so we just let shots pile up here until we can get to them.
        cbilling:         The downside to this is that we can't return errors to the client if the shot cannot be added,
        cbilling:         but the suggested workflow is to handle errors here anyway. A client running shots shouldn't stop
        cbilling:         the experiment on account of errors from the analyis stage, so what's the point of passing errors to it?
        cbilling:         We'll just raise errors here and the user can decide what to do with them."""
        cbilling:         logger = logging.getLogger('lyse.FileBox.incoming')
        cbilling:         # HDF5 prints lots of errors by default, for things that aren't
        cbilling:         # actually errors. These are silenced on a per thread basis,
        cbilling:         # and automatically silenced in the main thread when h5py is
        cbilling:         # imported. So we'll silence them in this thread too:
        cbilling:         h5py._errors.silence_errors()
        cbilling:         n_shots_added = 0
        cbilling:         while True:
        cbilling:             try:
        cbilling:                 filepaths = []
        cbilling:                 filepath = self.incoming_queue.get()
        cbilling:                 filepaths.append(filepath)
        cbilling:                 if self.incoming_queue.qsize() == 0:
        cbilling:                     # Wait momentarily in case more arrive so we can batch process them:
        cbilling:                     time.sleep(0.1)
chrisjbillington:                 # Batch process to decrease number of dataframe concatenations:
chrisjbillington:                 batch_size = len(self.shots_model.dataframe) // 3 + 1 
        cbilling:                 while True:
        cbilling:                     try:
        cbilling:                         filepath = self.incoming_queue.get(False)
           Chris:                     except queue.Empty:
        cbilling:                         break
        cbilling:                     else:
        cbilling:                         filepaths.append(filepath)
chrisjbillington:                         if len(filepaths) >= batch_size:
        cbilling:                             break
        cbilling:                 logger.info('adding:\n%s' % '\n'.join(filepaths))
        cbilling:                 if n_shots_added == 0:
        cbilling:                     total_shots = self.incoming_queue.qsize() + len(filepaths)
chrisjbillington:                     self.set_add_shots_progress(1, total_shots, "reading shot files")
        cbilling: 
        cbilling:                 # Remove duplicates from the list (preserving order) in case the
        cbilling:                 # client sent the same filepath multiple times:
        cbilling:                 filepaths = sorted(set(filepaths), key=filepaths.index) # Inefficient but readable
        cbilling:                 # We open the HDF5 files here outside the GUI thread so as not to hang the GUI:
        cbilling:                 dataframes = []
           Chris:                 indices_of_files_not_found = []
        cbilling:                 for i, filepath in enumerate(filepaths):
           Chris:                     try:
           Chris:                         dataframe = get_dataframe_from_shot(filepath)
           Chris:                         dataframes.append(dataframe)
           Chris:                     except IOError:
           Chris:                         app.output_box.output('Warning: Ignoring shot file not found or not readable %s\n' % filepath, red=True)
           Chris:                         indices_of_files_not_found.append(i)
        cbilling:                     n_shots_added += 1
        cbilling:                     shots_remaining = self.incoming_queue.qsize()
        cbilling:                     total_shots = n_shots_added + shots_remaining + len(filepaths) - (i + 1)
chrisjbillington:                     self.set_add_shots_progress(n_shots_added, total_shots, "reading shot files")
chrisjbillington:                 self.set_add_shots_progress(n_shots_added, total_shots, "concatenating dataframes")
           Chris:                 if dataframes:
           Chris:                     new_row_data = concat_with_padding(*dataframes)
           Chris:                 else:
           Chris:                     new_row_data = None
           Chris: 
           Chris:                 # Do not add the shots that were not found on disk. Reverse
           Chris:                 # loop so that removing an item doesn't change the indices of
           Chris:                 # subsequent removals:
           Chris:                 for i in reversed(indices_of_files_not_found):
           Chris:                     del filepaths[i]
           Chris:                 if filepaths:
           Chris:                     self.shots_model.add_files(filepaths, new_row_data)
           Chris:                     # Let the analysis loop know to look for new shots:
           Chris:                     self.analysis_pending.set()
        cbilling:                 if shots_remaining == 0:
chrisjbillington:                     self.set_add_shots_progress(n_shots_added, total_shots, None)
        cbilling:                     n_shots_added = 0 # reset our counter for the next batch
           Chris:                 
        cbilling:             except Exception:
        cbilling:                 # Keep this incoming loop running at all costs, but make the
        cbilling:                 # otherwise uncaught exception visible to the user:
        cbilling:                 zprocess.raise_exception_in_thread(sys.exc_info())
        cbilling: 
        cbilling:     def analysis_loop(self):
        cbilling:         logger = logging.getLogger('lyse.FileBox.analysis_loop')
        cbilling:         # HDF5 prints lots of errors by default, for things that aren't
        cbilling:         # actually errors. These are silenced on a per thread basis,
        cbilling:         # and automatically silenced in the main thread when h5py is
        cbilling:         # imported. So we'll silence them in this thread too:
        cbilling:         h5py._errors.silence_errors()
        cbilling:         while True:
           Chris:             try:
           Chris:                 self.analysis_pending.wait()
           Chris:                 self.analysis_pending.clear()
           Chris:                 at_least_one_shot_analysed = False
           Chris:                 while True:
           Chris:                     if not self.analysis_paused:
           Chris:                         # Find the first shot that has not finished being analysed:
           Chris:                         filepath = self.shots_model.get_first_incomplete()
           Chris:                         if filepath is not None:
           Chris:                             logger.info('analysing: %s'%filepath)
           Chris:                             self.do_singleshot_analysis(filepath)
           Chris:                             at_least_one_shot_analysed = True
           Chris:                         if filepath is None and at_least_one_shot_analysed:
           Chris:                             self.multishot_required = True
           Chris:                         if filepath is None:
           Chris:                             break
           Chris:                         if self.multishot_required:
           Chris:                             logger.info('doing multishot analysis')
           Chris:                             self.do_multishot_analysis()
           Chris:                     else:
           Chris:                         logger.info('analysis is paused')
        cbilling:                         break
           Chris:                 if self.multishot_required:
           Chris:                     logger.info('doing multishot analysis')
           Chris:                     self.do_multishot_analysis()
           Chris:             except Exception:
           Chris:                 etype, value, tb = sys.exc_info()
           Chris:                 orig_exception = ''.join(traceback.format_exception_only(etype, value))
           Chris:                 message = ('Analysis loop encountered unexpected exception. ' +
           Chris:                            'This is a bug and should be reported. The analysis ' +
           Chris:                            'loop is continuing, but lyse may be in an inconsistent state. '
           Chris:                            'Restart lyse, or continue at your own risk. '
           Chris:                            'Original exception was:\n\n' + orig_exception)
           Chris:                 # Raise the exception in a thread so we can keep running
           Chris:                 zprocess.raise_exception_in_thread((RuntimeError, RuntimeError(message), tb))
           Chris:                 self.pause_analysis()
        cbilling:             
        cbilling:    
        cbilling:     @inmain_decorator()
        cbilling:     def pause_analysis(self):
        cbilling:         # This automatically triggers the slot that sets self.analysis_paused
        cbilling:         self.ui.pushButton_analysis_running.setChecked(True)
        cbilling:         
        cbilling:     def do_singleshot_analysis(self, filepath):
           Chris:         # Check the shot file exists before sending it to the singleshot
           Chris:         # routinebox. This does not guarantee it won't have been deleted by
           Chris:         # the time the routinebox starts running analysis on it, but by
           Chris:         # detecting it now we can most of the time avoid the user code
           Chris:         # coughing exceptions due to the file not existing. Which would also
           Chris:         # not be a problem, but this way we avoid polluting the outputbox with
           Chris:         # more errors than necessary.
           Chris:         if not os.path.exists(filepath):
           Chris:             self.shots_model.mark_as_deleted_off_disk(filepath)
           Chris:             return
        cbilling:         self.to_singleshot.put(filepath)
        cbilling:         while True:
             jan:             signal, status_percent, updated_data = self.from_singleshot.get()
chrisjbillington:             for file in updated_data:
chrisjbillington:                 # Update the data for all the rows with new data:
chrisjbillington:                 self.shots_model.update_row(file, updated_row_data=updated_data[file])
chrisjbillington:             # Update the status percent for the the row on which analysis is actually running:
chrisjbillington:             self.shots_model.update_row(filepath, status_percent=status_percent, dataframe_already_updated=True)
        cbilling:             if signal == 'done':
        cbilling:                 return
        cbilling:             if signal == 'error':
             jan:                 if not os.path.exists(filepath):
             jan:                     # Do not pause if the file has been deleted. An error is
             jan:                     # no surprise there:
             jan:                     self.shots_model.mark_as_deleted_off_disk(filepath)
             jan:                 else:
           Chris:                     self.pause_analysis()
        cbilling:                 return
chrisjbillington:             if signal == 'progress':
chrisjbillington:                 continue
chrisjbillington:             raise ValueError('invalid signal %s' % str(signal))
        cbilling:                         
        cbilling:     def do_multishot_analysis(self):
        cbilling:         self.to_multishot.put(None)
        cbilling:         while True:
             jan:             signal, _, updated_data = self.from_multishot.get()
             jan:             for file in updated_data:
             jan:                 self.shots_model.update_row(file, updated_row_data=updated_data[file])
        cbilling:             if signal == 'done':
        cbilling:                 self.multishot_required = False
        cbilling:                 return
        cbilling:             elif signal == 'error':
        cbilling:                 self.pause_analysis()
        cbilling:                 return
        cbilling:         
        cbilling:         
        cbilling: class Lyse(object):
        cbilling: 
        cbilling:     def __init__(self):
        cbilling:         loader = UiLoader()
        cbilling:         self.ui = loader.load('main.ui', LyseMainWindow())
        cbilling: 
        cbilling:         self.connect_signals()
        cbilling: 
        cbilling:         self.setup_config()
        cbilling:         self.port = int(self.exp_config.get('ports', 'lyse'))
        cbilling: 
        cbilling:         # The singleshot routinebox will be connected to the filebox
        cbilling:         # by queues:
           Chris:         to_singleshot = queue.Queue()
           Chris:         from_singleshot = queue.Queue()
        cbilling: 
        cbilling:         # So will the multishot routinebox:
           Chris:         to_multishot = queue.Queue()
           Chris:         from_multishot = queue.Queue()
        cbilling: 
        cbilling:         self.output_box = OutputBox(self.ui.verticalLayout_output_box)
        cbilling:         self.singleshot_routinebox = RoutineBox(self.ui.verticalLayout_singleshot_routinebox, self.exp_config,
        cbilling:                                                 self, to_singleshot, from_singleshot, self.output_box.port)
        cbilling:         self.multishot_routinebox = RoutineBox(self.ui.verticalLayout_multishot_routinebox, self.exp_config,
        cbilling:                                                self, to_multishot, from_multishot, self.output_box.port, multishot=True)
        cbilling:         self.filebox = FileBox(self.ui.verticalLayout_filebox, self.exp_config,
        cbilling:                                to_singleshot, from_singleshot, to_multishot, from_multishot)
        cbilling: 
     janwerkmann:         self.last_save_config_file = None
     janwerkmann:         self.last_save_data = None
     janwerkmann: 
     janwerkmann:         self.ui.actionLoad_configuration.triggered.connect(self.on_load_configuration_triggered)
     janwerkmann:         self.ui.actionRevert_configuration.triggered.connect(self.on_revert_configuration_triggered)
     janwerkmann:         self.ui.actionSave_configuration.triggered.connect(self.on_save_configuration_triggered)
     janwerkmann:         self.ui.actionSave_configuration_as.triggered.connect(self.on_save_configuration_as_triggered)
     janwerkmann: 
        cbilling:         self.ui.resize(1600, 900)
        cbilling: 
        cbilling:         # Set the splitters to appropriate fractions of their maximum size:
        cbilling:         self.ui.splitter_horizontal.setSizes([1000, 600])
        cbilling:         self.ui.splitter_vertical.setSizes([300, 600])
     janwerkmann: 
     janwerkmann:         # autoload a config file, if labconfig is set to do so:
     janwerkmann:         try:
     janwerkmann:             autoload_config_file = self.exp_config.get('lyse', 'autoload_config_file')
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             self.output_box.output('Ready.\n\n')
     janwerkmann:         else:
     janwerkmann:             self.ui.setEnabled(False)
     janwerkmann:             self.output_box.output('Loading default config file %s...' % autoload_config_file)
     janwerkmann: 
     janwerkmann:             def load_the_config_file():
     janwerkmann:                 try:
     janwerkmann:                     self.load_configuration(autoload_config_file)
     janwerkmann:                     self.output_box.output('done.\n')
     janwerkmann:                 except Exception as e:
     janwerkmann:                     self.output_box.output('\nCould not load config file: %s: %s\n\n' %
     janwerkmann:                                            (e.__class__.__name__, str(e)), red=True)
     janwerkmann:                 else:
     janwerkmann:                     self.output_box.output('Ready.\n\n')
     janwerkmann:                 finally:
     janwerkmann:                     self.ui.setEnabled(True)
     janwerkmann:             # Defer this until 50ms after the window has shown,
     janwerkmann:             # so that the GUI pops up faster in the meantime
     janwerkmann:             self.ui.firstPaint.connect(lambda: QtCore.QTimer.singleShot(50, load_the_config_file))
     janwerkmann: 
        cbilling:         self.ui.show()
        cbilling:         # self.ui.showMaximized()
        cbilling: 
     janwerkmann:     def on_close_event(self):
     janwerkmann:         save_data = self.get_save_data()
     janwerkmann:         if self.last_save_data is not None and save_data != self.last_save_data:
     janwerkmann:             if self.only_window_geometry_is_different(save_data, self.last_save_data):
     janwerkmann:                 self.save_configuration(self.last_save_config_file)
     janwerkmann:                 return True
     janwerkmann: 
     janwerkmann:             message = ('Current configuration (which scripts are loaded and other GUI state) '
     janwerkmann:                        'has changed: save config file \'%s\'?' % self.last_save_config_file)
     janwerkmann:             reply = QtWidgets.QMessageBox.question(self.ui, 'Quit lyse', message,
     janwerkmann:                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Cancel)
     janwerkmann:             if reply == QtWidgets.QMessageBox.Cancel:
     janwerkmann:                 return False
     janwerkmann:             if reply == QtWidgets.QMessageBox.Yes:
     janwerkmann:                 self.save_configuration(self.last_save_config_file)
     janwerkmann:         return True
     janwerkmann: 
     janwerkmann:     def on_save_configuration_triggered(self):
     janwerkmann:         if self.last_save_config_file is None:
     janwerkmann:             self.on_save_configuration_as_triggered()
     janwerkmann:             self.ui.actionSave_configuration_as.setEnabled(True)
     janwerkmann:             self.ui.actionRevert_configuration.setEnabled(True)
     janwerkmann:         else:
     janwerkmann:             self.save_configuration(self.last_save_config_file)
     janwerkmann: 
     janwerkmann:     def on_revert_configuration_triggered(self):
     janwerkmann:         save_data = self.get_save_data()
     janwerkmann:         if self.last_save_data is not None and save_data != self.last_save_data:
     janwerkmann:             message = 'Revert configuration to the last saved state in \'%s\'?' % self.last_save_config_file
     janwerkmann:             reply = QtWidgets.QMessageBox.question(self.ui, 'Load configuration', message,
     janwerkmann:                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
     janwerkmann:             if reply == QtWidgets.QMessageBox.Cancel:
     janwerkmann:                 return
     janwerkmann:             elif reply == QtWidgets.QMessageBox.Yes:
     janwerkmann:                 self.load_configuration(self.last_save_config_file)
     janwerkmann:         else:
     janwerkmann:             error_dialog('no changes to revert')
     janwerkmann: 
     janwerkmann:     def on_save_configuration_as_triggered(self):
     janwerkmann:         if self.last_save_config_file is not None:
     janwerkmann:             default = self.last_save_config_file
     janwerkmann:         else:
     janwerkmann:             try:
     janwerkmann:                 default_path = os.path.join(self.exp_config.get('DEFAULT', 'app_saved_configs'), 'lyse')
     janwerkmann:             except LabConfig.NoOptionError:
     janwerkmann:                 self.exp_config.set('DEFAULT', 'app_saved_configs', os.path.join('%(labscript_suite)s', 'userlib', 'app_saved_configs', '%(experiment_name)s'))
     janwerkmann:                 default_path = os.path.join(self.exp_config.get('DEFAULT', 'app_saved_configs'), 'lyse')
     janwerkmann:             if not os.path.exists(default_path):
     janwerkmann:                 os.makedirs(default_path)
     janwerkmann: 
     janwerkmann:             default = os.path.join(default_path, 'lyse.ini')
     janwerkmann:         save_file = QtWidgets.QFileDialog.getSaveFileName(self.ui,
     janwerkmann:                                                       'Select  file to save current lyse configuration',
     janwerkmann:                                                       default,
     janwerkmann:                                                       "config files (*.ini)")
     janwerkmann:         if type(save_file) is tuple:
     janwerkmann:             save_file, _ = save_file
     janwerkmann: 
     janwerkmann:         if not save_file:
     janwerkmann:             # User cancelled
     janwerkmann:             return
     janwerkmann:         # Convert to standard platform specific path, otherwise Qt likes
     janwerkmann:         # forward slashes:
     janwerkmann:         save_file = os.path.abspath(save_file)
     janwerkmann:         self.save_configuration(save_file)
     janwerkmann: 
     janwerkmann:     def only_window_geometry_is_different(self, current_data, old_data):
     janwerkmann:         ui_keys = ['window_size', 'window_pos', 'splitter', 'splitter_vertical', 'splitter_horizontal']
     janwerkmann:         compare = [current_data[key] == old_data[key] for key in current_data.keys() if key not in ui_keys]
     janwerkmann:         return all(compare)
     janwerkmann: 
     janwerkmann:     def get_save_data(self):
     janwerkmann:         save_data = {}
     janwerkmann: 
     janwerkmann:         box = self.singleshot_routinebox
chrisjbillington:         save_data['SingleShot'] = list(zip([routine.filepath for routine in box.routines],
chrisjbillington:                                            [box.model.item(row, box.COL_ACTIVE).checkState() 
chrisjbillington:                                             for row in range(box.model.rowCount())]))
     janwerkmann:         save_data['LastSingleShotFolder'] = box.last_opened_routine_folder
     janwerkmann:         box = self.multishot_routinebox
chrisjbillington:         save_data['MultiShot'] = list(zip([routine.filepath for routine in box.routines],
chrisjbillington:                                           [box.model.item(row, box.COL_ACTIVE).checkState() 
chrisjbillington:                                            for row in range(box.model.rowCount())]))
     janwerkmann:         save_data['LastMultiShotFolder'] = box.last_opened_routine_folder
     janwerkmann: 
     janwerkmann:         save_data['LastFileBoxFolder'] = self.filebox.last_opened_shots_folder
     janwerkmann: 
     janwerkmann:         save_data['analysis_paused'] = self.filebox.analysis_paused
     janwerkmann:         window_size = self.ui.size()
     janwerkmann:         save_data['window_size'] = (window_size.width(), window_size.height())
     janwerkmann:         window_pos = self.ui.pos()
chrisjbillington: 
     janwerkmann:         save_data['window_pos'] = (window_pos.x(), window_pos.y())
     janwerkmann: 
chrisjbillington:         save_data['screen_geometry'] = get_screen_geometry()
     janwerkmann:         save_data['splitter'] = self.ui.splitter.sizes()
     janwerkmann:         save_data['splitter_vertical'] = self.ui.splitter_vertical.sizes()
     janwerkmann:         save_data['splitter_horizontal'] = self.ui.splitter_horizontal.sizes()
     janwerkmann:         return save_data
     janwerkmann: 
     janwerkmann:     def save_configuration(self, save_file):
     janwerkmann:         lyse_config = LabConfig(save_file)
     janwerkmann:         save_data = self.get_save_data()
     janwerkmann:         self.last_save_config_file = save_file
     janwerkmann:         self.last_save_data = save_data
     janwerkmann:         for key, value in save_data.items():
     janwerkmann:             lyse_config.set('lyse_state', key, pprint.pformat(value))
     janwerkmann: 
     janwerkmann:     def on_load_configuration_triggered(self):
     janwerkmann:         save_data = self.get_save_data()
     janwerkmann:         if self.last_save_data is not None and save_data != self.last_save_data:
     janwerkmann:             message = ('Current configuration (which groups are active/open and other GUI state) '
     janwerkmann:                        'has changed: save config file \'%s\'?' % self.last_save_config_file)
     janwerkmann:             reply = QtWidgets.QMessageBox.question(self.ui, 'Load configuration', message,
     janwerkmann:                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Cancel)
     janwerkmann:             if reply == QtWidgets.QMessageBox.Cancel:
     janwerkmann:                 return
     janwerkmann:             if reply == QtWidgets.QMessageBox.Yes:
     janwerkmann:                 self.save_configuration(self.last_save_config_file)
     janwerkmann: 
     janwerkmann:         if self.last_save_config_file is not None:
     janwerkmann:             default = self.last_save_config_file
     janwerkmann:         else:
     janwerkmann:             default = os.path.join(self.exp_config.get('paths', 'experiment_shot_storage'), 'lyse.ini')
     janwerkmann: 
     janwerkmann:         file = QtWidgets.QFileDialog.getOpenFileName(self.ui,
     janwerkmann:                                                  'Select lyse configuration file to load',
     janwerkmann:                                                  default,
     janwerkmann:                                                  "config files (*.ini)")
     janwerkmann:         if type(file) is tuple:
     janwerkmann:             file, _ = file
     janwerkmann: 
     janwerkmann:         if not file:
     janwerkmann:             # User cancelled
     janwerkmann:             return
     janwerkmann:         # Convert to standard platform specific path, otherwise Qt likes
     janwerkmann:         # forward slashes:
     janwerkmann:         file = os.path.abspath(file)
     janwerkmann:         self.load_configuration(file)
     janwerkmann: 
     janwerkmann:     def load_configuration(self, filename):
     janwerkmann:         self.last_save_config_file = filename
     janwerkmann:         self.ui.actionSave_configuration.setText('Save configuration %s' % filename)
     janwerkmann:         lyse_config = LabConfig(filename)
     janwerkmann: 
     janwerkmann:         try:
     janwerkmann:             self.singleshot_routinebox.add_routines(ast.literal_eval(lyse_config.get('lyse_state', 'SingleShot')), clear_existing=True)
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
     janwerkmann:         try:
     janwerkmann:             self.singleshot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastSingleShotFolder'))
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
     janwerkmann:         try:
     janwerkmann:             self.multishot_routinebox.add_routines(ast.literal_eval(lyse_config.get('lyse_state', 'MultiShot')), clear_existing=True)
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
     janwerkmann:         try:
     janwerkmann:             self.multishot_routinebox.last_opened_routine_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastMultiShotFolder'))
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
     janwerkmann:         try:
     janwerkmann:             self.filebox.last_opened_shots_folder = ast.literal_eval(lyse_config.get('lyse_state', 'LastFileBoxFolder'))
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
     janwerkmann:         try:
     janwerkmann:             if ast.literal_eval(lyse_config.get('lyse_state', 'analysis_paused')):
     janwerkmann:                 self.filebox.pause_analysis()
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
     janwerkmann:         try:
chrisjbillington:             screen_geometry = ast.literal_eval(lyse_config.get('lyse_state', 'screen_geometry'))
     janwerkmann:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
     janwerkmann:             pass
chrisjbillington:         else:
chrisjbillington:             # Only restore the window size and position, and splitter
chrisjbillington:             # positions if the screen is the same size/same number of monitors
chrisjbillington:             # etc. This prevents the window moving off the screen if say, the
chrisjbillington:             # position was saved when 2 monitors were plugged in but there is
chrisjbillington:             # only one now, and the splitters may not make sense in light of a
chrisjbillington:             # different window size, so better to fall back to defaults:
chrisjbillington:             current_screen_geometry = get_screen_geometry()
chrisjbillington:             if current_screen_geometry == screen_geometry:
chrisjbillington:                 try:
chrisjbillington:                     self.ui.resize(*ast.literal_eval(lyse_config.get('lyse_state', 'window_size')))
chrisjbillington:                 except (LabConfig.NoOptionError, LabConfig.NoSectionError):
chrisjbillington:                     pass
chrisjbillington:                 try:
chrisjbillington:                     self.ui.move(*ast.literal_eval(lyse_config.get('lyse_state', 'window_pos')))
chrisjbillington:                 except (LabConfig.NoOptionError, LabConfig.NoSectionError):
chrisjbillington:                     pass
chrisjbillington:                 try:
chrisjbillington:                     self.ui.splitter.setSizes(ast.literal_eval(lyse_config.get('lyse_state', 'splitter')))
chrisjbillington:                 except (LabConfig.NoOptionError, LabConfig.NoSectionError):
chrisjbillington:                     pass
chrisjbillington:                 try:
chrisjbillington:                     self.ui.splitter_vertical.setSizes(ast.literal_eval(lyse_config.get('lyse_state', 'splitter_vertical')))
chrisjbillington:                 except (LabConfig.NoOptionError, LabConfig.NoSectionError):
chrisjbillington:                     pass
chrisjbillington:                 try:
chrisjbillington:                     self.ui.splitter_horizontal.setSizes(ast.literal_eval(lyse_config.get('lyse_state', 'splitter_horizontal')))
chrisjbillington:                 except (LabConfig.NoOptionError, LabConfig.NoSectionError):
chrisjbillington:                     pass
     janwerkmann: 
     janwerkmann:         # Set as self.last_save_data:
     janwerkmann:         save_data = self.get_save_data()
     janwerkmann:         self.last_save_data = save_data
     janwerkmann:         self.ui.actionSave_configuration_as.setEnabled(True)
     janwerkmann:         self.ui.actionRevert_configuration.setEnabled(True)
     janwerkmann: 
        cbilling:     def setup_config(self):
        cbilling:         required_config_params = {"DEFAULT": ["experiment_name"],
        cbilling:                                   "programs": ["text_editor",
        cbilling:                                                "text_editor_arguments",
        cbilling:                                                "hdf5_viewer",
        cbilling:                                                "hdf5_viewer_arguments"],
        cbilling:                                   "paths": ["shared_drive",
        cbilling:                                             "experiment_shot_storage",
        cbilling:                                             "analysislib"],
        cbilling:                                   "ports": ["lyse"]
        cbilling:                                   }
     janwerkmann:         self.exp_config = LabConfig(required_params=required_config_params)
        cbilling: 
        cbilling:     def connect_signals(self):
        cbilling:         if os.name == 'nt':
        cbilling:             self.ui.newWindow.connect(set_win_appusermodel)
           Chris:     
           Chris:     def on_keyPress(self, key, modifiers, is_autorepeat):
           Chris:         # Keyboard shortcut to delete shots or routines depending on which
           Chris:         # treeview/tableview has focus. Shift-delete to skip confirmation.
           Chris:         if key == QtCore.Qt.Key_Delete and not is_autorepeat:
           Chris:             confirm = modifiers != QtCore.Qt.ShiftModifier 
           Chris:             if self.filebox.ui.tableView.hasFocus():
chrisjbillington:                 self.filebox.shots_model.remove_selection(confirm)
           Chris:             if self.singleshot_routinebox.ui.treeView.hasFocus():
chrisjbillington:                 self.singleshot_routinebox.remove_selection(confirm)
           Chris:             if self.multishot_routinebox.ui.treeView.hasFocus():
chrisjbillington:                 self.multishot_routinebox.remove_selection(confirm)
     janwerkmann: 
     janwerkmann: 
     janwerkmann: class KeyPressQApplication(QtWidgets.QApplication):
        cbilling: 
           Chris:     """A Qapplication that emits a signal keyPress(key) on keypresses"""
           Chris:     keyPress = Signal(int, QtCore.Qt.KeyboardModifiers, bool)
           Chris:     keyRelease = Signal(int, QtCore.Qt.KeyboardModifiers, bool)
        cbilling: 
           Chris:     def notify(self, object, event):
           Chris:         if event.type() == QtCore.QEvent.KeyPress and event.key():
           Chris:             self.keyPress.emit(event.key(), event.modifiers(), event.isAutoRepeat())
           Chris:         elif event.type() == QtCore.QEvent.KeyRelease and event.key():
           Chris:             self.keyRelease.emit(event.key(), event.modifiers(), event.isAutoRepeat())
     janwerkmann:         return QtWidgets.QApplication.notify(self, object, event)
     janwerkmann: 
     janwerkmann: 
        cbilling: if __name__ == "__main__":
        cbilling:     logger = setup_logging('lyse')
        cbilling:     labscript_utils.excepthook.set_logger(logger)
        cbilling:     logger.info('\n\n===============starting===============\n')
           Chris:     qapplication = KeyPressQApplication(sys.argv)
        cbilling:     qapplication.setAttribute(QtCore.Qt.AA_DontShowIconsInMenus, False)
        cbilling:     app = Lyse()
        cbilling: 
        cbilling:     # Start the web server:
        cbilling:     server = WebServer(app.port)
        cbilling: 
        cbilling:     # Let the interpreter run every 500ms so it sees Ctrl-C interrupts:
        cbilling:     timer = QtCore.QTimer()
        cbilling:     timer.start(500)
        cbilling:     timer.timeout.connect(lambda: None)  # Let the interpreter run each 500 ms.
        cbilling:     # Upon seeing a ctrl-c interrupt, quit the event loop
        cbilling:     signal.signal(signal.SIGINT, lambda *args: qapplication.exit())
        cbilling:     # Do not run qapplication.exec_() whilst waiting for keyboard input if
        cbilling:     # we hop into interactive mode.
        cbilling:     QtCore.pyqtRemoveInputHook() # TODO remove once updating to pyqt 4.11 or whatever fixes that bug
           Chris:     
           Chris:     # Connect keyboard shortcuts:
           Chris:     qapplication.keyPress.connect(app.on_keyPress)
           Chris:     
        cbilling:     qapplication.exec_()
        cbilling:     server.shutdown()
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # /analysis_subprocess.py                                           #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the program lyse, in the labscript suite     #
        cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
        cbilling: # Simplified BSD License. See the license.txt file in the root of   #
        cbilling: # the project for the full license.                                 #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
           Chris: from __future__ import division, unicode_literals, print_function, absolute_import
           Chris: from labscript_utils import PY2
           Chris: if PY2:
           Chris:     str = unicode
           Chris: 
        cbilling: import labscript_utils.excepthook
        cbilling: import zprocess
        cbilling: to_parent, from_parent, kill_lock = zprocess.setup_connection_with_parent(lock = True)
        cbilling: 
        cbilling: import sys
        cbilling: import os
        cbilling: import threading
        cbilling: import traceback
        cbilling: import time
        cbilling: 
     janwerkmann: from qtutils.qt import QtCore, QtGui, QtWidgets, QT_ENV, PYQT5
     janwerkmann: from qtutils.qt.QtCore import pyqtSignal as Signal
     janwerkmann: from qtutils.qt.QtCore import pyqtSlot as Slot
        cbilling: 
        cbilling: import matplotlib
     janwerkmann: if QT_ENV == PYQT5:
     janwerkmann:     matplotlib.use("QT5Agg")
     janwerkmann: else:
     janwerkmann:     matplotlib.use("QT4Agg")
        cbilling: 
        cbilling: import lyse
        cbilling: lyse.spinning_top = True
        cbilling: import lyse.figure_manager
        cbilling: lyse.figure_manager.install()
        cbilling: 
     janwerkmann: if QT_ENV == PYQT5:
     janwerkmann:     from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
     janwerkmann: else:
     janwerkmann:     from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar
        cbilling: import pylab
        cbilling: import zprocess.locking, labscript_utils.h5_lock, h5py
        cbilling: 
        cbilling: import zprocess
        cbilling: from qtutils import inmain, inmain_later, inmain_decorator, UiLoader, inthread, DisconnectContextManager
        cbilling: import qtutils.icons
        cbilling: 
        cbilling: from labscript_utils.modulewatcher import ModuleWatcher
        cbilling: 
        cbilling: class _DeprecationDict(dict):
        cbilling:     """Dictionary that spouts deprecation warnings when you try to access some
        cbilling:     keys."""
        cbilling:     def __init__(self, *args, **kwargs):
        cbilling:         self.deprecation_messages = {} # To be added to after the deprecated items are added to the dict.
        cbilling:         dict.__init__(self, *args, **kwargs)
        cbilling: 
        cbilling:     def __getitem__(self, key):
        cbilling:         if key in self.deprecation_messages:
        cbilling:             import warnings
        cbilling:             import linecache
        cbilling:             # DeprecationWarnings are ignored by default. Clear the filter so
        cbilling:             # they are not:
        cbilling:             previous_warning_filters = warnings.filters[:]
        cbilling:             try:
        cbilling:                 warnings.resetwarnings()
        cbilling:                 # Hacky stuff to get it to work from within execfile() with
        cbilling:                 # correct line data:
        cbilling:                 linecache.clearcache()
        cbilling:                 caller = sys._getframe(1)
        cbilling:                 globals = caller.f_globals
        cbilling:                 lineno = caller.f_lineno
        cbilling:                 module = globals['__name__']
        cbilling:                 filename = globals.get('__file__')
        cbilling:                 fnl = filename.lower()
        cbilling:                 if fnl.endswith((".pyc", ".pyo")):
        cbilling:                     filename = filename[:-1]
        cbilling:                 message = self.deprecation_messages[key]
        cbilling:                 warnings.warn_explicit(message, DeprecationWarning, filename, lineno, module)
        cbilling:             finally:
        cbilling:                 # Restore the warnings filter:
        cbilling:                 warnings.filters[:] = previous_warning_filters
        cbilling:         return dict.__getitem__(self, key)
        cbilling: 
        cbilling:     def __setitem__(self, key, value):
        cbilling:         if key in self.deprecation_messages:
        cbilling:             # No longer deprecated if the user puts something in place of the
        cbilling:             # originally deprecated item:
        cbilling:             del self.deprecation_messages[key]
        cbilling:         return dict.__setitem__(self, key, value)
        cbilling: 
        cbilling: 
        cbilling: def set_win_appusermodel(window_id):
        cbilling:     from labscript_utils.winshell import set_appusermodel, appids, app_descriptions
        cbilling:     icon_path = os.path.abspath('lyse.ico')
        cbilling:     executable = sys.executable.lower()
        cbilling:     if not executable.endswith('w.exe'):
        cbilling:         executable = executable.replace('.exe', 'w.exe')
        cbilling:     relaunch_command = executable + ' ' + os.path.abspath(__file__.replace('.pyc', '.py'))
        cbilling:     relaunch_display_name = app_descriptions['lyse']
        cbilling:     set_appusermodel(window_id, appids['lyse'], icon_path, relaunch_command, relaunch_display_name)
     janwerkmann: 
     janwerkmann: 
     janwerkmann: class PlotWindow(QtWidgets.QWidget):
        cbilling:     # A signal for when the window manager has created a new window for this widget:
        cbilling:     newWindow = Signal(int)
        cbilling:     close_signal = Signal()
        cbilling: 
        cbilling:     def event(self, event):
     janwerkmann:         result = QtWidgets.QWidget.event(self, event)
        cbilling:         if event.type() == QtCore.QEvent.WinIdChange:
        cbilling:             self.newWindow.emit(self.effectiveWinId())
        cbilling:         return result
        cbilling: 
        cbilling:     def closeEvent(self, event):
        cbilling:         self.hide()
        cbilling:         event.ignore()
        cbilling:         
        cbilling: 
        cbilling: class Plot(object):
        cbilling:     def __init__(self, figure, identifier, filepath):
        cbilling:         loader = UiLoader()
        cbilling:         self.ui = loader.load('plot_window.ui', PlotWindow())
        cbilling: 
        cbilling:         # Tell Windows how to handle our windows in the the taskbar, making pinning work properly and stuff:
        cbilling:         if os.name == 'nt':
        cbilling:             self.ui.newWindow.connect(set_win_appusermodel)
        cbilling: 
        cbilling:         self.set_window_title(identifier, filepath)
        cbilling: 
        cbilling:         # figure.tight_layout()
        cbilling:         self.figure = figure
         dsbark7:         self.canvas = figure.canvas
        cbilling:         self.navigation_toolbar = NavigationToolbar(self.canvas, self.ui)
        cbilling: 
        cbilling:         self.lock_action = self.navigation_toolbar.addAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/lock-unlock'),
        cbilling:            'Lock axes', self.on_lock_axes_triggered)
        cbilling:         self.lock_action.setCheckable(True)
        cbilling:         self.lock_action.setToolTip('Lock axes')
        cbilling: 
           Chris:         self.copy_to_clipboard_action = self.navigation_toolbar.addAction(
           Chris:             QtGui.QIcon(':qtutils/fugue/clipboard--arrow'),
           Chris:            'Copy to clipboard', self.on_copy_to_clipboard_triggered)
           Chris:         self.copy_to_clipboard_action.setToolTip('Copy to clipboard')
           Chris:         self.copy_to_clipboard_action.setShortcut(QtGui.QKeySequence.Copy)
           Chris: 
           Chris: 
        cbilling:         self.ui.verticalLayout_canvas.addWidget(self.canvas)
        cbilling:         self.ui.verticalLayout_navigation_toolbar.addWidget(self.navigation_toolbar)
        cbilling: 
        cbilling:         self.lock_axes = False
        cbilling:         self.axis_limits = None
        cbilling: 
        cbilling:         self.update_window_size()
        cbilling: 
        cbilling:         self.ui.show()
        cbilling: 
        cbilling:     def on_lock_axes_triggered(self):
        cbilling:         if self.lock_action.isChecked():
        cbilling:             self.lock_axes = True
        cbilling:             self.lock_action.setIcon(QtGui.QIcon(':qtutils/fugue/lock'))
        cbilling:         else:
        cbilling:             self.lock_axes = False
        cbilling:             self.lock_action.setIcon(QtGui.QIcon(':qtutils/fugue/lock-unlock'))
        cbilling: 
           Chris:     def on_copy_to_clipboard_triggered(self):
chrisjbillington:         lyse.figure_to_clipboard(self.figure)
           Chris: 
        cbilling:     @inmain_decorator()
        cbilling:     def save_axis_limits(self):
        cbilling:         axis_limits = {}
        cbilling:         for i, ax in enumerate(self.figure.axes):
        cbilling:             # Save the limits of the axes to restore them afterward:
        cbilling:             axis_limits[i] = ax.get_xlim(), ax.get_ylim()
        cbilling: 
        cbilling:         self.axis_limits = axis_limits
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def clear(self):
        cbilling:         self.figure.clear()
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def restore_axis_limits(self):
        cbilling:         for i, ax in enumerate(self.figure.axes):
        cbilling:             try:
        cbilling:                 xlim, ylim = self.axis_limits[i]
        cbilling:                 ax.set_xlim(xlim)
        cbilling:                 ax.set_ylim(ylim)
        cbilling:             except KeyError:
        cbilling:                 continue
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def set_window_title(self, identifier, filepath):
        cbilling:         self.ui.setWindowTitle(str(identifier) + ' - ' + os.path.basename(filepath))
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def update_window_size(self):
        cbilling:         l, w = self.figure.get_size_inches()
        cbilling:         dpi = self.figure.get_dpi()
        cbilling:         self.canvas.resize(int(l*dpi),int(w*dpi))
        cbilling:         self.ui.adjustSize()
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def draw(self):
        cbilling:         self.canvas.draw()
        cbilling: 
        cbilling:     def show(self):
        cbilling:         self.ui.show()
        cbilling: 
        cbilling:     @property
        cbilling:     def is_shown(self):
        cbilling:         return self.ui.isVisible()
        cbilling: 
        cbilling: 
        cbilling: class AnalysisWorker(object):
        cbilling:     def __init__(self, filepath, to_parent, from_parent):
        cbilling:         self.to_parent = to_parent
        cbilling:         self.from_parent = from_parent
        cbilling:         self.filepath = filepath
chrisjbillington: 
chrisjbillington:         # Filepath as a unicode string on py3 and a bytestring on py2,
chrisjbillington:         # so that the right string type can be passed to functions that
chrisjbillington:         # require the 'native' string type for that python version. On
chrisjbillington:         # Python 2, encode it with the filesystem encoding.
           Chris:         if PY2:
chrisjbillington:             self.filepath_native_string = self.filepath.encode(sys.getfilesystemencoding())
chrisjbillington:         else:
chrisjbillington:             self.filepath_native_string = self.filepath
        cbilling:         
        cbilling:         # Add user script directory to the pythonpath:
chrisjbillington:         sys.path.insert(0, os.path.dirname(self.filepath_native_string))
        cbilling:         
        cbilling:         # Plot objects, keyed by matplotlib Figure object:
        cbilling:         self.plots = {}
        cbilling: 
        cbilling:         # An object with a method to unload user modules if any have
        cbilling:         # changed on disk:
        cbilling:         self.modulewatcher = ModuleWatcher()
        cbilling:         
        cbilling:         # Start the thread that listens for instructions from the
        cbilling:         # parent process:
        cbilling:         self.mainloop_thread = threading.Thread(target=self.mainloop)
        cbilling:         self.mainloop_thread.daemon = True
        cbilling:         self.mainloop_thread.start()
        cbilling:         
        cbilling:     def mainloop(self):
        cbilling:         # HDF5 prints lots of errors by default, for things that aren't
        cbilling:         # actually errors. These are silenced on a per thread basis,
        cbilling:         # and automatically silenced in the main thread when h5py is
        cbilling:         # imported. So we'll silence them in this thread too:
        cbilling:         h5py._errors.silence_errors()
        cbilling:         while True:
        cbilling:             task, data = self.from_parent.get()
        cbilling:             with kill_lock:
        cbilling:                 if task == 'quit':
        cbilling:                     inmain(qapplication.quit)
        cbilling:                 elif task == 'analyse':
        cbilling:                     path = data
        cbilling:                     success = self.do_analysis(path)
        cbilling:                     if success:
             jan:                         self.to_parent.put(['done', lyse._updated_data])
        cbilling:                     else:
             jan:                         self.to_parent.put(['error', lyse._updated_data])
        cbilling:                 else:
        cbilling:                     self.to_parent.put(['error','invalid task %s'%str(task)])
        cbilling:         
        cbilling:     @inmain_decorator()
        cbilling:     def do_analysis(self, path):
        cbilling:         now = time.strftime('[%x %X]')
        cbilling:         if path is not None:
        cbilling:             print('%s %s %s ' %(now, os.path.basename(self.filepath), os.path.basename(path)))
        cbilling:         else:
        cbilling:             print('%s %s' %(now, os.path.basename(self.filepath)))
        cbilling: 
        cbilling:         self.pre_analysis_plot_actions()
        cbilling: 
        cbilling:         # The namespace the routine will run in:
        cbilling:         sandbox = _DeprecationDict(path=path,
        cbilling:                                    __name__='__main__',
chrisjbillington:                                    __file__= os.path.basename(self.filepath_native_string))
        cbilling:         # path global variable is deprecated:
        cbilling:         deprecation_message = ("use of 'path' global variable is deprecated and will be removed " +
        cbilling:                                "in a future version of lyse.  Please use lyse.path, which defaults " +
        cbilling:                                "to sys.argv[1] when scripts are run stand-alone.")
        cbilling:         sandbox.deprecation_messages['path'] = deprecation_message
        cbilling:         # Use lyse.path instead:
        cbilling:         lyse.path = path
             jan:         lyse._updated_data = {}
           Chris: 
           Chris:         # Save the current working directory before changing it to the
           Chris:         # location of the user's script:
           Chris:         cwd = os.getcwd()
chrisjbillington:         os.chdir(os.path.dirname(self.filepath))
chrisjbillington: 
        cbilling:         # Do not let the modulewatcher unload any modules whilst we're working:
        cbilling:         try:
        cbilling:             with self.modulewatcher.lock:
        cbilling:                 # Actually run the user's analysis!
           Chris:                 with open(self.filepath) as f:
chrisjbillington:                     code = compile(f.read(), os.path.basename(self.filepath_native_string),
chrisjbillington:                                    'exec', dont_inherit=True)
           Chris:                     exec(code, sandbox)
        cbilling:         except:
        cbilling:             traceback_lines = traceback.format_exception(*sys.exc_info())
        cbilling:             del traceback_lines[1]
           Chris:             # Avoiding a list comprehension here so as to avoid this
           Chris:             # python bug in earlier versions of 2.7 (fixed in 2.7.9):
           Chris:             # https://bugs.python.org/issue21591
           Chris:             message = ''
           Chris:             for line in traceback_lines:
           Chris:                 if PY2:
           Chris:                     # errors='replace' is for Windows filenames present in the
           Chris:                     # traceback that are not UTF8. They will not display
           Chris:                     # correctly, but that's the best we can do - the traceback
           Chris:                     # may contain code from the file in a different encoding,
           Chris:                     # so we could have a mixed encoding string. This is only
           Chris:                     # a problem for Python 2.
           Chris:                     line = line.decode('utf8', errors='replace')
           Chris:                 message += line
        cbilling:             sys.stderr.write(message)
        cbilling:             return False
        cbilling:         else:
        cbilling:             return True
        cbilling:         finally:
           Chris:             os.chdir(cwd)
        cbilling:             print('')
        cbilling:             self.post_analysis_plot_actions()
        cbilling:         
        cbilling:     def pre_analysis_plot_actions(self):
        cbilling:         for plot in self.plots.values():
        cbilling:             plot.save_axis_limits()
        cbilling:             plot.clear()
        cbilling: 
        cbilling:     def post_analysis_plot_actions(self):
        cbilling:         # reset the current figure to figure 1:
        cbilling:         lyse.figure_manager.figuremanager.set_first_figure_current()
        cbilling:         # Introspect the figures that were produced:
        cbilling:         for identifier, fig in lyse.figure_manager.figuremanager.figs.items():
        cbilling:             if not fig.axes:
        cbilling:                 continue
        cbilling:             try:
        cbilling:                 plot = self.plots[fig]
        cbilling:             except KeyError:
        cbilling:                 # If we don't already have this figure, make a window
        cbilling:                 # to put it in:
        cbilling:                 self.new_figure(fig, identifier)
        cbilling:             else:
        cbilling:                 if not plot.is_shown:
        cbilling:                     plot.show()
        cbilling:                     plot.update_window_size()
        cbilling:                 plot.set_window_title(identifier, self.filepath)
        cbilling:                 if plot.lock_axes:
        cbilling:                     plot.restore_axis_limits()
        cbilling:                 plot.draw()
        cbilling: 
        cbilling: 
        cbilling:     def new_figure(self, fig, identifier):
        cbilling:         self.plots[fig] = Plot(fig, identifier, self.filepath)
        cbilling: 
        cbilling:     def reset_figs(self):
        cbilling:         pass
        cbilling:         
        cbilling:         
        cbilling: if __name__ == '__main__':
        cbilling:     filepath = from_parent.get()
        cbilling:     
        cbilling:     # Set a meaningful client id for zprocess.locking:
        cbilling:     zprocess.locking.set_client_process_name('lyse-'+os.path.basename(filepath))
     janwerkmann: 
     janwerkmann:     qapplication = QtWidgets.QApplication(sys.argv)
        cbilling:     worker = AnalysisWorker(filepath, to_parent, from_parent)
        cbilling:     qapplication.exec_()
        cbilling:         
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /dataframe_utilities.py                                           #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program lyse, in the labscript suite     #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
        pstarkey: 
           Chris: from __future__ import division, unicode_literals, print_function, absolute_import
           Chris: from labscript_utils import PY2
           Chris: if PY2:
           Chris:     str = unicode
           Chris:     
        pstarkey: import labscript_utils.h5_lock, h5py
        pstarkey: import pandas
        pstarkey: import os
        pstarkey: from numpy import *
        cbilling: import tzlocal
        pstarkey: import labscript_utils.shared_drive
chrisjbillington: from labscript_utils.dict_diff import dict_diff
        pstarkey: 
        cbilling: import runmanager
        cbilling: 
           Chris: # Monkey patch a bugfix onto older versions of pandas on Python 2. This code
           Chris: # can be removed once lyse otherwise depends on pandas >= 0.21.0.
           Chris: # https://github.com/pandas-dev/pandas/pull/17099
           Chris: if PY2:
           Chris:     try:
           Chris:         from labscript_utils import check_version, VersionException
           Chris:         check_version('pandas', '0.21.0', '2.0')
           Chris:     except VersionException:
           Chris:         
           Chris:         import numpy as np
           Chris:         from pandas import Series, Index
           Chris:         from pandas.core.indexing import maybe_droplevels
           Chris:         def _getitem_multilevel(self, key):
           Chris:             loc = self.columns.get_loc(key)
           Chris:             if isinstance(loc, (slice, Series, np.ndarray, Index)):
           Chris:                 new_columns = self.columns[loc]
           Chris:                 result_columns = maybe_droplevels(new_columns, key)
           Chris:                 if self._is_mixed_type:
           Chris:                     result = self.reindex(columns=new_columns)
           Chris:                     result.columns = result_columns
           Chris:                 else:
           Chris:                     new_values = self.values[:, loc]
           Chris:                     result = self._constructor(new_values, index=self.index,
           Chris:                                                columns=result_columns)
           Chris:                     result = result.__finalize__(self)
           Chris:                 if len(result.columns) == 1:
           Chris:                     top = result.columns[0]
           Chris:                     if isinstance(top, tuple):
           Chris:                         top = top[0]
           Chris:                     if top == '':
           Chris:                         result = result['']
           Chris:                         if isinstance(result, Series):
           Chris:                             result = self._constructor_sliced(result,
           Chris:                                                               index=self.index,
           Chris:                                                               name=key)
           Chris: 
           Chris:                 result._set_is_copy(self)
           Chris:                 return result
           Chris:             else:
           Chris:                 return self._get_item_cache(key)
           Chris: 
           Chris:         pandas.DataFrame._getitem_multilevel = _getitem_multilevel
           Chris: 
           Chris: 
        pstarkey: def asdatetime(timestr):
chrisjbillington:     if isinstance(timestr, bytes):
chrisjbillington:         timestr = timestr.decode('utf-8')
        cbilling:     tz = tzlocal.get_localzone().zone
        pstarkey:     return pandas.Timestamp(timestr, tz=tz)
        pstarkey: 
        pstarkey: def get_nested_dict_from_shot(filepath):
        cbilling:     row = runmanager.get_shot_globals(filepath)
        pstarkey:     with h5py.File(filepath,'r') as h5_file:
        pstarkey:         if 'results' in h5_file:
        pstarkey:             for groupname in h5_file['results']:
        pstarkey:                 resultsgroup = h5_file['results'][groupname]
        pstarkey:                 row[groupname] = dict(resultsgroup.attrs)
        pstarkey:         if 'images' in h5_file:
        pstarkey:             for orientation in h5_file['images'].keys():
         Russell:                 if isinstance(h5_file['images'][orientation], h5py.Group):
         Russell:                     row[orientation] = dict(h5_file['images'][orientation].attrs)
         Russell:                     for label in h5_file['images'][orientation]:
         Russell:                         row[orientation][label] = {}
         Russell:                         group = h5_file['images'][orientation][label]
         Russell:                         for image in group:
         Russell:                             row[orientation][label][image] = {}
         Russell:                             for key, val in group[image].attrs.items():
         Russell:                                 if not isinstance(val, h5py.Reference):
         Russell:                                     row[orientation][label][image][key] = val
        pstarkey:         row['filepath'] = filepath
        cbilling:         row['agnostic_path'] = labscript_utils.shared_drive.path_to_agnostic(filepath)
        spielman:         row['sequence'] = asdatetime(h5_file.attrs['sequence_id'].split('_')[0])
        spielman:         try:
        spielman:             row['sequence_index'] = h5_file.attrs['sequence_index']
           Chris:         except KeyError:
           Chris:             row['sequence_index'] = None
        pstarkey:         if 'script' in h5_file: 
        pstarkey:             row['labscript'] = h5_file['script'].attrs['name']
        pstarkey:         try:
        pstarkey:             row['run time'] = asdatetime(h5_file.attrs['run time'])
        pstarkey:         except KeyError:
        pstarkey:             row['run time'] = float('nan')
        pstarkey:         try:    
        pstarkey:             row['run number'] = h5_file.attrs['run number']
        pstarkey:         except KeyError:
          rander:             row['run number'] = float('nan')
        pstarkey:         try:
          rander:             row['run repeat'] = h5_file.attrs['run repeat']
          rander:         except KeyError:
          rander:             row['run repeat'] = 0
        pstarkey:         try:
        pstarkey:             row['individual id'] = h5_file.attrs['individual id']
        pstarkey:             row['generation'] = h5_file.attrs['generation']
        pstarkey:         except KeyError:
        pstarkey:             pass
        pstarkey:         return row
        pstarkey:             
        pstarkey: def flatten_dict(dictionary, keys=tuple()):
        pstarkey:     """Takes a nested dictionary whose keys are strings, and returns a
        pstarkey:     flat dictionary whose keys are tuples of strings, each element of
        pstarkey:     which is the key for one level of the hierarchy."""
        pstarkey:     result = {}
        pstarkey:     for name in dictionary:
        pstarkey:         if isinstance(dictionary[name],dict):
           Chris:             flat = flatten_dict(dictionary[name],keys=keys + (name,))
        pstarkey:             result.update(flat)
        pstarkey:         else:
           Chris:             result[keys + (name,)] = dictionary[name]
        pstarkey:     return result
        pstarkey:             
        pstarkey: def flat_dict_to_hierarchical_dataframe(dictionary):
        pstarkey:     """Make all the keys tuples of the same length"""
        pstarkey:     max_tuple_length = 2 # Must have at least two levels to make a MultiIndex
        pstarkey:     for key in dictionary:
        pstarkey:         max_tuple_length = max(max_tuple_length,len(key))
        pstarkey:     result = {}
        pstarkey:     for key in dictionary:
        pstarkey:         newkey = key[:]
        pstarkey:         while len(newkey) < max_tuple_length:
        pstarkey:             newkey += ('',)
        pstarkey:         result[newkey] = dictionary[key]    
        pstarkey:     index = pandas.MultiIndex.from_tuples(sorted(result.keys()))
        pstarkey:     return pandas.DataFrame([result],columns=index)  
        pstarkey: 
        pstarkey: def flat_dict_to_flat_series(dictionary):
        pstarkey:     max_tuple_length = 2 # Must have at least two levels to make a MultiIndex
        pstarkey:     result = {}
        pstarkey:     for key in dictionary:
        pstarkey:         if len(key) > 1:
        pstarkey:             result[key] = dictionary[key]
        pstarkey:         else:
        pstarkey:             result[key[0]] = dictionary[key]
chrisjbillington:     keys = list(result.keys())
        pstarkey:     keys.sort(key = lambda item: 
        pstarkey:         (len(item),) + item if isinstance(item, tuple) else (1,item))
        pstarkey:     return pandas.Series(result,index=keys)  
        pstarkey:           
        pstarkey: def get_dataframe_from_shot(filepath):
        pstarkey:     nested_dict = get_nested_dict_from_shot(filepath)
        pstarkey:     flat_dict =  flatten_dict(nested_dict)
        pstarkey:     df = flat_dict_to_hierarchical_dataframe(flat_dict)
        pstarkey:     return df
        pstarkey:     
        cbilling: def get_dataframe_from_shots(filepaths):
        cbilling:     return concat_with_padding(*[get_dataframe_from_shot(filepath) for filepath in filepaths])
        cbilling: 
        pstarkey: def get_series_from_shot(filepath):
        pstarkey:     nested_dict = get_nested_dict_from_shot(filepath)
        pstarkey:     flat_dict =  flatten_dict(nested_dict)
        pstarkey:     s = flat_dict_to_flat_series(flat_dict)
        pstarkey:     return s
        pstarkey:     
        pstarkey: def pad_columns(df, n):
        pstarkey:     """Add depth to hiererchical column labels with empty strings"""
        pstarkey:     if df.columns.nlevels == n:
        pstarkey:         return df
        pstarkey:     new_columns = []
        pstarkey:     data = {}
        pstarkey:     for column in df.columns:
        pstarkey:         new_column = column + ('',)*(n-len(column))
        pstarkey:         new_columns.append(new_column)
        pstarkey:         data[new_column] = df[column]
        pstarkey:     index = pandas.MultiIndex.from_tuples(new_columns)
        pstarkey:     return pandas.DataFrame(data,columns = index)
        pstarkey: 
        cbilling: def concat_with_padding(*dataframes):
        cbilling:     """Concatenates dataframes with MultiIndex column labels,
        cbilling:     padding shallower hierarchies such that the MultiIndexes have
        pstarkey:     the same nlevels."""
        cbilling:     dataframes = list(dataframes)
          rander:     # Remove empty dataframes (these don't concat since pandas 0.18) 
          rander:     dataframes = [df for df in dataframes if not df.empty]
        cbilling:     max_nlevels = max(df.columns.nlevels for df in dataframes)
        cbilling:     for i, df in enumerate(dataframes):
        cbilling:         if df.columns.nlevels < max_nlevels:
        cbilling:             dataframes[i] = pad_columns(df, max_nlevels)
        cbilling:     return pandas.concat(dataframes, ignore_index=True)
        pstarkey:     
           Chris: def replace_with_padding(df, row, index):
        pstarkey:     if df.columns.nlevels < row.columns.nlevels:
        pstarkey:         df = pad_columns(df, row.columns.nlevels)
        pstarkey:     elif df.columns.nlevels > row.columns.nlevels:
        pstarkey:         row = pad_columns(row, df.columns.nlevels)
           Chris: 
           Chris:     # Change the index of the row object to equal that of where it is to be
           Chris:     # inserted:
           Chris:     row.index = pandas.Int64Index([index])
           Chris: 
           Chris:     # Replace the target row in the dataframe by dropping, appending, then
           Chris:     # sorting by index:
        pstarkey:     df = df.drop([index])
        pstarkey:     df = df.append(row)
          shaunj:     df = df.sort_index()
        pstarkey:     return df
        pstarkey:     
        pstarkey: 
        pstarkey:     
cbilling: from lyse import *
cbilling: from lyse import *
cbilling: from pylab import *
cbilling: 
cbilling: # Let's obtain our data for this shot -- globals, image attributes and
cbilling: # the results of any previously run single-shot routines:
cbilling: ser = data(path)
cbilling: 
cbilling: # Get a global called x:
cbilling: x = ser['x']
cbilling: 
cbilling: # Get a result saved by another single-shot analysis routine which has
cbilling: # already run. The result is called 'y', and the routine was called
cbilling: # 'some_routine':
cbilling: y = ser['some_routine','y']
cbilling: 
cbilling: # Image attributes are also stored in this series:
cbilling: w_x2 = ser['side','absorption','OD','Gaussian_XW']
cbilling: 
cbilling: # If we want actual measurement data, we'll have to instantiate a Run object:
cbilling: run = Run(path)
cbilling: 
cbilling: # Obtaining a trace:
cbilling: t, mot_fluorecence = run.get_trace('mot fluorecence')
cbilling: 
cbilling: # Now we might do some analysis on this data. Say we've written a
cbilling: # linear fit function (or we're calling some other libaries linear
cbilling: # fit function):
cbilling: m, c = linear_fit(t, mot_fluorecence)
cbilling: 
cbilling: # We might wish to plot the fit on the trace to show whether the fit is any good:
cbilling: 
cbilling: plot(t,mot_fluorecence,label='data')
cbilling: plot(t,m*t + x,label='linear fit')
cbilling: xlabel('time')
cbilling: ylabel('MOT flourescence')
cbilling: legend()
cbilling: 
cbilling: # Don't call show() ! lyse will introspect what figures have been made
cbilling: # and display them once this script has finished running.  If you call
cbilling: # show() it won't find anything. lyse keeps track of figures so that new
cbilling: # figures replace old ones, rather than you getting new window popping
cbilling: # up every time your script runs.
cbilling: 
cbilling: # We might wish to save this result so that we can compare it across
cbilling: # shots in a multishot analysis:
cbilling: run.save_result('mot loadrate', c)
cbilling: from lyse import *
cbilling: from pylab import *
cbilling: 
cbilling: # Let's obtain the dataframe for all of lyse's currently loaded shots:
cbilling: df = data()
cbilling: 
cbilling: # Now let's see how the MOT load rate varies with, say a global called
cbilling: # 'detuning', which might be the detuning of the MOT beams:
cbilling: 
cbilling: detunings = df['detuning']
cbilling: 
cbilling: # mot load rate was saved by a routine called calculate_load_rate:
cbilling: 
cbilling: load_rates = df['calculate_load_rate', 'mot loadrate']
cbilling: 
cbilling: # Let's plot them against each other:
cbilling: 
cbilling: plot(detunings, load_rates,'bo',label='data')
cbilling: 
cbilling: # Maybe we expect a linear relationship over the range we've got:
cbilling: m, c = linear_fit(detunings, load_rates)
cbilling: # (note, not a function provided by lyse, though I'm sure we'll have
cbilling: # lots of stock functions like this available for import!)
cbilling: 
cbilling: plot(detunings, m*detunings + c, 'ro', label='linear fit')
cbilling: legend()
cbilling: 
cbilling: #To save this result to the output hdf5 file, we have to instantiate a
cbilling: #Sequence object:
cbilling: seq = Sequence(path, df)
cbilling: seq.save_result('detuning_loadrate_slope',c)
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # /figure_manager.py                                                #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of the program lyse, in the labscript suite     #
cbilling: # (see http://labscriptsuite.org), and is licensed under the        #
cbilling: # Simplified BSD License. See the license.txt file in the root of   #
cbilling: # the project for the full license.                                 #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
   Chris: from __future__ import division, unicode_literals, print_function, absolute_import
   Chris: from labscript_utils import PY2
   Chris: if PY2:
   Chris:     str = unicode
   Chris:     
cbilling: import lyse
cbilling: import sys
cbilling: 
cbilling: class FigureManager(object):
cbilling: 
cbilling:     def __init__(self):
cbilling:         self.figs = {}
cbilling:         self._figure = matplotlib.pyplot.figure
cbilling:         self._close = matplotlib.pyplot.close
cbilling:         self._show = matplotlib.pyplot.show
cbilling:         
cbilling:     def get_first_empty_figure(self,*args,**kwargs):
cbilling:         i = 1
cbilling:         while True:
cbilling:             fig = self._figure(i,*args,**kwargs)
cbilling:             if not fig.axes:
cbilling:                 return i, fig
cbilling:             i += 1
cbilling:             
cbilling:     def set_first_figure_current(self):
cbilling:         self._figure(1)
cbilling:                 
cbilling:     def __call__(self,identifier=None, *args, **kwargs):
cbilling:         if identifier is None:
cbilling:             number, fig =  self.get_first_empty_figure(*args,**kwargs)
cbilling:             self.figs[number] = fig
cbilling:         elif identifier in self.figs:
cbilling:             fig = self.figs[identifier]
cbilling:             self._figure(fig.number)
cbilling:         else:
cbilling:             number, fig =  self.get_first_empty_figure(*args,**kwargs)
cbilling:             self.figs[identifier] = fig
cbilling:         return fig
cbilling: 
cbilling:     def close(self,identifier=None):
cbilling:         if identifier is None:
cbilling:             thisfig = matplotlib.pyplot.gcf()
cbilling:             for key, fig in self.figs.items():
cbilling:                 if fig is thisfig:
cbilling:                     del self.figs[key]
cbilling:                     self._close()
cbilling:         elif isinstance(identifier,matplotlib.figure.Figure):
cbilling:             thisfig = identifier
cbilling:             for key, fig in self.figs.items():
cbilling:                 if fig is thisfig:
cbilling:                     del self.figs[fig]
cbilling:                     self._close(thisfig)
cbilling:         elif identifier == 'all':
cbilling:             self.figs = {}
cbilling:             self._close('all')
cbilling:         else:
cbilling:             fig = self.figs[identifier]
cbilling:             self._close(fig.number)
cbilling:             del self.figs[identifier]
cbilling:             
cbilling:     def show(self):
cbilling:         if lyse.spinning_top:
cbilling:             pass # supress show()
cbilling:         else:
cbilling:             self._show()
cbilling: 
cbilling: 
cbilling: figuremanager = None
cbilling: matplotlib = None
cbilling: 
cbilling: def install():
cbilling:     if 'matplotlib.pyplot' in sys.modules:
cbilling:         message = ('install() must be imported prior to importing pylab/pyplot ' +
cbilling:                    'in order to correctly override the figure() function.')
cbilling:         raise RuntimeError(message)
cbilling: 
cbilling:     global matplotlib
cbilling:     global figuremanager
cbilling:     import matplotlib.pyplot
cbilling:     import matplotlib.figure
cbilling: 
cbilling:     figuremanager = FigureManager()
cbilling:     matplotlib.pyplot.figure = figuremanager
cbilling:     matplotlib.pyplot.close = figuremanager.close
cbilling:     matplotlib.pyplot.show = figuremanager.show
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # /tempfile2clipboard.py                                            #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2017, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the program lyse, in the labscript suite     #
chrisjbillington: # (see http://labscriptsuite.org), and is licensed under the        #
chrisjbillington: # Simplified BSD License. See the license.txt file in the root of   #
chrisjbillington: # the project for the full license.                                 #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
           Chris: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: 
     janwerkmann: from qtutils.qt.QtWidgets import QApplication
     janwerkmann: from qtutils.qt.QtGui import QImage
chrisjbillington: 
chrisjbillington: """
chrisjbillington: This is a stand-alone script which copies an image to the clipboard and then
chrisjbillington: optionally deletes the image file.
chrisjbillington: 
chrisjbillington: usage:
chrisjbillington: 
chrisjbillington:     python tempfile2clipboard.py [--delete] image_filepath
chrisjbillington: 
chrisjbillington: 
chrisjbillington: After copying the image data to the clipboard, this script optionally deletes
chrisjbillington: the image file, if the --delete argument is provided, and then continues
chrisjbillington: running until the clipboard data changes.
chrisjbillington: 
chrisjbillington: This is due to the way in which some clipboards work - data is not requested
chrisjbillington: from the application until it is pasted somewhere, and so the application
chrisjbillington: doing the copying must still be running. It is also useful to have this
chrisjbillington: functionality be a stand-alone script since it requires a Qt mainloop, and
chrisjbillington: this way we avoid corner-cases of how this may interfere with any use of Qt in
chrisjbillington: the calling program.
chrisjbillington: 
chrisjbillington: """
chrisjbillington: 
chrisjbillington: def main():
chrisjbillington:     USAGE = 'Usage:\n    python tempfile2clipboard.py [--delete] image_filepath\n'
chrisjbillington: 
chrisjbillington:     if len(sys.argv) > 1 and sys.argv[1] == '--delete':
chrisjbillington:         delete = True
chrisjbillington:         del sys.argv[1]
chrisjbillington:     else:
chrisjbillington:         delete = False
chrisjbillington: 
chrisjbillington:     if len(sys.argv) != 2:
chrisjbillington:         sys.stderr.write("Invalid arguments.\n" + USAGE)
chrisjbillington:         sys.exit(1)
chrisjbillington: 
chrisjbillington:     image_file = sys.argv[1]
chrisjbillington:     image = QImage(image_file)
chrisjbillington:     if delete:
chrisjbillington:         os.unlink(image_file)
chrisjbillington: 
chrisjbillington:     if image.isNull():
chrisjbillington:         sys.stderr.write("Invalid image file: {}.\n".format(image_file) + USAGE)
chrisjbillington:         sys.exit(1)
chrisjbillington: 
chrisjbillington:     app = QApplication([])
chrisjbillington:     app.clipboard().setImage(image)
chrisjbillington: 
chrisjbillington:     # Keep running until the clipboard contents change to something else:
chrisjbillington:     app.clipboard().dataChanged.connect(app.quit)
chrisjbillington:     app.exec_()
chrisjbillington: 
chrisjbillington: 
chrisjbillington: if __name__ == '__main__':
chrisjbillington:     main()
