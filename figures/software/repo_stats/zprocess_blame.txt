chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: 
chrisjbillington: sys.path.insert(0, os.path.abspath('..'))
chrisjbillington: 
chrisjbillington: # Pull the version string out of setup.py without importing it
chrisjbillington: with open('../setup.py') as f:
chrisjbillington:     for line in f:
chrisjbillington:         if 'VERSION' in line:
chrisjbillington:             __version__ = eval(line.split('=')[1])
chrisjbillington:             break
chrisjbillington: 
chrisjbillington: extensions = [
chrisjbillington:     'sphinx.ext.autodoc',
chrisjbillington:     'sphinxcontrib.napoleon',
chrisjbillington: ]
chrisjbillington: 
chrisjbillington: master_doc = 'index'
chrisjbillington: project = u'zprocess'
chrisjbillington: copyright = u'2013-2018, Chris Billington'
chrisjbillington: version = __version__
chrisjbillington: release = '.'.join(__version__.split('.')[:-1])
chrisjbillington: 
chrisjbillington: autodoc_member_order = 'bysource'
chrisjbillington: autoclass_content = 'both'
chrisjbillington: 
chrisjbillington: on_rtd = os.environ.get('READTHEDOCS', None) == 'True'
chrisjbillington: 
chrisjbillington: if not on_rtd:  # only import and set the theme if we're building docs locally
chrisjbillington:     import sphinx_rtd_theme
chrisjbillington:     html_theme = 'sphinx_rtd_theme'
chrisjbillington:     html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
chrisjbillington: 
chrisjbillington: # # Monkeypatch add_directive_header method of AttributeDocumenter to not show
chrisjbillington: # # values of attributes, autodoc doesn't seem to be able to find them anyway
chrisjbillington: # # for our enums - they all come out as None.
chrisjbillington: # from sphinx.ext.autodoc import AttributeDocumenter, ClassLevelDocumenter
chrisjbillington: 
chrisjbillington: # def add_directive_header(self, sig):
chrisjbillington: #     ClassLevelDocumenter.add_directive_header(self, sig)
chrisjbillington: 
chrisjbillington: # AttributeDocumenter.add_directive_header = add_directive_header
chrisjbillington: from __future__ import unicode_literals, print_function, division
chrisjbillington: import subprocess
chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: import errno
chrisjbillington: 
chrisjbillington: PYTHON2 = 'python'
chrisjbillington: PYTHON3 = 'python3'
chrisjbillington: 
chrisjbillington: # The version we're testing:
chrisjbillington: PYTHONS = {'2': PYTHON2,
chrisjbillington:            '3': PYTHON3}
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def mkdir_p(path):
chrisjbillington:     try:
chrisjbillington:         os.makedirs(path)
chrisjbillington:     except OSError as exc:  # Python >2.5
chrisjbillington:         if exc.errno == errno.EEXIST and os.path.isdir(path):
chrisjbillington:             pass
chrisjbillington:         else:
chrisjbillington:             raise
chrisjbillington: 
chrisjbillington: for python_version in PYTHONS:
chrisjbillington:     python_executable = PYTHONS[python_version]
chrisjbillington:     print('doing tests for python version {} with executable {}'.format(python_version, python_executable))
           Chris:     cmds = [python_executable, '-c', 'import site; print(site.getusersitepackages())']
           Chris:     user_site = subprocess.check_output(cmds).decode('utf8').strip()
chrisjbillington:     if not os.path.exists(user_site):
chrisjbillington:         mkdir_p(user_site)
chrisjbillington: 
chrisjbillington:     path_file = os.path.join(user_site, 'coverage.pth')
chrisjbillington: 
chrisjbillington:     COVERAGE_PROCESS_START = os.path.abspath('.coveragerc')
chrisjbillington:     import coverage
chrisjbillington:     coverage_import_path = os.path.dirname(os.path.dirname(os.path.abspath(coverage.__file__)))
chrisjbillington:     environ = os.environ.copy()
chrisjbillington:     environ['COVERAGE_PROCESS_START'] = COVERAGE_PROCESS_START
chrisjbillington: 
chrisjbillington:     try:
chrisjbillington:         with open(path_file, 'w') as f:
chrisjbillington:             f.write("import sys; sys.path.insert(0, '{}')\n".format(coverage_import_path))
chrisjbillington:             f.write("import coverage; coverage.process_startup()" + '\n')
chrisjbillington:         subprocess.call([python_executable, 'tests/tests.py'], env = environ)
chrisjbillington:     finally:
chrisjbillington:         try:
chrisjbillington:             os.unlink(path_file)
chrisjbillington:         except OSError:
chrisjbillington:             pass
chrisjbillington: try:
chrisjbillington:     subprocess.call([sys.executable, '-m', 'coverage', 'combine'])
chrisjbillington:     subprocess.call([sys.executable, '-m', 'coverage', 'html', '--rcfile=.coveragerc'])
chrisjbillington:     subprocess.call([sys.executable, '-m', 'coverage', 'erase'])
chrisjbillington: except Exception:
chrisjbillington:     pass
        cbilling: #!/usr/bin/env python
        cbilling: 
        cbilling: # To upload a version to PyPI, run:
        cbilling: #
        cbilling: #    python setup.py sdist upload
        cbilling: #
        cbilling: # If the package is not registered with PyPI yet, do so with:
        cbilling: #
        cbilling: # python setup.py register
        cbilling: 
chrisjbillington: from setuptools import setup
        cbilling: import os
        cbilling: 
chrisjbillington: VERSION = '2.4.12'
        cbilling: 
        cbilling: # Auto generate a __version__ package for the package to import
        cbilling: with open(os.path.join('zprocess', '__version__.py'), 'w') as f:
        cbilling:     f.write("__version__ = '%s'\n"%VERSION)
        cbilling: 
chrisjbillington: dependencies = ['pyzmq', 'xmlrunner']
chrisjbillington: 
chrisjbillington: import sys
chrisjbillington: if sys.version_info.major == 2:
chrisjbillington:     # Backported modules:
chrisjbillington:     dependencies.append('ipaddress')
chrisjbillington:     dependencies.append('subprocess32')
chrisjbillington: 
        cbilling: setup(name='zprocess',
        cbilling:       version=VERSION,
           Chris:       description="A set of utilities for multiprocessing using zeromq.",
        cbilling:       author='Chris Billington',
        cbilling:       author_email='chrisjbillington@gmail.com',
        cbilling:       url='https://bitbucket.org/cbillington/zprocess/',
        cbilling:       license="BSD",
chrisjbillington:       packages=['zprocess', 'zprocess.locking', 'zprocess.zlog'],
chrisjbillington:       install_requires=dependencies
        cbilling:      )
chrisjbillington: from __future__ import absolute_import, unicode_literals, print_function, division
chrisjbillington: import sys
chrisjbillington: PY2 = sys.version_info.major == 2
chrisjbillington: import os
chrisjbillington: import time
chrisjbillington: import threading
chrisjbillington: import subprocess
chrisjbillington: import zmq
chrisjbillington: 
chrisjbillington: 
chrisjbillington: parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
chrisjbillington: sys.path.insert(0, parent_dir)
chrisjbillington: 
chrisjbillington: from zprocess.security import SecureContext
chrisjbillington: from zprocess.process_tree import OutputInterceptor
chrisjbillington: 
chrisjbillington: context = SecureContext()
chrisjbillington: sock = context.socket(zmq.PULL)
chrisjbillington: port = sock.bind_to_random_port('tcp://127.0.0.1')
chrisjbillington: print('pre-redirect: hello!')
chrisjbillington: if sys.stdout is not None:
chrisjbillington:     print('pre-redirect: stdout is a tty:', sys.stdout.isatty())
chrisjbillington: interceptor = OutputInterceptor('localhost', port, 'stdout')
chrisjbillington: interceptor2 = OutputInterceptor('localhost', port, 'stderr')
chrisjbillington: interceptor.connect()
chrisjbillington: interceptor2.connect()
chrisjbillington: try:
chrisjbillington:     for i in range(3):
chrisjbillington:         print("python hello")
chrisjbillington:         sys.stdout.write('1\n')
chrisjbillington:         sys.stderr.write('2\n')
chrisjbillington:         os.system('echo echo hello')
chrisjbillington: 
chrisjbillington:     child = subprocess.Popen(['python', '-c',
chrisjbillington:                              'import time; time.sleep(2); print("hello")'])
chrisjbillington:     del child
chrisjbillington:     print('stdout is a tty:', sys.stdout.isatty())
chrisjbillington: finally:
chrisjbillington:     interceptor.disconnect()
chrisjbillington:     interceptor2.disconnect()
chrisjbillington:     print('post-redirect: hello!')
chrisjbillington:     if sys.stdout is not None:
chrisjbillington:         print('stdout is a tty:', sys.stdout.isatty())
chrisjbillington: 
chrisjbillington:     if sys.stdout is None or sys.stdout.fileno() < 0:
chrisjbillington:         f = open('test.txt', 'w')
chrisjbillington:         g = f
chrisjbillington:     else:
chrisjbillington:         f = sys.stdout
chrisjbillington:         g = sys.stderr
chrisjbillington:     while sock.poll(100):
chrisjbillington:         data = sock.recv_multipart()
chrisjbillington:         if data[0] == b'stdout':
chrisjbillington:             f.write(data[1].decode())
chrisjbillington:         else:
chrisjbillington:             g.write(data[1].decode())
chrisjbillington:     f.flush()
chrisjbillington:     g.flush()
chrisjbillington: #! /usr/bin/env python3
chrisjbillington: # -*- coding: utf-8 -*-
chrisjbillington: 
chrisjbillington: from __future__ import unicode_literals, print_function, division
chrisjbillington: 
chrisjbillington: import unittest
chrisjbillington: 
chrisjbillington: import sys
chrisjbillington: PY2 = sys.version_info.major == 2
chrisjbillington: import os
chrisjbillington: import time
chrisjbillington: import threading
chrisjbillington: 
chrisjbillington: import zmq
chrisjbillington: 
chrisjbillington: import xmlrunner
chrisjbillington: 
chrisjbillington: parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
chrisjbillington: sys.path.insert(0, parent_dir)
chrisjbillington: 
chrisjbillington: from zprocess import (ZMQServer, Process, TimeoutError,
chrisjbillington:                       raise_exception_in_thread, zmq_get, zmq_push, zmq_get_raw)
chrisjbillington: import zprocess.clientserver as clientserver
chrisjbillington: from zprocess.clientserver import _typecheck_or_convert_data
chrisjbillington: from zprocess.process_tree import _default_process_tree
chrisjbillington: shared_secret = _default_process_tree.shared_secret
chrisjbillington: from zprocess.security import SecureContext
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class TestError(Exception):
chrisjbillington:     pass
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class RaiseExceptionInThreadTest(unittest.TestCase):
chrisjbillington: 
chrisjbillington:     def setUp(self):
chrisjbillington:         # Mock threading.Thread to just run a function in the main thread:
chrisjbillington:         class MockThread(object):
chrisjbillington:             used = False
chrisjbillington:             def __init__(self, target, args):
chrisjbillington:                 self.target = target
chrisjbillington:                 self.args = args
chrisjbillington:             def start(self):
chrisjbillington:                 MockThread.used = True
chrisjbillington:                 self.target(*self.args)
chrisjbillington:         self.mock_thread = MockThread
chrisjbillington:         self.orig_thread = threading.Thread
chrisjbillington:         threading.Thread = MockThread
chrisjbillington: 
chrisjbillington:     def test_can_raise_exception_in_thread(self):
chrisjbillington:         try:
chrisjbillington:             raise TestError('test')
chrisjbillington:         except Exception:
chrisjbillington:             exc_info = sys.exc_info()
chrisjbillington:             with self.assertRaises(TestError):
chrisjbillington:                 raise_exception_in_thread(exc_info)
chrisjbillington:             self.assertTrue(self.mock_thread.used)
chrisjbillington: 
chrisjbillington:     def tearDown(self):
chrisjbillington:         # Restore threading.Thread to what it should be
chrisjbillington:         threading.Thread = self.orig_thread
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class  TypeCheckConvertTests(unittest.TestCase):
chrisjbillington:     """test the _typecheck_or_convert_data function"""
chrisjbillington: 
chrisjbillington:     def test_turns_None_into_empty_bytestring_raw(self):
chrisjbillington:         result = _typecheck_or_convert_data(None, 'raw')
chrisjbillington:         self.assertEqual(result, b'')
chrisjbillington: 
chrisjbillington:     def test_turns_None_into_empty_bytestring_multipart(self):
chrisjbillington:         result = _typecheck_or_convert_data(None, 'multipart')
chrisjbillington:         self.assertEqual(result, [b''])
chrisjbillington: 
chrisjbillington:     def test_wraps_bytestring_into_list_multipart(self):
chrisjbillington:         data = b'spam'
chrisjbillington:         result = _typecheck_or_convert_data(data, 'multipart')
chrisjbillington:         self.assertEqual(result, [data])
chrisjbillington: 
chrisjbillington:     def test_accepts_bytes_raw(self):
chrisjbillington:         data = b'spam'
chrisjbillington:         result = _typecheck_or_convert_data(data, 'raw')
chrisjbillington:         self.assertEqual(result, data)
chrisjbillington: 
chrisjbillington:     def test_accepts_list_of_bytes_multipart(self):
chrisjbillington:         data = [b'spam', b'ham']
chrisjbillington:         result = _typecheck_or_convert_data(data, 'multipart')
chrisjbillington:         self.assertEqual(result, data)
chrisjbillington: 
chrisjbillington:     def test_accepts_string_string(self):
chrisjbillington:         data = 'spam'
chrisjbillington:         result = _typecheck_or_convert_data(data, 'string')
chrisjbillington:         self.assertEqual(result, data)
chrisjbillington: 
chrisjbillington:     def test_accepts_pyobj_pyobj(self):
chrisjbillington:         data = {'spam': ['ham'], 'eggs': True}
chrisjbillington:         result = _typecheck_or_convert_data(data, 'pyobj')
chrisjbillington:         self.assertEqual(result, data)
chrisjbillington: 
chrisjbillington:     def test_rejects_string_raw(self):
chrisjbillington:         data = 'spam'
chrisjbillington:         with self.assertRaises(TypeError):
chrisjbillington:             _typecheck_or_convert_data(data, 'raw')
chrisjbillington: 
chrisjbillington:     def test_rejects_string_multipart(self):
chrisjbillington:         data = [b'spam', 'ham']
chrisjbillington:         with self.assertRaises(TypeError):
chrisjbillington:             _typecheck_or_convert_data(data, 'multipart')
chrisjbillington: 
chrisjbillington:     def test_rejects_pyobj_string(self):
chrisjbillington:         data = {'spam': ['ham'], 'eggs': True}
chrisjbillington:         with self.assertRaises(TypeError):
chrisjbillington:             _typecheck_or_convert_data(data, 'string')
chrisjbillington: 
chrisjbillington:     def test_rejects_invalid_send_type(self):
chrisjbillington:         data = {'spam': ['ham'], 'eggs': True}
chrisjbillington:         with self.assertRaises(ValueError):
chrisjbillington:             _typecheck_or_convert_data(data, 'invalid_send_type')
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class TestProcess(Process):
chrisjbillington:     def run(self):
chrisjbillington:         item = self.from_parent.get()
chrisjbillington:         x, y = item
chrisjbillington:         sys.stdout.write(repr(x))
chrisjbillington:         sys.stderr.write(y)
chrisjbillington:         self.to_parent.put(item)
chrisjbillington:         os.system('echo hello from echo')
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ProcessClassTests(unittest.TestCase):
chrisjbillington: 
chrisjbillington:     def setUp(self):
chrisjbillington:         """Create a subprocess with output redirection to a zmq port"""
chrisjbillington:         context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:         self.redirection_sock = context.socket(zmq.PULL)
chrisjbillington:         redirection_port = self.redirection_sock.bind_to_random_port(
chrisjbillington:                                'tcp://127.0.0.1')
chrisjbillington:         self.process = TestProcess(redirection_port)
chrisjbillington: 
chrisjbillington:     def test_process(self):
chrisjbillington:         to_child, from_child = self.process.start()
chrisjbillington:         # Check the child process is running:
chrisjbillington:         self.assertIs(self.process.child.poll(), None)
chrisjbillington: 
chrisjbillington:         # Send some data:
chrisjbillington:         x = [('spam', ['ham']), ('eggs', True)]
chrisjbillington:         y = 'über'
chrisjbillington:         data = (x, y)
chrisjbillington:         to_child.put(data)
chrisjbillington: 
chrisjbillington:         # Subprocess should send back the data unmodified:
chrisjbillington:         recv_data = from_child.get(timeout=1)
chrisjbillington:         self.assertEqual(recv_data, data)
chrisjbillington: 
chrisjbillington:         # Subprocess should not send any more data, expect TimeoutError:
chrisjbillington:         with self.assertRaises(TimeoutError):
chrisjbillington:             from_child.get(timeout=0.1)
chrisjbillington: 
chrisjbillington:         # Check we recieved its stdout and stderr:
chrisjbillington:         self.assertEqual(self.redirection_sock.poll(1000), zmq.POLLIN)
chrisjbillington:         self.assertEqual(self.redirection_sock.recv_multipart(),
chrisjbillington:                          [b'stdout', repr(x).encode('utf8')])
chrisjbillington:         self.assertEqual(self.redirection_sock.poll(1000), zmq.POLLIN)
chrisjbillington:         self.assertEqual(self.redirection_sock.recv_multipart(),
chrisjbillington:                          [b'stderr', y.encode('utf8')])
chrisjbillington:         # And the shell output:
chrisjbillington:         self.assertEqual(self.redirection_sock.poll(1000), zmq.POLLIN)
chrisjbillington:         self.assertEqual(self.redirection_sock.recv_multipart(),
chrisjbillington:                          [b'stdout', b'hello from echo\n'])
chrisjbillington:         # And no more...
chrisjbillington:         self.assertEqual(self.redirection_sock.poll(100), 0)
chrisjbillington: 
chrisjbillington:     def tearDown(self):
chrisjbillington:         self.process.terminate()
chrisjbillington:         self.redirection_sock.close()
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class HeartbeatClientTestProcess(Process):
chrisjbillington:     """For testing that subprocesses are behaving correcly re. heartbeats"""
chrisjbillington:     def run(self):
chrisjbillington:         self.from_parent.get()
chrisjbillington:         # If the parent sends a message, acquire the kill lock for 3 seconds:
chrisjbillington:         with self.kill_lock:
chrisjbillington:             time.sleep(3)
chrisjbillington:         time.sleep(10)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class HeartbeatServerTestProcess(Process):
chrisjbillington:     """For testing that parent processes are behaving correcly re. heartbeats"""
chrisjbillington:     def run(self):
chrisjbillington:         # We'll send heartbeats of our own, independent of the HeartbeatClient
chrisjbillington:         # already running in this process:
chrisjbillington:         shared_secret = self.process_tree.shared_secret
chrisjbillington:         context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:         sock = context.socket(zmq.REQ)
chrisjbillington:         sock.setsockopt(zmq.LINGER, 0)
chrisjbillington:         server_port = self.from_parent.get()
chrisjbillington:         sock.connect('tcp://127.0.0.1:%s' % server_port)
chrisjbillington:         # Send a heartbeat with whatever data:
chrisjbillington:         data = b'heartbeat_data'
chrisjbillington:         sock.send(data)
chrisjbillington:         if sock.poll(1000):
chrisjbillington:             response = sock.recv()
chrisjbillington:             # Tell the parent whether things were as expected:
chrisjbillington:             if response == data:
chrisjbillington:                 self.to_parent.put(True)
chrisjbillington:                 time.sleep(1) # Ensure it sends before we return
chrisjbillington:                 return
chrisjbillington:         self.to_parent.put(False)
chrisjbillington:         time.sleep(1) # Ensure it sends before we return
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class HeartbeatTests(unittest.TestCase):
chrisjbillington:     def setUp(self):
chrisjbillington:         """Create a sock for output redirection and a zmq port to mock a heartbeat
chrisjbillington:         server"""
chrisjbillington:         import zmq
chrisjbillington:         context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:         self.heartbeat_sock = context.socket(zmq.REP)
chrisjbillington:         heartbeat_port = self.heartbeat_sock.bind_to_random_port('tcp://127.0.0.1')
chrisjbillington: 
chrisjbillington:         class mock_heartbeat_server(object):
chrisjbillington:             port = heartbeat_port
chrisjbillington: 
chrisjbillington:         self.mock_heartbeat_server = mock_heartbeat_server
chrisjbillington: 
chrisjbillington:     def test_subproc_lives_with_heartbeats(self):
chrisjbillington:         _default_process_tree.heartbeat_server = self.mock_heartbeat_server
chrisjbillington:         self.process = HeartbeatClientTestProcess()
chrisjbillington:         self.process.start()
chrisjbillington:         for i in range(3):
chrisjbillington:             # Wait for a heartbeat request:
chrisjbillington:             self.assertTrue(self.heartbeat_sock.poll(3000))
chrisjbillington:             # Echo it back:
chrisjbillington:             self.heartbeat_sock.send(self.heartbeat_sock.recv())
chrisjbillington: 
chrisjbillington:     def test_subproc_dies_without_heartbeats(self):
chrisjbillington:         _default_process_tree.heartbeat_server = self.mock_heartbeat_server
chrisjbillington:         self.process = HeartbeatClientTestProcess()
chrisjbillington:         self.process.start()
chrisjbillington:         # Wait for a heartbeat request:
chrisjbillington:         self.assertTrue(self.heartbeat_sock.poll(3000))
chrisjbillington:         # Don't respond to it
chrisjbillington:         time.sleep(2)
chrisjbillington:         # Process should be dead:
chrisjbillington:         self.assertIsNot(self.process.child.poll(), None)
chrisjbillington: 
chrisjbillington:     def test_subproc_dies_on_incorrect_response(self):
chrisjbillington:         _default_process_tree.heartbeat_server = self.mock_heartbeat_server
chrisjbillington:         self.process = HeartbeatClientTestProcess()
chrisjbillington:         self.process.start()
chrisjbillington:         # Wait for a heartbeat request:
chrisjbillington:         self.assertTrue(self.heartbeat_sock.poll(3000))
chrisjbillington:         # Echo it back wrongly:
chrisjbillington:         self.heartbeat_sock.send(self.heartbeat_sock.recv() + b'wrong')
chrisjbillington:         time.sleep(1)
chrisjbillington:         # Process should be dead:
chrisjbillington:         self.assertIsNot(self.process.child.poll(), None)
chrisjbillington: 
chrisjbillington:     def test_subproc_survives_until_kill_lock_released(self):
chrisjbillington:         _default_process_tree.heartbeat_server = self.mock_heartbeat_server
chrisjbillington:         self.process = HeartbeatClientTestProcess()
chrisjbillington:         to_child, from_child = self.process.start()
chrisjbillington:         # Wait for a heartbeat request:
chrisjbillington:         self.assertTrue(self.heartbeat_sock.poll(3000))
chrisjbillington:         # Tell child to acquire kill lock for 3 sec:
chrisjbillington:         to_child.put(None)
chrisjbillington:         # Don't respond to the heartbeat, process should still be alive 2 sec later
chrisjbillington:         time.sleep(2)
chrisjbillington:         # Process should be alive:
chrisjbillington:         self.assertIs(self.process.child.poll(), None)
chrisjbillington:         # After kill lock released, child should be terminated:
chrisjbillington:         time.sleep(2)
chrisjbillington:         # Process should be dead:
chrisjbillington:         self.assertIsNot(self.process.child.poll(), None)
chrisjbillington: 
chrisjbillington:     def test_parent_correctly_responds_to_heartbeats(self):
chrisjbillington:         # No mock server this time, we're testing the real one:
chrisjbillington:         _default_process_tree.heartbeat_server = None
chrisjbillington:         self.process = HeartbeatServerTestProcess()
chrisjbillington:         to_child, from_child = self.process.start()
chrisjbillington:         to_child.put(_default_process_tree.heartbeat_server.port)
chrisjbillington:         self.assertTrue(from_child.sock.poll(1000))
chrisjbillington:         self.assertTrue(from_child.get())
chrisjbillington: 
chrisjbillington:     def tearDown(self):
chrisjbillington:         self.heartbeat_sock.close()
chrisjbillington:         try:
chrisjbillington:             self.process.terminate()
chrisjbillington:         except Exception:
chrisjbillington:             pass # already dead
chrisjbillington: 
chrisjbillington: class TestEventProcess(Process):
chrisjbillington:     def run(self):
chrisjbillington:         event = self.process_tree.event('hello', role='post')
chrisjbillington:         event.post('1', data=u'boo')
chrisjbillington:         time.sleep(0.1)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class EventTests(unittest.TestCase):
chrisjbillington:     def test_events(self):
chrisjbillington:         proc = TestEventProcess()
chrisjbillington:         event = _default_process_tree.event('hello', role='wait')
chrisjbillington:         proc.start()
chrisjbillington:         try:
chrisjbillington:             data = event.wait('1', timeout=1)
chrisjbillington:             self.assertEqual(data, u'boo')
chrisjbillington:         finally:
chrisjbillington:             proc.terminate()
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ClientServerTests(unittest.TestCase):
chrisjbillington: 
chrisjbillington:     def test_rep_server(self):
chrisjbillington:         class MyServer(ZMQServer):
chrisjbillington:             def handler(self, data):
chrisjbillington:                 if data == 'error':
chrisjbillington:                     raise TestError
chrisjbillington:                 return data
chrisjbillington: 
chrisjbillington:         server = MyServer(8000, bind_address='tcp://127.0.0.1')
chrisjbillington:         try:
chrisjbillington:             self.assertIsInstance(server.context, SecureContext)
chrisjbillington:             response = zmq_get(8000, data='hello!')
chrisjbillington:             self.assertEqual(response, 'hello!')
chrisjbillington: 
chrisjbillington:             # Ignore the exception in the other thread:
chrisjbillington:             clientserver.raise_exception_in_thread =  lambda *args: None
chrisjbillington:             try:
chrisjbillington:                 with self.assertRaises(TestError):
chrisjbillington:                     zmq_get(8000, data='error')
chrisjbillington:             finally:
chrisjbillington:                 clientserver.raise_exception_in_thread = raise_exception_in_thread
chrisjbillington:         finally:
chrisjbillington:             server.shutdown()
chrisjbillington: 
chrisjbillington:     def test_raw_server(self):
chrisjbillington:         class MyServer(ZMQServer):
chrisjbillington:             def handler(self, data):
chrisjbillington:                 if data == b'error':
chrisjbillington:                     raise TestError
chrisjbillington:                 return data
chrisjbillington: 
chrisjbillington:         for argname in ["dtype", "type", "positional"]:
chrisjbillington:             if argname == 'dtype':
chrisjbillington:                 server = MyServer(8000, dtype='raw',
chrisjbillington:                                   bind_address='tcp://127.0.0.1')
chrisjbillington:             elif argname == 'type':
chrisjbillington:                 server = MyServer(8000, type='raw',
chrisjbillington:                                   bind_address='tcp://127.0.0.1')
chrisjbillington:             elif argname == 'positional':
chrisjbillington:                 server = MyServer(8000, 'raw',
chrisjbillington:                                   bind_address='tcp://127.0.0.1')
chrisjbillington:             try:
chrisjbillington:                 self.assertIsInstance(server.context, SecureContext)
chrisjbillington:                 response = zmq_get_raw(8000, data=b'hello!')
chrisjbillington:                 self.assertEqual(response, b'hello!')
chrisjbillington: 
chrisjbillington:                 # Ignore the exception in the other thread:
chrisjbillington:                 clientserver.raise_exception_in_thread =  lambda *args: None
chrisjbillington:                 try:
chrisjbillington:                     self.assertIn(b'TestError', zmq_get_raw(8000, data=b'error'))
chrisjbillington:                 finally:
chrisjbillington:                     clientserver.raise_exception_in_thread = \
chrisjbillington:                         raise_exception_in_thread
chrisjbillington:             finally:
chrisjbillington:                 server.shutdown()
chrisjbillington: 
chrisjbillington:     def test_pull_server(self):
chrisjbillington: 
chrisjbillington:         testcase = self
chrisjbillington:         got_data = threading.Event()
chrisjbillington: 
chrisjbillington:         class MyPullServer(ZMQServer):
chrisjbillington:             def handler(self, data):
chrisjbillington:                 if data == 'error!':
chrisjbillington:                     return "not None!"
chrisjbillington:                 testcase.assertEqual(data, 'hello!')
chrisjbillington:                 got_data.set()
chrisjbillington: 
chrisjbillington:         server = MyPullServer(8000, bind_address='tcp://127.0.0.1',
chrisjbillington:                               pull_only=True)
chrisjbillington: 
chrisjbillington:         # So we can catch errors raised by raise_exception_in_thread
chrisjbillington: 
chrisjbillington:         try:
chrisjbillington:             self.assertIsInstance(server.context, SecureContext)
chrisjbillington:             response = zmq_push(8000, data='hello!')
chrisjbillington:             self.assertEqual(response, None)
chrisjbillington:             self.assertEqual(got_data.wait(timeout=1), True)
chrisjbillington:             got_data.clear()
chrisjbillington: 
chrisjbillington:             # Confirm you get an error when the handler returns something:
chrisjbillington:             got_error = threading.Event()
chrisjbillington:             class MockThread(object):
chrisjbillington:                 def __init__(self, target, args):
chrisjbillington:                     self.target = target
chrisjbillington:                     self.args = args
chrisjbillington:                 def start(self):
chrisjbillington:                     try:
chrisjbillington:                         self.target(*self.args)
chrisjbillington:                     except ValueError:
chrisjbillington:                         got_error.set()
chrisjbillington: 
chrisjbillington:             orig_thread = threading.Thread
chrisjbillington:             try:
chrisjbillington:                 threading.Thread = MockThread
chrisjbillington:                 response = zmq_push(8000, data='error!')
chrisjbillington:                 self.assertEqual(got_error.wait(timeout=1), True)
chrisjbillington:             finally:
chrisjbillington:                 threading.Thread = orig_thread
chrisjbillington: 
chrisjbillington:             # Confirm the server still works:
chrisjbillington:             response = zmq_push(8000, data='hello!')
chrisjbillington:             self.assertEqual(response, None)
chrisjbillington:             self.assertEqual(got_data.wait(timeout=1), True)
chrisjbillington:             got_data.clear()
chrisjbillington:         finally:
chrisjbillington:             server.shutdown()
chrisjbillington: 
chrisjbillington:     def test_customauth_backcompat(self):
chrisjbillington:         class MyCustomAuthServer(ZMQServer):
chrisjbillington:             def setup_auth(self, context):
chrisjbillington:                 pass
chrisjbillington: 
chrisjbillington:         server = MyCustomAuthServer(8000, bind_address='tcp://127.0.0.1')
chrisjbillington:         try:
chrisjbillington:             self.assertNotIsInstance(server.context, SecureContext)
chrisjbillington:         finally:
chrisjbillington:             server.shutdown()
chrisjbillington: 
chrisjbillington: if __name__ == '__main__':
chrisjbillington:     output = 'test-reports'
chrisjbillington:     if PY2:
chrisjbillington:         output = output.encode('utf8')
chrisjbillington:     unittest.main(verbosity=3,
chrisjbillington:                   testRunner=xmlrunner.XMLTestRunner(output=output, verbosity=3))
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __init__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Chris Billington                                  #
        cbilling: #                                                                   #
        cbilling: # This file is part of the zprocess project (see                    #
        cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
        cbilling: # the Simplified BSD License. See the license.txt file in the root  #
        cbilling: # of the project for the full license.                              #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: import os
        cbilling: import sys
        cbilling: import signal
chrisjbillington: 
chrisjbillington: PY2 = sys.version_info[0] == 2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
        pstarkey: import zmq
chrisjbillington: 
chrisjbillington: _path, _cwd = os.path.split(os.getcwd())
chrisjbillington: if _cwd == 'zprocess' and _path not in sys.path:
chrisjbillington:     # Running from within zprocess dir? Add to sys.path for testing during
chrisjbillington:     # development:
chrisjbillington:     sys.path.insert(0, _path)
        cbilling: 
        cbilling: try:
chrisjbillington:     from zprocess.__version__ import __version__
        cbilling: except ImportError:
        cbilling:     # Version file has not been autogenerated from build process:
        cbilling:     __version__ = None
        cbilling: 
chrisjbillington: # For communication between Python 2 and Python 3. Can be set by importing
chrisjbillington: # code to use a higher protocol in the case that it is known that both peers
chrisjbillington: # are a high enough version.
chrisjbillington: PICKLE_PROTOCOL = 2
chrisjbillington: 
chrisjbillington: if 'zprocess' in  os.getenv('COVERAGE_PROCESS_START', ''):
chrisjbillington:     # We're running with coverage.py, likely running the test suite. Add
chrisjbillington:     # sigterm handler so that atexit handlers run even when terminated and
chrisjbillington:     # coverage data is saved:
chrisjbillington:     def sigterm_handler(_signo, _stack_frame):
chrisjbillington:         raise SystemExit(0)
chrisjbillington:     signal.signal(signal.SIGTERM, sigterm_handler)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: from zprocess.utils import (TimeoutError, start_daemon, embed, 
chrisjbillington:                             raise_exception_in_thread)
chrisjbillington: 
chrisjbillington: from zprocess.clientserver import (ZMQServer, ZMQClient,
chrisjbillington:            zmq_get, zmq_get_multipart, zmq_get_string, zmq_get_raw,
chrisjbillington:            zmq_push, zmq_push_multipart, zmq_push_string, zmq_push_raw)
        cbilling: 
chrisjbillington: from zprocess.process_tree import (Process, ProcessTree,
chrisjbillington:                                   setup_connection_with_parent,
chrisjbillington:                                   subprocess_with_queues, Event)
        cbilling: 
        cbilling: 
           Chris: 
           Chris: 
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # clientserver.py                                                   #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013 - 2018, Chris Billington                           #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the zprocess project (see                    #
chrisjbillington: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
chrisjbillington: # the Simplified BSD License. See the license.txt file in the root  #
chrisjbillington: # of the project for the full license.                              #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: import threading
chrisjbillington: import time
chrisjbillington: import traceback
chrisjbillington: from functools import partial
chrisjbillington: from socket import gethostbyname
chrisjbillington: 
chrisjbillington: import zmq
chrisjbillington: 
chrisjbillington: _path, _cwd = os.path.split(os.getcwd())
chrisjbillington: if _cwd == 'zprocess' and _path not in sys.path:
chrisjbillington:     # Running from within zprocess dir? Add to sys.path for testing during
chrisjbillington:     # development:
chrisjbillington:     sys.path.insert(0, _path)
chrisjbillington: 
chrisjbillington: import zprocess
chrisjbillington: from zprocess.security import SecureContext
chrisjbillington: from zprocess.utils import raise_exception_in_thread, TimeoutError
chrisjbillington: 
chrisjbillington: PY2 = sys.version_info[0] == 2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def _typecheck_or_convert_data(data, dtype):
chrisjbillington:     """Utility function to check that messages are the valid type to be sent, for
chrisjbillington:     the dtype (one of 'pyobj', 'multipart', 'string', or 'raw'). Returns converted
chrisjbillington:     data or raises TypeError. Only conversion done is to wrap single bytes objects
chrisjbillington:     into a single-element list for multipart messages. We *do not* do auto encoding
chrisjbillington:     of strings here. Strings can't be sent by raw and multipart sends, so yes, they
chrisjbillington:     need to be encoded, but we can't to auto *decoding* on the other end, because
chrisjbillington:     the data may not represent text - it might just be bytes. So we prefer symmetry
chrisjbillington:     and so don't encode here."""
chrisjbillington:     # when not using python objects, a null message should be an empty string:
chrisjbillington:     if data is None and dtype in ['raw', 'multipart']:
chrisjbillington:         data = b''
chrisjbillington:     elif data is None and dtype == 'string':
chrisjbillington:         data = ''
chrisjbillington:     if dtype == 'multipart' and isinstance(data, bytes):
chrisjbillington:         # Wrap up a single string into a list so it doesn't get sent
chrisjbillington:         # as one character per message!
chrisjbillington:         data = [data]
chrisjbillington:     # Type error checking:
chrisjbillington:     if dtype == 'raw':
chrisjbillington:         if not isinstance(data, bytes):
chrisjbillington:             msg = 'raw sockets can only send bytes, not {}.'.format(type(data))
chrisjbillington:             raise TypeError(msg)
chrisjbillington:     elif dtype == 'string':
chrisjbillington:         if PY2 and isinstance(data, bytes):
chrisjbillington:             # Auto convert assuming UTF8:
chrisjbillington:             data = data.decode('utf8')
chrisjbillington:         if not isinstance(data, str):
chrisjbillington:             msg = ('string sockets can only send strings, ' +
chrisjbillington:                    'not {}.'.format(type(data)))
chrisjbillington:             raise TypeError(msg)
chrisjbillington:     elif dtype == 'multipart':
chrisjbillington:         if not all(isinstance(part, bytes) for part in data):
chrisjbillington:             msg = ('multipart sockets can only send an iterable of ' 
chrisjbillington:                    'bytes objects, not {}.'.format(type(data)))
chrisjbillington:             raise TypeError(msg)
chrisjbillington:     elif dtype != 'pyobj':
chrisjbillington:         msg = ("invalid dtype %s, " % str(dtype) + 
chrisjbillington:                "must be 'raw', 'string', 'multipart' or 'pyobj'")
chrisjbillington:         raise ValueError(msg)
chrisjbillington:     return data
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ZMQServer(object):
chrisjbillington:     """Wrapper around a zmq.REP or zmq.PULL socket"""
chrisjbillington:     def __init__(self, port, dtype='pyobj', pull_only=False, 
chrisjbillington:                  bind_address='tcp://127.0.0.1', shared_secret=None,
chrisjbillington:                  allow_insecure=False):
chrisjbillington:         self.port = port
chrisjbillington:         self.dtype = dtype
chrisjbillington:         self.pull_only = pull_only
chrisjbillington:         self.bind_address = bind_address
chrisjbillington: 
chrisjbillington:         if 'setup_auth' in self.__class__.__dict__:
chrisjbillington:             # Backward compatibility for subclasses implementing their own
chrisjbillington:             # authentication:
chrisjbillington:             self.context = zmq.Context()
chrisjbillington:             self.auth = self.setup_auth(self.context)
chrisjbillington:             if self.pull_only:
chrisjbillington:                 self.sock = self.context.socket(zmq.PULL)
chrisjbillington:             else:
chrisjbillington:                 self.sock = self.context.socket(zmq.REP)
chrisjbillington:         else:
chrisjbillington:             # Our shared secret authentication:
chrisjbillington:             self.context = SecureContext(shared_secret=shared_secret)
chrisjbillington:             if self.pull_only:
chrisjbillington:                 self.sock = self.context.socket(zmq.PULL,
chrisjbillington:                                                 allow_insecure=allow_insecure)
chrisjbillington:             else:
chrisjbillington:                 self.sock = self.context.socket(zmq.REP,
chrisjbillington:                                                 allow_insecure=allow_insecure)
chrisjbillington: 
chrisjbillington:         self.sock.setsockopt(zmq.LINGER, 0)
chrisjbillington: 
chrisjbillington:         self.sock.bind('%s:%s' % (str(self.bind_address), str(self.port)))
chrisjbillington: 
chrisjbillington:         if self.dtype == 'raw':
chrisjbillington:             self.send = self.sock.send
chrisjbillington:             self.recv = self.sock.recv
chrisjbillington:         elif self.dtype == 'string':
chrisjbillington:             self.send = self.sock.send_string
chrisjbillington:             self.recv = self.sock.recv_string
chrisjbillington:         elif self.dtype == 'multipart':
chrisjbillington:             self.send = self.sock.send_multipart
chrisjbillington:             self.recv = self.sock.recv_multipart
chrisjbillington:         elif self.dtype == 'pyobj':
chrisjbillington:             self.send = partial(self.sock.send_pyobj,
chrisjbillington:                                 protocol=zprocess.PICKLE_PROTOCOL)
chrisjbillington:             self.recv = self.sock.recv_pyobj
chrisjbillington:         else:
chrisjbillington:             msg = ("invalid dtype %s, must be 'raw', 'string', " +
chrisjbillington:                    "'multipart' or 'pyobj'" % str(self.dtype))
chrisjbillington:             raise ValueError(msg)
chrisjbillington:             
chrisjbillington:         self.mainloop_thread = threading.Thread(target=self.mainloop)
chrisjbillington:         self.mainloop_thread.daemon = True
chrisjbillington:         self.mainloop_thread.start()
chrisjbillington: 
chrisjbillington:     def setup_auth(self, context):
chrisjbillington:         """Deprecated. To be overridden by subclasses setting up their
chrisjbillington:         own authentication. If present in a subclass, this will be called
chrisjbillington:         and no shared secret authentication will be used."""
chrisjbillington:         pass
chrisjbillington: 
chrisjbillington:     def shutdown_on_interrupt(self):
chrisjbillington:         try:
chrisjbillington:             while True:
chrisjbillington:                 time.sleep(3600)
chrisjbillington:         except KeyboardInterrupt:
chrisjbillington:             sys.stderr.write('Interrupted, shutting down\n')
chrisjbillington:         finally:
chrisjbillington:             self.shutdown()
chrisjbillington:             
chrisjbillington:     def mainloop(self):
chrisjbillington:         while True:
chrisjbillington:             try:
chrisjbillington:                 request_data = self.recv()
chrisjbillington:             except zmq.ContextTerminated:
chrisjbillington:                 self.sock.close(linger=0)
chrisjbillington:                 return
chrisjbillington:             try:
chrisjbillington:                 response_data = self.handler(request_data)
chrisjbillington:                 if self.pull_only and response_data is not None:
chrisjbillington:                     msg = ("Pull-only server hander() method returned " +
chrisjbillington:                            "non-None value %s. Ignoring." % str(response_data))
chrisjbillington:                     raise ValueError(msg)
chrisjbillington:                 response_data = _typecheck_or_convert_data(response_data,
chrisjbillington:                                                            self.dtype)
chrisjbillington:             except Exception:
chrisjbillington:                 # Raise the exception in a separate thread so that the
chrisjbillington:                 # server keeps running:
chrisjbillington:                 exc_info = sys.exc_info()
chrisjbillington:                 raise_exception_in_thread(exc_info)
chrisjbillington:                 exception_string = traceback.format_exc()
chrisjbillington:                 if not self.pull_only:
chrisjbillington:                     # Send the error to the client:
chrisjbillington:                     msg = ("The server had an unhandled exception whilst " + 
chrisjbillington:                            "processing the request:\n%s" % str(exception_string))
chrisjbillington:                     response_data = exc_info[0](msg)
chrisjbillington:                     if self.dtype == 'raw':
chrisjbillington:                         response_data = str(response_data).encode('utf8')
chrisjbillington:                     elif self.dtype == 'multipart':
chrisjbillington:                         response_data = [str(response_data).encode('utf8')]
chrisjbillington:                     elif self.dtype == 'string':
chrisjbillington:                         response_data = str(response_data)
chrisjbillington:                     response_data = _typecheck_or_convert_data(response_data,
chrisjbillington:                                                                self.dtype)
chrisjbillington:             if not self.pull_only:
chrisjbillington:                 self.send(response_data)
chrisjbillington: 
chrisjbillington:     def shutdown(self):
chrisjbillington:         self.context.term()
chrisjbillington:         self.mainloop_thread.join()
chrisjbillington: 
chrisjbillington:     def handler(self, request_data):
chrisjbillington:         """To be overridden by subclasses. This is an example
chrisjbillington:         implementation"""
chrisjbillington:         response = ('This is an example ZMQServer. ' +
chrisjbillington:                     'Your request was %s.' % str(request_data))
chrisjbillington:         return response
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class _Sender(object):
chrisjbillington:     """Wrapper around a zmq.PUSH or zmq.REQ socket, returning a callable
chrisjbillington:     for sending (and optionally receiving data)"""
chrisjbillington:     def __init__(self, dtype='pyobj', push_only=False,
chrisjbillington:                  shared_secret=None, allow_insecure=False):
chrisjbillington:         self.local = threading.local()
chrisjbillington:         self.dtype = dtype
chrisjbillington:         self.push_only = push_only
chrisjbillington:         self.shared_secret = shared_secret
chrisjbillington:         self.allow_insecure = allow_insecure
chrisjbillington: 
chrisjbillington:     def new_socket(self, host, port):
chrisjbillington:         # Every time the REQ/REP cadence is broken, we need to create
chrisjbillington:         # and bind a new socket to get it back on track. Also, we have
chrisjbillington:         # a separate socket for each thread. Also a new socket if there
chrisjbillington:         # is a different host or port.
chrisjbillington:         self.local.host = gethostbyname(host)
chrisjbillington:         self.local.port = int(port)
chrisjbillington:         context = SecureContext.instance(shared_secret=self.shared_secret)
chrisjbillington:         if self.push_only:
chrisjbillington:             self.local.sock = context.socket(zmq.PUSH,
chrisjbillington:                                              allow_insecure=self.allow_insecure)
chrisjbillington:         else:
chrisjbillington:             self.local.sock = context.socket(zmq.REQ,
chrisjbillington:                                              allow_insecure=self.allow_insecure)
chrisjbillington:         # Allow up to 1 second to send unsent messages on socket shutdown:
chrisjbillington:         self.local.sock.setsockopt(zmq.LINGER, 1000)
chrisjbillington:         self.local.sock.connect('tcp://%s:%d' % (self.local.host, self.local.port))
chrisjbillington:         # Different send/recv methods depending on the desired protocol:
chrisjbillington:         if self.dtype == 'raw':
chrisjbillington:             self.local.send = self.local.sock.send
chrisjbillington:             self.local.recv = self.local.sock.recv
chrisjbillington:         elif self.dtype == 'string':
chrisjbillington:             self.local.send = self.local.sock.send_string
chrisjbillington:             self.local.recv = self.local.sock.recv_string
chrisjbillington:         elif self.dtype == 'multipart':
chrisjbillington:             self.local.send = self.local.sock.send_multipart
chrisjbillington:             self.local.recv = self.local.sock.recv_multipart
chrisjbillington:         elif self.dtype == 'pyobj':
chrisjbillington:             self.local.send = partial(self.local.sock.send_pyobj,
chrisjbillington:                                       protocol=zprocess.PICKLE_PROTOCOL)
chrisjbillington:             self.local.recv = self.local.sock.recv_pyobj
chrisjbillington:         else:
chrisjbillington:             msg = ("invalid dtype %s, must be 'raw', 'string', " +
chrisjbillington:                    "'multipart' or 'pyobj'" % str(self.dtype))
chrisjbillington:             raise ValueError(msg)
chrisjbillington: 
chrisjbillington:     def __call__(self, port, host='127.0.0.1', data=None, timeout=5):
chrisjbillington:         """If self.push_only, send data on the push socket, ignoring timeout.
chrisjbillington:         Otherwise, uses reliable request-reply to send data to a zmq REP
chrisjbillington:         socket, and return the reply"""
chrisjbillington:         # We cache the socket so as to not exhaust ourselves of tcp
chrisjbillington:         # ports. However if a different server is in use, we need a new
chrisjbillington:         # socket. Also if we don't have a socket, we also need a new one:
chrisjbillington:         if (not hasattr(self.local, 'sock')
chrisjbillington:                 or gethostbyname(host) != self.local.host
chrisjbillington:                 or int(port) != self.local.port):
chrisjbillington:             self.new_socket(host, port)
chrisjbillington:         data = _typecheck_or_convert_data(data, self.dtype)
chrisjbillington:         try:
chrisjbillington:             self.local.send(data, zmq.NOBLOCK)
chrisjbillington:             if self.push_only:
chrisjbillington:                 return
chrisjbillington:             events = self.local.sock.poll(timeout * 1000, flags=zmq.POLLIN)
chrisjbillington:             if events:
chrisjbillington:                 response = self.local.recv()
chrisjbillington:             else:
chrisjbillington:                 # The server hasn't replied. We don't know what it's doing, so
chrisjbillington:                 # we'd better stop using this socket in case late messages
chrisjbillington:                 # arrive on it in the future:
chrisjbillington:                 raise TimeoutError('No response from server: timed out')
chrisjbillington:             if isinstance(response, Exception):
chrisjbillington:                 raise response
chrisjbillington:             else:
chrisjbillington:                 return response
chrisjbillington:         except:
chrisjbillington:             # Any exceptions, we want to stop using this socket:
chrisjbillington:             self.local.sock.close(linger=0)
chrisjbillington:             del self.local.sock
chrisjbillington:             raise
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ZMQClient(object):
chrisjbillington:     """Wrapper around zmq REQ or PUSH socket"""
chrisjbillington:     def __init__(self, shared_secret=None, allow_insecure=False):
chrisjbillington:         self.shared_secret = shared_secret
chrisjbillington:         self.allow_insecure = allow_insecure
chrisjbillington:         kwargs = {'shared_secret': shared_secret, 
chrisjbillington:                   'allow_insecure': allow_insecure}
chrisjbillington: 
chrisjbillington:         self.get = _Sender('pyobj', **kwargs)
chrisjbillington:         self.get_multipart = _Sender('multipart', **kwargs)
chrisjbillington:         self.get_string = _Sender('string', **kwargs)
chrisjbillington:         self.get_raw = _Sender('raw', **kwargs)
chrisjbillington:         self.push = _Sender('pyobj', push_only=True, **kwargs)
chrisjbillington:         self.push_multipart = _Sender('multipart', push_only=True, **kwargs)
chrisjbillington:         self.push_raw = _Sender('raw', push_only=True, **kwargs)
chrisjbillington:         self.push_string = _Sender('string', push_only=True, **kwargs)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # Backwards compatability follows:
chrisjbillington: 
chrisjbillington: # Default to on all interfaces and allow insecure connections.
chrisjbillington: _ZMQServer = ZMQServer
chrisjbillington: class ZMQServer(_ZMQServer):
chrisjbillington:     """Wrapper around a zmq.REP or zmq.PULL socket"""
chrisjbillington:     def __init__(self, port, dtype=None, pull_only=False, 
chrisjbillington:                  bind_address='tcp://0.0.0.0', shared_secret=None,
chrisjbillington:                  allow_insecure=True, **kwargs):
chrisjbillington:         # Allow old kwarg "type" instead of "dtype":
chrisjbillington:         if 'type' in kwargs:
chrisjbillington:             dtype = kwargs.pop('type')
chrisjbillington:             if kwargs:
chrisjbillington:                 raise ValueError('too many keyword arguments')
chrisjbillington:         elif dtype is None:
chrisjbillington:             dtype = 'pyobj'
chrisjbillington:         _ZMQServer.__init__(self, port, dtype=dtype, pull_only=pull_only,
chrisjbillington:                             bind_address=bind_address,
chrisjbillington:                             shared_secret=shared_secret,
chrisjbillington:                             allow_insecure=allow_insecure)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # methods for a default insecure client
chrisjbillington: _default_client = ZMQClient(allow_insecure=True)
chrisjbillington: 
chrisjbillington: zmq_get = _default_client.get
chrisjbillington: zmq_get_multipart = _default_client.get_multipart
chrisjbillington: zmq_get_string = _default_client.get_string
chrisjbillington: zmq_get_raw = _default_client.get_raw
chrisjbillington: zmq_push = _default_client.push
chrisjbillington: zmq_push_multipart = _default_client.push_multipart
chrisjbillington: zmq_push_string = _default_client.push_string
chrisjbillington: zmq_push_raw = _default_client.push_raw
chrisjbillington: 
chrisjbillington: 
chrisjbillington: __all__ = ['ZMQServer', 'ZMQClient',
chrisjbillington:            'zmq_get', 'zmq_get_multipart', 'zmq_get_string', 'zmq_get_raw',
chrisjbillington:            'zmq_push', 'zmq_push_multipart', 'zmq_push_string', 'zmq_push_raw']
chrisjbillington: 
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # example_client.py                                                 #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Chris Billington                                  #
cbilling: #                                                                   #
cbilling: # This file is part of the zprocess project (see                    #
cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
cbilling: # the Simplified BSD License. See the license.txt file in the root  #
cbilling: # of the project for the full license.                              #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
pstarkey: from __future__ import print_function
cbilling: from zprocess import setup_connection_with_parent, Event
cbilling: 
cbilling: to_parent, from_parent = setup_connection_with_parent()
cbilling: 
cbilling: # The normal kind of getting data from the parent directly:
cbilling: item = from_parent.get()
pstarkey: print('client: got an item: '+ str(item))
pstarkey: print('client: sending the item back...')
cbilling: to_parent.put(item)
cbilling: 
cbilling: # Waiting for an event posted by the parent (though it could be posted by any process, we don't care):
cbilling: foo_event = Event('foo',type='wait')
cbilling: for i in range(10):
cbilling:     data = foo_event.wait(i, timeout=1)
pstarkey:     print('client: received foo event %d. Data was: %s'%(i, str(data)))
cbilling:     
cbilling: import time
cbilling: # To prove that this process gets killed when its parent ends:
cbilling: time.sleep(1000)
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # example_server.py                                                 #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Chris Billington                                  #
cbilling: #                                                                   #
cbilling: # This file is part of the zprocess project (see                    #
cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
cbilling: # the Simplified BSD License. See the license.txt file in the root  #
cbilling: # of the project for the full license.                              #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
pstarkey: from __future__ import print_function
cbilling: from zprocess import subprocess_with_queues, Event
cbilling: import time
cbilling: 
cbilling: to_child, from_child, child = subprocess_with_queues('example_client.py')
cbilling: 
cbilling: # The normal kind of directly passing data to the child:
  rander: to_child.put(['<Some item!>','<some data!>'])
pstarkey: print('server: got the item back: ', from_child.get())
cbilling: 
cbilling: # Posting an event that all processes in the tree can see (if there were more processes, of course):
cbilling: foo_event = Event('foo',type='post')
cbilling: 
cbilling: for i in range(10):
cbilling:     time.sleep(0.5)
pstarkey:     print('server: posting a foo event with id=%d'%i)
cbilling:     foo_event.post(i, data='hello!')
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # processclass_example.py                                           #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Chris Billington                                  #
cbilling: #                                                                   #
cbilling: # This file is part of the zprocess project (see                    #
cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
cbilling: # the Simplified BSD License. See the license.txt file in the root  #
cbilling: # of the project for the full license.                              #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
pstarkey: from __future__ import print_function
cbilling: from zprocess import Process
cbilling: import os
cbilling: 
cbilling: class Foo(Process):
cbilling:     def run(self, data):
pstarkey:         print('this is a running foo in process', os.getpid())
pstarkey:         print('data is', data)
cbilling:         message = self.from_parent.get()
pstarkey:         print('foo, got a message:', message)
cbilling:         self.to_parent.put('hello yourself!')
cbilling: 
cbilling: # This __main__ check is important to stop the same code executing again in the child:
cbilling: if __name__ == '__main__':
cbilling:     foo = Foo()
cbilling:     to_child, from_child = foo.start('bar')
cbilling:     to_child.put('hello, foo!')
cbilling:     response = from_child.get()
pstarkey:     print('parent, got a response:', response)
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __init__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Chris Billington                                  #
        cbilling: #                                                                   #
        cbilling: # This file is part of the zprocess project (see                    #
        cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
        cbilling: # the Simplified BSD License. See the license.txt file in the root  #
        cbilling: # of the project for the full license.                              #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: 
chrisjbillington: import sys
        cbilling: import os
        cbilling: import socket
        cbilling: import threading
        cbilling: import time
        cbilling: import weakref
chrisjbillington: PY2 = sys.version_info.major == 2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
        cbilling: import zmq
        cbilling: 
        cbilling: DEFAULT_TIMEOUT = 30 # seconds
        cbilling: DEFAULT_PORT = 7339
        cbilling: 
        cbilling: process_identifier_prefix = ''
        cbilling: thread_identifier_prefix = threading.local()
        cbilling: 
        cbilling: 
        cbilling: def name_change_checks():
        cbilling:     if Lock.instances:
        cbilling:         raise RuntimeError('Cannot change process/thread name while Locks are in use.' +
        cbilling:                            'Please change names before instantiating Lock objects.')
        cbilling:     if '_zmq_lock_client' in globals():
        cbilling:         # Clear thread local data so that the client id is re-generated in all threads:
        cbilling:         _zmq_lock_client.local = threading.local()
        cbilling:                 
        cbilling:                 
        cbilling: def set_client_process_name(name):
        cbilling:     global process_identifier_prefix
        cbilling:     name_change_checks()
        cbilling:     process_identifier_prefix = name + '-'
        cbilling:         
        cbilling:         
        cbilling: def set_client_thread_name(name):
        cbilling:     name_change_checks()
        cbilling:     thread_identifier_prefix.prefix = name + '-'
        cbilling:     
        cbilling:     
        cbilling: def get_client_id():
        cbilling:     try:
        cbilling:         prefix = thread_identifier_prefix.prefix
        cbilling:     except AttributeError:
        cbilling:         prefix = thread_identifier_prefix.prefix = ''
        cbilling:     thread_identifier = prefix + threading.current_thread().name
        cbilling:     process_identifier = process_identifier_prefix + str(os.getpid())
        cbilling:     host_name = socket.gethostname()
        cbilling:     return ':'.join([host_name, process_identifier,thread_identifier])
        cbilling: 
        pstarkey: 
chrisjbillington: def _typecheck_or_convert_key(key):
chrisjbillington:     """Checks that key is bytes or string and encodes to bytes with utf8.
chrisjbillington:     Raises TypeError if it's neither. If data is bytes, checks that it is utf8
chrisjbillington:     encoded and raises ValueError if not."""
chrisjbillington: 
chrisjbillington:     msg = "Key must be a string or bytes, if bytes, must be utf-8 encoded"
chrisjbillington:     # Decode to ensure that if it's python2 str or python3 bytes that is
chrisjbillington:     # is in fact utf8 encoded:
           Chris:     if isinstance(key, bytes):
chrisjbillington:         try:
chrisjbillington:             key.decode('utf8')
chrisjbillington:         except UnicodeDecodeError:
chrisjbillington:             raise ValueError(msg)
chrisjbillington:     elif isinstance(key, str):
chrisjbillington:         key = key.encode('utf8')
chrisjbillington:     else:
chrisjbillington:         raise TypeError(msg)
chrisjbillington:     return key
chrisjbillington: 
chrisjbillington: 
        cbilling: class ZMQLockClient(object):
        cbilling: 
        cbilling:     RESPONSE_TIMEOUT = 5000
        cbilling:     
        cbilling:     def __init__(self, host, port):
        cbilling:         self.host = socket.gethostbyname(host)
        cbilling:         self.port = port
        cbilling:         self.lock = threading.Lock()
        cbilling:         # We'll store one zmq socket/poller for each thread, with thread
        cbilling:         # local storage:
        cbilling:         self.local = threading.local()
        cbilling:         self.shutdown_complete = threading.Event()
        cbilling:          
        cbilling:     def new_socket(self):
        cbilling:         # Every time the REQ/REP cadence is broken, we need to create
        cbilling:         # and bind a new socket to get it back on track. Also, we have
        cbilling:         # a separate socket for each thread:
        cbilling:         context = zmq.Context.instance()
        cbilling:         self.local.sock = context.socket(zmq.REQ)
        cbilling:         self.local.sock.setsockopt(zmq.LINGER, 0)
        cbilling:         self.local.poller = zmq.Poller()
        cbilling:         self.local.poller.register(self.local.sock, zmq.POLLIN)
        cbilling:         self.local.sock.connect('tcp://%s:%s'%(self.host, str(self.port)))    
        cbilling:         self.local.client_id = get_client_id()
        cbilling:         
        cbilling:     def say_hello(self,timeout=None):
        cbilling:         """Ping the server to test for a response"""
        cbilling:         try:
        cbilling:             if timeout is None:
        cbilling:                 timeout = self.RESPONSE_TIMEOUT
        cbilling:             else:
        cbilling:                 timeout = 1000*timeout # convert to ms
        cbilling:             if not hasattr(self.local,'sock'):
        cbilling:                 self.new_socket()
        cbilling:             start_time = time.time()
chrisjbillington:             self.local.sock.send(b'hello', zmq.NOBLOCK)
        cbilling:             events = self.local.poller.poll(timeout)
        cbilling:             if events:
chrisjbillington:                 response = self.local.sock.recv().decode('utf8')
        cbilling:                 if response == 'hello':
        cbilling:                     return round((time.time() - start_time)*1000,2)
           Chris:                 raise zmq.ZMQError('Invalid repsonse from server: ' + response)
        cbilling:             raise zmq.ZMQError('No response from zlock server: timed out')
        cbilling:         except:
        cbilling:             self.local.sock.close(linger=False)
        cbilling:             del self.local.sock
        cbilling:             raise
        cbilling:     
        cbilling:     def status(self):
        cbilling:         try:
        cbilling:             if not hasattr(self.local,'sock'):
        cbilling:                 self.new_socket()
chrisjbillington:             self.local.sock.send(b'status', zmq.NOBLOCK)
        cbilling:             events = self.local.poller.poll(self.RESPONSE_TIMEOUT)
        cbilling:             if events:
chrisjbillington:                 response = self.local.sock.recv().decode('utf8')
        cbilling:                 if response.startswith('ok'):
        cbilling:                     return response
        cbilling:                 raise zmq.ZMQError(response)
        cbilling:             raise zmq.ZMQError('No response from zlock server: timed out')
        cbilling:         except:
        cbilling:             self.local.sock.close(linger=False)
        cbilling:             del self.local.sock
        cbilling:             raise
        cbilling:             
        cbilling:     def clear(self, clear_all):
        cbilling:         try:
chrisjbillington:             if not hasattr(self.local, 'sock'):
        cbilling:                 self.new_socket()
chrisjbillington:             self.local.sock.send_multipart([b'clear', str(clear_all)], zmq.NOBLOCK)
        cbilling:             events = self.local.poller.poll(self.RESPONSE_TIMEOUT)
        cbilling:             if events:
chrisjbillington:                 response = self.local.sock.recv().decode('utf8')
        cbilling:                 if response == 'ok':
        cbilling:                     return
        cbilling:                 raise zmq.ZMQError(response)
        cbilling:             raise zmq.ZMQError('No response from zlock server: timed out')
        cbilling:         except:
        cbilling:             self.local.sock.close(linger=False)
        cbilling:             del self.local.sock
        cbilling:             raise
        cbilling:             
        cbilling:     def acquire(self, key, timeout=None):
chrisjbillington:         key = _typecheck_or_convert_key(key)
        cbilling:         if timeout is None:
        cbilling:             timeout = DEFAULT_TIMEOUT
chrisjbillington:         if not hasattr(self.local, 'sock'):
        cbilling:             self.new_socket()
        cbilling:         try:
        cbilling:             while True:
chrisjbillington:                 messages = (b'acquire', key, self.local.client_id.encode('utf8'), str(timeout).encode('utf8'))
        cbilling:                 self.local.sock.send_multipart(messages, zmq.NOBLOCK)
        cbilling:                 events = self.local.poller.poll(self.RESPONSE_TIMEOUT)
        cbilling:                 if not events:
        cbilling:                     raise zmq.ZMQError('No response from zlock server: timed out')
chrisjbillington:                 response = self.local.sock.recv().decode('utf8')
        cbilling:                 if response == 'ok':
        cbilling:                     break
        cbilling:                 elif response == 'retry':
        cbilling:                     continue
        cbilling:                 raise zmq.ZMQError(response)
        cbilling:         except: 
chrisjbillington:             if hasattr(self.local, 'sock'):
        cbilling:                 self.local.sock.close(linger=False)
        cbilling:                 del self.local.sock
        cbilling:             raise
        cbilling:         
        cbilling:     def release(self, key, client_id):
chrisjbillington:         key = _typecheck_or_convert_key(key)
        cbilling:         if not hasattr(self.local,'sock'):
        cbilling:             self.new_socket()
        cbilling:         try:
        cbilling:             if client_id is None:
        cbilling:                 client_id = self.local.client_id
chrisjbillington:             messages = (b'release', key, client_id.encode('utf8'))
        cbilling:             self.local.sock.send_multipart(messages)
        cbilling:             events = self.local.poller.poll(self.RESPONSE_TIMEOUT)
        cbilling:             if not events:
        cbilling:                 raise zmq.ZMQError('No response from zlock server: timed out')
chrisjbillington:             response = self.local.sock.recv().decode('utf8')
        cbilling:             if response == 'ok':
        cbilling:                 return
        cbilling:             raise zmq.ZMQError(response)
        cbilling:         except:
chrisjbillington:             if hasattr(self.local, 'sock'):
        cbilling:                 self.local.sock.close(linger=False)
        cbilling:                 del self.local.sock
        cbilling:             raise
        cbilling:     
        cbilling:     
        cbilling: class Lock(object):
        cbilling: 
        cbilling:     instances = weakref.WeakValueDictionary()
        cbilling:     class_lock = threading.Lock()
        cbilling:     
        cbilling:     def __new__(cls, key, *args, **kwargs):
        cbilling:         with cls.class_lock:
        cbilling:             try:
        cbilling:                 instance = cls.instances[key]
        cbilling:             except KeyError:
        cbilling:                 instance = object.__new__(cls)
        cbilling:                 cls.instances[key] = instance
        cbilling:             return instance
        cbilling:             
        cbilling:     def __init__(self, key):
        cbilling:         with self.class_lock:
chrisjbillington:             if not hasattr(self, 'key'):
        cbilling:                 self.key = key
        cbilling:                 self.local_lock = threading.RLock()
        cbilling:                 self.recursion_level=0
        cbilling:                 try:
        cbilling:                     _zmq_lock_client
        cbilling:                 except NameError:
        cbilling:                     raise RuntimeError('Not connected to a zlock server')
        cbilling:         
        cbilling:     def acquire(self, timeout=None):
        cbilling:         self.local_lock.acquire()
        cbilling:         self.recursion_level += 1
        cbilling:         if self.recursion_level==1:
        cbilling:             try:
        cbilling:                 acquire(self.key, timeout)
        cbilling:             except:
        cbilling:                 self.recursion_level -= 1
        cbilling:                 self.local_lock.release()
        cbilling:                 raise
        cbilling:             
        cbilling:     def release(self):
        cbilling:         if self.recursion_level==0:
        cbilling:             raise RuntimeError('cannot release un-acquired lock')
        cbilling:         try:
        cbilling:             if self.recursion_level==1:
        cbilling:                 release(self.key)
        cbilling:         finally:
        cbilling:             # Always release the local lock, even if we failed to release
        cbilling:             # the network lock:
        cbilling:             self.recursion_level -= 1
        cbilling:             self.local_lock.release()
        cbilling:         
        cbilling:     def __enter__(self):
        cbilling:         self.acquire()
        cbilling:         
        cbilling:     def __exit__(self, type, value, traceback):
        cbilling:         self.release()
        cbilling:         
        cbilling:         
        cbilling: class NetworkOnlyLock(object):
        cbilling: 
        cbilling:     instances = weakref.WeakValueDictionary()
        cbilling:     class_lock = threading.Lock()
        cbilling:     
        cbilling:     def __new__(cls, key, *args, **kwargs):
        cbilling:         with cls.class_lock:
        cbilling:             try:
        cbilling:                 instance = cls.instances[key]
        cbilling:             except KeyError:
        cbilling:                 instance = object.__new__(cls)
        cbilling:                 cls.instances[key] = instance
        cbilling:             return instance
        cbilling:             
        cbilling:     def __init__(self, key):
        cbilling:         with self.class_lock:
        cbilling:             if not hasattr(self,'key'):
        cbilling:                 self.key = key
        cbilling:                 # Get the Lock for this key:
        cbilling:                 self.lock = Lock(key)
        cbilling:         
        cbilling:     def acquire(self, timeout=None):
        cbilling:         with self.lock.local_lock:
        cbilling:             acquire(self.key, timeout)
        cbilling:             self.lock.recursion_level += 1
        cbilling:             
        cbilling:     def release(self):
        cbilling:         with self.lock.local_lock:
        cbilling:             if self.lock.recursion_level != 1:
        cbilling:                 raise RuntimeError('cannot release network lock whilst local locks still held')
        cbilling:             try:
        cbilling:                 release(self.key)
        cbilling:             finally:
        cbilling:                 self.lock.recursion_level = 0
        cbilling:         
        cbilling:     def __enter__(self):
        cbilling:         self.acquire()
        cbilling:         
        cbilling:     def __exit__(self, type, value, traceback):
        cbilling:         self.release()
        cbilling: 
        cbilling: 
        cbilling: def acquire(key, timeout=None):
        cbilling:     """Acquire a lock identified by key, for a specified time in
        cbilling:     seconds. Blocks until success, raises exception if the server isn't
        cbilling:     responding"""
        cbilling:     try:
        cbilling:         _zmq_lock_client
        cbilling:     except NameError:
        cbilling:         raise RuntimeError('Not connected to a zlock server')
        cbilling:     else:
        cbilling:         _zmq_lock_client.acquire(key, timeout)
        cbilling:         
        cbilling:         
        cbilling: def release(key, client_id=None):
        cbilling:     """Release the lock identified by key. Raises an exception if the
        cbilling:     lock was not held, or was held by someone else, or if the server
        cbilling:     isn't responding. If client_id is provided, one thread can release
        cbilling:     the lock on behalf of another, but this should not be the normal
        cbilling:     usage."""
        cbilling:     try:
        cbilling:         _zmq_lock_client
        cbilling:     except NameError:
        cbilling:         raise RuntimeError('Not connected to a zlock server')
        cbilling:     else:
        cbilling:         _zmq_lock_client.release(key, client_id)
        cbilling:      
        cbilling:      
        cbilling: def ping(timeout=None):
        cbilling:     try:
        cbilling:         _zmq_lock_client
        cbilling:     except NameError:
        cbilling:         raise RuntimeError('Not connected to a zlock server')
        cbilling:     else:
        cbilling:         return _zmq_lock_client.say_hello(timeout)
        cbilling:     
        cbilling:     
        cbilling: def status():
        cbilling:     try:
        cbilling:         _zmq_lock_client
        cbilling:     except NameError:
        cbilling:         raise RuntimeError('Not connected to a zlock server')
        cbilling:     else:
        cbilling:         return _zmq_lock_client.status()
        cbilling:       
        cbilling:       
        cbilling: def clear(clear_all):
        cbilling:     try:
        cbilling:         _zmq_lock_client
        cbilling:     except NameError:
        cbilling:         raise RuntimeError('Not connected to a zlock server')
        cbilling:     else:
        cbilling:         return _zmq_lock_client.clear(clear_all)
        cbilling:        
        cbilling:        
        cbilling: def set_default_timeout(t):
        cbilling:     """Sets how long the locks should be acquired for before the server
        cbilling:     times them out and allows other clients to acquire them. Attempting
        cbilling:     to release them will then result in an exception."""
        cbilling:     global DEFAULT_TIMEOUT
        cbilling:     DEFAULT_TIMEOUT = t
        cbilling: 
        cbilling:     
        cbilling: def connect(host='localhost', port=DEFAULT_PORT, timeout=None):
        cbilling:     """This method should be called at program startup, it establishes
        cbilling:     communication with the server and ensures it is responding"""
        cbilling:     global _zmq_lock_client
        cbilling:     _zmq_lock_client = ZMQLockClient(host, port)
        cbilling:     # We ping twice since the first does initialisation and so takes
        cbilling:     # longer. The second will be more accurate:
        cbilling:     ping(timeout)
        cbilling:     return ping(timeout)
        cbilling: 
        cbilling:     
        cbilling: if __name__ == '__main__':
        cbilling:     # test:
        cbilling:     connect()
        cbilling:     with Lock('test'):
chrisjbillington:         print('with lock')
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __main__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Chris Billington                                  #
        cbilling: #                                                                   #
        cbilling: # This file is part of the zprocess project (see                    #
        cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
        cbilling: # the Simplified BSD License. See the license.txt file in the root  #
        cbilling: # of the project for the full license.                              #
        cbilling: #                                                                   #
        cbilling: #####################################################################
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: import os
        cbilling: import sys
        cbilling: import traceback
        cbilling: import time
        cbilling: import logging, logging.handlers
        cbilling: import random
        cbilling: 
        cbilling: import zmq
        cbilling: 
        cbilling: import zprocess.locking as zlock
        cbilling: 
        cbilling: 
        cbilling: MAX_RESPONSE_TIME = 1 # sec
        cbilling: LOGGING = True
           Chris: DEBUG = False
        cbilling: 
        cbilling: # Protocol description:
        cbilling: #
chrisjbillington: # Clients make requests as multipart zmq messages of utf-8 encoded
chrisjbillington: # bytestrings. To acquire a lock, the request should be:
        cbilling: #
        cbilling: # ['acquire', some_lock_key, client_id, timeout]
        cbilling: #
chrisjbillington: # where some_lock_key is a string uniquely identifying the resource that is
chrisjbillington: # being locked, client id is a string uniquely identifying who is acquiring
chrisjbillington: # the lock, and timeout is (a string representation of) how long (in seconds)
chrisjbillington: # the lock should be held for in the event that it is not released, say if the
chrisjbillington: # client process dies. So for example a request to lock access to a file might
chrisjbillington: # be:
        cbilling: #
        cbilling: # ['acquire', 'Z:\\some_folder\some_file.h5', 'hostname:process_id:thread-id', '30']
        cbilling: #
        cbilling: # The server will then block for up to MAX_RESPONSE_TIME attempting to
        cbilling: # acquire the lock (it continues to serve other requests in this time,
        cbilling: # some of which may release the lock), and responds as soon as it can
        cbilling: # (immediately if the lock is currently free).  If it succeeds it will
        cbilling: # respond with a single zmq message:
        cbilling: #
        cbilling: # ['ok']
        cbilling: #
        cbilling: # If it can't acquire it after MAX_RESPONSE_TIME, it will instead
        cbilling: # respond with:
        cbilling: #
        cbilling: # ['retry']
        cbilling: #
        cbilling: # The client is free to retry immediately at that point, if it is going
        cbilling: # to retry there is no need to insert a delay before doing so. Not having
        cbilling: # a delay will not create tons of network activity as this only happens
        cbilling: # once every MAX_RESPONSE_TIME in the case of ongoing lock contention.
chrisjbillington: #
        cbilling: #
        cbilling: # Anything else the server replies with will be a single zmq message
        cbilling: # and should be considered an error and raised in the client code. This
        cbilling: # will occur if the client provides the wrong number of messages, if it
        cbilling: # spells 'acquire' wrong or similar, or if there is an exception in the
        cbilling: # server due to a bug in the server itself. If you see a server crash,
        cbilling: # please tell me (chrisjbillington@gmail.com) about it.
        cbilling: #
        cbilling: # To release a lock, send a three-part multipart message:
        cbilling: #
        cbilling: # ['release', some_lock_key, client_id]
        cbilling: #
        cbilling: # so for example:
        cbilling: #
        cbilling: # ['release', 'Z:\\some_folder\some_file.h5', 'hostname:process_id:thread-id']
        cbilling: #
        cbilling: # The server will respond with:
        cbilling: #
        cbilling: # ['ok']
        cbilling: #
        cbilling: # And again anything else (always a single message though) indicates an
        cbilling: # exception, perhaps inicating that the client releasing the lock never
        cbilling: # held it in the first place, or that it had expired.
        cbilling: #
        cbilling: # You can also send ['hello'], and the server will respond with ['hello']
        cbilling: # to show that it is alive and working. Or you can send ['status'],
        cbilling: # and the server will respond with a message with information about
        cbilling: # currently held locks.
        cbilling: 
        cbilling: def setup_logging():
           Chris: 
           Chris:     if DEBUG:
           Chris:         loglevel = logging.DEBUG
           Chris:     else:
           Chris:         loglevel = logging.INFO
        cbilling:     logger = logging.getLogger('ZLock')
           Chris:     logger.setLevel(loglevel)
        cbilling:     formatter = logging.Formatter('[%(asctime)s] %(levelname)s %(message)s')
     janwerkmann:     if sys.stdout is not None and sys.stdout.isatty():
        cbilling:         terminalhandler = logging.StreamHandler(sys.stdout)
        cbilling:         terminalhandler.setFormatter(formatter)
           Chris:         terminalhandler.setLevel(loglevel)
        cbilling:         logger.addHandler(terminalhandler)
        cbilling:     else:
        cbilling:         # Prevent bug on windows where writing to stdout without a command
        cbilling:         # window causes a crash:
        cbilling:         sys.stdout = sys.stderr = open(os.devnull,'w')
        cbilling:     if os.name == 'nt':
        cbilling:         path = os.path.join(os.path.dirname(os.path.abspath(__file__)),'zlock.log')
        cbilling:     else:
        cbilling:         path = '/var/log/zlock.log'
        cbilling:     try:
           Chris:         handler = logging.handlers.RotatingFileHandler(path, maxBytes=1024*1024*50, backupCount=1)
        cbilling:         handler.setFormatter(formatter)
           Chris:         handler.setLevel(loglevel)
        cbilling:         logger.addHandler(handler)
        cbilling:     except IOError:
        cbilling:         logger.warning('Can\'t open or do not have permission to write to log file %s. '%path + 
        cbilling:                        'Only terminal logging will be output.')
        cbilling:     return logger
        cbilling: 
        cbilling: 
        cbilling: class ZMQLockServer(object):
        cbilling:     
        cbilling:     def __init__(self, port):
        cbilling:         self.port = int(port)
        cbilling:         
        cbilling:         # A dictionary of locks currently held by clients:
        cbilling:         self.held_locks = {}
        cbilling:         
        cbilling:         # We use a ROUTER instead of a REP socket so that we can delay
        cbilling:         # replying to some requests until after other requests have
        cbilling:         # been processed. This is useful in the case of lock contention:
        cbilling:         # instead of replying saying 'sorry, the lock is already held', we
        cbilling:         # can instead wait until some other requests have been processed
        cbilling:         # (which may release the lock) before replying. Then the client
        cbilling:         # doesn't have to wait in between polls, the waiting happens on
        cbilling:         # the server.
        cbilling: 
chrisjbillington:         self.context = zmq.Context.instance()
chrisjbillington:         self.router = self.context.socket(zmq.ROUTER)
        cbilling:         self.poller = zmq.Poller()
        cbilling:         self.poller.register(self.router, zmq.POLLIN)
        cbilling:         
        cbilling:         # Bind the router to the outside world:
        cbilling:         self.router.bind('tcp://0.0.0.0:%d'%self.port)
        cbilling:         
        cbilling:         self.handlers = {'hello': self.hello, 
        cbilling:                          'acquire': self.acquire,
        cbilling:                          'release': self.release,
        cbilling:                          'status': self.status,
        cbilling:                          'clear': self.clear}
        cbilling:         
        cbilling:     def hello(self):
        cbilling:         if LOGGING: logger.info('someone said hello')
        cbilling:         return 'hello'
        cbilling:             
        cbilling:     def acquire(self, key, client_id, timeout):
        cbilling:         if (key not in self.held_locks) or self.held_locks[key]['expiry'] < time.time():
        cbilling:             self.held_locks[key] = {'client_id': client_id, 'expiry': float(timeout) + time.time()}
        cbilling:             if LOGGING: logger.info('%s acquired %s'%(client_id, key))
        cbilling:             return 'ok'
        cbilling:         if LOGGING: logger.info('%s is waiting to acquire %s'%(client_id, key))
        cbilling:         return 'retry'
        cbilling:             
        cbilling:     def release(self, key, client_id):
        cbilling:         if key in self.held_locks:
        cbilling:             if self.held_locks[key]['client_id'] == client_id and self.held_locks[key]['expiry'] > time.time():
        cbilling:                 del self.held_locks[key]
        cbilling:                 if LOGGING: logger.info('%s released %s'%(client_id, key))
        cbilling:                 return 'ok'
        cbilling:         raise RuntimeError('lock %s timed out or was not acquired prior to release by %s'%(key, client_id))
        cbilling:     
        cbilling:     def status(self):
        cbilling:         lines = ['ok']
        cbilling:         fmt = lambda key, client, expiry: ('-------\n'
        cbilling:                                            '   key: %s\n'%key +
        cbilling:                                            'client: %s\n'%client+
        cbilling:                                            'expiry: %d'%expiry + (' [EXPIRED]' if expiry < 0 else ''))
        cbilling:                                            
        pstarkey:         for key, lock in list(self.held_locks.items()):
        cbilling:             lines.append(fmt(key, lock['client_id'], int(lock['expiry']-time.time())))
        cbilling:         lines.append('-------')
        cbilling:         if not self.held_locks:
        cbilling:             lines.append('no locks currently held')
        cbilling:             lines.append('-------')
        cbilling:         response = '\n'.join(lines)
        cbilling:         if LOGGING: logger.info('Got a status request. Status is: %s'%response)
        cbilling:         return response
        cbilling:     
        cbilling:     def clear(self, clear_all=False):
        cbilling:         if clear_all:
        cbilling:             if clear_all.lower() == 'false':
        cbilling:                 clear_all = False
        cbilling:         if LOGGING: logger.info('Got a request to clear %s locks'%('*all*' if clear_all else 'expired'))
        pstarkey:         for key, lock in list(self.held_locks.copy().items()):
        cbilling:             if clear_all or time.time() > lock['expiry']:
        cbilling:                 del self.held_locks[key]
        cbilling:         return 'ok'
        cbilling:         
        cbilling:     def handle_one_request(self, request, *args):
        cbilling:         try:
        cbilling:             response = self.handlers[request](*args)
        cbilling:         except Exception:
        cbilling:             response = traceback.format_exc()
        cbilling:             logger.error('%s:\n%s'%(str([request] + list(args)), response))
        cbilling:         return response
        cbilling:                           
        cbilling:     def run(self):
        cbilling:         if LOGGING: logger.info('This is zlock server, running on port %d'%self.port)
        cbilling:         unprocessed_messages = []
        cbilling:         poll_interval = -1
        cbilling:         while True:
        cbilling:             # Wait at most RETRY_INTERVAL for incoming request messages:
        cbilling:             events = self.poller.poll(poll_interval)
        cbilling:             poll_interval = -1
        cbilling:             if events:
        cbilling:                 # If there was a new request, this will be processed
        cbilling:                 # first, being prepended to unprocessed_messages.  Then we
        cbilling:                 # will process any other requests that are waiting,
        cbilling:                 # in case the locks they are waiting on have timed out,
        cbilling:                 # or MAX_RESPONSE_TIME has elapse and we need to reply
        cbilling:                 # to their client.
        cbilling:                 new_request_message = self.router.recv_multipart()
        cbilling:                 unprocessed_messages.insert(0, (new_request_message, time.time() + MAX_RESPONSE_TIME))
           Chris:                 if LOGGING: logger.debug(new_request_message)
        cbilling:             else:
        cbilling:                 if LOGGING: logger.debug('processing existing requests')
        cbilling:             # Process all waiting request messages:
        cbilling:             n_requests_processed = 0
        cbilling:             for request_message, expiry in unprocessed_messages[:]:
        cbilling:                 # Unpack the REQ multipart message:
        cbilling:                 prefix, args = request_message[0:2], request_message[2:]
           Chris:                 decoded_args = [arg.decode('utf8', 'surrogateescape') for arg in args]
        cbilling:                 # Handle the request:
chrisjbillington:                 response = self.handle_one_request(*decoded_args)
        cbilling:                 if response == 'retry' and expiry - time.time() > 0:
        cbilling:                     # Lock contention. Lock acquisition will be retried
        cbilling:                     # after other requests are processed, or once maximum
        cbilling:                     # response time is reached. Don't give the client
        cbilling:                     # a response yet:
        cbilling:                      continue
        cbilling:                 else:
        cbilling:                     # If success or error, tell the client about it. Or
        cbilling:                     # if we have already been retrying their request for
        cbilling:                     # MAX_RESPONSE_TIME, forward the 'retry' response
        cbilling:                     # to them.
        cbilling:                     unprocessed_messages.remove((request_message, expiry))
           Chris:                     self.router.send_multipart(prefix + [response.encode('utf8')])
        cbilling:                     n_requests_processed += 1
        cbilling:             # Shuffle the waiting requests so as to remove any systematic
        cbilling:             # ordering effects:
        cbilling:             random.shuffle(unprocessed_messages)
        cbilling:             if n_requests_processed > 0:
        cbilling:                 # If at least one request was processed, then perhaps
        cbilling:                 # a previously contended lock is now free. Process all
        cbilling:                 # requests again immediately:
        cbilling:                 poll_interval = 0
        cbilling:             elif unprocessed_messages:
        cbilling:                 # Otherwise, when is the soonest time that a client
        cbilling:                 # requires a response? Process the requests again then:
        cbilling:                 poll_interval = 1000*min(t - time.time() for m, t in unprocessed_messages)
        cbilling:                 # ensure non-negative, that would block forever:
        cbilling:                 poll_interval = max(0, poll_interval)
        cbilling:             else:
        cbilling:                 poll_interval = -1
        cbilling:                 
        cbilling: if __name__ == '__main__':
        cbilling:     if LOGGING: logger = setup_logging()
        cbilling:     
        cbilling:     try:
        pstarkey:         import six
        pstarkey:         if six.PY2:
        pstarkey:             import ConfigParser
        pstarkey:         else:
        pstarkey:             import configparser as ConfigParser
        cbilling:         from labscript_utils.labconfig import LabConfig
        cbilling:         port = LabConfig().get('ports','zlock')
        cbilling:     except (ImportError, IOError, ConfigParser.NoOptionError):
        cbilling:         if LOGGING: logger.warning("Couldn't get port setting from LabConfig. Using default port")
        cbilling:         port = zlock.DEFAULT_PORT
        cbilling:     
        cbilling:     server = ZMQLockServer(port)
        cbilling:     while True:
        cbilling:         try:
        cbilling:             server.run()
        cbilling:         except KeyboardInterrupt:
        cbilling:             if LOGGING: logger.info('KeyboardInterrupt, stopping')
chrisjbillington:             server.context.destroy(linger=False)
        cbilling:             break
        cbilling:         except Exception:
        cbilling:             message = traceback.format_exc()
        cbilling:             if LOGGING: logger.critical('unhandled exception, attempting to restart:\n%s'%message)
        cbilling:             # Close all sockets:
chrisjbillington:             server.context.destroy(linger=False)
        cbilling:             # Re-initialise the server:
        cbilling:             server = ZMQLockServer(port)
        cbilling:             time.sleep(1)
        cbilling:             
        cbilling:             
        cbilling:             
        cbilling:     
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # process_class_wrapper.py                                          #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Chris Billington                                  #
        cbilling: #                                                                   #
        cbilling: # This file is part of the zprocess project (see                    #
        cbilling: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
        cbilling: # the Simplified BSD License. See the license.txt file in the root  #
        cbilling: # of the project for the full license.                              #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
        cbilling: 
        cbilling: def _setup():
        cbilling:     # Clear the namespace of any evidence we were here:
        cbilling:     del globals()['_setup']
        cbilling:     import sys, os
chrisjbillington: 
chrisjbillington:     # Ensure the zprocess we import is the same on as we are running from,
chrisjbillington:     # relevant particularly for running the test suite:
chrisjbillington:     parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
chrisjbillington:     if not parent_dir in sys.path:
chrisjbillington:         sys.path.insert(0, parent_dir)
chrisjbillington: 
chrisjbillington:     from zprocess import ProcessTree
chrisjbillington:     process_tree = ProcessTree.connect_to_parent(lock=True)
chrisjbillington:     module_name, module_filepath, syspath = process_tree.from_parent.get()
chrisjbillington:     # Set sys.path so that all modules imported in the user's code are
chrisjbillington:     # importable here:
        cbilling:     sys.path = syspath
        cbilling:     sys.path.append(os.path.dirname(module_filepath))
        cbilling:     if module_name == '__main__':
chrisjbillington:         # Execute the user's module in __main__, so that the class is
chrisjbillington:         # unpickleable. Otherwise __main__ will refer to this file, which is
chrisjbillington:         # not where their class is! Temporarily rename this module so that the
chrisjbillington:         # user's __main__ block doesn't execute:
        cbilling:         globals()['__name__'] = 'process_class_wrapper'
chrisjbillington:         exec(compile(open(module_filepath, "rb").read(),module_filepath, 'exec'),
chrisjbillington:              globals(), globals())
        cbilling:         # Set __name__ back to normal. Runtime checks of this now cannot
chrisjbillington:         # distinguish between parent and child processes, but I think wanting
chrisjbillington:         # to do so without already knowing yourself is probably poor form:
        cbilling:         globals()['__name__'] = '__main__'
        cbilling:         
chrisjbillington:     process_cls = process_tree.from_parent.get()
chrisjbillington:     instance = process_cls(process_tree)
chrisjbillington:     instance._run() 
        cbilling:     
        cbilling: if __name__ == '__main__':
        cbilling:     _setup()
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: PY2 = sys.version_info.major == 2
chrisjbillington: import os
chrisjbillington: import threading
chrisjbillington: import subprocess
chrisjbillington: import time
chrisjbillington: import signal
chrisjbillington: import weakref
chrisjbillington: import ast
chrisjbillington: import json
chrisjbillington: import ctypes
chrisjbillington: import atexit
chrisjbillington: from ctypes.util import find_library
chrisjbillington: from socket import gethostbyname
chrisjbillington: 
chrisjbillington: import zmq
chrisjbillington: 
chrisjbillington: _path, _cwd = os.path.split(os.getcwd())
chrisjbillington: if _cwd == 'zprocess' and _path not in sys.path:
chrisjbillington:     # Running from within zprocess dir? Add to sys.path for testing during
chrisjbillington:     # development:
chrisjbillington:     sys.path.insert(0, _path)
chrisjbillington: 
chrisjbillington: import zprocess
chrisjbillington: from zprocess.clientserver import ZMQClient
chrisjbillington: from zprocess.security import SecureContext
chrisjbillington: from zprocess.utils import TimeoutError
chrisjbillington: 
chrisjbillington: PY2 = sys.version_info[0] == 2
chrisjbillington: if PY2:
chrisjbillington:     import cPickle as pickle
chrisjbillington:     str = unicode
chrisjbillington: else:
chrisjbillington:     import pickle
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class HeartbeatServer(object):
chrisjbillington:     """A server which receives messages from clients and echoes them back. Each
chrisjbillington:     process has a HeartbeatServer to provide heartbeating to its subprocesses -
chrisjbillington:     there is not only one in the top process.
chrisjbillington:     """
chrisjbillington:     def __init__(self, bind_address='tcp://0.0.0.0', 
chrisjbillington:                  shared_secret=None):
chrisjbillington:         context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:         self.sock = context.socket(zmq.REP)
chrisjbillington:         self.port = self.sock.bind_to_random_port(bind_address)
chrisjbillington:         self.mainloop_thread = threading.Thread(target=self.mainloop)
chrisjbillington:         self.mainloop_thread.daemon = True
chrisjbillington:         self.mainloop_thread.start()
chrisjbillington: 
chrisjbillington:     def mainloop(self):
chrisjbillington:         try:
chrisjbillington:             zmq.proxy(self.sock, self.sock)
chrisjbillington:         except zmq.ContextTerminated:
chrisjbillington:             # Shutting down:
chrisjbillington:             self.sock.close(linger=0)
chrisjbillington:             return
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class HeartbeatClient(object):
chrisjbillington:     """A heartbeating thread that terminates the process if it doesn't get the
chrisjbillington:     heartbeats back within one second, unless a lock is held."""
chrisjbillington:     def __init__(self, server_host, server_port, lock=False,
chrisjbillington:                  shared_secret=None, allow_insecure=False):
chrisjbillington:         if lock:
chrisjbillington:             self.lock = threading.Lock()
chrisjbillington:         else:
chrisjbillington:             self.lock = None
chrisjbillington:         context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:         self.sock = context.socket(zmq.REQ, allow_insecure=allow_insecure)
chrisjbillington:         self.sock.setsockopt(zmq.LINGER, 0)
chrisjbillington:         server_ip = gethostbyname(server_host)
chrisjbillington:         self.sock.connect('tcp://{}:{}'.format(server_ip, server_port))
chrisjbillington:         self.mainloop_thread = threading.Thread(target=self.mainloop)
chrisjbillington:         self.mainloop_thread.daemon = True
chrisjbillington:         self.mainloop_thread.start()
chrisjbillington: 
chrisjbillington:     def mainloop(self):
chrisjbillington:         try:
chrisjbillington:             pid = str(os.getpid()).encode('utf8')
chrisjbillington:             while True:
chrisjbillington:                 time.sleep(1)
chrisjbillington:                 self.sock.send(pid, zmq.NOBLOCK)
chrisjbillington:                 if not self.sock.poll(1000):
chrisjbillington:                     break
chrisjbillington:                 msg = self.sock.recv()
chrisjbillington:                 if not msg == pid:
chrisjbillington:                     break
chrisjbillington:             # sys.stderr.write('Heartbeat failure\n')
chrisjbillington:             if self.lock is not None:
chrisjbillington:                 with self.lock:
chrisjbillington:                     os.kill(os.getpid(), signal.SIGTERM)
chrisjbillington:             else:
chrisjbillington:                 os.kill(os.getpid(), signal.SIGTERM)
chrisjbillington:         except zmq.ContextTerminated:
chrisjbillington:             # Shutting down:
chrisjbillington:             self.sock.close(linger=0)
chrisjbillington:             return
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class EventBroker(object):
chrisjbillington:     """A broker to collect Event.post() messages from anywhere in the process tree
chrisjbillington:     and broadcast them to subscribers calling event.wait(). There is only one of
chrisjbillington:     these, at the top level process in the ProcessTree."""
chrisjbillington: 
chrisjbillington:     # A message subscribers can use to confirm their connection
chrisjbillington:     # (and any subscriptions) have been processed.
chrisjbillington:     WELCOME_MESSAGE = b'_zprocess_broker_hello\0'
chrisjbillington: 
chrisjbillington:     def __init__(self, bind_address='tcp://0.0.0.0', shared_secret=None,
chrisjbillington:                  allow_insecure=False):
chrisjbillington:         context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:         self.frontend = context.socket(zmq.PULL, allow_insecure=allow_insecure)
chrisjbillington:         self.backend = context.socket(zmq.XPUB, allow_insecure=allow_insecure)
chrisjbillington: 
chrisjbillington:         self.poller = zmq.Poller()
chrisjbillington:         self.poller.register(self.frontend, zmq.POLLIN)
chrisjbillington:         self.poller.register(self.backend, zmq.POLLIN)
chrisjbillington: 
chrisjbillington:         self.in_port = self.frontend.bind_to_random_port(bind_address)
chrisjbillington:         self.out_port = self.backend.bind_to_random_port(bind_address)
chrisjbillington: 
chrisjbillington:         self.mainloop_thread = threading.Thread(target=self.mainloop)
chrisjbillington:         self.mainloop_thread.daemon = True
chrisjbillington:         self.mainloop_thread.start()
chrisjbillington: 
chrisjbillington:     def mainloop(self):
chrisjbillington:         while True:
chrisjbillington:             try:
chrisjbillington:                 events = dict(self.poller.poll())
chrisjbillington:                 if self.backend in events:
chrisjbillington:                     msg = self.backend.recv()
chrisjbillington:                     is_subscription, topic = ord(msg[0:1]), msg[1:]
chrisjbillington:                     if is_subscription and topic.startswith(self.WELCOME_MESSAGE):
chrisjbillington:                         # A new subscriber asking for a welcome message to confirm
chrisjbillington:                         # that we have received all subscriptions made prior to
chrisjbillington:                         # this request. Send the topic back (it includes a unique
chrisjbillington:                         # random number to ensure only the recipient gets it)
chrisjbillington:                         self.backend.send(topic)
chrisjbillington:                 if self.frontend in events:
chrisjbillington:                     # Forward messages to subscribers:
chrisjbillington:                     self.backend.send_multipart(self.frontend.recv_multipart())
chrisjbillington:             except zmq.ContextTerminated:
chrisjbillington:                 # Shutting down:
chrisjbillington:                 self.frontend.close(linger=0)
chrisjbillington:                 self.backend.close(linger=0)
chrisjbillington:                 return
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class Event(object):
chrisjbillington: 
chrisjbillington:     def __init__(self, process_tree, event_name, role='wait'):
chrisjbillington:         # Ensure we have a broker, whether it's in this process or a parent one:
chrisjbillington:         self.event_name = event_name
chrisjbillington:         # We null terminate the event name otherwise any subscriber subscribing to
chrisjbillington:         # and event *starting* with our event name will also receive it, which
chrisjbillington:         # we do not want:
chrisjbillington:         self._encoded_event_name = self.event_name.encode('utf8') + b'\0'
chrisjbillington:         self.role = role
chrisjbillington:         if not role in ['wait', 'post', 'both']:
chrisjbillington:             raise ValueError("role must be 'wait', 'post', or 'both'")
chrisjbillington:         self.can_wait = self.role in ['wait', 'both']
chrisjbillington:         self.can_post = self.role in ['post', 'both']
chrisjbillington:         context = SecureContext.instance(shared_secret=process_tree.shared_secret)
chrisjbillington:         broker_ip = gethostbyname(process_tree.broker_host)
chrisjbillington:         if self.can_wait:
chrisjbillington:             self.sub = context.socket(zmq.SUB,
chrisjbillington:                                       allow_insecure=process_tree.allow_insecure)
chrisjbillington:             self.sub.set_hwm(1000)
chrisjbillington:             self.sub.setsockopt(zmq.SUBSCRIBE, self._encoded_event_name)
chrisjbillington:             self.sub.connect(
chrisjbillington:                 'tcp://{}:{}'.format(broker_ip, process_tree.broker_out_port))
chrisjbillington:             # Request a welcome message from the broker confirming it receives this
chrisjbillington:             # subscription request. This is important so that by the time this
chrisjbillington:             # __init__ method returns, the caller can know for sure that if the
chrisjbillington:             # broker receives a message, it will definitely be forwarded to the
chrisjbillington:             # subscribers and not discarded. It is important that this come after
chrisjbillington:             # connect() and after the other setsockopt for our event subscription,
chrisjbillington:             # otherwise the two subscription requests may be sent in the opposite
chrisjbillington:             # order, preventing us from relying on the receipt of a welcome message
chrisjbillington:             # as confirmation that the other subscription was received. We use a
chrisjbillington:             # unique random number to prevent treating *other* subscribers' welcome
chrisjbillington:             # messages as our own. This is a lot of hoops to jump through when it
chrisjbillington:             # would be really nice if zeroMQ could just have a way of saying "block
chrisjbillington:             # until all subscription messages processed", which is all we're really
chrisjbillington:             # doing.
chrisjbillington:             unique_id = os.urandom(32)
chrisjbillington:             self.sub.setsockopt(zmq.SUBSCRIBE,
chrisjbillington:                                 EventBroker.WELCOME_MESSAGE + unique_id)
chrisjbillington:             # Allow 5 seconds to connect to the Broker:
chrisjbillington:             events = self.sub.poll(flags=zmq.POLLIN, timeout=5000)
chrisjbillington:             if not events:
chrisjbillington:                 raise TimeoutError("Could not connect to event broker")
chrisjbillington:             assert self.sub.recv() == EventBroker.WELCOME_MESSAGE + unique_id
chrisjbillington:             # Great, we're definitely connected to the broker now, and it has
chrisjbillington:             # processed our subscription. Remove the welcome event subscription
chrisjbillington:             # and proceed:
chrisjbillington:             self.sub.setsockopt(zmq.UNSUBSCRIBE,
chrisjbillington:                                 EventBroker.WELCOME_MESSAGE + unique_id)
chrisjbillington:             self.sublock = threading.Lock()
chrisjbillington:         if self.can_post:
chrisjbillington:             self.push = context.socket(zmq.PUSH,
chrisjbillington:                                        allow_insecure=process_tree.allow_insecure)
chrisjbillington:             self.push.connect(
chrisjbillington:                 'tcp://{}:{}'.format(broker_ip, process_tree.broker_in_port))
chrisjbillington:             self.pushlock = threading.Lock()
chrisjbillington: 
chrisjbillington:     def post(self, identifier, data=None):
chrisjbillington:         if not self.can_post:
chrisjbillington:             msg = ("Instantiate Event with role='post' " +
chrisjbillington:                    "or 'both' to be able to post events")
chrisjbillington:             raise ValueError(msg)
chrisjbillington:         with self.pushlock:
chrisjbillington:             self.push.send_multipart([self._encoded_event_name,
chrisjbillington:                                     str(identifier).encode('utf8'),
chrisjbillington:                                     pickle.dumps(data,
chrisjbillington:                                         protocol=zprocess.PICKLE_PROTOCOL)])
chrisjbillington: 
chrisjbillington:     def wait(self, identifier, timeout=None):
chrisjbillington:         identifier = str(identifier)
chrisjbillington:         if not self.can_wait:
chrisjbillington:             msg = ("Instantiate Event with role='wait' " +
chrisjbillington:                    "or 'both' to be able to wait for events")
chrisjbillington:             raise ValueError(msg)
chrisjbillington:         # First check through events that are already in the buffer:
chrisjbillington:         while True:
chrisjbillington:             with self.sublock:
chrisjbillington:                 events = self.sub.poll(0, flags=zmq.POLLIN)
chrisjbillington:                 if not events:
chrisjbillington:                     break
chrisjbillington:                 encoded_event_name, event_id, data = self.sub.recv_multipart()
chrisjbillington:                 event_id = event_id.decode('utf8')
chrisjbillington:                 data = pickle.loads(data)
chrisjbillington:                 assert encoded_event_name == self._encoded_event_name
chrisjbillington:                 if event_id == identifier:
chrisjbillington:                     return data
chrisjbillington:         # Since we might have to make several recv() calls before we get the
chrisjbillington:         # right identifier, we must implement our own timeout:
chrisjbillington:         start_time = time.time()
chrisjbillington:         while timeout is None or (time.time() < start_time + timeout):
chrisjbillington:             with self.sublock:
chrisjbillington:                 if timeout is not None:
chrisjbillington:                     # How long left before the elapsed time is greater than
chrisjbillington:                     # timeout?
chrisjbillington:                     remaining = (start_time + timeout - time.time())
chrisjbillington:                     poll_timeout = max(0, remaining)
chrisjbillington:                     events = self.sub.poll(1000 * poll_timeout, flags=zmq.POLLIN)
chrisjbillington:                     if not events:
chrisjbillington:                         break
chrisjbillington:                 encoded_event_name, event_id, data = self.sub.recv_multipart()
chrisjbillington:                 event_id = event_id.decode('utf8')
chrisjbillington:                 data = pickle.loads(data)
chrisjbillington:                 assert encoded_event_name == self._encoded_event_name
chrisjbillington:                 if event_id == identifier:
chrisjbillington:                     return data
chrisjbillington:         raise TimeoutError('No event received: timed out')
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class WriteQueue(object):
chrisjbillington: 
chrisjbillington:     """Provides writing of python objects to the underlying zmq socket,
chrisjbillington:     with added locking. No reading is supported, once you put an object,
chrisjbillington:     you can't check what was put or whether the items have been gotten"""
chrisjbillington: 
chrisjbillington:     def __init__(self, sock):
chrisjbillington:         self.sock = sock
chrisjbillington:         self.lock = threading.Lock()
chrisjbillington: 
chrisjbillington:     def put(self, obj):
chrisjbillington:         with self.lock:
chrisjbillington:             self.sock.send_pyobj(obj, protocol=zprocess.PICKLE_PROTOCOL)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ReadQueue(object):
chrisjbillington:     """Provides reading and writing methods to the underlying zmq socket,
chrisjbillington:     with added locking. Actually there are two sockets, one for reading,
chrisjbillington:     one for writing. The only real use case for writing is when the
chrisjbillington:     read socket is blocking, but the process at the other end has died,
chrisjbillington:     and you need to stop the thread that is blocking on the read. So
chrisjbillington:     you send it a quit signal with put()."""
chrisjbillington: 
chrisjbillington:     def __init__(self, sock, to_self_sock):
chrisjbillington:         self.sock = sock
chrisjbillington:         self.to_self_sock = to_self_sock
chrisjbillington:         self.socklock = threading.Lock()
chrisjbillington:         self.to_self_sock_lock = threading.Lock()
chrisjbillington: 
chrisjbillington:     def get(self, timeout=None):
chrisjbillington:         with self.socklock:
chrisjbillington:             if timeout is not None:
chrisjbillington:                 if not self.sock.poll(timeout*1000):
chrisjbillington:                     raise TimeoutError('get() timed out')
chrisjbillington:             obj = self.sock.recv_pyobj()
chrisjbillington:         return obj
chrisjbillington: 
chrisjbillington:     def put(self, obj):
chrisjbillington:         with self.to_self_sock_lock:
chrisjbillington:             self.to_self_sock.send_pyobj(obj, protocol=zprocess.PICKLE_PROTOCOL)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class StreamProxy(object):
chrisjbillington:     def __init__(self, fd, sock, socklock, streamname):
chrisjbillington:         self.fd = fd
chrisjbillington:         self.sock = sock
chrisjbillington:         self.socklock = socklock
chrisjbillington:         self.streamname_bytes = streamname.encode('utf8')
chrisjbillington:         # Hopefully this covers all our bases for ensuring the mainloop gets
chrisjbillington:         # a chance to run after C output before Python output is produced:
chrisjbillington:         if os.name == 'posix':
chrisjbillington:             libpthread = ctypes.CDLL(find_library('pthread'))
chrisjbillington:             self.sched_yield = libpthread.sched_yield
chrisjbillington:         else:
chrisjbillington:             self.sched_yield = lambda: time.sleep(0)
chrisjbillington: 
chrisjbillington:     def write(self, s):
chrisjbillington:         if isinstance(s, str):
chrisjbillington:             s = s.encode('utf8')
chrisjbillington:         # Release the GIL momentarily to increase the odds that previous output
chrisjbillington:         # from C or a subprocess will have been processed by
chrisjbillington:         # OutputInterceptor._mainloop(), preserving the order of output. This is no
chrisjbillington:         # guarantee, but is the best we can do if we want to be able to capture
chrisjbillington:         # output from C and subprocesses whilst distinguishing between stdout and
chrisjbillington:         # stderr without doing LD_PRELOAD tricks. Sleeping zero or calling
chrisjbillington:         # sched_yield releases the GIL momentarily, giving other threads a chance
chrisjbillington:         # to run. The mainloop is higher priority on Windows, so it will get the
chrisjbillington:         # GIL until it is done or until the next checkinterval(). It is not higher
chrisjbillington:         # priority on linux, but this is the best we can do.
chrisjbillington:         self.sched_yield()
chrisjbillington:         with self.socklock:
chrisjbillington:             # We write directly to the zmq socket for Python output to guarantee
chrisjbillington:             # that sys.stdout and sys.stderr will come out in the correct order
chrisjbillington:             # when coming from Python code, which we cannot similarly guarantee for
chrisjbillington:             # C output. The downside of this is that Python stdout and C stdout
chrisjbillington:             # output may be in the incorrect order, though we do our best to
chrisjbillington:             # decrease the odds of this with thread yielding. This seemed like
chrisjbillington:             # the better compromise than sending everything through the pipes and
chrisjbillington:             # possibly reordering stdout and stderr for ordinary Python output.
chrisjbillington:             self.sock.send_multipart([self.streamname_bytes, s])
chrisjbillington:         # os.write(self.fd, s)
chrisjbillington: 
chrisjbillington:     def close(self):
chrisjbillington:         os.close(self.fd)
chrisjbillington: 
chrisjbillington:     def fileno(self):
chrisjbillington:         return self.fd
chrisjbillington: 
chrisjbillington:     def isatty(self):
chrisjbillington:         return os.isatty(self.fd)
chrisjbillington: 
chrisjbillington:     def flush(self):
chrisjbillington:         pass
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class OutputInterceptor(object):
chrisjbillington:     # Two OutputInterceptors talking to the same server must share a sock and
chrisjbillington:     # corresponding lock:
chrisjbillington:     socks_by_connection = weakref.WeakValueDictionary()
chrisjbillington:     locks_by_connection = weakref.WeakValueDictionary()
chrisjbillington:     # A lock to serialise calls to connect() and disconnect()
chrisjbillington:     connect_disconnect_lock = threading.Lock()
chrisjbillington:     # Only one stdout or stderr can be conencted at a time,
chrisjbillington:     # so we keep track with this class attribute dict:
chrisjbillington:     streams_connected = {'stdout': None, 'stderr': None}
chrisjbillington: 
chrisjbillington:     # Ensure output is flushed at interpreter shutdown:
chrisjbillington:     def _close_socks():
chrisjbillington:         cls = OutputInterceptor
chrisjbillington:         for connection in list(cls.socks_by_connection.keys()):
chrisjbillington:             try:
chrisjbillington:                 sock = cls.socks_by_connection[connection]
chrisjbillington:                 lock = cls.locks_by_connection[connection]
chrisjbillington:             except KeyError:
chrisjbillington:                 continue
chrisjbillington:             with lock:
chrisjbillington:                 sock.close()
chrisjbillington: 
chrisjbillington:     atexit.register(_close_socks)
chrisjbillington: 
chrisjbillington:     """Redirect stderr and stdout to a zmq PUSH socket"""
chrisjbillington:     def __init__(self, host, port, streamname='stdout',
chrisjbillington:                  shared_secret=None, allow_insecure=False):
chrisjbillington:         if streamname not in ['stdout', 'stderr']:
chrisjbillington:             msg = "streamname must be 'stdout' or 'stderr'"
chrisjbillington:             raise ValueError(msg)
chrisjbillington: 
chrisjbillington:         self.streamname = streamname
chrisjbillington:         self.stream_fd = None
chrisjbillington:         self.backup_fd = None
chrisjbillington:         self.read_pipe_fd = None
chrisjbillington:         self.mainloop_thread = None
chrisjbillington:         self.shutting_down = False
chrisjbillington: 
chrisjbillington:         ip = gethostbyname(host)
chrisjbillington:         connection_details = (ip, port, shared_secret, allow_insecure)
chrisjbillington:         if connection_details not in self.socks_by_connection:
chrisjbillington:             context = SecureContext.instance(shared_secret=shared_secret)
chrisjbillington:             sock = context.socket(zmq.PUSH, allow_insecure=allow_insecure)
chrisjbillington:             # At socket close, allow up to 1 second to send all unsent messages:
chrisjbillington:             sock.setsockopt(zmq.LINGER, 1000)
chrisjbillington:             sock.connect('tcp://%s:%d' % (ip, port))
chrisjbillington:             socklock = threading.Lock()
chrisjbillington:             self.socks_by_connection[connection_details] = sock
chrisjbillington:             self.locks_by_connection[connection_details] = socklock
chrisjbillington:         self.sock = self.socks_by_connection[connection_details]
chrisjbillington:         self.socklock = self.locks_by_connection[connection_details]
chrisjbillington: 
chrisjbillington:     def _flush(self):
chrisjbillington:         """Flush the C level file pointer for the stream. This should be
chrisjbillington:         done before closing their file descriptors"""
chrisjbillington:         if os.name == 'nt':
chrisjbillington:             # Windows:
chrisjbillington:             libc = ctypes.cdll.msvcrt
chrisjbillington:             # In windows we flush all output streams by calling flush on a null
chrisjbillington:             # pointer:
chrisjbillington:             file_ptr = ctypes.c_void_p()
chrisjbillington:         else:
chrisjbillington:             libc = ctypes.CDLL(None)
chrisjbillington:             try:
chrisjbillington:                 # Linux:
chrisjbillington:                 file_ptr = ctypes.c_void_p.in_dll(libc, self.streamname)
chrisjbillington:             except ValueError:
chrisjbillington:                 # MacOS:
chrisjbillington:                 file_ptr = ctypes.c_void_p.in_dll(libc, '__%sp' % self.streamname)
chrisjbillington:         libc.fflush(file_ptr)
chrisjbillington: 
chrisjbillington:     def connect(self):
chrisjbillington:         """Begin output redirection"""
chrisjbillington:         with self.connect_disconnect_lock:
chrisjbillington:             if self.streams_connected[self.streamname] is not None:
chrisjbillington:                 msg = ("An OutputInterceptor is already connected for stream " +
chrisjbillington:                        "'%s'" % self.streamname)
chrisjbillington:                 raise RuntimeError(msg)
chrisjbillington:             self.streams_connected[self.streamname] = self
chrisjbillington:             stream = getattr(sys, self.streamname)
chrisjbillington:             if stream is not None and stream.fileno() > 0:
chrisjbillington:                 self.stream_fd = stream.fileno()
chrisjbillington:             else:
chrisjbillington:                 # On Windows with pythonw, sys.stdout and sys.stderr are None or
chrisjbillington:                 # have invalid (negative) file descriptors. We still want to
chrisjbillington:                 # redirect any C code or subprocesses writing to stdout or stderr
chrisjbillington:                 # so we use the standard file descriptor numbers, which, assuming
chrisjbillington:                 # no other tricks played by other code, will be 1 and 2:
chrisjbillington:                 if self.streamname == 'stdout':
chrisjbillington:                     self.stream_fd = 1
chrisjbillington:                 elif self.streamname == 'stderr':
chrisjbillington:                     self.stream_fd = 2
chrisjbillington:                 else:
chrisjbillington:                     raise ValueError(self.streamname)
chrisjbillington:                 
chrisjbillington:             # os.dup() lets us take a sort of backup of the current file
chrisjbillington:             # descriptor for the stream, so that we can restore it later:
chrisjbillington:             self.backup_fd = os.dup(self.stream_fd)
chrisjbillington:                 
chrisjbillington:             # We set up a pipe and set the write end of it to be the output file
chrisjbillington:             # descriptor. C code and subprocesses will see this as the stream and
chrisjbillington:             # write to it, and we will read from the read end of the pipe in a 
chrisjbillington:             # thread to pass their output to the zmq socket.
chrisjbillington:             self.read_pipe_fd, write_pipe_fd = os.pipe()
chrisjbillington:             self.mainloop_thread = threading.Thread(target=self._mainloop)
chrisjbillington:             self.mainloop_thread.daemon = True
chrisjbillington:             self.mainloop_thread.start()
chrisjbillington: 
chrisjbillington:             # Before doing the redirection, flush the current streams:
chrisjbillington:             self._flush()
chrisjbillington:             # Redirect the stream to our write pipe, closing the original stream
chrisjbillington:             # file descriptor:
chrisjbillington:             os.dup2(write_pipe_fd, self.stream_fd)
chrisjbillington:             # Replace sys.<streamname> with a proxy object. Any Python code writing
chrisjbillington:             # to the stream will have the output passed directly to the zmq socket,
chrisjbillington:             # and any other code inspecting sys.stdout/sderr's fileno() will see
chrisjbillington:             # the write end of our redirection pipe.
chrisjbillington:             proxy = StreamProxy(write_pipe_fd,
chrisjbillington:                                 self.sock, self.socklock, self.streamname)
chrisjbillington:             setattr(sys, self.streamname, proxy)
chrisjbillington: 
chrisjbillington:     def disconnect(self):
chrisjbillington:         """Stop output redirection"""
chrisjbillington:         with self.connect_disconnect_lock:
chrisjbillington:             if self.streams_connected[self.streamname] is not self:
chrisjbillington:                 msg = ("This OutputInterceptor not connected for stream " +
chrisjbillington:                        "'%s'" % self.streamname)
chrisjbillington:                 raise RuntimeError(msg)
chrisjbillington:             self.streams_connected[self.streamname] = None
chrisjbillington:             orig_stream = getattr(sys, '__%s__' % self.streamname)
chrisjbillington:             self._flush()
chrisjbillington:             os.dup2(self.backup_fd, self.stream_fd)
chrisjbillington:             self.stream_fd = None
chrisjbillington:             os.close(self.backup_fd)
chrisjbillington:             self.backup_fd = None
chrisjbillington:             proxy_stream = getattr(sys, self.streamname)
chrisjbillington:             # self-pipe trick to break out of the blocking read and see the
chrisjbillington:             # shutting_down flag. We do this rather than close the file descriptor
chrisjbillington:             # for the write end of the pipe because other processes may still have
chrisjbillington:             # an open file descriptor for the write end of the pipe, so the
chrisjbillington:             # mainloop would not get a signal that the pipe was closed. Any
chrisjbillington:             # remaining subprocesses will get a broken pipe error if they try to
chrisjbillington:             # write output.
chrisjbillington:             self.shutting_down = True
chrisjbillington:             os.write(proxy_stream.fileno(), b'<dummy message>')
chrisjbillington:             proxy_stream.close()
chrisjbillington:             setattr(sys, self.streamname, orig_stream)
chrisjbillington:             self.mainloop_thread.join()
chrisjbillington:             self.mainloop_thread = None
chrisjbillington:             self.shutting_down = False          
chrisjbillington: 
chrisjbillington:     def _mainloop(self):
chrisjbillington:         streamname_bytes = self.streamname.encode('utf8')
chrisjbillington:         # Set the priority of this thread a bit higher so that when C code or
chrisjbillington:         # subprocesses write to stdout, and multiple threads are waiting on the
chrisjbillington:         # GIL, this thread will get it and process the output before Python
chrisjbillington:         # output is produced from other threads. This is only reliable if we
chrisjbillington:         # can guarantee that the main thread releases and re-acquires the GIL
chrisjbillington:         # before producing output, which we do in StreamProxy.write().
chrisjbillington:         if os.name == 'nt':
chrisjbillington:             w32 = ctypes.windll.kernel32
chrisjbillington:             THREAD_SET_INFORMATION = 0x20
chrisjbillington:             THREAD_PRIORITY_ABOVE_NORMAL = 1
chrisjbillington:             handle = w32.OpenThread(THREAD_SET_INFORMATION, False,
chrisjbillington:                                     threading.current_thread().ident)
chrisjbillington:             result = w32.SetThreadPriority(handle, THREAD_PRIORITY_ABOVE_NORMAL)
chrisjbillington:             w32.CloseHandle(handle)
chrisjbillington:             if not result:
chrisjbillington:                 print('Failed to set priority of thread',  w32.GetLastError())
chrisjbillington:         else:
chrisjbillington:             # In linux/mac, we cannot set a higher priority without root
chrisjbillington:             # privileges. Best we can do it to call sched_yield from the other
chrisjbillington:             # thread.
chrisjbillington:             pass
chrisjbillington:         while True:
chrisjbillington:             s = os.read(self.read_pipe_fd, 4096)
chrisjbillington:             with self.socklock:
chrisjbillington:                 if not s or self.shutting_down:
chrisjbillington:                     os.close(self.read_pipe_fd)
chrisjbillington:                     self.read_pipe_fd = None
chrisjbillington:                     break
chrisjbillington:                 self.sock.send_multipart([streamname_bytes, s])
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class Process(object):
chrisjbillington:     """A class providing similar functionality to multiprocessing.Process, but
chrisjbillington:     using zmq for communication and creating processes in a fresh environment
chrisjbillington:     rather than by forking (or imitation forking as in Windows). Do not override
chrisjbillington:     its methods other than run()."""
chrisjbillington: 
chrisjbillington:     def __init__(self, process_tree, output_redirection_port=None,
chrisjbillington:                  remote_process_client=None):
chrisjbillington:         self._redirection_port = output_redirection_port
chrisjbillington:         self.process_tree = process_tree
chrisjbillington:         self.to_child = None
chrisjbillington:         self.from_child = None
chrisjbillington:         self.child = None
chrisjbillington:         self.to_parent = None
chrisjbillington:         self.from_parent = None
chrisjbillington:         self.kill_lock = None
chrisjbillington:         self.remote_process_client = remote_process_client
chrisjbillington: 
chrisjbillington:     def start(self, *args, **kwargs):
chrisjbillington:         """Call in the parent process to start a subprocess. Passes args and
chrisjbillington:         kwargs to the run() method"""
chrisjbillington:         path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
chrisjbillington:                             'process_class_wrapper.py')
chrisjbillington:         child_details = self.process_tree.subprocess(path,
chrisjbillington:                             output_redirection_port=self._redirection_port,
chrisjbillington:                             remote_process_client=self.remote_process_client)
chrisjbillington:         self.to_child, self.from_child, self.child = child_details
chrisjbillington:         # Get the file that the class definition is in (not this file you're
chrisjbillington:         # reading now, rather that of the subclass):
chrisjbillington:         module_file = os.path.abspath(sys.modules[self.__module__].__file__)
chrisjbillington:         basepath, extension = os.path.splitext(module_file)
chrisjbillington:         if extension == '.pyc':
chrisjbillington:             module_file = basepath + '.py'
chrisjbillington:         if not os.path.exists(module_file):
chrisjbillington:             # Nope? How about this extension then?
chrisjbillington:             module_file = basepath + '.pyw'
chrisjbillington:         if not os.path.exists(module_file):
chrisjbillington:             # Still no? Well I can't really work out what the extension is then,
chrisjbillington:             # can I?
chrisjbillington:             msg = ("Can't find module file, what's going on, does " +
chrisjbillington:                    "it have an unusual extension?")
chrisjbillington:             raise NotImplementedError(msg)
chrisjbillington:         # Send it to the child process so it can execute it in __main__,
chrisjbillington:         # otherwise class definitions from the users __main__ module will not be
chrisjbillington:         # unpickleable. Note that though executed in __main__, the code's
chrisjbillington:         # __name__ will not be __main__, and so any main block won't execute,
chrisjbillington:         # which is good!
chrisjbillington:         self.to_child.put([self.__module__, module_file, sys.path])
chrisjbillington:         self.to_child.put(self.__class__)
chrisjbillington:         self.to_child.put([args, kwargs])
chrisjbillington:         return self.to_child, self.from_child
chrisjbillington: 
chrisjbillington:     def _run(self):
chrisjbillington:         """Called in the child process to set up the connection with the
chrisjbillington:         parent"""
chrisjbillington:         self.to_parent = self.process_tree.to_parent
chrisjbillington:         self.from_parent = self.process_tree.from_parent
chrisjbillington:         self.kill_lock = self.process_tree.kill_lock
chrisjbillington:         args, kwargs = self.from_parent.get()
chrisjbillington:         self.run(*args, **kwargs)
chrisjbillington: 
chrisjbillington:     def terminate(self):
chrisjbillington:         try:
chrisjbillington:             self.child.terminate()
chrisjbillington:             self.child.wait()
chrisjbillington:         except OSError:
chrisjbillington:             pass  # process is already dead
chrisjbillington: 
chrisjbillington:     def run(self, *args, **kwargs):
chrisjbillington:         """The method that gets called in the subprocess. To be overridden by
chrisjbillington:         subclasses"""
chrisjbillington:         pass
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class RemoteChildProxy(object):
chrisjbillington:     def __init__(self, remote_process_client, pid):
chrisjbillington:         """Class to wrap operations on a remote subprocess"""
chrisjbillington:         self.client = remote_process_client
chrisjbillington:         self.pid = pid
chrisjbillington: 
chrisjbillington:     def terminate(self):
chrisjbillington:         return self.client.request('terminate', self.pid)
chrisjbillington: 
chrisjbillington:     def kill(self):
chrisjbillington:         return self.client.request('kill', self.pid)
chrisjbillington: 
chrisjbillington:     def wait(self, timeout=None):
chrisjbillington:         # The server will only do 0.01 second timeouts at a time to not be blocked
chrisjbillington:         # from other requests, so we will make requests at 0.1 second intervals to
chrisjbillington:         # reach whatever the requested timeout was:
chrisjbillington:         if timeout is not None:
chrisjbillington:             end_time = time.time() + timeout
chrisjbillington:         while True:
chrisjbillington:             try:
chrisjbillington:                 return self.client.request('wait', self.pid)
chrisjbillington:             except TimeoutError:
chrisjbillington:                 if timeout is not None and time.time() > end_time:
chrisjbillington:                     raise
chrisjbillington:                 else:
chrisjbillington:                     time.sleep(0.1)
chrisjbillington: 
chrisjbillington:     def poll(self):
chrisjbillington:         return self.client.request('poll', self.pid)
chrisjbillington: 
chrisjbillington:     @property
chrisjbillington:     def returncode(self):
chrisjbillington:         return self.client.request('returncode', self.pid)
chrisjbillington: 
chrisjbillington:     def __del__(self):
chrisjbillington:         print('del!')
chrisjbillington:         self.client.request('__del__', self.pid)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class RemoteProcessClient(zprocess.clientserver.ZMQClient):
chrisjbillington:     """A class to represent communication with a RemoteProcessServer"""
chrisjbillington:     def __init__(self, host, port=7340, shared_secret=None, allow_insecure=False):
chrisjbillington:         zprocess.clientserver.ZMQClient.__init__(self, shared_secret=shared_secret,
chrisjbillington:                                                  allow_insecure=allow_insecure)
chrisjbillington:         self.host = host
chrisjbillington:         self.port = port
chrisjbillington:         self.shared_secret = shared_secret
chrisjbillington: 
chrisjbillington:     def request(self, command, *args, **kwargs):
chrisjbillington:         return self.get(self.port, host=self.host,
chrisjbillington:                         data=[command, args, kwargs],
chrisjbillington:                         timeout=5)
chrisjbillington: 
chrisjbillington:     def Popen(self, command):
chrisjbillington:         pid = self.request('Popen', command)
chrisjbillington:         return RemoteChildProxy(self, pid)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ProcessTree(object):
chrisjbillington:     def __init__(self, shared_secret=None, allow_insecure=False):
chrisjbillington:         self.shared_secret = shared_secret
chrisjbillington:         self.allow_insecure = allow_insecure
chrisjbillington:         self.broker = None
chrisjbillington:         self.broker_host = None
chrisjbillington:         self.broker_in_port = None
chrisjbillington:         self.broker_out_port = None
chrisjbillington:         self.heartbeat_server = None
chrisjbillington:         self.heartbeat_client = None
chrisjbillington:         self.to_parent = None
chrisjbillington:         self.from_parent = None
chrisjbillington:         self.kill_lock = None
chrisjbillington: 
chrisjbillington:     def _check_broker(self):
chrisjbillington:         if self.broker_in_port is None:
chrisjbillington:             # We don't have a parent with a broker: it is our responsibility to
chrisjbillington:             # make a broker:
chrisjbillington:             self.broker = EventBroker(shared_secret=self.shared_secret,
chrisjbillington:                                       allow_insecure=self.allow_insecure)
chrisjbillington:             self.broker_host = 'localhost'
chrisjbillington:             self.broker_in_port = self.broker.in_port
chrisjbillington:             self.broker_out_port = self.broker.out_port
chrisjbillington: 
chrisjbillington:     def event(self, event_name, role='wait'):
chrisjbillington:         self._check_broker()
chrisjbillington:         return Event(self, event_name, role=role)
chrisjbillington: 
chrisjbillington:     def subprocess(self, path, output_redirection_port=None,
chrisjbillington:                    remote_process_client=None):
chrisjbillington:         context = SecureContext.instance(shared_secret=self.shared_secret)
chrisjbillington:         to_child = context.socket(zmq.PUSH, allow_insecure=self.allow_insecure)
chrisjbillington:         from_child = context.socket(zmq.PULL, allow_insecure=self.allow_insecure)
chrisjbillington:         to_self = context.socket(zmq.PUSH, allow_insecure=self.allow_insecure)
chrisjbillington: 
chrisjbillington:         from_child_port = from_child.bind_to_random_port('tcp://127.0.0.1')
chrisjbillington:         to_self.connect('tcp://127.0.0.1:%s' % from_child_port)
chrisjbillington:         to_child_port = to_child.bind_to_random_port('tcp://127.0.0.1')
chrisjbillington:         self._check_broker()
chrisjbillington:         if self.heartbeat_server is None:
chrisjbillington:             # First child process, we need a heartbeat server:
chrisjbillington:             self.heartbeat_server = HeartbeatServer(
chrisjbillington:                                         shared_secret=self.shared_secret)
chrisjbillington: 
chrisjbillington:         #TODO: fix this:
chrisjbillington:         # If a custom process identifier has been set in zlock, ensure the child
chrisjbillington:         # inherits it:
chrisjbillington:         try:
chrisjbillington:             zlock = sys.modules['zprocess.zlock']
chrisjbillington:             zlock_process_identifier_prefix = zlock.process_identifier_prefix
chrisjbillington:         except KeyError:
chrisjbillington:             zlock_process_identifier_prefix = ''
chrisjbillington: 
chrisjbillington:         parentinfo = {'parent_host': 'localhost',
chrisjbillington:                       'to_parent_port': from_child_port,
chrisjbillington:                       'from_parent_port': to_child_port,
chrisjbillington:                       'heartbeat_server_host': 'localhost',
chrisjbillington:                       'heartbeat_server_port': self.heartbeat_server.port,
chrisjbillington:                       'broker_host': 'localhost',
chrisjbillington:                       'broker_in_port': self.broker_in_port,
chrisjbillington:                       'broker_out_port': self.broker_out_port,
chrisjbillington:                       'output_redirection_host': 'localhost',
chrisjbillington:                       'output_redirection_port': output_redirection_port,
chrisjbillington:                       'shared_secret': self.shared_secret,
chrisjbillington:                       'allow_insecure': self.allow_insecure,
chrisjbillington:                       'zlock_process_identifier_prefix':
chrisjbillington:                           zlock_process_identifier_prefix,
chrisjbillington:                       }
chrisjbillington: 
chrisjbillington:         command = [sys.executable, os.path.abspath(path),
chrisjbillington:                    '--zprocess-parentinfo', json.dumps(parentinfo)]
chrisjbillington: 
chrisjbillington:         if remote_process_client is None:
chrisjbillington:             child = subprocess.Popen(command)
chrisjbillington:         else:
chrisjbillington:             raise NotImplementedError("This feature is not yet complete")
chrisjbillington:             child = remote_process_client.Popen(command)
chrisjbillington: 
chrisjbillington:         # The child has 15 seconds to connect to us:
chrisjbillington:         events = from_child.poll(15000)
chrisjbillington:         if not events:
chrisjbillington:             raise RuntimeError('child process did not connect within the timeout.')
chrisjbillington:         assert from_child.recv() == b'hello'
chrisjbillington: 
chrisjbillington:         to_child = WriteQueue(to_child)
chrisjbillington:         from_child = ReadQueue(from_child, to_self)
chrisjbillington: 
chrisjbillington:         return to_child, from_child, child
chrisjbillington: 
chrisjbillington:     def _connect_to_parent(self, lock, parentinfo):
chrisjbillington: 
chrisjbillington:         # If a custom process identifier has been set in zlock, ensure we
chrisjbillington:         # inherit it:
chrisjbillington:         zlock_pid_prefix = parentinfo.get('zlock_process_identifier_prefix', None)
chrisjbillington:         if zlock_pid_prefix is not None:
chrisjbillington:             import zprocess.locking
chrisjbillington:             # Append '-sub' to indicate we're a subprocess, if it's not already
chrisjbillington:             # there
chrisjbillington:             if not zlock_pid_prefix.endswith('sub'):
chrisjbillington:                 zlock_pid_prefix += 'sub'
chrisjbillington:             # Only set it if the user has not already set it to something in
chrisjbillington:             # this process:
chrisjbillington:             if not zprocess.locking.process_identifier_prefix:
chrisjbillington:                 zprocess.locking.set_client_process_name(zlock_pid_prefix)
chrisjbillington: 
chrisjbillington:         context = SecureContext.instance(shared_secret=self.shared_secret)
chrisjbillington:         to_parent = context.socket(zmq.PUSH, allow_insecure=self.allow_insecure)
chrisjbillington:         from_parent = context.socket(zmq.PULL, allow_insecure=self.allow_insecure)
chrisjbillington:         to_self = context.socket(zmq.PUSH, allow_insecure=self.allow_insecure)
chrisjbillington: 
chrisjbillington:         port_to_self = to_self.bind_to_random_port('tcp://127.0.0.1')
chrisjbillington:         from_parent.connect('tcp://127.0.0.1:%d' % parentinfo['from_parent_port'])
chrisjbillington:         from_parent.connect('tcp://127.0.0.1:%d' % port_to_self)
chrisjbillington:         to_parent.connect("tcp://127.0.0.1:%s" %  parentinfo['to_parent_port'])
chrisjbillington:         to_parent.send(b'hello')
chrisjbillington: 
chrisjbillington:         self.from_parent = ReadQueue(from_parent, to_self)
chrisjbillington:         self.to_parent = WriteQueue(to_parent)
chrisjbillington: 
chrisjbillington:         output_redirection_host = parentinfo.get('output_redirection_host', None)
chrisjbillington:         output_redirection_port = parentinfo.get('output_redirection_port', None)
chrisjbillington:         if output_redirection_port is not None:
chrisjbillington:             stdout = OutputInterceptor(output_redirection_host,
chrisjbillington:                                        output_redirection_port,
chrisjbillington:                                        shared_secret=self.shared_secret,
chrisjbillington:                                        allow_insecure=self.allow_insecure)
chrisjbillington:             stderr = OutputInterceptor(output_redirection_host,
chrisjbillington:                                        output_redirection_port,
chrisjbillington:                                        streamname='stderr',
chrisjbillington:                                        shared_secret=self.shared_secret,
chrisjbillington:                                        allow_insecure=self.allow_insecure)
chrisjbillington:             stdout.connect()
chrisjbillington:             stderr.connect()
chrisjbillington: 
chrisjbillington:         heartbeat_server_host = parentinfo['heartbeat_server_host']
chrisjbillington:         heartbeat_server_port = parentinfo['heartbeat_server_port']
chrisjbillington:         self.heartbeat_client = HeartbeatClient(heartbeat_server_host,
chrisjbillington:                                                 heartbeat_server_port,
chrisjbillington:                                                 shared_secret=self.shared_secret,
chrisjbillington:                                                 allow_insecure=self.allow_insecure,
chrisjbillington:                                                 lock=lock)
chrisjbillington: 
chrisjbillington:         self.broker_host = parentinfo['broker_host']
chrisjbillington:         self.broker_in_port = parentinfo['broker_in_port']
chrisjbillington:         self.broker_out_port = parentinfo['broker_out_port']
chrisjbillington:         self.kill_lock = self.heartbeat_client.lock
chrisjbillington: 
chrisjbillington:     @classmethod
chrisjbillington:     def connect_to_parent(cls, lock=False):
chrisjbillington:         for i, arg in enumerate(sys.argv):
chrisjbillington:             if arg == '--zprocess-parentinfo':
chrisjbillington:                 parentinfo = json.loads(sys.argv[i+1])
chrisjbillington:                 break
chrisjbillington:         else:
chrisjbillington:             msg = "No zprocess parent info in command line args"
chrisjbillington:             raise RuntimeError(msg)
chrisjbillington: 
chrisjbillington:         process_tree = cls(shared_secret=parentinfo['shared_secret'],
chrisjbillington:                            allow_insecure=parentinfo['allow_insecure'])
chrisjbillington: 
chrisjbillington:         process_tree._connect_to_parent(lock, parentinfo)
chrisjbillington: 
chrisjbillington:         return process_tree
chrisjbillington: 
chrisjbillington: 
chrisjbillington: 
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # Backwards compatability follows:
chrisjbillington: 
chrisjbillington: # A default process tree for all out backward compat functions to work with:
chrisjbillington: _default_process_tree = ProcessTree(allow_insecure=True)
chrisjbillington: 
chrisjbillington: # Allow instantiating an Event without a ProcessTree as the first argument,
chrisjbillington: # insert a default ProcessTree:
chrisjbillington: _Event = Event
chrisjbillington: class Event(_Event):
chrisjbillington:     def __init__(self, *args, **kwargs):
chrisjbillington:         # Convert the keyword argument renaming:
chrisjbillington:         if 'type' in kwargs:
chrisjbillington:             kwargs['role'] = kwargs['type']
chrisjbillington:             del kwargs['type']
chrisjbillington:         if not args or not isinstance(args[0], ProcessTree):
chrisjbillington:             args = (_default_process_tree,) + args
chrisjbillington:         _Event.__init__(self, *args, **kwargs)
chrisjbillington: 
chrisjbillington: # Allow instantiating a Process() without a ProcessTree as the first argument,
chrisjbillington: # insert a default ProcessTree:
chrisjbillington: _Process = Process
chrisjbillington: class Process(_Process):
chrisjbillington:     def __init__(self, *args, **kwargs):
chrisjbillington:         if not args or not isinstance(args[0], ProcessTree):
chrisjbillington:             args = (_default_process_tree,) + args
chrisjbillington:         _Process.__init__(self, *args, **kwargs)
chrisjbillington:         
chrisjbillington:     def _run(self):
chrisjbillington:         # Set the process tree as the default for this process:
chrisjbillington:         global _default_process_tree
chrisjbillington:         _default_process_tree = self.process_tree
chrisjbillington:         _Process._run(self)
chrisjbillington: 
chrisjbillington: # New way is to call ProcessTree.connect_to_parent(lock) and get back a
chrisjbillington: # ProcessTree. This is the old way, returning queues and (optionally) a lock
chrisjbillington: # instead:
chrisjbillington: def setup_connection_with_parent(lock=False):
chrisjbillington:     process_tree = ProcessTree.connect_to_parent(lock)
chrisjbillington:     # Set as the default for this process:
chrisjbillington:     global _default_process_tree
chrisjbillington:     _default_process_tree = process_tree
chrisjbillington:     if lock:
chrisjbillington:         return (process_tree.to_parent,
chrisjbillington:                 process_tree.from_parent,
chrisjbillington:                 process_tree.kill_lock)
chrisjbillington:     else:
chrisjbillington:         return process_tree.to_parent, process_tree.from_parent
chrisjbillington: 
chrisjbillington: # New way is to instantiate a ProcessTree and call
chrisjbillington: # process_tree.subprocess(). Old way is:
chrisjbillington: def subprocess_with_queues(path, output_redirection_port=None):
chrisjbillington:     if output_redirection_port == 0: # This used to mean no redirection
chrisjbillington:         output_redirection_port = None
chrisjbillington:     return _default_process_tree.subprocess(path, output_redirection_port)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: 
chrisjbillington: __all__ = ['Process', 'ProcessTree', 'setup_connection_with_parent',
chrisjbillington:            'subprocess_with_queues', 'Event']
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # if __name__ == '__main__':
chrisjbillington:     # def foo():
chrisjbillington:     #     remote_client = RemoteProcessClient('localhost', allow_insecure=True)
chrisjbillington:     #     to_child, from_child, child = _default_process_tree.subprocess(
chrisjbillington:     #         'test_remote.py', remote_process_client=remote_client)
chrisjbillington:     # foo()
chrisjbillington: 
chrisjbillington:     
chrisjbillington: # What does the command server need to do? It needs to start up and start listening
chrisjbillington: # publicly on the command server port, and the heartbeating port.
chrisjbillington: 
chrisjbillington: # when it recieves a command, it should launch a subprocess. How does it know what
chrisjbillington: # the ports are? Maybe the ports are JSON, and prefixed by --zprocess_parentinfo,
chrisjbillington: # for backward compatibility and to allow other args to be passed into the program.
chrisjbillington: 
chrisjbillington: # For each parent heartbeating server, it will have a HeartBeatProxy, which is both
chrisjbillington: # a heartbeat server and client.
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: PY2 = sys.version_info.major == 2
chrisjbillington: import os
chrisjbillington: if PY2:
chrisjbillington:     import subprocess32 as subprocess
chrisjbillington: else:
chrisjbillington:     import subprocess
chrisjbillington: 
chrisjbillington: _splitcwd = os.getcwd().split(os.path.sep)
chrisjbillington: _path = os.path.join(*_splitcwd[:-2])
chrisjbillington: _cwd = os.path.join(*_splitcwd[-2:])
chrisjbillington: 
chrisjbillington: if _cwd == os.path.join('zprocess', 'remote') and _path not in sys.path:
chrisjbillington:     # Running from within zprocess dir? Add to sys.path for testing during
chrisjbillington:     # development:
chrisjbillington:     print(_path)
chrisjbillington:     sys.path.insert(0, _path)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: import zprocess
chrisjbillington: from zprocess import ZMQServer
chrisjbillington: print(sys.path[0])
chrisjbillington: print(zprocess.__file__)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class RemoteProcessServer(ZMQServer):
chrisjbillington:     DEFAULT_PORT = 7340
chrisjbillington:     def __init__(self, port, bind_address='tcp://0.0.0.0', shared_secret=None,
chrisjbillington:                  allow_insecure=True):
chrisjbillington:         ZMQServer.__init__(self, port, bind_address=bind_address,
chrisjbillington:                            shared_secret=shared_secret,
chrisjbillington:                            allow_insecure=allow_insecure)
chrisjbillington:         # Entries should be removed from this dict if the parent calls __del__ on
chrisjbillington:         # the proxy, or if the parent stops responding to heartbeats:
chrisjbillington:         self.children = {}
chrisjbillington: 
chrisjbillington:     def proxy_terminate(self, pid):
chrisjbillington:         return self.children[pid].terminate()
chrisjbillington: 
chrisjbillington:     def proxy_kill(self, pid):
chrisjbillington:         return self.children[pid].kill()
chrisjbillington: 
chrisjbillington:     def proxy_wait(self, pid):
chrisjbillington:         # We only wait for 10ms - the client can implement a blocking wait by
chrisjbillington:         # calling multiple times, we don't want to be blocked here:
chrisjbillington:         return self.children[pid].wait(0.01)
chrisjbillington: 
chrisjbillington:     def proxy_poll(self, pid):
chrisjbillington:         return self.children[pid].poll()
chrisjbillington: 
chrisjbillington:     def proxy_returncode(self):
chrisjbillington:         return self.client.returncode
chrisjbillington: 
chrisjbillington:     def proxy___del__(self, pid):
chrisjbillington:         del self.children[pid]
chrisjbillington: 
chrisjbillington:     def proxy_Popen(self, args):
chrisjbillington:         child = subprocess.Popen(args)
chrisjbillington:         self.children[child.pid] = child
chrisjbillington:         return child.pid
chrisjbillington: 
chrisjbillington:     def handler(self, data):
chrisjbillington:         command, args, kwargs = data
chrisjbillington:         print(command, args, kwargs)
chrisjbillington:         return getattr(self, 'proxy_' + command)(*args, **kwargs)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: if __name__ == '__main__':
chrisjbillington:     print("Starting RemoteProcessServer on port", RemoteProcessServer.DEFAULT_PORT)
chrisjbillington:     server = RemoteProcessServer(RemoteProcessServer.DEFAULT_PORT)
chrisjbillington:     print('Press Ctrl-C to shutdown')
chrisjbillington:     server.shutdown_on_interrupt()
chrisjbillington: from __future__ import print_function, unicode_literals, division
chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: import ctypes
chrisjbillington: import base64
chrisjbillington: import weakref
chrisjbillington: 
chrisjbillington: import ipaddress
chrisjbillington: import zmq
chrisjbillington: import zmq.auth.thread
chrisjbillington: 
chrisjbillington: if sys.version_info[0] == 2:
chrisjbillington:     str = unicode
chrisjbillington: 
chrisjbillington: def _check_versions():
chrisjbillington:     if not zmq.zmq_version_info() >= (4, 0, 0):
chrisjbillington:         raise ImportError('Require libzmq >= 4.0')
chrisjbillington: 
chrisjbillington:     _libzmq = ctypes.CDLL(zmq.backend.cython.utils.__file__)
chrisjbillington:     if not hasattr(_libzmq, 'sodium_init'):
chrisjbillington:         msg = ('zprocess warning: libzmq not built with libsodium. ' +
chrisjbillington:                'Encryption/decryption will be slow. If on Windows, ' +
chrisjbillington:                'use conda zeromq/pyzmq packages for fast crypto.\n')
chrisjbillington:         sys.stderr.write(msg)
chrisjbillington: 
chrisjbillington:     if not hasattr(zmq, 'curve_public'):
chrisjbillington:         # Access the function via ctypes if not in pyzmq:
chrisjbillington:         if hasattr(_libzmq, 'zmq_curve_public'):
chrisjbillington:             # Use the zeromq function
chrisjbillington:             def _curve_public(secret_key):
chrisjbillington:                 public_key = b'0' * 40
chrisjbillington:                 zmq.error._check_rc(_libzmq.zmq_curve_public(public_key,
chrisjbillington:                                                              secret_key))
chrisjbillington:                 return public_key
chrisjbillington:         else:
chrisjbillington:             # Old zeromq, use its crypto library function directly:
chrisjbillington:             if hasattr(_libzmq, 'crypto_scalarmult_base'):
chrisjbillington:                 def _curve_public(secret_key):
chrisjbillington:                     public_key_bytes = b'0' * 40
chrisjbillington:                     secret_key_bytes = zmq.utils.z85.decode(secret_key)
chrisjbillington:                     _libzmq.crypto_scalarmult_base(public_key_bytes,
chrisjbillington:                                                    secret_key_bytes)
chrisjbillington:                     return zmq.utils.z85.encode(public_key_bytes[:32])
chrisjbillington:             else:
chrisjbillington:                 # Old zeromq, and not built with libsodium. We can't proceed.
chrisjbillington:                 msg = ("Require zeromq >= 4.2.0, " +
chrisjbillington:                        "or zeromq >= 4.0.0 built with libsodium")
chrisjbillington:                 raise ImportError(msg)
chrisjbillington:         zmq.curve_public = _curve_public
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class InsecureConnection(RuntimeError):
chrisjbillington:     pass
chrisjbillington: 
chrisjbillington: 
chrisjbillington: INSECURE_ERROR = ' '.join(
chrisjbillington: """Plaintext socket send() or recv() on external interface. This can allow an
chrisjbillington: attacker arbitrary code execution if you receive and unpickle Python objects,
chrisjbillington: and open your application to other attacks. Unless your network is fully
chrisjbillington: trusted, pass a preshared secret generated by generate_shared_secret() to the
chrisjbillington: SecureContext() to secure your connection, or bind only on the internal
chrisjbillington: network interface if communication is internal. To proceed insecurely at your
chrisjbillington: own risk, use to SecureContext.socket(sockettype,
chrisjbillington: allow_insecure=True)""".splitlines())
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def generate_shared_secret():
chrisjbillington:     """Compute a new pair of random CurveZMQ secret keys, decode them from z85
chrisjbillington:     encoding, and return the result as a base64 encoded unicode string as suitable
chrisjbillington:     for passing to SecureContext() or storing on disk. We use base64 because it is
chrisjbillington:     more compatible with Python config files than z85."""
chrisjbillington:     _check_versions()
chrisjbillington:     _, client_secret = zmq.curve_keypair()
chrisjbillington:     _, server_secret = zmq.curve_keypair()
chrisjbillington:     return base64.b64encode(zmq.utils.z85.decode(client_secret) + 
chrisjbillington:                             zmq.utils.z85.decode(server_secret)).decode('utf8')
chrisjbillington: 
chrisjbillington: def _unpack_shared_secret(shared_secret):
chrisjbillington:     """Base64 decode, split and z85 encode the shared secret to produce the
chrisjbillington:     client and server CurveZMQ secret keys."""
chrisjbillington:     binary_secret = base64.b64decode(shared_secret)
chrisjbillington:     if not len(binary_secret) == 64:
chrisjbillington:         msg = 'Shared secret should be 64 bytes, got %d' % len(binary_secret)
chrisjbillington:         raise ValueError(msg)
chrisjbillington:     client_secret, server_secret = binary_secret[:32], binary_secret[32:]
chrisjbillington:     return zmq.utils.z85.encode(client_secret), zmq.utils.z85.encode(server_secret)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class SecureSocket(zmq.Socket):
chrisjbillington:     """A Socket that configures as a CurveZMQ server upon bind() and as a
chrisjbillington:     CurveZMQ client upon connect(), using the keys held by the parent
chrisjbillington:     SecureContext to authenticate and be authenticated by its peer. If the
chrisjbillington:     shared_secret passed to the parent SecureContext() was None, then
chrisjbillington:     plaintext sockets will be used, but InsecureConnection will be raised if
chrisjbillington:     send() or recv() are called when bound or connected to an external network
chrisjbillington:     interface. This can be suppressed by passing allow_insecure=True to the
chrisjbillington:     Context.socket() call. inproc:// connections are not secured."""
chrisjbillington: 
chrisjbillington:     # Dummy class attrs to distinguish from zmq options:
chrisjbillington:     secure = None
chrisjbillington:     allow_insecure = None
chrisjbillington: 
chrisjbillington:     def __init__(self, *args, **kwargs):
chrisjbillington:         self.allow_insecure = kwargs.pop('allow_insecure', False)
chrisjbillington:         zmq.Socket.__init__(self, *args, **kwargs)
chrisjbillington: 
chrisjbillington:     def _is_internal(self, endpoint):
chrisjbillington:         """Return whether a bind or connect endpoint is on an internal
chrisjbillington:         interface"""
chrisjbillington:         import socket
chrisjbillington:         if endpoint.startswith('inproc://'):
chrisjbillington:             return True
chrisjbillington:         if endpoint.startswith('tcp://'):
chrisjbillington:             host = ''.join(''.join(endpoint.split('//')[1:]).split(':')[0])
chrisjbillington:             if host == '*':
chrisjbillington:                 return False
chrisjbillington:             address = socket.gethostbyname(host)
chrisjbillington:             if isinstance(address, bytes):
chrisjbillington:                 address = address.decode()
chrisjbillington:             return ipaddress.ip_address(address).is_loopback
chrisjbillington:         return False
chrisjbillington: 
chrisjbillington:     def _configure_curve(self, server):
chrisjbillington:         """Set the curve configuration of the socket depending on whether we
chrisjbillington:         are a server or not"""
chrisjbillington:         orig_server = self.curve_server
chrisjbillington:         if server:
chrisjbillington:             self.curve_publickey = self.context.server_publickey
chrisjbillington:             self.curve_secretkey = self.context.server_secretkey
chrisjbillington:             self.curve_server = True
chrisjbillington:         else:
chrisjbillington:             self.curve_server = False
chrisjbillington:             self.curve_publickey = self.context.client_publickey
chrisjbillington:             self.curve_secretkey = self.context.client_secretkey
chrisjbillington:             self.curve_serverkey = self.context.server_publickey
chrisjbillington:         return orig_server
chrisjbillington:         
chrisjbillington:     def _bind_or_connect(self, addr, bind=False, connect=False):
chrisjbillington:         assert bool(bind) != bool(connect)
chrisjbillington:         method = zmq.Socket.bind if bind else zmq.Socket.connect
chrisjbillington:         if addr.startswith('inproc://'):
chrisjbillington:             # No crypto/auth on inproc:
chrisjbillington:             self.secure = True
chrisjbillington:             return method(self, addr)
chrisjbillington:         if self.context.secure:
chrisjbillington:             prev_setting = self._configure_curve(server=bind)
chrisjbillington:         try:
chrisjbillington:             return method(self, addr)
chrisjbillington:         except:
chrisjbillington:             if self.context.secure:
chrisjbillington:                 # Roll back configuration:
chrisjbillington:                 self._configure_curve(server=prev_setting)
chrisjbillington:             raise
chrisjbillington:         finally:
chrisjbillington:             self.secure = self.context.secure or self._is_internal(addr)
chrisjbillington: 
chrisjbillington:     def bind(self, addr):
chrisjbillington:         return self._bind_or_connect(addr, bind=True)
chrisjbillington: 
chrisjbillington:     def connect(self, addr):
chrisjbillington:         return self._bind_or_connect(addr, connect=True)
chrisjbillington: 
chrisjbillington:     def _checkinsecure(self, method, *args, **kwargs):
chrisjbillington:         if not (self.secure or self.allow_insecure):
chrisjbillington:             raise InsecureConnection(INSECURE_ERROR)
chrisjbillington:         return method(self, *args, **kwargs)
chrisjbillington: 
chrisjbillington:     def send(self, *args, **kwargs):
chrisjbillington:         return self._checkinsecure(zmq.Socket.send, *args, **kwargs)
chrisjbillington: 
chrisjbillington:     def recv(self, *args, **kwargs):
chrisjbillington:         return self._checkinsecure(zmq.Socket.recv, *args, **kwargs)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class SecureContext(zmq.Context):
chrisjbillington:     """A ZeroMQ Context with SecureContext.socket() returning a
chrisjbillington:     SecureSocket(), which can authenticate and communicate securely with all
chrisjbillington:     other SecureSocket() instances with a SecureContext sharing a
chrisjbillington:     shared_secret as returned by generate_shared_secret() and distributed
chrisjbillington:     securely to all authorised peers."""
chrisjbillington: 
chrisjbillington:     _socket_class = SecureSocket
chrisjbillington:     _instances = weakref.WeakValueDictionary()
chrisjbillington:     # Dummy class attrs to distinguish from zmq options:
chrisjbillington:     secure = False
chrisjbillington:     client_publickey = None
chrisjbillington:     client_secretkey = None
chrisjbillington:     server_publickey = None
chrisjbillington:     server_secretkey = None
chrisjbillington: 
chrisjbillington:     def __init__(self, io_threads=1, shared_secret=None):
chrisjbillington:         zmq.Context.__init__(self, io_threads)
chrisjbillington:         if shared_secret is not None:
chrisjbillington:             _check_versions()
chrisjbillington:             keys = _unpack_shared_secret(shared_secret)
chrisjbillington:             self.client_secretkey, self.server_secretkey = keys
chrisjbillington:             self.client_publickey = zmq.curve_public(self.client_secretkey)
chrisjbillington:             self.server_publickey = zmq.curve_public(self.server_secretkey)
chrisjbillington:             # Don't hold ref to auth: needed for auto cleanup at shutdown:
chrisjbillington:             auth = zmq.auth.thread.ThreadAuthenticator(self)
chrisjbillington:             auth.start()
chrisjbillington:             # Allow only clients who have the client public key:
chrisjbillington:             auth.thread.authenticator.allow_any = False
chrisjbillington:             auth.thread.authenticator.certs['*'] = {self.client_publickey: True}
chrisjbillington:             self.secure = True
chrisjbillington: 
chrisjbillington:     @classmethod
chrisjbillington:     def instance(cls, io_threads=1, shared_secret=None):
chrisjbillington:         """Returns a shared instance with the same shared secret, if there is
chrisjbillington:         one, otherwise creates it. If an instance already exists, io_threads
chrisjbillington:         will be ignored, otherwise it will be used in the new instance"""
chrisjbillington:         try:
chrisjbillington:             return cls._instances[shared_secret]
chrisjbillington:         except KeyError:
chrisjbillington:             instance = cls(io_threads, shared_secret=shared_secret)
chrisjbillington:             cls._instances[shared_secret] = instance
chrisjbillington:             return instance
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: import threading
chrisjbillington: import subprocess
chrisjbillington: import time
chrisjbillington: 
chrisjbillington: import zmq
chrisjbillington: from zmq.utils.monitor import recv_monitor_message
chrisjbillington: 
chrisjbillington: PY2 = sys.version_info[0] == 2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class TimeoutError(zmq.ZMQError):
chrisjbillington:     pass
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def _reraise(exc_info):
chrisjbillington:     exctype, value, traceback = exc_info
chrisjbillington:     # handle python2/3 difference in raising exception        
chrisjbillington:     if PY2:
chrisjbillington:         exec('raise exctype, value, traceback', globals(), locals())
chrisjbillington:     else:
chrisjbillington:         raise value.with_traceback(traceback)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def raise_exception_in_thread(exc_info):
chrisjbillington:     """Raises an exception in a thread"""
chrisjbillington:     threading.Thread(target=_reraise, args=(exc_info,)).start()
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def start_daemon(cmd_args):
chrisjbillington:     """calls subprocess.Popen configured to detach the subprocess from the
chrisjbillington:     parent, such that it keeps running even if the parent exits. Returns None.
chrisjbillington:     Note that the child process will have its current working directory set to
chrisjbillington:     the value of tempfile.gettempdir(), rather than remaining in the parent's
chrisjbillington:     working directory. In Windows this prevents it holding a lock on the
chrisjbillington:     current directory, which would prevent it from being deleted, and the
chrisjbillington:     behaviour is the same on unix for consistency."""
chrisjbillington:     import tempfile
chrisjbillington:     if os.name == 'nt':
chrisjbillington:         creationflags=0x00000008 # DETACHED_PROCESS from the win32 API
chrisjbillington:         subprocess.Popen(cmd_args,
chrisjbillington:                          creationflags=creationflags, stdout=None, stderr=None,
chrisjbillington:                          close_fds=True, cwd=tempfile.gettempdir())
chrisjbillington:     else:
chrisjbillington:         devnull = open(os.devnull,'w')
chrisjbillington:         if not os.fork():
chrisjbillington:             os.setsid()
chrisjbillington:             subprocess.Popen(cmd_args,
chrisjbillington:                              stdin=devnull, stdout=devnull, stderr=devnull,
chrisjbillington:                              close_fds=True, cwd=tempfile.gettempdir())
chrisjbillington:             os._exit(0)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: def embed():
chrisjbillington:     """embeds an IPython qt console in the calling scope.
chrisjbillington:     Intended for debugging. May cause strange interpreter behaviour."""
chrisjbillington: 
chrisjbillington:     # Imports, including ones we only need in the qtconsole process,
chrisjbillington:     # so that the user gets errors about them rather than just no qtconsole:
chrisjbillington: 
chrisjbillington:     from IPython.utils.frame import extract_module_locals
chrisjbillington:     from ipykernel.kernelapp import IPKernelApp
chrisjbillington:     from IPython.core.interactiveshell import InteractiveShell
chrisjbillington: 
chrisjbillington: 
chrisjbillington:     from zmq.eventloop import ioloop
chrisjbillington: 
chrisjbillington: 
chrisjbillington:     def launch_qtconsole():
chrisjbillington:         subprocess.call([sys.executable, '-c',
chrisjbillington:                         'from qtconsole.qtconsoleapp import main; main()',
chrisjbillington:                         '--existing', app.connection_file])
chrisjbillington:         if not kernel_has_quit.is_set():
chrisjbillington:             ioloop.IOLoop.instance().stop()
chrisjbillington: 
chrisjbillington:     kernel_has_quit = threading.Event()
chrisjbillington:     qtconsole_thread = threading.Thread(target=launch_qtconsole)
chrisjbillington:     qtconsole_thread.daemon = True
chrisjbillington: 
chrisjbillington: 
chrisjbillington:     # Hack to prevent the kernel app from disabline SIGINT:
chrisjbillington:     IPKernelApp.init_signal = lambda self: None
chrisjbillington: 
chrisjbillington:     # Get some interpreter state that will need to be restored after the
chrisjbillington:     # kernel quits:
chrisjbillington:     sys_state = sys.stdin, sys.stdout, sys.stderr, sys.displayhook, sys.excepthook
chrisjbillington:     ps1 = getattr(sys, 'ps1', None)
chrisjbillington:     ps2 = getattr(sys, 'ps2', None)
chrisjbillington:     ps3 = getattr(sys, 'ps3', None)
chrisjbillington: 
chrisjbillington:     # Some of the below copied from ipykernel.embed.embed_kernel
chrisjbillington:     app = IPKernelApp()
chrisjbillington:     app.initialize([])
chrisjbillington: 
chrisjbillington:     # Remove the exit handler, we'll run it manually rather than at
chrisjbillington:     # interpreter exit:
chrisjbillington:     # atexit.unregister(app.kernel.shell.atexit_operations)
chrisjbillington: 
chrisjbillington:     # Undo unnecessary sys module mangling from init_sys_modules.
chrisjbillington:     # This would not be necessary if we could prevent it
chrisjbillington:     # in the first place by using a different InteractiveShell
chrisjbillington:     # subclass, as in the regular embed case.
chrisjbillington:     main = app.kernel.shell._orig_sys_modules_main_mod
chrisjbillington:     if main is not None:
chrisjbillington:         sys.modules[app.kernel.shell._orig_sys_modules_main_name] = main
chrisjbillington: 
chrisjbillington:     # load the calling scope if not given
chrisjbillington:     (caller_module, caller_locals) = extract_module_locals(1)
chrisjbillington:     app.kernel.user_module = caller_module
chrisjbillington:     app.kernel.user_ns = caller_locals
chrisjbillington:     app.shell.set_completer_frame()
chrisjbillington: 
chrisjbillington:     qtconsole_thread.start()
chrisjbillington:     try:
chrisjbillington:         app.start()
chrisjbillington:     finally:
chrisjbillington:         sys.stdin, sys.stdout, sys.stderr, sys.displayhook, sys.excepthook = sys_state
chrisjbillington:         if ps1 is not None:
chrisjbillington:             sys.ps1 = ps1
chrisjbillington:         else:
chrisjbillington:             del sys.ps1
chrisjbillington:         if ps2 is not None:
chrisjbillington:             sys.ps2 = ps2
chrisjbillington:         else:
chrisjbillington:             del sys.ps2
chrisjbillington:         if ps3 is not None:
chrisjbillington:             sys.ps3 = ps3
chrisjbillington:         else:
chrisjbillington:             del sys.ps3
chrisjbillington:         kernel_has_quit.set()
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # __init__.py                                                       #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Chris Billington                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the zprocess project (see                    #
chrisjbillington: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
chrisjbillington: # the Simplified BSD License. See the license.txt file in the root  #
chrisjbillington: # of the project for the full license.                              #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
chrisjbillington: from __future__ import absolute_import
chrisjbillington: import sys
chrisjbillington: import os
chrisjbillington: import socket
chrisjbillington: import threading
chrisjbillington: import time
chrisjbillington: import logging
chrisjbillington: import subprocess
chrisjbillington: import zmq
chrisjbillington: 
chrisjbillington: import six
chrisjbillington: 
chrisjbillington: DEFAULT_PORT = 7341
chrisjbillington: import __main__
chrisjbillington: 
chrisjbillington: class ZMQLogClient(object):
chrisjbillington: 
chrisjbillington:     RESPONSE_TIMEOUT = 5000
chrisjbillington:     
chrisjbillington:     def __init__(self, host, port):
chrisjbillington:         self.host = socket.gethostbyname(host)
chrisjbillington:         self.port = port
chrisjbillington:         self.lock = threading.Lock()
chrisjbillington:         # We'll store one zmq socket/poller for each thread, with thread
chrisjbillington:         # local storage:
chrisjbillington:         self.local = threading.local()
chrisjbillington:         self.shutdown_complete = threading.Event()
chrisjbillington:          
chrisjbillington:     def new_req_socket(self):
chrisjbillington:         # Every time we get an error, we need to create a new req socket
chrisjbillington:         # to get things back on track. Also, we have a separate socket for
chrisjbillington:         # each thread so that these methods can be called simultaneously
chrisjbillington:         # from many threads:
chrisjbillington:         context = zmq.Context.instance()
chrisjbillington:         self.local.reqsock = context.socket(zmq.REQ)
chrisjbillington:         self.local.reqsock.setsockopt(zmq.LINGER, 0)
chrisjbillington:         self.local.poller = zmq.Poller()
chrisjbillington:         self.local.poller.register(self.local.reqsock, zmq.POLLIN)
chrisjbillington:         self.local.reqsock.connect('tcp://%s:%s'%(self.host, str(self.port)))
chrisjbillington:          
chrisjbillington:     def new_push_socket(self):
chrisjbillington:         # We have a separate socket for each thread so that these methods
chrisjbillington:         # can be called simultaneously from many threads:
chrisjbillington:         context = zmq.Context.instance()
chrisjbillington:         self.local.pushsock = context.socket(zmq.PUSH)
chrisjbillington:         self.local.pushsock.setsockopt(zmq.LINGER, 1000)
chrisjbillington:         try:
chrisjbillington:             self.local.pushsock.setsockopt(zmq.SNDHWM, 1000)
chrisjbillington:         except AttributeError:
chrisjbillington:             self.local.pushsock.setsockopt(zmq.HWM, 1000)
chrisjbillington:         self.local.pushsock.connect('tcp://%s:%s'%(self.host, str(self.port)))
chrisjbillington:         self.local.high_water_mark = False
chrisjbillington:         
chrisjbillington:     def say_hello(self,timeout=None):
chrisjbillington:         """Ping the server to test for a response"""
chrisjbillington:         try:
chrisjbillington:             if timeout is None:
chrisjbillington:                 timeout = self.RESPONSE_TIMEOUT
chrisjbillington:             else:
chrisjbillington:                 timeout = 1000*timeout # convert to ms
chrisjbillington:             if not hasattr(self.local,'reqsock'):
chrisjbillington:                 self.new_req_socket()
chrisjbillington:             start_time = time.time()
chrisjbillington:             self.local.reqsock.send('hello',zmq.NOBLOCK)
chrisjbillington:             events = self.local.poller.poll(timeout)
chrisjbillington:             if events:
chrisjbillington:                 response = self.local.reqsock.recv()
chrisjbillington:                 if response == 'hello':
chrisjbillington:                     return round((time.time() - start_time)*1000,2)
chrisjbillington:             raise zmq.ZMQError('No response from zlog server: timed out')
chrisjbillington:         except:
chrisjbillington:             self.local.reqsock.close(linger=False)
chrisjbillington:             del self.local.reqsock
chrisjbillington:             raise
chrisjbillington:     
chrisjbillington:     def log(self, logfile, logtext):
chrisjbillington:         if not hasattr(self.local,'pushsock'):
chrisjbillington:             self.new_push_socket()
chrisjbillington:         try:
chrisjbillington:             self.local.pushsock.send_multipart([logfile, logtext], zmq.NOBLOCK)
chrisjbillington:             self.local.high_water_mark = False
chrisjbillington:         except zmq.error.Again: 
chrisjbillington:             if not self.local.high_water_mark:
chrisjbillington:                 self.local.high_water_mark = True
chrisjbillington:                 sys.stderr.write('warning: logging server appears to be offline - messages dropped.')
chrisjbillington:             pass
chrisjbillington:     
chrisjbillington:     def check_file_access(self, filepath, timeout=None):
chrisjbillington:         """Ask the server if it can open the given file in append mode for logging"""
chrisjbillington:         try:
chrisjbillington:             if timeout is None:
chrisjbillington:                 timeout = self.RESPONSE_TIMEOUT
chrisjbillington:             else:
chrisjbillington:                 timeout = 1000*timeout # convert to ms
chrisjbillington:             if not hasattr(self.local,'reqsock'):
chrisjbillington:                 self.new_req_socket()
chrisjbillington:             self.local.reqsock.send(filepath,zmq.NOBLOCK)
chrisjbillington:             events = self.local.poller.poll(timeout)
chrisjbillington:             if events:
chrisjbillington:                 response = self.local.reqsock.recv()
chrisjbillington:                 if response == 'ok':
chrisjbillington:                     return True
chrisjbillington:                 else:
chrisjbillington:                     raise IOError('zlog server reported an error:\n ' +  response)
chrisjbillington:             raise zmq.ZMQError('No response from zlog server: timed out')
chrisjbillington:         except:
chrisjbillington:             self.local.reqsock.close(linger=False)
chrisjbillington:             del self.local.reqsock
chrisjbillington:             raise
chrisjbillington:             
chrisjbillington:     def setrotate(self, *args):
chrisjbillington:         raise NotImplementedError
chrisjbillington:         
chrisjbillington: 
chrisjbillington: def check_connected():
chrisjbillington:     try:
chrisjbillington:         _zmq_log_client
chrisjbillington:     except NameError:
chrisjbillington:         raise RuntimeError('Not connected to a zlog server. Call zlog.connect()')
chrisjbillington:                 
chrisjbillington: def ping(timeout=None):
chrisjbillington:     check_connected()
chrisjbillington:     return _zmq_log_client.say_hello(timeout)
chrisjbillington:         
chrisjbillington: def log(logfile, logtext):
chrisjbillington:     check_connected()
chrisjbillington:     return _zmq_log_client.log(logfile, logtext)
chrisjbillington:     
chrisjbillington: def check_file_access(filepath, timeout=None):
chrisjbillington:     check_connected()
chrisjbillington:     return _zmq_log_client.check_file_access(filepath, timeout)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class Formatter(logging.Formatter):
chrisjbillington:     def formatTime(self, record, datefmt=None):
chrisjbillington:         ct = self.converter(record.created)
chrisjbillington:         t = time.strftime("%Y-%m-%d %H:%M:%S", ct)
chrisjbillington:         s = "%s,%06d" % (t, int((record.created % 1)*1e6))
chrisjbillington:         return s
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class Logger(logging.Logger): 
chrisjbillington: 
chrisjbillington:     instances = {}
chrisjbillington:     
chrisjbillington:     def __new__(cls, name='', *args, **kwargs):
chrisjbillington:         # Get names of parent loggers:
chrisjbillington:         namelevels = name.split('.')
chrisjbillington:         parent_levels = ['.'.join(namelevels[:i+1]) for i in range(len(namelevels))]
chrisjbillington:         # Convert all args to kwargs for easier parsing:
chrisjbillington:         kwargs.update(dict(list(zip(six.get_function_code(cls.__init__).co_varnames[2:], args))))
chrisjbillington:         for parent_level in reversed(parent_levels):
chrisjbillington:             try:
chrisjbillington:                 parent_logger = cls.instances[parent_level]
chrisjbillington:                 break
chrisjbillington:             except KeyError:
chrisjbillington:                 pass
chrisjbillington:         else:
chrisjbillington:             parent_logger = None
chrisjbillington:         # Inherit unset args from parent logger:
chrisjbillington:         new_kwargs = {}
chrisjbillington:         for argname in six.get_function_code(cls.__init__).co_varnames[2:]:
chrisjbillington:             try:
chrisjbillington:                 new_kwargs[argname] = kwargs[argname]
chrisjbillington:             except KeyError:
chrisjbillington:                 if parent_logger is not None:
chrisjbillington:                     try:
chrisjbillington:                         new_kwargs[argname] = parent_logger.kwargs[argname]
chrisjbillington:                     except KeyError:
chrisjbillington:                         pass
chrisjbillington:         
chrisjbillington:         instance = object.__new__(cls)
chrisjbillington:         instance.kwargs = new_kwargs
chrisjbillington:         cls.instances[name] = instance
chrisjbillington:         return instance
chrisjbillington:         
chrisjbillington:     def __init__(self, name='', filepath=None, fmt=None, to_terminal=logging.INFO, 
chrisjbillington:                  rotate_at_size_MB=None, max_rotated_files=None, terminal_only = False, _skip_pre_checks=False):
chrisjbillington:         # The __new__ method has replaced any unspecified arguments (other
chrisjbillington:         # than name) with those of the parent logger, if one was found. It
chrisjbillington:         # put the results in self.kwargs. So we will use values there
chrisjbillington:         # preferentially, then fall back on defaults.
chrisjbillington:         self.name = name
chrisjbillington:         filepath = self.kwargs.get('filepath', filepath)
chrisjbillington:         fmt = self.kwargs.get('fmt', fmt)
chrisjbillington:         to_terminal = self.kwargs.get('to_terminal', to_terminal)
chrisjbillington:         rotate_at_size_MB = self.kwargs.get('rotate_at_size_MB', rotate_at_size_MB)
chrisjbillington:         max_rotated_files = self.kwargs.get('max_rotated_files', max_rotated_files)
chrisjbillington:         terminal_only = self.kwargs.get('terminal_only', terminal_only)
chrisjbillington:         _skip_pre_checks = self.kwargs.get('_skip_pre_checks', _skip_pre_checks)
chrisjbillington:         logging.Logger.__init__(self, name)
chrisjbillington:         
chrisjbillington:         self.terminal_only = terminal_only
chrisjbillington:         self.to_terminal = to_terminal
chrisjbillington:         
chrisjbillington:         if filepath is None:
chrisjbillington:             # Absolute import means this is not zlock.__main__, this is
chrisjbillington:             # the user's __main__:
chrisjbillington:             import __main__
chrisjbillington:             try:
chrisjbillington:                 main_file = __main__.__file__
chrisjbillington:             except AttributeError:
chrisjbillington:                 filepath = 'interactive.log'
chrisjbillington:             else:
chrisjbillington:                 main_dir, main_base = os.path.split(os.path.abspath(main_file))
chrisjbillington:                 filename = os.path.splitext(main_base)[0]
chrisjbillington:                 if filename in ['__init__', '__main__', 'main']:
chrisjbillington:                     # name it after the folder instead:
chrisjbillington:                     filename = os.path.split(main_dir)[1]
chrisjbillington:                 filepath = os.path.join(main_dir, filename+'.log')
chrisjbillington:         filepath = os.path.abspath(filepath)
chrisjbillington:         self.filepath = filepath
chrisjbillington:         
chrisjbillington:         if not _skip_pre_checks:
chrisjbillington:             # This can be skipped, which is necessary for the zlog
chrisjbillington:             # server itself, as it cannot wait for a response from itself
chrisjbillington:             # (it is single threaded). It will do these checks manually.
chrisjbillington:             try:
chrisjbillington:                 check_connected()
chrisjbillington:             except RuntimeError:
chrisjbillington:                 connect()
chrisjbillington:             check_file_access(filepath, timeout=None)
chrisjbillington:         
chrisjbillington:         if fmt is None:
chrisjbillington:             if name:
chrisjbillington:                 fmt = '[%(asctime)s] %(levelname)s %(name)s: %(message)s'
chrisjbillington:             else:
chrisjbillington:                 fmt = '[%(asctime)s] %(levelname)s %(message)s'
chrisjbillington:                 
chrisjbillington:         self.formatter = Formatter(fmt)
chrisjbillington: 
chrisjbillington:         if to_terminal is not None and sys.stdout is not None and sys.stdout.isatty():
chrisjbillington:             terminalhandler = logging.StreamHandler(sys.stdout)
chrisjbillington:             terminalhandler.setFormatter(self.formatter)
chrisjbillington:             terminalhandler.setLevel(to_terminal)
chrisjbillington:             self.addHandler(terminalhandler)
chrisjbillington:         elif os.name == 'nt' and not sys.stdout.isatty():
chrisjbillington:             # Prevent bug on windows where writing to stdout without a command
chrisjbillington:             # window causes a crash:
chrisjbillington:             sys.stdout = sys.stderr = open(os.devnull,'w')
chrisjbillington: 
chrisjbillington:     def handle(self, record):
chrisjbillington:         if self.to_terminal is not None:
chrisjbillington:             logging.Logger.handle(self, record)
chrisjbillington:         if not self.terminal_only:
chrisjbillington:             msg = self.formatter.format(record)
chrisjbillington:             log(self.filepath, msg)
chrisjbillington:             
chrisjbillington:     
chrisjbillington: def connect(host=None, port=None, timeout=None):
chrisjbillington:     """This method should be called at program startup, it establishes
chrisjbillington:     communication with the server and ensures it is responding"""
chrisjbillington:     if host is None or port is None:
chrisjbillington:         try:
chrisjbillington:             if six.PY2:
chrisjbillington:                 import ConfigParser
chrisjbillington:             else:
chrisjbillington:                 import configparser as ConfigParser
chrisjbillington:             from LabConfig import LabConfig
chrisjbillington:             config = LabConfig()
chrisjbillington:         except (ImportError, IOError):
chrisjbillington:             pass
chrisjbillington:         else:
chrisjbillington:             if host is None:
chrisjbillington:                 try:
chrisjbillington:                     host = config.get('servers','zlog')
chrisjbillington:                 except ConfigParser.NoOptionError:
chrisjbillington:                     pass
chrisjbillington:             if port is None:
chrisjbillington:                 try:
chrisjbillington:                     port = config.get('ports','zlog')
chrisjbillington:                 except ConfigParser.NoOptionError:
chrisjbillington:                     pass
chrisjbillington:         if host is None:
chrisjbillington:             host = 'localhost'
chrisjbillington:         if port is None:
chrisjbillington:             port = DEFAULT_PORT
chrisjbillington:     global _zmq_log_client
chrisjbillington:     _zmq_log_client = ZMQLogClient(host, port)
chrisjbillington:     if socket.gethostbyname(host) == socket.gethostbyname('localhost'):
chrisjbillington:         try:
chrisjbillington:             # short connection timeout if localhost, don't want to
chrisjbillington:             # waste time:
chrisjbillington:             ping(timeout=0.05)
chrisjbillington:         except zmq.ZMQError:
chrisjbillington:             # No zlog server running on localhost. Start one. It will run
chrisjbillington:             # forever, even after this program exits. This is important for
chrisjbillington:             # other programs which might be using it. I don't really consider
chrisjbillington:             # this bad practice since the server is typically supposed to
chrisjbillington:             # be running all the time:
chrisjbillington:             devnull = open(os.devnull,'w')
chrisjbillington:             subprocess.Popen([sys.executable,'-m','zlog'], stdout=devnull, stderr=devnull)
chrisjbillington:             # Try again. Longer timeout this time, give it time to start up:
chrisjbillington:             ping(timeout=15)
chrisjbillington:     else:
chrisjbillington:         ping(timeout)
chrisjbillington:         # We ping twice since the first does initialisation and so takes
chrisjbillington:         # longer. The second will be more accurate:
chrisjbillington:     return ping(timeout)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # __main__.py                                                       #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Chris Billington                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the zprocess project (see                    #
chrisjbillington: # https://bitbucket.org/cbillington/zprocess) and is licensed under #
chrisjbillington: # the Simplified BSD License. See the license.txt file in the root  #
chrisjbillington: # of the project for the full license.                              #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
chrisjbillington: import os
chrisjbillington: import sys
chrisjbillington: import traceback
chrisjbillington: import time
chrisjbillington: import zmq
chrisjbillington: import zprocess.logging as zlog
chrisjbillington: 
chrisjbillington: LOGGING = True
chrisjbillington: # The path to our own log file:
chrisjbillington: if os.name == 'nt':
chrisjbillington:     ZLOG_LOG_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__),'zlog.log'))
chrisjbillington: else:
chrisjbillington:     ZLOG_LOG_PATH = '/var/log/zlog.log'
chrisjbillington:     
chrisjbillington: # Protocol description:
chrisjbillington: #
chrisjbillington: # To log, clients should connect on a zmq.PUSH socket and send a
chrisjbillington: # multipart zmq message:
chrisjbillington: #
chrisjbillington: # ['/path/to/log/file.log', 'log text']
chrisjbillington: # 
chrisjbillington: # Both the path and text should be utf-8 encoded if they include non-ascii
chrisjbillington: # chars. log_text doesn't need a trailing newline character, zlog
chrisjbillington: # will add that.
chrisjbillington: #
chrisjbillington: # For all other functions below, the client should connect on a
chrisjbillington: # zmq.REQ socket. The server is a zmq.ROUTER, so it can handle both of
chrisjbillington: # these. Avoid using a single zmq.DEALER for a client, as then errors in
chrisjbillington: # request formatting may result in replies that are not read by your code
chrisjbillington: # right away, and will be read later by different parts of your code. This
chrisjbillington: # would be hard to debug. So use a seperate zmq.PUSH for actual logging
chrisjbillington: # and zmq.REQ for other requests. Remember to set a send high water mark
chrisjbillington: # on your PUSH socket, so that if the zlog server goes down your client
chrisjbillington: # doesn't memory leak. If the HWM is reached, handle the resulting send
chrisjbillington: # error (perhaps coughing a warning) so that your program doesn't crash
chrisjbillington: # (the python client does all this, this is advice for other clients).
chrisjbillington: #
chrisjbillington: # To check if zlog is running, clients should send:
chrisjbillington: #
chrisjbillington: # ['hello'].
chrisjbillington: #
chrisjbillington: # Zlog will respond with ['hello'].
chrisjbillington: #
chrisjbillington: # To check that zlog can log ok, clients should send:
chrisjbillington: #
chrisjbillington: # ['/path/to/log/file.log']
chrisjbillington: #
chrisjbillington: # Zlog with respond ['ok'] if it can open the file in append mode. Otherwise
chrisjbillington: # it will respond with the error message it got when it tried.
chrisjbillington: #
chrisjbillington: # To configure log rotation, clients can send a multipart message:
chrisjbillington: #
chrisjbillington: # ['setrotate', '/path/to/log/file', '<maxsize>', '<maxfiles>']
chrisjbillington: #
chrisjbillington: # Zlog will confiure itself to rotate the log file if it is greater than
chrisjbillington: # <maxsize> in MB.  It will keep at most <maxfiles>, deleting older
chrisjbillington: # ones. Set <maxfiles> to 0 for no maximum. Zlog will respond with
chrisjbillington: # ['ok'] if it has the required permissions to create and rotate the
chrisjbillington: # files. Otherwise it will respond with the error message it got when
chrisjbillington: # it checked. Rotation will then be automatic.
chrisjbillington: 
chrisjbillington: MAX_OPEN_FILES = 500
chrisjbillington: 
chrisjbillington: class ZMQLogServer(object):
chrisjbillington:     
chrisjbillington:     def __init__(self, port):
chrisjbillington:         self.port = int(port)
chrisjbillington:         context = zmq.Context.instance()
chrisjbillington:         self.sock = context.socket(zmq.ROUTER)
chrisjbillington:         
chrisjbillington:         # Bind to the outside world:
chrisjbillington:         self.sock.bind('tcp://0.0.0.0:%d'%self.port)
chrisjbillington:         
chrisjbillington:         # Keep a list of opened files so we can close old ones and not
chrisjbillington:         # run out of descriptors at the operating system level:
chrisjbillington:         self.open_files = {}
chrisjbillington:         self.last_access = {}
chrisjbillington:      
chrisjbillington:         # Eat our own dogfood: Set up logging via ourself:
chrisjbillington:         self.logger = zlog.Logger(filepath=ZLOG_LOG_PATH, _skip_pre_checks=True)
chrisjbillington:         # Instantiate a log client in the client module, as it cannot do
chrisjbillington:         # so itself without calling connect(), which will deadlock waiting
chrisjbillington:         # for a response that we can't give until our mainloop is running!
chrisjbillington:         zlog._zmq_log_client = zlog.ZMQLogClient('localhost', self.port)
chrisjbillington:         # We similarly must do this manually:
chrisjbillington:         result = self.check_file_access(ZLOG_LOG_PATH)
chrisjbillington:         if result != 'ok':
chrisjbillington:             # But we want to continue, some clients are relying on
chrisjbillington:             # us...admin will just have to see stderr or notice there
chrisjbillington:             # is no log file for the server itself and fix this.
chrisjbillington:             # Just disable file logging for now.
chrisjbillington:             self.logger.terminal_only = True
chrisjbillington:             
chrisjbillington:     def get_file(self, filepath, fresh=False):
chrisjbillington:         self.last_access[filepath] = time.time()
chrisjbillington:         if not fresh:
chrisjbillington:             try:
chrisjbillington:                 f = self.open_files[filepath]
chrisjbillington:                 fstat, pathstat = os.fstat(f.fileno()), os.stat(filepath)
chrisjbillington:                 assert fstat.st_ino == pathstat.st_ino and fstat.st_dev == pathstat.st_dev
chrisjbillington:                 return f
chrisjbillington:             except (KeyError, OSError, AssertionError):
chrisjbillington:                 # Either we don't have it, or it's been deleted or moved
chrisjbillington:                 # or something. Better open it from scratch.
chrisjbillington:                 pass
chrisjbillington:         self.open_files[filepath] = open(filepath,'a')
chrisjbillington:         # Now we check if we have too many files open, and close some:
chrisjbillington:         while len(self.open_files) > MAX_OPEN_FILES:
chrisjbillington:             oldest_file = min(self.last_access, key=self.last_access.__getitem__)
chrisjbillington:             del self.last_access[oldest_file]
chrisjbillington:             self.open_files[oldest_file].close()
chrisjbillington:             del self.open_files[oldest_file]
chrisjbillington:         return self.open_files[filepath]
chrisjbillington:         
chrisjbillington:     def check_file_access(self, filepath):
chrisjbillington:         try:
chrisjbillington:             f = self.get_file(filepath, fresh=True)
chrisjbillington:             return 'ok'
chrisjbillington:         except Exception as e:
chrisjbillington:             if LOGGING: self.logger.exception("can't access %s"%filepath)
chrisjbillington:             return str(e)
chrisjbillington:         
chrisjbillington:     def setrotate(self, filepath, maxsize, maxfiles):
chrisjbillington:         return 'ok'
chrisjbillington:         
chrisjbillington:     def checkrotate(self, filepath):
chrisjbillington:         return 'ok'
chrisjbillington:     
chrisjbillington:     def log(self, filepath, message):
chrisjbillington:         try:
chrisjbillington:             f = self.get_file(filepath)
chrisjbillington:             f.write(message+'\n')
chrisjbillington:             f.flush()
chrisjbillington:         except Exception as e:
chrisjbillington:             if filepath == ZLOG_LOG_PATH:
chrisjbillington:                 # Well well. Can't log to our own log file. Better not
chrisjbillington:                 # log an error about that, that would recurse. Just print
chrisjbillington:                 # to stderr. Admin will simply have to notice and fix,
chrisjbillington:                 # there is no way for us to tell them without raising
chrisjbillington:                 # an exception and doing a sys.exit().
chrisjbillington:                 self.logger.terminal_only = True
chrisjbillington:             if LOGGING: self.logger.exception("can't log to %s\n"%filepath)
chrisjbillington:             # Nothing else we can do, can't inform the client
chrisjbillington:         
chrisjbillington:     def run(self):
chrisjbillington:         if LOGGING: self.logger.info('This is zlog server, running on port %d'%self.port)
chrisjbillington:         while True:
chrisjbillington:             request = self.sock.recv_multipart()
chrisjbillington:             routing_id = request[0]
chrisjbillington:             if not request[1]:
chrisjbillington:                 # An empty frame. That means it's a REQ client.
chrisjbillington:                 args = request[2:]
chrisjbillington:                 if LOGGING: self.logger.info(str(args))
chrisjbillington:                 if args == ['hello']:
chrisjbillington:                     result = 'hello'
chrisjbillington:                 elif len(args) == 1:
chrisjbillington:                     result = self.check_file_access(*args)
chrisjbillington:                 elif len(args) == 4 and args[0] == 'setrotate':
chrisjbillington:                     result = self.checkrotate(*args)
chrisjbillington:                 else:
chrisjbillington:                     result = 'invalid request'
chrisjbillington:                 self.sock.send_multipart([routing_id, '', result])
chrisjbillington:             else:
chrisjbillington:                 # No empty frame; it's a PUSH client. 
chrisjbillington:                 args = request[1:]
chrisjbillington:                 if len(args) == 2:
chrisjbillington:                     self.log(*args)
chrisjbillington:                 
chrisjbillington:                 
chrisjbillington:                 
chrisjbillington: if __name__ == '__main__':
chrisjbillington:     try:
chrisjbillington:         import six
chrisjbillington:         if six.PY2:
chrisjbillington:             import ConfigParser
chrisjbillington:         else:
chrisjbillington:             import configparser as ConfigParser
chrisjbillington:         from LabConfig import LabConfig
chrisjbillington:         port = LabConfig().get('ports','zlog')
chrisjbillington:         found_config = True
chrisjbillington:     except (ImportError, IOError, ConfigParser.NoOptionError):
chrisjbillington:         found_config = False
chrisjbillington:         port = zlog.DEFAULT_PORT
chrisjbillington:     server = ZMQLogServer(port)
chrisjbillington:     if not found_config:
chrisjbillington:         if LOGGING: server.logger.warning("Couldn't get port setting from LabConfig. Using default port")
chrisjbillington:     while True:
chrisjbillington:         try:
chrisjbillington:             server.run()
chrisjbillington:         except KeyboardInterrupt:
chrisjbillington:             if LOGGING: server.logger.info('KeyboardInterrupt, stopping\n')
chrisjbillington:             break
chrisjbillington:         except Exception:
chrisjbillington:             message = traceback.format_exc()
chrisjbillington:             if LOGGING: server.logger.critical('unhandled exception, attempting to restart')
chrisjbillington:             # Close all sockets:
chrisjbillington:             context = zmq.Context.instance()
chrisjbillington:             context.destroy(linger=False)
chrisjbillington:             time.sleep(1)
chrisjbillington:             # Re-initialise the server:
chrisjbillington:             server = ZMQLogServer(port)
chrisjbillington:             
chrisjbillington:             
chrisjbillington:             
chrisjbillington:     
