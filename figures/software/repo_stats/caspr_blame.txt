vnegnev: #include <stdio.h>
vnegnev: #include <stdlib.h>
vnegnev: #include <string.h>
vnegnev: #include "asm.h"
vnegnev: #include "directive.h"
vnegnev: 
vnegnev: int asmgen_parse_value(struct ScanData *scanner,
lincoln: 		       khash_t(symtab) *curSyms,
vnegnev: 		       unsigned int *pResult) {
vnegnev:   struct Token curToken;
vnegnev:   unsigned int lval, rval;
vnegnev:   
vnegnev:   /* scan next token or expression */
vnegnev:   switch (get_token(&curToken, scanner)) {
vnegnev:     
vnegnev:   case TOK_INT:
vnegnev:     /* integer value, just pass it back */
vnegnev:     DEBUG(1) printf("Got an integer - %d\n", curToken.value);
vnegnev:     lval = curToken.value;
vnegnev:     if (curToken.limHigh - curToken.limLow < 8*sizeof(lval) - 1) {
vnegnev:       /* if token is specified with a bitslice, use only those bits */
vnegnev:       lval = GETBITS(curToken.limLow, curToken.limHigh, lval);
vnegnev:     }
vnegnev:     *pResult = lval;
vnegnev:     return 0;
vnegnev:     break;
vnegnev:     
vnegnev:   case TOK_IDENT:
vnegnev:     /* identifier, locate it in the symbol table */
vnegnev:     DEBUG(1) printf("Got a symbol lookup - '%s'\n", curToken.token);
lincoln:     if (hashtab_lookup(curSyms, curToken.token, (int*)&lval) == 0) {
vnegnev:       /* symbol table lookup success */
vnegnev:       if (curToken.limHigh - curToken.limLow < 8*sizeof(lval) - 1) {
vnegnev: 	/* if token is specified with a bitslice, use only those bits */
vnegnev: 	lval = GETBITS(curToken.limLow, curToken.limHigh, lval);
vnegnev:       }
vnegnev:       *pResult = lval;
vnegnev:       return 0;
vnegnev:     }
vnegnev:     printf("ERROR - Symbol '%s' Not Found\n", curToken.token);
vnegnev:     break;
vnegnev:     
vnegnev:   case TOK_LPAREN:
vnegnev:     /* left parentheses, beginning of an arithmetic expression */
vnegnev:     
vnegnev:     /* start by evaluating first term (may be another expression */
vnegnev:     if (asmgen_parse_value(scanner, curSyms, &lval) != 0) {
vnegnev:       /* error parsing sub-expression */
vnegnev:       printf("ERROR - Cannot Parse Arithmetic Expression\n");
vnegnev:       return -1;
vnegnev:     }
vnegnev:     
vnegnev:     /* inner loop to evalate left-to-right arithmetic expressions */
vnegnev:     while (1) {
vnegnev:       /* get next token */
vnegnev:       switch (get_token(&curToken, scanner)) {
vnegnev: 	
vnegnev:       case TOK_RPAREN:
vnegnev: 	/* close parentheses, end of sub-expression */
vnegnev: 	*pResult = lval;
vnegnev: 	return 0;
vnegnev: 	break;
vnegnev: 	
vnegnev:       case TOK_ARITHOP:
vnegnev: 	/* arithmetic operation (+/-), get right hand value */ //VN: implemented >, <, *
vnegnev: 	if (asmgen_parse_value(scanner, curSyms, &rval) != 0) {
vnegnev: 	  /* error parsing sub-expression */
vnegnev: 	  printf("ERROR - Cannot Parse Arithmetic Expression\n");
vnegnev: 	  return -1;
vnegnev: 	}
vnegnev: 	
vnegnev: 	/* handle arithmetic operation */
vnegnev: 	switch (curToken.token[0]) {
vnegnev: 	case '+':
vnegnev: 	  lval += rval;
vnegnev: 	  break;
vnegnev: 	case '-':
vnegnev: 	  lval -= rval;
vnegnev: 	  break;
vnegnev: 	case '*':
vnegnev: 	  lval *= rval;
vnegnev: 	  break;
vnegnev: 	case '>':
vnegnev: 	  lval = lval >> rval;
vnegnev: 	  break;
vnegnev: 	case '<':
vnegnev: 	  lval = lval << rval;
vnegnev: 	  break;
vnegnev: 	case '&':
vnegnev: 	  lval = lval & rval;
vnegnev: 	  break;
vnegnev: 	case '|':
vnegnev: 	  lval = lval | rval;
vnegnev: 	  break;
vnegnev: 	default:
vnegnev: 	  /* unhandled */
vnegnev: 	  printf("ERROR - Unknown Arithmetic operation '%s'\n", curToken.token);
vnegnev: 	  return -1;
vnegnev: 	  break;
vnegnev: 	}
vnegnev: 	break;
vnegnev: 	
vnegnev:       default:
vnegnev: 	printf("ERROR - Unexpected token '%s' while parsing subexpression\n",
vnegnev: 	       curToken.token);
vnegnev: 	return -1;
vnegnev: 	break;
vnegnev:       }
vnegnev:     }
vnegnev:     break;
vnegnev:     
vnegnev:   default:
vnegnev:     /* unknown token */
vnegnev:     printf("Unhandled token \'%s\'\n", curToken.token);
vnegnev:     break;
vnegnev:   }
vnegnev:   return -1;
vnegnev: }
vnegnev: 
lincoln: int asmgen_parse_syms(khash_t(symtab) *curSyms,
vnegnev: 		      FILE *handle) {
vnegnev:   struct ScanData asmScan;
vnegnev:   unsigned int offset = 0;
vnegnev:   struct Token curToken;
vnegnev:   TokenType ttype;
vnegnev:   struct ASMRecord *rec, *asmrec = NULL;
vnegnev:   int found;
vnegnev:   
vnegnev:   /* set up the scanner */
vnegnev:   SCANNER_INIT(&asmScan,handle);
vnegnev:   
vnegnev:   /* main loop */
vnegnev:   while (1) {
vnegnev:     switch (get_token(&curToken, &asmScan)) {
vnegnev:       
vnegnev:     case TOK_EOF:
vnegnev:       /* end of file */
vnegnev:       SCANNER_STOP(&asmScan);
vnegnev:       
vnegnev:       /* make a special symbol to note size of assembled file */
lincoln:       hashtab_record(curSyms, "$filesize", offset);
vnegnev:       return 0;
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_LABEL:
vnegnev:       /* hit a line label */
lincoln:       hashtab_record(curSyms, curToken.token, offset);
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_ENDL:
vnegnev:       /* end of line at beginning, skip to next */
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_DIRECTIVE:
vnegnev:       /* directive, pass current data to directive handler */
vnegnev:       directive_parse(&asmScan, &curToken, curSyms, &asmrec, &offset);
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_IDENT:
vnegnev:       /* assume to be an assembly mnemonic */
vnegnev:       DEBUG(3) printf("Got identifier - %s\n", curToken.token);
vnegnev:       
vnegnev:       /* find mnemonic in record */
vnegnev:       found = 0;
vnegnev:       for (rec=asmrec; (found==0)&&(rec!=NULL); rec=rec->next) {
vnegnev: 	if (strcmp(curToken.token, rec->mnemonic) == 0) {
vnegnev: 	  found = 1;
vnegnev: 	  offset += rec->byte_count;
vnegnev: 	  /* scan tokens until end of line */
vnegnev: 	  do {
vnegnev: 	    ttype = get_token(&curToken, &asmScan);
vnegnev: 	  } while ((ttype != TOK_EOF) && (ttype != TOK_ENDL));
vnegnev: 	}
vnegnev:       }
vnegnev:       if (found == 0) {
vnegnev: 	fprintf(stderr, "ERROR - mnemonic %s not found\n", curToken.token);
vnegnev: 	SCANNER_STOP(&asmScan);
vnegnev: 	return -1;
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     default:
vnegnev:       fprintf(stderr, "Unexpected Token %s, line %d\n",
vnegnev: 	      curToken.token, curToken.linenum);
vnegnev:       SCANNER_STOP(&asmScan);
vnegnev:       return -1;
vnegnev:       break;
vnegnev:     }
vnegnev:   }
vnegnev: }
vnegnev: 
lincoln: int asmgen_assemble(khash_t(symtab) *curSyms,
vnegnev: 		    FILE *input,
vnegnev: 		    char *data) {
vnegnev:   struct ScanData cfgScan;
vnegnev:   struct Token curToken;
vnegnev:   struct ASMRecord *instr;
vnegnev:   struct ASMRecord *asmcfg = NULL;
vnegnev:   unsigned int argCount, fieldNum, value;
vnegnev:   unsigned int offset = 0, outBits;
vnegnev:   unsigned int bitmask = 0; //VN: used to truncate big numbers to the right bit length
vnegnev:   int x;
vnegnev:   
vnegnev:   /* set up the scanner */
vnegnev:   SCANNER_INIT(&cfgScan, input);
vnegnev:   
vnegnev:   /* try to assemble this thing */
vnegnev:   while (1) {
vnegnev:     switch (get_token(&curToken, &cfgScan)) {
vnegnev:       
vnegnev:     case TOK_EOF:
vnegnev:       /* end of file, stop assembling */
vnegnev:       return 0;
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_LABEL:
vnegnev:     case TOK_ENDL:
vnegnev:       /* ignore these tokens, just pass over */
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_DIRECTIVE:
vnegnev:       /* directive, pass current data to directive handler */
vnegnev:       directive_parse(&cfgScan, &curToken, NULL, &asmcfg, &offset);
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_IDENT:
vnegnev:       /* assume this is a format entry */
vnegnev:       DEBUG(1) printf("\nAssembling mnemonic %s\n", curToken.token);
vnegnev:       
vnegnev:       /* find instruction layout */
vnegnev:       for (instr = asmcfg; (instr!=NULL) &&
vnegnev: 	     (strcmp(instr->mnemonic, curToken.token) != 0);
vnegnev: 	     instr = instr->next) { }
vnegnev:       
vnegnev:       /* shouldn't happen, but just in case */
vnegnev:       if (instr == NULL) {
vnegnev: 	printf("ERROR - Unexpected instruction %s\n", curToken.token);
vnegnev: 	return -1;
vnegnev:       }
vnegnev:       
vnegnev:       /* got it, so start assembling */
vnegnev:       DEBUG(1) printf("Found format for instruction %s, %d bytes\n",
vnegnev: 		      curToken.token, instr->byte_count);
vnegnev: 
vnegnev:       outBits = instr->asm_mask;
vnegnev:       for (argCount=0; argCount<instr->num_args; argCount++) {
vnegnev: 	/* parse next token or parenthesized expression */
vnegnev: 	if (asmgen_parse_value(&cfgScan, curSyms, &value) != 0) {
vnegnev: 	  fprintf(stderr, "ERROR - Argument %d bad, line %d\n",
vnegnev: 		  argCount, curToken.linenum);
vnegnev: 	  return -1;
vnegnev: 	  }
vnegnev: 	if (CHECK_FIELD_TOO_SMALL(instr->arg_widths[argCount], value)) {
 beclab: 	  DEBUG(1) printf("WARNING - Value 0x%x not representable with %d bits, line %d\n",
vnegnev: 		 value, instr->arg_widths[argCount], curToken.linenum);
vnegnev: 	  //VN: added bit mask to ensure that value isn't too big
vnegnev: 	  bitmask = (1 << ( instr->arg_widths[argCount] ) ) - 1;
vnegnev:   	  value = value & bitmask;
 beclab: 	  DEBUG(1) printf("Anding with 0x%x gives 0x%x. \n", bitmask, value);
vnegnev: 	}
vnegnev: 	
vnegnev: 	/* token OK, fill in all fields using this */
vnegnev: 	for (fieldNum=0; instr->fmt_args[fieldNum].argNum > -1; fieldNum++) {
vnegnev: 	  if (argCount == instr->fmt_args[fieldNum].argNum) {
vnegnev: 	    DEBUG(1) printf("Field number %d uses arg %d (value 0x%x)\n",
vnegnev: 			    fieldNum, argCount, value);
vnegnev: 	    outBits |= GETBITS(0,instr->arg_widths[argCount], value)
vnegnev: 	      << instr->fmt_args[fieldNum].argOffset;
vnegnev: 	  }
vnegnev: 	}
vnegnev:       }
vnegnev:       
vnegnev:       /* expect the newline at the end */
vnegnev:       if (get_token(&curToken, &cfgScan) != TOK_ENDL) {
vnegnev: 	fprintf(stderr, "ERROR - Bad token %s at end of line %d\n",
vnegnev: 		curToken.token, curToken.linenum);
vnegnev: 	return -1;
vnegnev:       }
vnegnev:       
vnegnev:       /* fill in the assembled instruction into the data buffer */
vnegnev:       DEBUG(1) printf("Outputting %d bytes\n", instr->byte_count);
vnegnev:       for (x=(instr->byte_count-1); x>=0; x--) {
vnegnev: 	data[offset] = GETBITS(8*x,(8*x)+7, outBits);
vnegnev: 	DEBUG(1) printf("Assembled %02x\n", data[offset]);
vnegnev: 	offset += 1;
vnegnev:       }
vnegnev:       
vnegnev:       break;
vnegnev:       
vnegnev:     default:
vnegnev:       /* dunno, this is bad */
vnegnev:       fprintf(stderr, "ERROR - Bad token %s at line %d\n",
vnegnev: 		curToken.token, curToken.linenum);
vnegnev: 	return -1;
vnegnev:       break;
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   return 0;
vnegnev: }
vnegnev: #include <stdio.h>
vnegnev: #include "asm.h"
vnegnev: 
lincoln: int asmout_make_mif(khash_t(symtab) *curSyms, char *out, char *data) {
vnegnev:   FILE *handle;
vnegnev:   int x, t, datasize, mifwords, mifbytes;
vnegnev:   int bytewidth, mifwidth = 8;
vnegnev:   
vnegnev:   /* sanity check */
lincoln:   if (hashtab_lookup(curSyms, "$filesize", &datasize) != 0) {
vnegnev:     fprintf(stderr, "ERROR - Unknown file size\n");
vnegnev:     return -1;
vnegnev:   }
lincoln:   if (hashtab_lookup(curSyms, "$mifwords", &mifwords) != 0) {
vnegnev:     fprintf(stderr, "ERROR - Unknown MIF output size\n");
vnegnev:     return -1;
vnegnev:   }
lincoln:   if (hashtab_lookup(curSyms, "$mifwidth", &mifwidth) == 0) {
vnegnev:     if ((mifwidth == 0) && ((mifwidth % 8) != 0)) {
vnegnev:       fprintf(stderr, "ERROR - Illegal MIF width size "
vnegnev: 	      "(must be multiple of 8)\n");
vnegnev:       return -1;
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   bytewidth = mifwidth / 8;
vnegnev:   mifbytes = mifwords * bytewidth;
vnegnev:   if (datasize > mifbytes) {
vnegnev:     fprintf(stderr, "ERROR - Assembled file will not fit within "
vnegnev: 	    "mif filesize\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* open output */
vnegnev:   if ((handle = fopen(out, "w")) == NULL) {
vnegnev:     perror("ERROR - Could not open output file");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* dump MIF header */
vnegnev:   fprintf(handle,
vnegnev: 	  "-- caspr\n\n"
vnegnev: 	  "WIDTH=%d;\n"
vnegnev: 	  "DEPTH=%d;\n\n"
vnegnev: 	  "ADDRESS_RADIX=HEX;\n"
vnegnev: 	  "DATA_RADIX=HEX;\n\n"
vnegnev: 	  "CONTENT BEGIN\n",
vnegnev: 	  mifwidth, mifwords);
vnegnev:   
vnegnev:   /* output each assembled unit (no optimization for now) */
vnegnev:   for (x=0; x<mifbytes; x+=bytewidth) {
vnegnev:     fprintf(handle, "\t%x  :   ", x / bytewidth);
vnegnev:     for (t=0; t<bytewidth; t++) {
vnegnev:       if ((x+t) < datasize) {
vnegnev: 	fprintf(handle, "%02X", data[x+t] & 0xff);
vnegnev:       }
vnegnev:       else {
vnegnev: 	fprintf(handle, "00");
vnegnev:       }
vnegnev:     }
vnegnev:     fprintf(handle, ";\n");
vnegnev:   }
vnegnev:   
vnegnev:   /* dump MIF trailer */
vnegnev:   fprintf(handle, "END;\n");
vnegnev:   
vnegnev:   /* done */
vnegnev:   fclose(handle);
vnegnev:   return 0;
vnegnev: }
vnegnev: 
lincoln: int asmout_make_rom(khash_t(symtab) *curSyms, char *out, char *data) {
vnegnev:   FILE *handle;
vnegnev:   int x, y, t, datasize;
vnegnev:   
vnegnev:   /* sanity check */
lincoln:   if (hashtab_lookup(curSyms, "$filesize", &datasize) != 0) {
vnegnev:     fprintf(stderr, "ERROR - Unknown file size\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev: 
vnegnev:   /* open output */
vnegnev:   if ((handle = fopen(out, "w")) == NULL) {
vnegnev:     perror("ERROR - Could not open output file");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* dump ROM header (none for now) */
vnegnev: 
vnegnev: 
vnegnev:   DEBUG(1) printf("Max Address %d\n", datasize);
vnegnev:   /* output each row */
vnegnev:   for (x=0; x<datasize; x+=8) {
vnegnev:     fprintf(handle, "0x%04X |", x);
vnegnev:     for (y=0; y<8; y++) {
vnegnev:       if ((x+y)<datasize) {
vnegnev: 	t = (data[x+y] & 0xff);
vnegnev: 	fprintf(handle, " %02X", t);
vnegnev:       }
vnegnev:       else {
vnegnev: 	fprintf(handle, " 00");
vnegnev:       }
vnegnev:     }
vnegnev:     fprintf(handle, "\n");
vnegnev:   }
vnegnev:   
vnegnev:   /* dump ROM trailer (none for now) */
vnegnev:   
vnegnev:   /* done */
vnegnev:   fclose(handle);
vnegnev:   return 0;
vnegnev: }
vnegnev: 
vnegnev: //VN: make a binary file
lincoln: int asmout_make_bin(khash_t(symtab) *curSyms, char *out, char *data) {
vnegnev:   FILE *handle;
vnegnev:   int x, y, datasize;
vnegnev:   char t; //VN: temporary 8-bit storage
vnegnev:   static char zer = 0x00;
lincoln:   int res;
vnegnev:   
vnegnev:   /* sanity check */
lincoln:   if (hashtab_lookup(curSyms, "$filesize", &datasize) != 0) {
vnegnev:     fprintf(stderr, "ERROR - Unknown file size\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev: 
vnegnev:   /* open output */
vnegnev:   if ((handle = fopen(out, "wb")) == NULL) { //VN: binary
vnegnev:     perror("ERROR - Could not open output file");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* dump ROM header (none for now) */
vnegnev: 
vnegnev: 
vnegnev:   printf("Max Address %d\n", datasize);
vnegnev:   // output each memory location
vnegnev:   for (x=0; x<datasize; x+=MEM_WIDTH) { //MEM_WIDTH bytes at a time
vnegnev: 
vnegnev:     //Either fill in file by reading forward (big-endian) or backward (little-endian).
vnegnev: #ifdef LITTLE_ENDIAN_OUTPUT
vnegnev:     for (y=MEM_WIDTH-1; y>=0; y--) {
vnegnev: #else
vnegnev:     for (y=0; y<MEM_WIDTH; y++) {
vnegnev: #endif
vnegnev:       if ((x+y)<datasize) {
vnegnev: 	t = data[x+y];
lincoln: 	res = fwrite(&t, 1, 1, handle); // Should check res...?
vnegnev:       }
vnegnev:       else {
vnegnev: 	//fill last mem location in if there's no content
lincoln: 	res = fwrite(&zer, 1, 1, handle); // Should check res...?
vnegnev:       }
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   /* dump ROM trailer (none for now) */
vnegnev:   
vnegnev:   /* done */
vnegnev:   fclose(handle);
vnegnev:   return 0;
vnegnev: }
vnegnev: #include <stdio.h>
vnegnev: #include <stdlib.h>
vnegnev: #include <string.h>
vnegnev: #include "asm.h"
vnegnev: #include "directive.h"
vnegnev: 
vnegnev: static char *cfg_file_formats[4] =
vnegnev:   { "%s.cfg",
vnegnev:     "cfg/%s.cfg",
vnegnev:     "/home/tim/dev/caspr/cfg/%s.cfg",
vnegnev:     NULL };
vnegnev: 
vnegnev: /* allocate one empty asm record */
vnegnev: int asmrec_init(struct ASMRecord *ptr) {
vnegnev:   int x;
vnegnev:   
vnegnev:   /* check */
vnegnev:   if (ptr == NULL) {
vnegnev:     /* failure */
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* initialize to zero */
vnegnev:   memset((char*)ptr, 0, sizeof(struct ASMRecord));
vnegnev:   
vnegnev:   /* initialize nonzero flags and stuff */
vnegnev:   ptr->byte_count = -1;
vnegnev:   ptr->num_args = 0;
vnegnev:   
vnegnev:   /* set all possible arg fields to unused/invalid status */
vnegnev:   for (x=0; x<MAX_ASM_ARGS; x++) {
vnegnev:     ptr->fmt_args[x].argNum = -1;
vnegnev:     ptr->fmt_args[x].argOffset = -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* done */
vnegnev:   return 0;
vnegnev: }
vnegnev: 
vnegnev: /* set the width of the next uninitialized argument to the
vnegnev:  * set width. seems a bit overkill, but should make the
vnegnev:  * config file parser a bit easier (may replace with a
vnegnev:  * macro later) */
vnegnev: int asmrec_add_arg(struct ASMRecord *ptr, int width) {
vnegnev:   
vnegnev:   /* sanity check */
vnegnev:   if (ptr == NULL) {
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* add next width in, bump the arg counter */
vnegnev:   ptr->arg_widths[ptr->num_args++] = width;
vnegnev:   
vnegnev:   return 0;
vnegnev: }
vnegnev: 
vnegnev: int asmrec_parse_format(struct ASMRecord *ptr, char *fmt) {
vnegnev:   int x, i, fmt_count, bitcount, bitinc, argused;
vnegnev:   char buf[MAX_TOKLEN];
vnegnev:   uint32_t imask = 0x00000000;
vnegnev:   
vnegnev:   /* sanity check */
vnegnev:   if (ptr == NULL) {
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   DEBUG(1) printf("Parsing format \'%s\'\n", fmt);
vnegnev:   
vnegnev:   /* count number of bits in instruction format,
vnegnev:    * and make a mask of the appropriate opcode
vnegnev:    * to OR with the fields later */
vnegnev:   bitcount = 0;
vnegnev:   fmt_count = 0;
vnegnev:   for (x=0; fmt[x]!='\0'; x++) {
vnegnev:     argused = -1;
vnegnev:     bitinc = 0;
vnegnev:     switch (fmt[x]) {
vnegnev:     
vnegnev:     case '0':
vnegnev:       imask = imask << 1;
vnegnev:       bitinc = 1;
vnegnev:       break;
vnegnev:       
vnegnev:     case '1':
vnegnev:       imask = imask << 1;
vnegnev:       imask += 1;
vnegnev:       bitinc = 1;
vnegnev:       break;
vnegnev:       
vnegnev:     case '(':
vnegnev:       /* convert "(X)" into numeric 'X' */
vnegnev:       i = 0;
vnegnev:       memset(buf, 0, MAX_TOKLEN);	/* clear string */
vnegnev:       for (x++; fmt[x]!=')'; x++) {
vnegnev: 	buf[i++] = fmt[x];
vnegnev:       }
vnegnev:       
vnegnev:       /* convert this to a numeric value */
vnegnev:       i = (int)strtol(buf, (char **)NULL, 0);
vnegnev:       if ((i >= 0) && (i < ptr->num_args)) {
vnegnev: 	ptr->fmt_args[fmt_count].argNum = i;
vnegnev: 	imask = imask << ptr->arg_widths[i];
vnegnev: 	bitinc = ptr->arg_widths[i];
vnegnev: 	argused = fmt_count++; /* save this for a bit */
vnegnev:       }
vnegnev:       else {
vnegnev: 	printf("ERROR - Invalid subfield specifier, \"(%d)\"\n", i);
vnegnev:       }
vnegnev:       break;
vnegnev:     }
vnegnev:     
vnegnev:     /* update known offsets */
vnegnev:     bitcount += bitinc;
vnegnev:     for (i=0; i<ptr->num_args; i++) {
vnegnev:       if (ptr->fmt_args[i].argOffset != -1) {
vnegnev: 	ptr->fmt_args[i].argOffset += bitinc;
vnegnev:       }
vnegnev:     }
vnegnev:     if (argused != -1) {
vnegnev:       ptr->fmt_args[argused].argOffset = 0;
vnegnev:     }
vnegnev:     
vnegnev:   }
vnegnev: 	   
vnegnev:   
vnegnev:   /* check that its multiple of 8 (byte aligned) */
vnegnev:   if ((bitcount % 8) != 0) {
vnegnev:     printf("ERROR - Instruction format is not byte aligned\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   ptr->byte_count = bitcount / 8;
vnegnev:   ptr->asm_mask = imask;
vnegnev:   DEBUG(1) printf("Instruction is %d bytes wide\n", ptr->byte_count);
vnegnev:   DEBUG(1) printf("Instruction mask is %04X\n", ptr->asm_mask);
vnegnev:   
vnegnev:   return 0;
vnegnev: }
vnegnev: 
vnegnev: int asmrec_free(struct ASMRecord *ptr) {
vnegnev:   struct ASMRecord *tmp;
vnegnev:   while (ptr != NULL) {
vnegnev:     tmp = ptr->next;
vnegnev:     free(ptr);
vnegnev:     ptr = tmp;
vnegnev:   }
vnegnev:   return 0;
vnegnev: }
vnegnev: 
lincoln: struct ASMRecord* asmrec_load(khash_t(symtab) *curSyms, char *infile) {
vnegnev:   struct ScanData cfgScan;
vnegnev:   struct ASMRecord *entry, *stack = NULL;
vnegnev:   struct Token curToken;
vnegnev:   char filename[256], **fmt;
vnegnev:   FILE *handle = NULL;
vnegnev:   TokenType ttype;		/* type of current token */
vnegnev:   int x;
vnegnev:   
vnegnev:   /* try to open file */
vnegnev:   for (fmt = cfg_file_formats; handle == NULL; fmt = &(fmt[1])) {
vnegnev:     if (*fmt == NULL) {
vnegnev:       DEBUG(2) fprintf(stderr, "Tried to open %s, but could not\n", infile);
vnegnev:       return NULL;
vnegnev:     }
vnegnev:     else {
vnegnev:       sprintf(filename, *fmt, infile);
vnegnev:       DEBUG(2) printf("Trying to open %s\n", filename);
vnegnev:       handle = fopen(filename, "r");
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   /* file is open */
vnegnev:   DEBUG(2) printf("file open\n");
vnegnev:   SCANNER_INIT(&cfgScan,handle);
vnegnev:   
vnegnev:   while (1) {
vnegnev:     switch (get_token(&curToken, &cfgScan)) {
vnegnev:       
vnegnev:     case TOK_EOF:
vnegnev:       /* end of file */
vnegnev:       SCANNER_STOP(&cfgScan);
vnegnev:       return stack;
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_ENDL:
vnegnev:       /* ignore this token, pass over it */
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_DIRECTIVE:
vnegnev:       /* directive, pass current data to directive handler */
vnegnev:       directive_parse(&cfgScan, &curToken, curSyms, NULL, NULL);
vnegnev:       break;
vnegnev:       
vnegnev:     case TOK_IDENT:
vnegnev:       /* assume this is a format entry */
vnegnev:       DEBUG(1) printf("\nGot a format entry for %s\n", curToken.token);
vnegnev:       
vnegnev:       /* set up a record for it */
vnegnev:       entry = MALLOC(struct ASMRecord);
vnegnev:       asmrec_init(entry);
vnegnev:       
vnegnev:       /* set name */
vnegnev:       strncpy(entry->mnemonic, curToken.token, MAX_TOKLEN);
vnegnev:       
vnegnev:       /* add argument widths as needed */
vnegnev:       ttype = scan_token(&curToken, &cfgScan);
vnegnev:       while (ttype == TOK_INT) {
vnegnev: 	asmrec_add_arg(entry, curToken.value);
vnegnev: 	ttype = get_token(&curToken, &cfgScan);
vnegnev:       }
vnegnev:       
vnegnev:       /* the format should be next */
vnegnev:       if (ttype == TOK_FORMAT) {
vnegnev: 	if (asmrec_parse_format(entry, curToken.token) != 0) {
vnegnev: 	  /* could not parse, forget it */
vnegnev: 	  printf("ERROR - Format unusable for %s, attempting "
vnegnev: 		 "to continue without it\n", entry->mnemonic);
vnegnev: 	  free(entry);
vnegnev: 	}
vnegnev: 	else {
vnegnev: 	  DEBUG(1) printf("Got format with %d argument fields\n",
vnegnev: 			  entry->num_args);
vnegnev: 	  for (x=0; x<entry->num_args; x++) {
vnegnev: 	    DEBUG(1) printf("-> Arg %d, Width %d, Offset %d\n", 
vnegnev: 			    ASMREC_ARGNUM(entry, x),
vnegnev: 			    ASMREC_WIDTH(entry, x),
vnegnev: 			    ASMREC_OFFSET(entry, x));
vnegnev: 	  }
vnegnev: 	
vnegnev: 	  /* add to linked list */
vnegnev: 	  entry->next = stack;
vnegnev: 	  stack = entry;
vnegnev: 	}
vnegnev:       }
vnegnev:       else {
vnegnev: 	printf("FATAL - Unexpected Token %s, line %d\n",
vnegnev: 	       curToken.token, curToken.linenum);
vnegnev: 	free(entry);
vnegnev: 	SCANNER_STOP(&cfgScan);
vnegnev: 	asmrec_free(stack);
vnegnev: 	return NULL;
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     default:
vnegnev:       printf("Unexpected Token %s, line %d\n",
vnegnev: 	     curToken.token, curToken.linenum);
vnegnev:       SCANNER_STOP(&cfgScan);
vnegnev:       asmrec_free(stack);
vnegnev:       return NULL;
vnegnev:       break;
vnegnev:     }
vnegnev:   }
vnegnev:   return NULL;
vnegnev: }
 vnegnev: #include <stdio.h>
 vnegnev: #include <stdlib.h>
 vnegnev: #include <string.h>
 vnegnev: #include "asm.h"
 vnegnev: #include "directive.h"
 vnegnev: 
 vnegnev: int directive_parse(struct ScanData *scanInfo,
 vnegnev: 		    struct Token *dirToken,
 lincoln: 		    khash_t(symtab) *curSyms,
 vnegnev: 		    struct ASMRecord **asmrec,
 vnegnev: 		    unsigned int *offset) {
 vnegnev:   char tokName[MAX_TOKLEN];
 vnegnev:   struct Token newToken;
 vnegnev:   unsigned int value;
 vnegnev:   
 vnegnev:   /* architecture selection directive */
 vnegnev:   if ((strcmp(dirToken->token, ".arch") == 0)) {
 vnegnev:     /* next token should be an identifier to our architecture file */
 vnegnev:     if (get_token(&newToken, scanInfo) != TOK_IDENT) {
 vnegnev:       fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 vnegnev: 	      newToken.token, newToken.linenum);
 vnegnev:       return -1;
 vnegnev:     }
 vnegnev:     
 vnegnev:     /* check that we have a valid pointer to write to */
 vnegnev:     if (asmrec != NULL) {
 vnegnev:       if (*asmrec != NULL) {
 vnegnev: 	asmrec_free(*asmrec);
 vnegnev:       }
 vnegnev:       DEBUG(1) printf("Loading architecture %s\n", newToken.token);
 vnegnev:       *asmrec = asmrec_load(curSyms, newToken.token);
 vnegnev:       if (*asmrec == NULL) {
 vnegnev: 	printf("Could not load architecture file for %s\n", newToken.token);
 vnegnev:       }
 vnegnev:     }
 vnegnev:   }
 vnegnev:   
 vnegnev:   /* define directive */
 vnegnev:   else if ((strcmp(dirToken->token, ".define") == 0)) {
 vnegnev:     /* next token should be an string to define */
 vnegnev:     if (get_token(&newToken, scanInfo) != TOK_IDENT) {
 vnegnev:       fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 vnegnev: 	      newToken.token, newToken.linenum);
 vnegnev:       return -1;
 vnegnev:     }
 vnegnev:     strcpy(tokName, newToken.token);
 vnegnev:     
 vnegnev:     /* check that we have a valid pointer to write to */
 vnegnev:     if (curSyms != NULL) {
 vnegnev:       /* next token(s) should be a numeric value/expression to set */
 vnegnev:       if (1) {
 vnegnev: 	if (asmgen_parse_value(scanInfo, curSyms, &value) != 0) {
 vnegnev: 	  fprintf(stderr, "ERROR - Invalid Define, line %d\n",
 vnegnev: 		  newToken.linenum);
 vnegnev: 	  return -1;
 vnegnev: 	}
 lincoln: 	hashtab_record(curSyms, tokName, value);
 vnegnev:       }
 vnegnev:       else {
 vnegnev: 	if (get_token(&newToken, scanInfo) != TOK_INT) {
 vnegnev: 	  fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 vnegnev: 		  newToken.token, newToken.linenum);
 vnegnev: 	  return -1;
 vnegnev: 	}
 lincoln: 	hashtab_record(curSyms, tokName, newToken.value);
 vnegnev:       }
 vnegnev:     }
 vnegnev:   }
 vnegnev:   
 vnegnev:   /* output specifier define */
 lincoln:   //LDT: Removed! Fixed to .bin format only to avoid
 lincoln:   //LDT: strings in symbols table!
cbilling:   else if ((strcmp(dirToken->token, ".outfmt") == 0)) {}
cbilling:   
 vnegnev:     /* next token should be an string specifying output */
 lincoln:   //  if (get_token(&newToken, scanInfo) != TOK_IDENT) {
 lincoln:   //    fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 lincoln:   //	      newToken.token, newToken.linenum);
 lincoln:   //    return -1;
 lincoln:   //  }
 vnegnev:     
 lincoln:   //  /* check that we have a valid pointer to write to */
 lincoln:   //  if (curSyms != NULL) {
 lincoln:   //    symtab_record(curSyms, "$outfmt", newToken.token, -1);
 lincoln:   //  }
 lincoln:   //}
 vnegnev:   
 vnegnev:   /* output position define */
 vnegnev:   else if ((strcmp(dirToken->token, ".org") == 0)) {
 vnegnev:     /* next token should be an string specifying output */
 vnegnev:     if (get_token(&newToken, scanInfo) != TOK_INT) {
 vnegnev:       fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 vnegnev: 	      newToken.token, newToken.linenum);
 vnegnev:       return -1;
 vnegnev:     }
 vnegnev:     
 vnegnev:     /* check that we have a valid pointer to write to */
 vnegnev:     if (offset != NULL) {
 vnegnev:       *offset = newToken.value;
 vnegnev:     }
 vnegnev:   }
 vnegnev:   
 vnegnev:   /* output specifier define */
 vnegnev:   else if ((strcmp(dirToken->token, ".mifwords") == 0)) {
 vnegnev:     /* next token should be an integer specifying size */
 vnegnev:     if (get_token(&newToken, scanInfo) != TOK_INT) {
 vnegnev:       fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 vnegnev: 	      newToken.token, newToken.linenum);
 vnegnev:       return -1;
 vnegnev:     }
 vnegnev:     
 vnegnev:     /* check that we have a valid pointer to write to */
 vnegnev:     if (curSyms != NULL) {
 lincoln:       hashtab_record(curSyms, "$mifwords", newToken.value);
 vnegnev:     }
 vnegnev:   }
 vnegnev:   
 vnegnev:   /* output specifier define */
 vnegnev:   else if ((strcmp(dirToken->token, ".mifwidth") == 0)) {
 vnegnev:     /* next token should be an integer specifying size */
 vnegnev:     if (get_token(&newToken, scanInfo) != TOK_INT) {
 vnegnev:       fprintf(stderr, "ERROR - Unexpected Token %s, line %d\n",
 vnegnev: 	      newToken.token, newToken.linenum);
 vnegnev:       return -1;
 vnegnev:     }
 vnegnev:     
 vnegnev:     /* check that we have a valid pointer to write to */
 vnegnev:     if (curSyms != NULL) {
 lincoln:       hashtab_record(curSyms, "$mifwidth", newToken.value);
 vnegnev:     }
 vnegnev:   }
 vnegnev:   
 vnegnev:   /* unknown directive */
 vnegnev:   else {
 vnegnev:     printf("ERROR - Unknown directive %s\n", dirToken->token);
 vnegnev:   }
 vnegnev:   
 vnegnev:   /* chew tokens until end of line */
 vnegnev:   while (get_token(&newToken, scanInfo) != TOK_ENDL) {
 vnegnev:     DEBUG(3) printf("-> ignoring token %s\n", newToken.token);
 vnegnev:   }
 vnegnev:   
 vnegnev:   return 0;
 vnegnev: }
 lincoln: #include <stdio.h>
 lincoln: #include <stdlib.h>
 lincoln: #include <string.h>
 lincoln: #include "scan.h"
 lincoln: #include "khash.h"
 lincoln: #include "hashtab.h"
 lincoln: #include "global.h"
 lincoln: 
 lincoln: int hashtab_record(khash_t(symtab) *curSyms, char *name, int intVal) {
 lincoln:   int ret;
 lincoln:   khiter_t k;     // An "iterator", points at buckets
 lincoln:   char *permkey;   // Pointer to the permanently allocated string
shjohnst:   
shjohnst:   if ((curSyms == NULL) || (name == NULL))   /* sanity check */
shjohnst:     return -1;
shjohnst:   
 lincoln:   permkey = strdup(name);
 lincoln:   k = kh_put(symtab, curSyms, permkey, &ret);       
 lincoln:   kh_value(curSyms, k) = intVal; 
 lincoln:   DEBUG(1) printf("Adding %s -> %d to symtab\n", name, intVal);
 lincoln:   return 0;
 lincoln: }
 lincoln: 
 lincoln: int hashtab_lookup(khash_t(symtab) *curSyms, char *name, int *intOut) {
shjohnst:   khiter_t k; 
 lincoln:   if ((curSyms == NULL) || (name == NULL))   /* sanity check */
 lincoln:     return -1;
 lincoln:   k = kh_get(symtab, curSyms, name); // Look up key 
 lincoln:   if(k == kh_end(curSyms))
 lincoln:     return -1;   /* not found */
 lincoln:   *intOut = kh_value(curSyms,k);
 lincoln:   return 0;
 lincoln: }
 lincoln: 
 lincoln: int hashtab_show(khash_t(symtab) *curSyms) {
shjohnst:   khiter_t k;
shjohnst:   int value;
 lincoln:   if (curSyms == NULL)   /* sanity check */
 lincoln:     return -1;
shjohnst:   
 lincoln:   printf("Listing of known symbols\n");
 lincoln:   for (k = kh_begin(curSyms); k != kh_end(curSyms); ++k) {
 lincoln:     if(!kh_exist(curSyms,k))
 lincoln:       continue;
 lincoln:     value = kh_value(curSyms,k);
 lincoln:     printf("-> %-15s%d (0x%x)\n", kh_key(curSyms,k), value, value);
 lincoln:   }
 lincoln:   return 0;
 lincoln: }
 lincoln: 
 lincoln: int hashtab_clear(khash_t(symtab) *curSyms) {
 lincoln:   kh_destroy(symtab, curSyms);
 lincoln:   return 0;
 lincoln: }
 lincoln: 
lincoln: #include <stdio.h>
lincoln: #include "khash.h"
lincoln: 
lincoln: KHASH_MAP_INIT_STR(caferank, int)  // Create a hash called "caferank" which has keys of type string and stores ints (ie it maps caferank[str cafe] -> int rank). 
lincoln: 
lincoln: int main() {
lincoln:         int ret, is_missing;          
lincoln:         khiter_t k;                               // An "iterator", points at buckets
lincoln:         khash_t(caferank) *h = kh_init(caferank);   // Create handle h to our hash "caferank"
lincoln: 
lincoln:         // Shove in some key->values 
lincoln:         k = kh_put(caferank, h, "CL", &ret);       
lincoln: 	kh_value(h, k) = 6;                    
lincoln:         k = kh_put(caferank, h, "Coffeewise", &ret);    
lincoln: 	kh_value(h, k) = 7;                    
lincoln:         k = kh_put(caferank, h, "CoffeeHQ", &ret); 
lincoln: 	kh_value(h, k) = 3;                    
lincoln:         k = kh_put(caferank, h, "Commonroom", &ret);
lincoln: 	kh_value(h, k) = 0;                    
lincoln: 
lincoln: 	// Now let's just print the data in the hash
lincoln: 	printf("\n");
lincoln:         for (k = kh_begin(h); k != kh_end(h); ++k) {
lincoln: 	  if(!kh_exist(h,k))
lincoln: 	    continue;
lincoln: 	  printf("Cafe %s scored %d\n", kh_key(h,k), kh_value(h,k) );
lincoln: 	}
lincoln: 
lincoln:         kh_destroy(caferank, h);                    // Clean up and end
lincoln:         return 0;
lincoln: }
lincoln: #include <stdio.h>
lincoln: #include <assert.h>
lincoln: #include <time.h>
lincoln: #include <stdlib.h>
lincoln: #include <string.h>
lincoln: 
lincoln: #include "khash.h"
lincoln: KHASH_SET_INIT_STR(str)
lincoln: KHASH_SET_INIT_INT(int)
lincoln: 
lincoln: static int data_size = 5000000;
lincoln: static unsigned *int_data;
lincoln: static char **str_data;
lincoln: 
lincoln: void ht_init_data()
lincoln: {
lincoln: 	int i;
lincoln: 	char buf[256];
lincoln: 	khint32_t x = 11;
lincoln: 	printf("--- generating data... ");
lincoln: 	int_data = (unsigned*)calloc(data_size, sizeof(unsigned));
lincoln: 	str_data = (char**)calloc(data_size, sizeof(char*));
lincoln: 	for (i = 0; i < data_size; ++i) {
lincoln: 		int_data[i] = (unsigned)(data_size * ((double)x / UINT_MAX) / 4) * 271828183u;
lincoln: 		sprintf(buf, "%x", int_data[i]);
lincoln: 		str_data[i] = strdup(buf);
lincoln: 		x = 1664525L * x + 1013904223L;
lincoln: 	}
lincoln: 	printf("done!\n");
lincoln: }
lincoln: void ht_destroy_data()
lincoln: {
lincoln: 	int i;
lincoln: 	for (i = 0; i < data_size; ++i) free(str_data[i]);
lincoln: 	free(str_data); free(int_data);
lincoln: }
lincoln: void ht_khash_int()
lincoln: {
lincoln: 	int i, ret;
lincoln: 	unsigned *data = int_data;
lincoln: 	khash_t(int) *h;
lincoln: 	unsigned k;
lincoln: 
lincoln: 	h = kh_init(int);
lincoln: 	for (i = 0; i < data_size; ++i) {
lincoln: 		k = kh_put(int, h, data[i], &ret);
lincoln: 		if (!ret) kh_del(int, h, k);
lincoln: 	}
lincoln: 	printf("[ht_khash_int] size: %u\n", kh_size(h));
lincoln: 	kh_destroy(int, h);
lincoln: }
lincoln: void ht_khash_str()
lincoln: {
lincoln: 	int i, ret;
lincoln: 	char **data = str_data;
lincoln: 	khash_t(str) *h;
lincoln: 	unsigned k;
lincoln: 
lincoln: 	h = kh_init(str);
lincoln: 	for (i = 0; i < data_size; ++i) {
lincoln: 		k = kh_put(str, h, data[i], &ret);
lincoln: 		if (!ret) kh_del(str, h, k);
lincoln: 	}
lincoln: 	printf("[ht_khash_str] size: %u\n", kh_size(h));
lincoln: 	kh_destroy(str, h);
lincoln: }
lincoln: void ht_timing(void (*f)(void))
lincoln: {
lincoln: 	clock_t t = clock();
lincoln: 	(*f)();
lincoln: 	printf("[ht_timing] %.3lf sec\n", (double)(clock() - t) / CLOCKS_PER_SEC);
lincoln: }
lincoln: int main(int argc, char *argv[])
lincoln: {
lincoln: 	if (argc > 1) data_size = atoi(argv[1]);
lincoln: 	ht_init_data();
lincoln: 	ht_timing(ht_khash_int);
lincoln: 	ht_timing(ht_khash_str);
lincoln: 	ht_destroy_data();
lincoln: 	return 0;
lincoln: }
lincoln: #include <stdio.h>
lincoln: #include "khash.h"
lincoln: 
lincoln: KHASH_MAP_INIT_INT(codetab, int)  // Create a hash called "codetab" which has keys of type int and stores ints (ie it maps codetab[int year] -> int postcode). 
lincoln: 
lincoln: int main() {
lincoln:         int ret, is_missing;          
lincoln:         khiter_t k;                               // An "iterator", points at buckets
lincoln:         khash_t(codetab) *h = kh_init(codetab);   // Create handle h to our hash "codetab"
lincoln: 
lincoln:         // Shove in some key->values 
lincoln:         k = kh_put(codetab, h, 1985, &ret);       // Create new key "1985"
lincoln: 	kh_value(h, k) = 5051;                    // In 1985 I lived in Blackwood 5051
lincoln:         k = kh_put(codetab, h, 1992, &ret);       // Create new key "1992"
lincoln: 	kh_value(h, k) = 5050;                    // In 1992 I lived in Bellevue Heights 5050
lincoln:         k = kh_put(codetab, h, 1993, &ret);        
lincoln: 	kh_value(h, k) = 5050;                    // ... and also in 1993
lincoln:         k = kh_put(codetab, h, 1999, &ret);        
lincoln: 	kh_value(h, k) = 3052;                    // In 1999 I lived in Parkville 3052
lincoln:         k = kh_put(codetab, h, 2000, &ret);       
lincoln: 	kh_value(h, k) = 3054;                    // In 2001 I lived in North Carlton 3054
lincoln:         k = kh_put(codetab, h, 2006, &ret);       
lincoln: 	kh_value(h, k) = 20009;                   // In 2006 I lived in Dupont Circle, USA 20009 (a signed short!)
lincoln:         k = kh_put(codetab, h, 2012, &ret);       
lincoln: 	kh_value(h, k) = 3121;                    // Now I live in Richmond 3121
lincoln: 
lincoln: 	// Let's look up a cardinal range of years
lincoln: 	int year;
lincoln: 	for(year=1984; year<2013; year++) {
lincoln: 	  printf("In %d ", year);
lincoln: 	  k = kh_get(codetab, h, year);           // Look up key 
lincoln: 	  if(k == kh_end(h)) {
lincoln: 	    printf("we don't know where Lincoln lived.\n");
lincoln: 	  }
lincoln: 	  else {
lincoln: 	    printf("Lincoln lived in postcode %d\n", kh_value(h,k) );
lincoln: 	  }
lincoln: 	}
lincoln: 
lincoln: 	// Now let's just print the data in the hash
lincoln: 	printf("\n");
lincoln:         for (k = kh_begin(h); k != kh_end(h); ++k) {
lincoln: 	  if(!kh_exist(h,k))
lincoln: 	    continue;
lincoln: 	  printf("Year %d -> postcode %d\n", kh_key(h,k), kh_value(h,k) );
lincoln: 	}
lincoln: 
lincoln:         kh_destroy(codetab, h);                    // Clean up and end
lincoln:         return 0;
lincoln: }
lincoln: #include <stdio.h>
lincoln: #include "khash.h"
lincoln: 
lincoln: KHASH_MAP_INIT_INT(symtab, char)  // Create a hash called "symtab" which has keys of type int and stores chars (ie it maps symtab[int] -> char). 
lincoln: 
lincoln: int main() {
lincoln:         int ret, is_missing;          
lincoln:         khiter_t k;                               // An "iterator", points at buckets
lincoln:         khash_t(symtab) *h = kh_init(symtab);     // Create handle h to our hash "symtab"
lincoln:         k = kh_put(symtab, h, 5, &ret);           // Create new key "5"
lincoln:         if (!ret) kh_del(symtab, h, k);           // If key already present, then delete it (!?)
lincoln:         kh_value(h, k) = 10;                      // Now set this key to have value 10 (ie symbtab[5]->10)
lincoln:         k = kh_get(symtab, h, 10);                // Look up key "10". There isn't one.
lincoln:         is_missing = (k == kh_end(h));            // is_missing should be true
lincoln: 	printf("is_missing is %d <- should be 1.\n", is_missing);
lincoln:         k = kh_get(symtab, h, 5);                 // Set cursor k to bucket with key "5"
lincoln: 	printf("Value of symtab[5] is %d <- should be 10.\n", kh_value(h, k) ); // Example of value retrieval. Nice.
lincoln:         kh_del(symtab, h, k);                     // Now wipe it out.
lincoln: 
lincoln:         // This appears to iterate over the whole hash and set values for all pre-existing keys to be 1.
lincoln:         for (k = kh_begin(h); k != kh_end(h); ++k)
lincoln:                 if (kh_exist(h, k)) kh_value(h, k) = 1;
lincoln: 
lincoln:         kh_destroy(symtab, h);                    // Clean up and end
lincoln:         return 0;
lincoln: }
vnegnev: #include <stdio.h>
vnegnev: #include <stdlib.h>
vnegnev: #include <string.h>
vnegnev: #include "asm.h"
vnegnev: 
lincoln: int guess_output(char *out) {
vnegnev:   int x, pIdx = -1;
vnegnev:   char fmtname[MAX_TOKLEN];
vnegnev:   
lincoln: //LDT: Set format to "bin"
lincoln:   sprintf(fmtname, "bin");
vnegnev:   
vnegnev:   for (x=0; out[x] != '\0'; x++) {
vnegnev:     if (out[x] == '.') {
vnegnev:       pIdx = x;
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   if (pIdx == -1) {
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   sprintf(&out[pIdx+1], "%s", fmtname);
vnegnev:   return 0;
vnegnev: }
lincoln: 
lincoln: // Creates the symbol table
lincoln: // (Preprocessor generic magic!)
lincoln: //KHASH_MAP_INIT_STR(symtab, int) 
lincoln: 
vnegnev: int main(int argc, char **argv) {
vnegnev:   /* local vars */
lincoln:   //  struct SymTab *prgSyms = NULL;
lincoln:   khash_t(symtab) *prgSyms = kh_init(symtab);  // Create handle to the sym tab
lincoln: 
vnegnev:   FILE *inFile;
lincoln:   char *data;
vnegnev:   char *outName, guessed[1024];
vnegnev:   int prgSize, ret;
vnegnev:   
lincoln:   //  hashtab_clear(prgSyms);
vnegnev:   
vnegnev:   /* check if there was a file specified as an argument */
vnegnev:   if (argc < 2) {
vnegnev:     printf("No input specified\n\n");
vnegnev:     printf("Usage:\n\t%s <input> [<output>]\n", argv[0]);
vnegnev:     return 0;
vnegnev:   }
vnegnev:   
vnegnev:   /* open input file */
vnegnev:   if ((inFile = fopen(argv[1], "r")) == NULL) {
vnegnev:     perror("FATAL - Could not open input file");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* load the symbol table from the input file given */
lincoln:   if (asmgen_parse_syms(prgSyms, inFile) != 0) {
vnegnev:     /* failed */
vnegnev:     fprintf(stderr, "FATAL - Could not parse input\n");
lincoln:     hashtab_clear(prgSyms);
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* display known symbols */
lincoln:   if (0) {
lincoln:     hashtab_show(prgSyms);
vnegnev:   }
vnegnev:   
vnegnev:   /* allocate space to write binary program data */
lincoln:   if (hashtab_lookup(prgSyms, "$filesize", &prgSize) != 0) {
vnegnev:     fprintf(stderr, "ERROR - Unknown file size\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   if ((data = CALLOC(char, prgSize)) == NULL) {
vnegnev:     fprintf(stderr, "ERROR - Memory allocation failed\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* rewind input file to beginning for second pass */
vnegnev:   if (fseek(inFile, 0L, SEEK_SET) != 0) {
vnegnev:     perror("FATAL - Could not rewind file");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* attempt to assemble */
lincoln:   if (asmgen_assemble(prgSyms, inFile, data) != 0) {
vnegnev:     fprintf(stderr, "FATAL - Could not assemble\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* identify output filename */
vnegnev:   if (argc < 3) {
vnegnev:     outName = guessed;
vnegnev:     strncpy(guessed, argv[1], 1024);
lincoln:     guess_output( guessed);
vnegnev:   }
vnegnev:   else {
vnegnev:     /* specified, use that */
vnegnev:     outName = argv[2];
vnegnev:   }
vnegnev:   printf("Output name is \'%s\'\n", outName);
vnegnev:   
lincoln:   //LDT: write file - to bin format only now
lincoln:   ret = asmout_make_bin(prgSyms, outName, data) != 0;
lincoln: 
vnegnev:   if (ret != 0) {
vnegnev:     fprintf(stderr, "FATAL - File output failed\n");
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   return 0;
vnegnev: }
vnegnev: #include <stdio.h>
vnegnev: #include <stdlib.h>
vnegnev: #include <ctype.h>
vnegnev: #include "scan.h"
vnegnev: 
vnegnev: /* actions to take on the current buffered character */
vnegnev: typedef enum
vnegnev:   { SAVE, TRASH, RETURN }
vnegnev: ChAction;
vnegnev: 
vnegnev: /* states in state machine */
vnegnev: typedef enum
vnegnev:   { START, COMMENT, IDENT, IDLIMIT1, IDLIMIT2, NUMER_DEC,
vnegnev:     NUMER_OCT, NUMER_HEX, FORMAT, SUBFORMAT, DONE }
vnegnev: StateType;
vnegnev: 
vnegnev: /*
vnegnev:  * Primary Scanner Function - scan_token
vnegnev:  *
vnegnev:  * Arguments:
vnegnev:  *   token  - a pointer to a token (scanner will write here)
vnegnev:  *
vnegnev:  * Returns:
vnegnev:  *   a enumerated TokenType value, indicating what type of token
vnegnev:  * was written to the token pointer (IDENT, INT, ASSIGN, etc..)
vnegnev:  */
vnegnev: TokenType scan_token(struct Token *inToken, struct ScanData *data) {
vnegnev:   
vnegnev:   /* local function variables */
vnegnev:   StateType curState;		/* current state machine status/state */
vnegnev:   ChAction chStatus;		/* what to do with this character */
vnegnev:   int ch;			/* current character */
vnegnev:   int tIdx;			/* position in token */
vnegnev:   
vnegnev:   /* sanity check for NULL pointers */
vnegnev:   if ((inToken == NULL) || (data->input == NULL)) {
vnegnev:     return TOK_ERROR;
vnegnev:   }
vnegnev:   
vnegnev:   /* initialize scanner token and state machine */
vnegnev:   inToken->type = TOK_EOF;	/* this will be an EOF if nothing read */
vnegnev:   tIdx = 0;			/* position in string token */
vnegnev:   curState = START;		/* start state machine */
vnegnev:   
vnegnev:   /* set token bit limits */
vnegnev:   inToken->limLow = 0;
vnegnev:   inToken->limHigh = 8*sizeof(inToken->value)-1;
vnegnev:   
vnegnev:   /*
vnegnev:    * Main Scanner Loop (state machine)
vnegnev:    *   [ implementation of discrete finite state autonoma ]
vnegnev:    *
vnegnev:    * loop until machine is in DONE state or, scanner is out
vnegnev:    * of token buffer space.
vnegnev:    */
vnegnev:   while ((curState != DONE) && (tIdx < (MAX_TOKLEN - 1)))  {
vnegnev:     
vnegnev:     /* grab next character if able */
vnegnev:     ch = fgetc(data->input);		/* read next character */
vnegnev:     chStatus = SAVE;		/* set save status on character */
vnegnev:     
vnegnev:     /* if uppercase, switch to lower */
vnegnev:     if (isupper(ch)) {
vnegnev:       ch = tolower(ch);
vnegnev:     }
vnegnev:     
vnegnev:     /* if we hit EOF, set DONE state, and kick out */
vnegnev:     if (ch == EOF) {
vnegnev:       curState = DONE;
vnegnev:       continue;
vnegnev:     }
vnegnev: 
vnegnev:     /* traverse states */
vnegnev:     switch (curState) {
vnegnev: 
vnegnev:     case START:			/* initial state */
vnegnev: 
vnegnev:       /* decide what sort of character this is */
vnegnev:       if (isspace(ch) && (ch != '\n')) {
vnegnev: 	/* this is whitespace, throw it away */
vnegnev: 	chStatus = TRASH;
vnegnev: 	curState = START;
vnegnev:       }
vnegnev:       else if (isalpha(ch)) {
vnegnev: 	/* alphabetic character - start of identifier */
vnegnev: 	inToken->type = TOK_IDENT;
vnegnev: 	curState = IDENT;
vnegnev:       }
vnegnev:       else if (ch == '0') {
vnegnev: 	/* starts with zero, octal number */
vnegnev: 	inToken->type = TOK_INT;
vnegnev: 	curState = NUMER_OCT;
vnegnev:       }	
vnegnev:       else if (isdigit(ch)) {
vnegnev: 	/* numerical value - start of integer literal */
vnegnev: 	inToken->type = TOK_INT;
vnegnev: 	curState = NUMER_DEC;
vnegnev:       }
vnegnev:       
vnegnev:       /*
vnegnev:        * the big multicharacter tests didn't claim this character,
vnegnev:        * so use a switch to determine what sort of character this is
vnegnev:        */
vnegnev:       else switch(ch) {
vnegnev:       case '.':
vnegnev: 	/* period - start of a assembly directive */
vnegnev: 	inToken->type = TOK_DIRECTIVE;
vnegnev: 	curState = IDENT;	/* piggy back off identifier logic */
vnegnev: 	break;
vnegnev:       case ';':
vnegnev: 	/* semicolon, comment char */
vnegnev: 	curState = COMMENT;
vnegnev: 	break;
vnegnev:       case '{':
vnegnev: 	/* left brace, start of format descriptor */
vnegnev: 	inToken->type = TOK_ERROR;	/* only until it finishes */
vnegnev: 	chStatus = TRASH;
vnegnev: 	curState = FORMAT;
vnegnev: 	break;
vnegnev:       case '\n':
vnegnev: 	/* newline (next line) */
vnegnev: 	inToken->type = TOK_ENDL;
vnegnev: 	curState = DONE;
vnegnev: 	data->linecount += 1;
vnegnev: 	break;
vnegnev:       case '$':
vnegnev: 	/* specifier for a hex number,
vnegnev: 	 * ignore the '$', but replace it with a '0x' */
vnegnev: 	chStatus = TRASH;
vnegnev: 	curState = START;
vnegnev: 	ungetc('x',data->input);	/* tricky tricky */
vnegnev: 	ungetc('0',data->input);
vnegnev: 	break;
vnegnev:       case '(':
vnegnev: 	/* left parentheses */
vnegnev: 	inToken->type = TOK_LPAREN;
vnegnev: 	curState = DONE;
vnegnev: 	break;
vnegnev:       case ')':
vnegnev: 	/* right parentheses */
vnegnev: 	inToken->type = TOK_RPAREN;
vnegnev: 	curState = DONE;
vnegnev: 	break;
vnegnev:       case '+':
vnegnev:       case '-':
vnegnev:       case '*': //VN: multiplication operator
vnegnev:       case '>': //VN: right shift (/2^n) operator
vnegnev:       case '<': //VN: left shift (*2^n) operator
vnegnev:       case '&': //VN: bitwise AND operator
vnegnev:       case '|': //VN: bitwise OR operator
vnegnev: 	/* arithmetic operator */
vnegnev: 	inToken->type = TOK_ARITHOP;
vnegnev: 	curState = DONE;
vnegnev: 	break;
vnegnev: 	
vnegnev:       default:
vnegnev: 	/* unhandled character */
vnegnev: 	inToken->type = TOK_ERROR;
vnegnev: 	curState = DONE;
vnegnev: 	break;
vnegnev:       }
vnegnev:       break;
vnegnev: 
vnegnev:     case COMMENT:
vnegnev:       /* comment state, stay here until line terminator */
vnegnev:       if ((ch == '\n') || (ch == '\r')) {
vnegnev: 	/* end of comment */
vnegnev: 	curState = START;
vnegnev: 	tIdx = 0;
vnegnev: 	chStatus = RETURN;
vnegnev:       }
vnegnev:       else {
vnegnev: 	chStatus = TRASH;		/* throw characters away */
vnegnev:       }
vnegnev:       break;
vnegnev: 
vnegnev:     case IDENT:
vnegnev:       /* part of an identifier, or possibly an assembly directive */
vnegnev:       /* stay here reading alphabetic, numeric, and '_' characters */
vnegnev:       if (ch == ':') {
vnegnev: 	/* ends up being a label */
vnegnev: 	inToken->type = TOK_LABEL;
vnegnev: 	chStatus = TRASH;
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       else if (ch == '<') {
vnegnev: 	/* beginning of identifier with a bit limit attached */
vnegnev: 	inToken->type = TOK_ERROR;	/* until completed */
vnegnev: 	curState = IDLIMIT1;
vnegnev:       }
vnegnev:       else if ((!isalnum(ch)) && (ch != '_')) {
vnegnev: 	/* not alphabetic, numeric, or a '_' */
vnegnev: 	chStatus = RETURN;	/* push back into stream */
vnegnev: 	curState = DONE;	/* we're done with this token */
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case IDLIMIT1:
vnegnev:       /* part of an identifier with bit limit */
vnegnev:       if (ch == '-') {
vnegnev: 	/* beginning of second part */
vnegnev: 	curState = IDLIMIT2;
vnegnev:       }
vnegnev:       else if (!isdigit(ch)) {
vnegnev: 	/* numbers or colons only here, bomb */
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case IDLIMIT2:
vnegnev:       /* part of an identifier with bit limit */
vnegnev:       if (ch == '>') {
vnegnev: 	/* end of second part */
vnegnev: 	inToken->type = TOK_IDENT_LIMIT;
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       else if (!isdigit(ch)) {
vnegnev: 	/* numbers or colons only here, bomb */
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case NUMER_DEC:
vnegnev:       /* part of an decimal integer literal */
vnegnev:       /* stay here while reading numeric digit characters */
vnegnev:       if (!isdigit(ch)) {
vnegnev: 	/* not a numeric digit */
vnegnev: 	chStatus = RETURN;		/* push back into stream */
vnegnev: 	curState = DONE;		/* we're done with this token */
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case NUMER_OCT:
vnegnev:       /* part of an octal integer literal */
vnegnev:       /* stay here while reading numeric digit characters */
vnegnev:       if (ch == 'x') {
vnegnev: 	/* hexadecimal number */
vnegnev: 	curState = NUMER_HEX;
vnegnev:       }
vnegnev:       else if (isdigit(ch)) {
vnegnev: 	if (ch > '7') {
vnegnev: 	  /* outside of octal range */
vnegnev: 	  inToken->type = TOK_ERROR;
vnegnev: 	}
vnegnev:       }
vnegnev:       else {
vnegnev: 	/* not a numeric digit */
vnegnev: 	chStatus = RETURN;		/* push back into stream */
vnegnev: 	curState = DONE;		/* we're done with this token */
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case NUMER_HEX:
vnegnev:       /* part of an hexadecimal integer literal */
vnegnev:       /* stay here while reading numeric digit characters */
vnegnev:       if (!isxdigit(ch)) {
vnegnev: 	/* not a numeric digit */
vnegnev: 	chStatus = RETURN;		/* push back into stream */
vnegnev: 	curState = DONE;		/* we're done with this token */
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case FORMAT:
vnegnev:       /* part of a { ... } format descriptor */
vnegnev:       if (ch == '\n') {
vnegnev: 	/* may hit one inside format, tick the counter */
vnegnev: 	chStatus = TRASH;
vnegnev: 	data->linecount += 1;
vnegnev:       }
vnegnev:       else if (isspace(ch)) {
vnegnev: 	/* other whitespace .. ignore it and move on */
vnegnev: 	chStatus = TRASH;
vnegnev:       } 
vnegnev:       else if ((ch == '0') || (ch == '1')) {
vnegnev: 	/* binary bits will be added the returned packet */
vnegnev:       }
vnegnev:       else if (ch == '(') {
vnegnev: 	/* subfield start - ie "00 (2) 00" */
vnegnev: 	curState = SUBFORMAT;
vnegnev:       }
vnegnev:       else if (ch == '}') {
vnegnev: 	/* end of format descriptor */
vnegnev: 	inToken->type = TOK_FORMAT;
vnegnev: 	chStatus = TRASH;
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       else {
vnegnev: 	/* unknown character in expression */
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     case SUBFORMAT:
vnegnev:       /* part of a { ... } format descriptor */
vnegnev:       if (ch == '\n') {
vnegnev: 	/* may hit one inside format, tick the counter */
vnegnev: 	chStatus = TRASH;
vnegnev: 	data->linecount += 1;
vnegnev:       }
vnegnev:       else if (isspace(ch)) {
vnegnev: 	/* other whitespace .. ignore it and move on */
vnegnev: 	chStatus = TRASH;
vnegnev:       } 
vnegnev:       else if (isdigit(ch)) {
vnegnev: 	/* decimal digits will be added to the returned packet */
vnegnev:       }
vnegnev:       else if (ch == ')') {
vnegnev: 	/* subfield end - ie "00 (2) 00" */
vnegnev: 	/* go back and finish the format */
vnegnev: 	curState = FORMAT;
vnegnev:       }
vnegnev:       else {
vnegnev: 	/* unknown character in expression */
vnegnev: 	curState = DONE;
vnegnev:       }
vnegnev:       break;
vnegnev:       
vnegnev:     default:
vnegnev:       /* should always have a defined state, but just in case */
vnegnev:       fprintf(stderr, "Invalid State in State Machine\n");
vnegnev:       inToken->type = TOK_ERROR;
vnegnev:       curState = DONE;
vnegnev:       break;
vnegnev:     }
vnegnev: 
vnegnev:     /* current state processed, what did it say to do? */
vnegnev:     if (chStatus == SAVE) {
vnegnev:       /* save character to token */
vnegnev:       inToken->token[tIdx] = (char)ch;	/* load into token */
vnegnev:       tIdx += 1;				/* increment index */
vnegnev:     }
vnegnev:     else if (chStatus == RETURN) {
vnegnev:       /* return character to stream */
vnegnev:       if (ungetc(ch,data->input) == EOF) {
vnegnev: 	/* ungetc failed, this is extremely bad */
vnegnev: 	fprintf(stderr,"Cannot push back to stream\n");
vnegnev: 	exit(1);
vnegnev:       }
vnegnev:     }
vnegnev:     /* if chStatus == TRASH, then this character is ignored */
vnegnev:   }
vnegnev:   
vnegnev:   /* main loop terminates right above here, so once here, state
vnegnev:      machine is done, and the token is almost formed */
vnegnev:   
vnegnev:   /* state machine is done, so terminate this token string */
vnegnev:   inToken->token[tIdx] = '\0';
vnegnev:   
vnegnev:   /* set line for this token */
vnegnev:   inToken->linenum = data->linecount;
vnegnev:   
vnegnev:   /* if this is an numerical integer, calculate its equivalent value */
vnegnev:   if (inToken->type == TOK_INT) {
vnegnev:     /* stdio to scan this for an integer value */
vnegnev:     //sscanf(inToken->token,"%d",&(inToken->value));
vnegnev:     inToken->value = (int)strtol(inToken->token, (char **)NULL, 0);
vnegnev:   }
vnegnev:   else {
vnegnev:     inToken->value = -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* do bit limits if needed */
vnegnev:   if (inToken->type == TOK_IDENT_LIMIT) {
vnegnev:     chop_token_limits(inToken);
vnegnev:   }
vnegnev:   
vnegnev:   /* return this token type */
vnegnev:   return inToken->type;
vnegnev: }
vnegnev: /*
vnegnev:  * scanutil.c
vnegnev:  * Tim Parys (11/21/2004)
vnegnev:  *
vnegnev:  * This file contains some related scanner functions
vnegnev:  * which are not necessary for the operation of the
vnegnev:  * scanner. Most of these are utility/wrapper functions
vnegnev:  * placed here to keep scan.c a bit neater.
vnegnev:  */
vnegnev: 
vnegnev: #include <stdio.h>
vnegnev: #include <stdlib.h>
vnegnev: #include <string.h>
vnegnev: #include <ctype.h>
vnegnev: #include "scan.h"
vnegnev: 
vnegnev: /*
vnegnev:  * push_token
vnegnev:  *    utility function to take the a pointer to a Token struct
vnegnev:  * and then create a cloned copy of it to use later. Memory
vnegnev:  * passed to this function IS NOT claimed, local variables are
vnegnev:  * safe to pass.
vnegnev:  *
vnegnev:  * returns 0 on sucess, nonzero on failure
vnegnev:  */
vnegnev: int push_token(struct Token *inToken, struct ScanData *data) {
vnegnev:   struct StackNode *newnode;
vnegnev:   
vnegnev:   /* allocate space for this token on the stack */
vnegnev:   newnode = MALLOC(struct StackNode);
vnegnev: 
vnegnev:   /* check for failed allocation */
vnegnev:   if (newnode == NULL) {
vnegnev:     /* allocation failure */
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   /* otherwise clone input node, and move onto stack */
vnegnev:   memcpy((char*)(&(newnode->token)),(char*)inToken,sizeof(struct Token));
vnegnev:   newnode->next = data->tokBuf;
vnegnev:   data->tokBuf = newnode;
vnegnev:   
vnegnev:   /* success */
vnegnev:   return 0;
vnegnev: }
vnegnev: 
vnegnev: /*
vnegnev:  * get_token
vnegnev:  *    wrapper function to call the main scanner routine, but use
vnegnev:  * any and all buffered tokens first (this should allow the parser
vnegnev:  * to push a set of tokens back, and allow back-tracking).
vnegnev:  *
vnegnev:  * returns type of token returned
vnegnev:  */
vnegnev: TokenType get_token(struct Token *inToken, struct ScanData *data) {
vnegnev:   struct StackNode *newnode;
vnegnev:   
vnegnev:   /* get top of stack */
vnegnev:   newnode = data->tokBuf;
vnegnev:   
vnegnev:   /* check empty stack */
vnegnev:   if (newnode == NULL) {
vnegnev:     /* empty stack, try scanning instead */
vnegnev:     return scan_token(inToken, data);
vnegnev:   }
vnegnev:   
vnegnev:   /* otherwise pull token and copy contents */
vnegnev:   memcpy((char*)inToken,(char*)(&(newnode->token)),sizeof(struct Token));
vnegnev:   data->tokBuf = newnode->next;
vnegnev:   free(newnode);	/* delete this node */
vnegnev: 
vnegnev:   /* success */
vnegnev:   return inToken->type;
vnegnev: }
vnegnev: 
vnegnev: /*
vnegnev:  * peek_token
vnegnev:  *    utility function to find the type of the next token that
vnegnev:  * would be returned by the scanner
vnegnev:  *
vnegnev:  * returns type of token to be read next
vnegnev:  */
vnegnev: TokenType peek_token(struct ScanData *data) {
vnegnev:   struct Token myToken;
vnegnev:   
vnegnev:   /* if the token is on the stack, this is easy */
vnegnev:   if (data->tokBuf != NULL) {
vnegnev:     return data->tokBuf->token.type;
vnegnev:   }
vnegnev: 
vnegnev:   /* else get a copy of the next token */
vnegnev:   (void)get_token(&myToken,data);
vnegnev:   if (push_token(&myToken, data) != 0) {
vnegnev:     /* cannot push back to stack, very bad */
vnegnev:     fprintf(stderr,"Cannot push token back into buffer\n");
vnegnev:     exit(1);
vnegnev:   }
vnegnev:   
vnegnev:   /* return its type */
vnegnev:   return myToken.type;
vnegnev: }
vnegnev: 
vnegnev: void clear_token_buffer(struct StackNode *data) {
vnegnev:   struct StackNode *temp;
vnegnev:   while (data != NULL) {
vnegnev:     temp = data->next;
vnegnev:     free(data);
vnegnev:     data = temp;
vnegnev:   }
vnegnev: }
vnegnev: 
vnegnev: /* bit of a cheap hack to do this, but oh well */
vnegnev: int chop_token_limits(struct Token *tok) {
vnegnev:   int x, tokLen;
vnegnev:   
vnegnev:   if (tok->type != TOK_IDENT_LIMIT) {
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   tokLen = strlen(tok->token);
vnegnev:   for (x=0; x<tokLen; x++) {
vnegnev:     if ((!isalnum(tok->token[x])) &&
vnegnev: 	(tok->token[x] != '_')) {
vnegnev:       tok->token[x] = '\0';
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   /* advance to first number */
vnegnev:   x=0;
vnegnev:   while (tok->token[x] != '\0') { x++; }
vnegnev:   while (tok->token[x] == '\0') { x++; }
vnegnev:   
vnegnev:   /* scan first number */
vnegnev:   tok->limLow = (int)strtol(&tok->token[x], (char **)NULL, 0);
vnegnev:   
vnegnev:   /* advance to second number */
vnegnev:   while (tok->token[x] != '\0') { x++; }
vnegnev:   while (tok->token[x] == '\0') { x++; }
vnegnev:   
vnegnev:   /* scan first number */
vnegnev:   tok->limHigh = (int)strtol(&tok->token[x], (char **)NULL, 0);
vnegnev:   tok->type = TOK_IDENT;
vnegnev:   
vnegnev:   return 0;
vnegnev: }
vnegnev: 
vnegnev: #include <stdio.h>
vnegnev: #include <stdlib.h>
vnegnev: #include <string.h>
vnegnev: #include "symtab.h"
vnegnev: #include "scan.h"
vnegnev: 
vnegnev: int symtab_clear(struct SymTab **curSyms) {
vnegnev:   struct SymTab *temp;
vnegnev:   
vnegnev:   /* sanity check */
vnegnev:   if (curSyms == NULL) {
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   while (*curSyms != NULL) {
vnegnev:     temp = (*curSyms)->next;
vnegnev:     free(*curSyms);
vnegnev:     *curSyms = temp;
vnegnev:   }
vnegnev:   
vnegnev:   return 0;
vnegnev: }
vnegnev: 
lincoln: int symtab_record(struct SymTab **curSyms, char *name, int intVal) {
vnegnev:   struct SymTab *newsym, *loop;
vnegnev:   
vnegnev:   /* sanity check */
vnegnev:   if ((curSyms == NULL) || (name == NULL)){
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   for (loop = *curSyms; loop != NULL; loop = loop->next) {
vnegnev:     if (strcmp(loop->name, name)==0) {
vnegnev:       /* already exists, overwrite */
vnegnev:       loop->intVal = intVal;
lincoln:       return 0;
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   /* not found, record new */
vnegnev:   if ((newsym = MALLOC(struct SymTab)) == NULL) {
vnegnev:     /* allocation error */
vnegnev:     fprintf(stderr, "FATAL - Could not allocate space\n");
vnegnev:     exit(-1);
vnegnev:   }
vnegnev:   
vnegnev:   /* record and add into list */
vnegnev:   strcpy(newsym->name, name);
vnegnev:   newsym->intVal = intVal;
vnegnev:   newsym->next = *curSyms;
vnegnev:   *curSyms = newsym;
vnegnev: 
vnegnev:   return 0;
vnegnev: }
vnegnev: 
lincoln: int symtab_lookup(struct SymTab **curSyms, char *name, int *intOut) {
vnegnev:   struct SymTab *loop;
vnegnev:   
vnegnev:   /* sanity check */
vnegnev:   if ((curSyms == NULL) || (name == NULL)){
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   for (loop = *curSyms; loop != NULL; loop = loop->next) {
vnegnev:     if (strcmp(loop->name, name)==0) {
vnegnev:       if (intOut != NULL) {
vnegnev: 	*intOut = loop->intVal;
vnegnev:       }
vnegnev:       return 0;
vnegnev:     }
vnegnev:   }
vnegnev:   
vnegnev:   /* not found */
vnegnev:   return -1;
vnegnev: }
vnegnev: 
vnegnev: int symtab_show(struct SymTab **curSyms) {
vnegnev:   struct SymTab *loop = *curSyms;
vnegnev:   
vnegnev:   /* sanity check */
vnegnev:   if (curSyms == NULL){
vnegnev:     return -1;
vnegnev:   }
vnegnev:   
vnegnev:   printf("Listing of known symbols\n");
vnegnev:   for (loop = *curSyms; loop != NULL; loop = loop->next) {
lincoln:     printf("-> %-15s%d (0x%x)\n",
vnegnev: 	     loop->name, loop->intVal, loop->intVal);
vnegnev:   }
vnegnev:   return 0;
vnegnev: }
