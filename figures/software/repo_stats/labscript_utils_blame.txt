        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __init__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the labscript suite (see                     #
        cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
        cbilling: # BSD License. See the license.txt file in the root of the project  #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: 
chrisjbillington: __version__ = '2.7.1'
           Chris: 
           Chris: 
           Chris: import sys
           Chris: import os
           Chris: import traceback
           Chris: 
           Chris: PY2 = sys.version_info[0] == 2
           Chris: 
           Chris: for path in sys.path:
           Chris:     if os.path.exists(os.path.join(path, '.is_labscript_suite_install_dir')):
           Chris:         labscript_suite_install_dir = path
           Chris:         break
           Chris: else:
           Chris:     labscript_suite_install_dir = None
        cbilling: 
chrisjbillington: # Enforce that the same file can't be imported under multiple names, to help
chrisjbillington: # prevent subtle bugs:
chrisjbillington: import labscript_utils.double_import_denier
chrisjbillington: labscript_utils.double_import_denier.enable()
        cbilling: 
        cbilling: class VersionException(Exception):
        cbilling:     pass
        cbilling: 
           Chris: def _get_version(module_name):
           Chris:     """return the version string module.__version__ by importing the module,
           Chris:     and the exc_info for the exception (if any) raised during import, or None
           Chris:     if there was no exception. If the version string is defined prior to the
           Chris:     exception during import, then it will still be returned. Otherwise None
           Chris:     will be returned in its place. This can be useful since having
           Chris:     incompatible versions of packages can itself be the cause of exceptions
           Chris:     during import, so it is preferable to raise a 'wrong version' in addition
           Chris:     to, or instead of the exception that was raised during import"""
           Chris: 
           Chris:     from labscript_utils.brute_import import brute_import
           Chris: 
           Chris:     try:
           Chris:         module = __import__(module_name)
           Chris:         exc_info = None
           Chris:     except Exception:
           Chris:         exc_info = sys.exc_info()
           Chris:         # brute_import returns the exception, but if for some reason it's
           Chris:         # different we should return the one we got at the first atttempted
           Chris:         # import:
           Chris:         module, _ = brute_import(module_name)
chrisjbillington:     return getattr(module, '__version__', None), exc_info
           Chris: 
           Chris: 
           Chris: def _reraise(exc_info):
           Chris:     type, value, traceback = exc_info
           Chris:     # handle python2/3 difference in raising exception        
           Chris:     if PY2:
           Chris:         exec('raise type, value, traceback', globals(), locals())
           Chris:     else:
           Chris:         raise value.with_traceback(traceback)
           Chris: 
          rander: 
        cbilling: def check_version(module_name, at_least, less_than, version=None):
          rander:     from distutils.version import LooseVersion
        cbilling: 
        cbilling:     if version is None:
           Chris:         version, exc_info = _get_version(module_name)
           Chris: 
           Chris:     if version is not None:
           Chris:         at_least_version, less_than_version, installed_version = [LooseVersion(v) for v in [at_least, less_than, version]]
           Chris:         if not at_least_version <= installed_version < less_than_version:
           Chris:             msg = '{module_name} {version} found. {at_least} <= {module_name} < {less_than} required.'.format(**locals())
           Chris:             if exc_info is not None:
           Chris:                 msg += '\n\n === In addition, the below exception was raised during import of {}: ===\n\n'.format(module_name)
           Chris:                 msg += ''.join(traceback.format_exception(*exc_info))
           Chris:             raise VersionException(msg)
           Chris: 
           Chris:     # Correct version string, but failed import:
           Chris:     if exc_info is not None:
           Chris:         _reraise(exc_info)
           Chris: 
           Chris:     # Successful import but no version string:
           Chris:     if version is None:
           Chris:         raise ValueError('Invalid version string from package {}: {}'.format(module_name, version))
           Chris: 
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # brute_import.py                                                   #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2017, Chris Billington                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: 
             jan: from labscript_utils import PY2
           Chris: import sys
           Chris: import os
           Chris: import types
           Chris: import imp
           Chris: import marshal
           Chris: 
           Chris: 
           Chris: def _fallback(module_name):
           Chris:     # No module code to execute? Just import the usual way then and return an
           Chris:     # empty module upon exception:
           Chris:     try:
           Chris:         module = __import__(module_name)
           Chris:         return module, None
           Chris:     except Exception:
           Chris:         module = types.ModuleType(module_name)
           Chris:         return module, sys.exc_info()
           Chris: 
           Chris: 
           Chris: def brute_import(module_name):
           Chris:     """Execute a module as if it were being imported, catch exceptions, and
           Chris:     return the (possibly only partially initialised) module object as well as
           Chris:     the exc_info for the exception (or None if there was no exception). This
           Chris:     is useful for say, inspecting the __version__ string of a module that is
           Chris:     failing to import in order to raise a potentially more useful exception if
           Chris:     the module is failing to import *because* it is the wrong version."""
             jan:     if PY2:
             jan:         module_name = bytes(module_name)
           Chris: 
           Chris:     sourcefile, pathname, (_, _, module_type) = imp.find_module(module_name)
           Chris:     module = types.ModuleType(module_name)
           Chris:     sys.modules[module_name] = module
           Chris: 
           Chris:     if module_type in [imp.PY_SOURCE, imp.PY_COMPILED]:
           Chris:         module.__file__ = pathname
           Chris:     elif module_type == imp.PKG_DIRECTORY:
           Chris:         module.__path__ = [pathname]
           Chris:         module.__file__ = os.path.join(pathname, '__init__.py')
           Chris:         sourcefile = open(module.__file__)
           Chris:     else:
           Chris:         return _fallback(module_name)
           Chris: 
           Chris:     if module_type in [imp.PY_SOURCE, imp.PKG_DIRECTORY]:
           Chris:         code = compile(sourcefile.read(), module.__file__, 'exec', dont_inherit=True)
           Chris:     elif module_type == imp.PY_COMPILED:
           Chris:         if sourcefile.read(4) != imp.get_magic():
           Chris:             # Different python version, we can't execute:
           Chris:             return _fallback(module_name)
           Chris:         # skip timestamp:
           Chris:         _ = sourcefile.read(4)
           Chris:         code = marshal.load(sourcefile)
           Chris:     else:
           Chris:         # Some C extension or something. No code for us to execute.
           Chris:         return _fallback(module_name)
             jan: 
           Chris:     try:
           Chris:         # Execute the module code in its namespace:
           Chris:         exec(code, module.__dict__)
           Chris:         return module, None
           Chris:     except Exception:
           Chris:         exc_info = sys.exc_info()
           Chris:         return module, sys.exc_info()
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # camera_server.py                                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2016, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
chrisjbillington: 
chrisjbillington: import sys
chrisjbillington: import time
chrisjbillington: import zprocess
chrisjbillington: from labscript_utils import check_version
chrisjbillington: import labscript_utils.shared_drive
chrisjbillington: # importing this wraps zlock calls around HDF file openings and closings:
chrisjbillington: import labscript_utils.h5_lock
chrisjbillington: import h5py
chrisjbillington: import numpy as np
           Chris: check_version('zprocess', '1.3.3', '3.0')
chrisjbillington: 
chrisjbillington: # This file implements the protocol for a camera server, that is, a program
chrisjbillington: # that BLACS can interface with to control cameras. It contains a class that
chrisjbillington: # acts as a camera server and communicates with BLACS over zeromq. The
chrisjbillington: # protocol is as below. A user need not implement this protocol themselves,
chrisjbillington: # they instead should subclass CameraServer and override the
chrisjbillington: # transition_to_buffered(), transition_to_static(), and abort() methods. An
chrisjbillington: # example is show at the bottom of this file. Note that the filepath send from
chrisjbillington: # BLACS to the camera server has a 'network agnostic' prefix - it is assumed
chrisjbillington: # that BLACS and the camera server may not have the same path to the location
chrisjbillington: # of the HDF5 file, it may be on a shared drive with different drive
chrisjbillington: # letters/mount points on the two computers. So BLACS calls
chrisjbillington: # labscript_utils.shared_drive.path_to_agnostic() on the filepath before
chrisjbillington: # sending it, and the camera server should call
chrisjbillington: # labscript_utils.shared_drive.path_to_local() once receiving it. If you
chrisjbillington: # subclass CameraServer, you don't have to worry about this step, so long as
chrisjbillington: # the shared drive path is correctly declared in your labconfig file.
chrisjbillington: #
chrisjbillington: # All communications are as utf-8 encoded strings.
chrisjbillington: #
chrisjbillington: # Ping, can occur at any time:
chrisjbillington: #   BLACS sends: 'hello'
chrisjbillington: #   CameraServer responds: 'hello'
chrisjbillington: #
chrisjbillington: # transition_to_buffered, occurs when BLACS is preparing to start a shot:
chrisjbillington: #   BLACS sends: '<utf8-encoded-path-of-h5-file->.h5'
chrisjbillington: #   CameraServer responds: 'ok'
chrisjbillington: #   BLACS sends: '' (empty string)
chrisjbillington: #   (Camera server calls self.transition_to_buffered(), to do any processing
chrisjbillington: #       it needs to to set up the shot)
chrisjbillington: #   CameraServer responds: 'done'
chrisjbillington: #   OR, if exception encountered calling self.transition_to_buffered(), camera
chrisjbillington: #       server calls self.abort() and then responds with the exception text.
chrisjbillington: #
chrisjbillington: # transition_to_static, occurs when BLACS has completed a shot:
chrisjbillington: #   BLACS sends: 'done'
chrisjbillington: #   CameraServer responds: 'ok'
chrisjbillington: #   BLACS sends: '' (empty string)
chrisjbillington: #   (Camera server calls self.transition_to_static(), to do any processing it
chrisjbillington: #       needs to do at the end of the shot)
chrisjbillington: #   CameraServer responds: 'done'
chrisjbillington: #   OR, if exception encountered calling self.transition_to_static(), camera
chrisjbillington: #       server calls self.abort() and then responds with the exception text.
chrisjbillington: #
chrisjbillington: # abort, can occur at any time:
chrisjbillington: #   BLACS sends 'abort'
chrisjbillington: #   (Camera server calls self.abort(), to return things to a sensible state
chrisjbillington: #       where transition_to_buffered can be called again )
chrisjbillington: #   CameraServer responds: 'done'
chrisjbillington: #   OR, if exception encountered calling self.abort(), camera server responds
chrisjbillington: #       with the exception text.
chrisjbillington: #
chrisjbillington: 
chrisjbillington: class CameraServer(zprocess.ZMQServer):
chrisjbillington:     def __init__(self, port):
chrisjbillington:            zprocess.ZMQServer.__init__(self, port, type='string')
chrisjbillington:            self._h5_filepath = None
chrisjbillington: 
chrisjbillington:     def handler(self, request_data):
chrisjbillington:         try:
chrisjbillington:             print(request_data)
chrisjbillington:             if request_data == 'hello':
chrisjbillington:                 return 'hello'
chrisjbillington:             elif request_data.endswith('.h5'):
chrisjbillington:                 self._h5_filepath = labscript_utils.shared_drive.path_to_local(request_data)
chrisjbillington:                 self.send('ok')
chrisjbillington:                 self.recv()
chrisjbillington:                 self.transition_to_buffered(self._h5_filepath)
chrisjbillington:                 return 'done'
chrisjbillington:             elif request_data == 'done':
chrisjbillington:                 self.send('ok')
chrisjbillington:                 self.recv()
chrisjbillington:                 self.transition_to_static(self._h5_filepath)
chrisjbillington:                 self._h5_filepath = None
chrisjbillington:                 return 'done'
chrisjbillington:             elif request_data == 'abort':
         dsbark7:                 self.abort()
chrisjbillington:                 self._h5_filepath = None
           Chris:                 return 'done'
chrisjbillington:             else:
chrisjbillington:                 raise ValueError('invalid request: %s'%request_data)
chrisjbillington:         except Exception:
chrisjbillington:             if self._h5_filepath is not None and request_data != 'abort':
chrisjbillington:                 try:
chrisjbillington:                     self.abort()
chrisjbillington:                 except Exception as e:
chrisjbillington:                     sys.stderr.write('Exception in self.abort() while handling another exception:\n{}\n'.format(str(e)))
chrisjbillington:             self._h5_filepath = None
chrisjbillington:             raise
chrisjbillington: 
chrisjbillington:     def transition_to_buffered(self, h5_filepath):
chrisjbillington:         """To be overridden by subclasses. Do any preparatory processing
chrisjbillington:         before a shot, eg setting exposure times, readying cameras to receive
chrisjbillington:         triggers etc."""
chrisjbillington:         print('transition to buffered')
chrisjbillington: 
chrisjbillington:     def transition_to_static(self, h5_filepath):
chrisjbillington:         """To be overridden by subclasses. Do any post processing after a
chrisjbillington:         shot, eg computing optical depth, fits, displaying images, saving
chrisjbillington:         images and results to the h5 file, returning cameras to an idle
chrisjbillington:         state."""
chrisjbillington:         print('transition to static')
chrisjbillington: 
chrisjbillington:     def abort(self):
chrisjbillington:         """To be overridden by subclasses. Return cameras and any other state
chrisjbillington:         to one in which transition_to_buffered() can be called again. abort()
chrisjbillington:         will be called if there was an exception in either
chrisjbillington:         transition_to_buffered() or transtition_to_static(), and so should
chrisjbillington:         ideally be written to return things to a sensible state even if those
chrisjbillington:         methods did not complete. Like any cleanup function, abort() should
chrisjbillington:         proceed to further cleanups even if earlier cleanups fail. As such it
chrisjbillington:         should make liberal use of try: except: blocks, so that an exception
chrisjbillington:         in performing one cleanup operation does not stop it from proceeding
chrisjbillington:         to subsequent cleanup operations"""
chrisjbillington:         print('abort')
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # A minimalistic example of how to subclass a CameraServer:
chrisjbillington: 
chrisjbillington: class TubingenCameraServer(CameraServer):
chrisjbillington:     """Minimalistic camera server. Transition to buffered and abort are not
chrisjbillington:     implemented, because we don't need to do anything in those cases. This
chrisjbillington:     camera server simply writes to the h5 file the images, which have been
chrisjbillington:     saved to disk during each shot by an external program."""
chrisjbillington: 
chrisjbillington:     def transition_to_buffered(self, h5_filepath):
chrisjbillington:         # Our minimalistic example doesn't need to implement this method,
chrisjbillington:         # since the camera we used simply saved images to disk every time
chrisjbillington:         # it received a trigger, and didn't need any per-shot
chrisjbillington:         # configuration. But here is where you would put code to get the
chrisjbillington:         # camera ready for a shot, with its configuration possibly
chrisjbillington:         # depending on the contents of the h5 file, such as the globals in
chrisjbillington:         # h5_file['globals'].attrs.
chrisjbillington:         pass
chrisjbillington: 
chrisjbillington:     def transition_to_static(self, h5_filepath):
chrisjbillington:         """Read FITS images from file saved by an external program, and save
chrisjbillington:         them to the h5 file"""
chrisjbillington:         import pyfits
chrisjbillington:         start_time = time.time()
chrisjbillington:         with h5py.File(h5_filepath) as f:
chrisjbillington:             group = f['devices']['camera']
chrisjbillington:             if not 'EXPOSURES' in group:
chrisjbillington:                 print('no images taken this shot')
chrisjbillington:                 return
chrisjbillington:             group = f.create_group('images').create_group('side').create_group('absorption')
chrisjbillington:             with pyfits.open(r'C:\CameraControl\images\1_0_0.fits') as fits_images:
chrisjbillington:                 image_array = np.array(fits_images[0].data, dtype=float)
chrisjbillington:                 group.create_dataset('atoms',data=image_array)
chrisjbillington:             with pyfits.open(r'C:\CameraControl\images\1_0_1.fits') as fits_images:
chrisjbillington:                 image_array = np.array(fits_images[0].data, dtype=float)
chrisjbillington:                 group.create_dataset('flat',data=image_array)
chrisjbillington:             with pyfits.open(r'C:\CameraControl\images\1_0_2.fits') as fits_images:
chrisjbillington:                 image_array = np.array(fits_images[0].data, dtype=float)
chrisjbillington:                 group.create_dataset('dark',data=image_array)
chrisjbillington:             # Copy over the effective pixel size to a spot that lyse
chrisjbillington:             # automatically grabs params from:
chrisjbillington:             effective_pixel_size = f['/devices/camera'].attrs['effective_pixel_size']
chrisjbillington:             f['images/side'].attrs['effective_pixel_size'] = effective_pixel_size
chrisjbillington:         print('image saving time: %s s' %str(time.time() - start_time))
chrisjbillington: 
chrisjbillington:     def abort(self):
chrisjbillington:         # Our minimalistic example doesn't need to implement this method,
chrisjbillington:         # since the camera we used was always ready and didn't need to be
chrisjbillington:         # 'reset' to be ready for a new shot. But here is where you would
chrisjbillington:         # put cleanup code to do so. Likely this would be very similar to
chrisjbillington:         # transition_to_static, except without saving any data to a h5 file.
chrisjbillington:         pass
chrisjbillington: 
chrisjbillington: if __name__ == '__main__':
chrisjbillington: 
chrisjbillington:     # How to run a camera server:
chrisjbillington: 
chrisjbillington:     port = 8765
chrisjbillington:     print('starting camera server on port %d...' % port)
chrisjbillington:     server = CameraServer(port)
chrisjbillington:     server.shutdown_on_interrupt()
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # /connections.py                                                   #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of labscript_utils, in the labscript suite      #
chrisjbillington: # (see http://labscriptsuite.org), and is licensed under the        #
chrisjbillington: # Simplified BSD License. See the license.txt file in the root of   #
chrisjbillington: # the project for the full license.                                 #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import labscript_utils.h5_lock, h5py
chrisjbillington: import labscript_utils.properties
chrisjbillington: import logging
chrisjbillington: import labscript_utils.excepthook
chrisjbillington: import numpy as np
chrisjbillington: import copy
chrisjbillington: import ast
chrisjbillington: from labscript_utils.dict_diff import dict_diff
             jan: import sys
             jan: from zprocess import raise_exception_in_thread
             jan: from labscript_utils import PY2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
chrisjbillington: 
chrisjbillington: def _ensure_str(s):
chrisjbillington:     """convert bytestrings and numpy strings to python strings"""
chrisjbillington:     return s.decode() if isinstance(s, bytes) else str(s)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ConnectionTable(object):    
chrisjbillington:     def __init__(self, h5file, logging_prefix=None):
chrisjbillington:         """Object to represent a connection table. Set logging prefix if you
chrisjbillington:         desire logging. Log used will be <prefix>.ConnectionTable"""
chrisjbillington:         self.filepath = h5file
chrisjbillington:         self.logger = None
chrisjbillington:         if logging_prefix is not None:
chrisjbillington:             self.logger = logging.getLogger('{}.ConnectionTable'.format(logging_prefix))
chrisjbillington:             self.logger.debug('Parsing connection table from %s'%h5file)
chrisjbillington:             
chrisjbillington:         self.toplevel_children = {}
             jan:         self.table = {}
             jan:         self.master_pseudoclock = None
             jan:         self.raw_table = np.empty(0)
chrisjbillington: 
chrisjbillington:         try:
chrisjbillington:             with h5py.File(h5file,'r') as hdf5_file:
chrisjbillington:                 try:
chrisjbillington:                     dataset = hdf5_file['connection table']
chrisjbillington:                 except Exception:
chrisjbillington:                     msg = 'could not open connection table dataset in %s' % h5file
chrisjbillington:                     if self.logger: self.logger.error(msg)
             jan:                     raise_exception_in_thread(sys.exc_info())
             jan:                     return
chrisjbillington: 
chrisjbillington:                 self.raw_table = dataset[:]
chrisjbillington:                 try:
chrisjbillington:                     self.master_pseudoclock = _ensure_str(dataset.attrs['master_pseudoclock'])
chrisjbillington:                 except KeyError:
             jan:                     pass
chrisjbillington: 
chrisjbillington:                 try:
chrisjbillington:                     all_connections = [Connection(raw_row) for raw_row in self.raw_table]
chrisjbillington:                     self.table = {connection.name: connection for connection in all_connections}
chrisjbillington:                     for name, connection in self.table.items():
chrisjbillington:                         connection._populate_relatives(self.table)
chrisjbillington:                         if connection.parent_port is None:
chrisjbillington:                             self.toplevel_children[name] = connection
chrisjbillington:                 except Exception:
chrisjbillington:                     msg = 'Could not parse connection table in %s' % h5file
chrisjbillington:                     if self.logger: self.logger.error(msg)
             jan:                     raise_exception_in_thread(sys.exc_info())
chrisjbillington: 
chrisjbillington:         except Exception:
chrisjbillington:             msg = 'Could not open connection table file %s' % h5file
chrisjbillington:             if self.logger: self.logger.exception(msg)
             jan:             raise_exception_in_thread(sys.exc_info())
             jan: 
chrisjbillington:     def assert_superset(self, other):
chrisjbillington:         # let's check that we're a superset of the connection table in "other"
chrisjbillington:         if not isinstance(other, ConnectionTable):
chrisjbillington:             msg = "Loaded file is not a valid connection table"
chrisjbillington:             raise TypeError(msg)
chrisjbillington:         
chrisjbillington:         missing = []    # things I don't know exist
chrisjbillington:         incompat = []   # things that are different from what I expect
chrisjbillington:         
chrisjbillington:         for name, other_connection in other.table.items():
chrisjbillington:             # does it exist?
chrisjbillington:             try:
chrisjbillington:                 connection = self.table[name]
chrisjbillington:             except KeyError:
chrisjbillington:                 missing.append('  ' + name)
chrisjbillington:             else:
chrisjbillington:                 # is it the same?   
chrisjbillington:                 if connection != other_connection:
chrisjbillington:                     diff = connection.diff(other_connection)
chrisjbillington:                     msg = '  ' + name + ':\n'
chrisjbillington:                     for key, (ours, theirs) in diff.items():
chrisjbillington:                         if isinstance(ours, dict) and isinstance(theirs, dict):
chrisjbillington:                             msg += '    {}:\n'.format(key)
chrisjbillington:                             subdiff = dict_diff(ours, theirs)
chrisjbillington:                             for key, (ours, theirs) in subdiff.items():
chrisjbillington:                                 msg += '      {}: {} != {}'.format(key, ours, theirs)
chrisjbillington:                         else:
chrisjbillington:                             msg += '    {}: {} != {}'.format(key, ours, theirs)
chrisjbillington:                     incompat.append(msg)
chrisjbillington:         
chrisjbillington:         # construct a human-readable explanation
chrisjbillington:         errmsg = ""
chrisjbillington:         if len(missing) > 0:
chrisjbillington:             errmsg += '\nDevices that do not exist in the connection table:\n  '+'\n'.join(missing)
chrisjbillington:         if len(incompat) > 0:
chrisjbillington:             errmsg += '\nDevices with incompatible settings:\n'+'\n'.join(incompat)
chrisjbillington:         
chrisjbillington:         # if there is no error message, then everything must be good!
chrisjbillington:         if errmsg:
chrisjbillington:             msg = "Cannot execute script as connection tables do not match." + errmsg
chrisjbillington:             raise Exception(msg)
chrisjbillington:         
chrisjbillington:     def compare_to(self, other):
chrisjbillington:         if not isinstance(other, ConnectionTable):
chrisjbillington:             return False, {"error": "The connection table passed in is not a valid connection table"}
chrisjbillington:         error = {}
chrisjbillington:         # Check if top level children in other table are a subset of self.        
chrisjbillington:         for name, connection in other.toplevel_children.items():
chrisjbillington:             if not name in self.toplevel_children:
chrisjbillington:                 if self.logger: self.logger.error('missing: %s '% str(name))
chrisjbillington:                 if "children_missing" not in error:
chrisjbillington:                     error["children_missing"] = {}
chrisjbillington:                 error["children_missing"][name] = True
chrisjbillington:             else:
chrisjbillington:                 # for each top level child in other, check if children of that object are also children of the child in self.
chrisjbillington:                 result, child_error = self.toplevel_children[name].compare_to(connection)
chrisjbillington:                 if not result:
chrisjbillington:                     #TODO more info on what doesn't match? Print a diff and return it as part of the message?
chrisjbillington:                     if self.logger: self.logger.error('Connection table mismatch')
chrisjbillington:                     if "children" not in error:
chrisjbillington:                         error["children"] = {}
chrisjbillington:                     error["children"][name] = child_error
chrisjbillington:                 
chrisjbillington:         if error != {}:
chrisjbillington:             return False,error
chrisjbillington:         else:
chrisjbillington:             return True,error
chrisjbillington: 
chrisjbillington:     def print_details(self):
chrisjbillington:         for key, value in self.toplevel_children.items():
chrisjbillington:             print(key)
chrisjbillington:             value.print_details('  ')
chrisjbillington:     
chrisjbillington:     def get_attached_devices(self):
chrisjbillington:         """Finds out which devices in the connection table are
chrisjbillington:         connected to BLACS, based on whether their 'BLACS_connection'
chrisjbillington:         attribute is non-empty. Returns a dictionary of them in the form
chrisjbillington:         {device_instance_name: labscript_class_name}"""
chrisjbillington:         attached_devices = {}
chrisjbillington:         for name, device in self.table.items():
chrisjbillington:             if device.BLACS_connection:
chrisjbillington:                 # The device is connected to BLACS. Save its name and class:
chrisjbillington:                 attached_devices[name] = device.device_class
chrisjbillington:         return attached_devices
chrisjbillington:         
chrisjbillington:     # Returns the "Connection" object which is a child of "parent_name",
chrisjbillington:     # connected via "parent_port" Eg, Returns the child of "pulseblaster_0"
chrisjbillington:     # connected via "dds 0"
chrisjbillington:     def find_child(self, parent_name, parent_port):
chrisjbillington:         for name, connection in self.table.items():
chrisjbillington:             if (connection.parent_name == parent_name 
chrisjbillington:                     and connection.parent_port == parent_port):
chrisjbillington:                 return connection
chrisjbillington:         return None
chrisjbillington:     
chrisjbillington:     def find_by_name(self,name):
             jan:         name = _ensure_str(name)
chrisjbillington:         for device_name, connection in self.toplevel_children.items():
chrisjbillington:             if device_name == name:
chrisjbillington:                 return connection
chrisjbillington:             else:
chrisjbillington:                 result = connection.find_by_name(name)
chrisjbillington:                 if result is not None:
chrisjbillington:                     return result
chrisjbillington:         return None
chrisjbillington: 
             jan:     def remove_device(self, device_name):
             jan:         """Removes a device from the ConnectionTable, but keeps it in the
             jan:         raw_table. This can help make comparissons of connection tables fail
             jan:         for tables with broken devices."""
             jan:         if device_name in self.toplevel_children:
             jan:             del self.toplevel_children[device_name]
             jan:         if device_name == self.master_pseudoclock:
             jan:             self.master_pseudoclock = None
             jan:         del self.table[device_name]
             jan: 
chrisjbillington: 
chrisjbillington: class Connection(object):
chrisjbillington:     """A class to represent a row in the connection table, present the
chrisjbillington:     contents as instance attributes after deserialising their contents, and
chrisjbillington:     providing default values for backward compatibility with older HDF5 files.
chrisjbillington:     Contains links to Connection objects for child devices of each device"""
chrisjbillington:     _defaults = {'unit conversion class': None,
chrisjbillington:                 'unit conversion params': {},
chrisjbillington:                 'BLACS_connection': "",
chrisjbillington:                 'properties': {}}
chrisjbillington: 
chrisjbillington:     def __init__(self, raw_row):
chrisjbillington: 
chrisjbillington:         # Populate a dict with the defaults:
chrisjbillington:         self._rowdict = self._defaults.copy()
chrisjbillington: 
chrisjbillington:         # Put the given values in, overwriting the defaults if applicable:
chrisjbillington:         deserialised_items = {_ensure_str(name): self._deserialise(name, value)
chrisjbillington:                               for name, value in zip(raw_row.dtype.names, raw_row)}
chrisjbillington: 
chrisjbillington:         self._rowdict.update(deserialised_items)
chrisjbillington:             
chrisjbillington:         # Populate attributes:
chrisjbillington:         self.name = self._rowdict['name']
chrisjbillington:         self.device_class = self._rowdict['class']
chrisjbillington:         self.parent_name = self._rowdict['parent']
chrisjbillington:         self.parent_port = self._rowdict['parent port']
chrisjbillington:         self.unit_conversion_class = self._rowdict['unit conversion class']
chrisjbillington:         self._unit_conversion_params = self._rowdict['unit conversion params']
chrisjbillington:         self.BLACS_connection = self._rowdict['BLACS_connection']
chrisjbillington:         self._properties = self._rowdict['properties']
chrisjbillington:         
chrisjbillington:         # To be populated by self._populate_relatives:
chrisjbillington:         self.child_list = {}
chrisjbillington:         self.parent = None
chrisjbillington:         
chrisjbillington:     def _deserialise(self, name, value):
chrisjbillington:         """deserialise one item of the row depending on what it is"""
chrisjbillington:         name == _ensure_str(name)
chrisjbillington:         if name in ['parent port', 'unit conversion class']:
chrisjbillington:             # If no unit conversion class, or parent port, set to the object
chrisjbillington:             # None, otherwise leave as the parent port string or unit
chrisjbillington:             # conversion class name as a (unicode) string
chrisjbillington:             if _ensure_str(value) == 'None':
chrisjbillington:                 return None
chrisjbillington:         elif name in ['unit conversion params', 'properties']:
chrisjbillington:             # deserialise a dict that is stored as a string. In older
chrisjbillington:             # labscript these were repr() of the dict, in newer they are
chrisjbillington:             # stored as JSON."""
chrisjbillington:             if labscript_utils.properties.is_json(value):
chrisjbillington:                 return labscript_utils.properties.deserialise(value)
chrisjbillington:             else:
chrisjbillington:                 # Backward compatibility with older hdf5 files:
chrisjbillington:                 return ast.literal_eval(value)
chrisjbillington:         return _ensure_str(value)
chrisjbillington: 
chrisjbillington:     def _populate_relatives(self, table):
chrisjbillington:         """Populate child devices based on a list of other connection objects,
chrisjbillington:         and set self.parent to our parent device."""
chrisjbillington:         for name, connection in table.items():
chrisjbillington:             if connection.parent_name == self.name:
chrisjbillington:                 self.child_list[connection.name] = connection
chrisjbillington:             if name == self.parent_name:
chrisjbillington:                 self.parent = connection
chrisjbillington: 
chrisjbillington:     def __eq__(self, other):
chrisjbillington:         return self._rowdict == other._rowdict
chrisjbillington: 
chrisjbillington:     def __ne__(self, other):
chrisjbillington:         return self._rowdict != other._rowdict
chrisjbillington: 
chrisjbillington:     @property
chrisjbillington:     def unit_conversion_params(self):
chrisjbillington:         # Return a copy so calling code can't modify our instance attribute
chrisjbillington:         return copy.deepcopy(self._unit_conversion_params)
chrisjbillington:         
chrisjbillington:     @property
chrisjbillington:     def properties(self):
chrisjbillington:         # Return a copy so calling code can't modify our instance attribute
chrisjbillington:         return copy.deepcopy(self._properties)
chrisjbillington:         
chrisjbillington:     def diff(self, other):
chrisjbillington:         return dict_diff(self._rowdict, other._rowdict)
chrisjbillington: 
chrisjbillington:     def compare_to(self, other_connection):
chrisjbillington:         if not isinstance(other_connection,Connection):
chrisjbillington:             return False,{"error":"Internal Error. Connection Table object is corrupted."}
chrisjbillington:             
chrisjbillington:         error = {}
chrisjbillington:         # Compare all parameters between this connection, and other connection
chrisjbillington:         if self.name != other_connection.name:
chrisjbillington:             error["name"] = True
chrisjbillington:         if self.device_class != other_connection.device_class:
chrisjbillington:             error["device_class"] = True
chrisjbillington:         if self.parent_port != other_connection.parent_port:
chrisjbillington:             error["parent_port"] = True
chrisjbillington:         if self.unit_conversion_class != other_connection.unit_conversion_class:
chrisjbillington:             error["unit_conversion_class"] = True
chrisjbillington:         if self.unit_conversion_params != other_connection.unit_conversion_params:
chrisjbillington:             error["unit_conversion_params"] = True
chrisjbillington:         if self.BLACS_connection != other_connection.BLACS_connection:
chrisjbillington:             error["BLACS_connection"] = True
chrisjbillington:         if self.properties != other_connection.properties:
chrisjbillington:             error["properties"] = True
chrisjbillington:         
chrisjbillington:         # for each child in other_connection, check that the child also exists here
chrisjbillington:         for name, connection in other_connection.child_list.items():
chrisjbillington:             if not name in self.child_list:
chrisjbillington:                 error.setdefault("children_missing",{})
chrisjbillington:                 error["children_missing"][name] = True
chrisjbillington:                 
chrisjbillington:             else:    
chrisjbillington:                 # call compare_to on child so that we can check it's children!
chrisjbillington:                 result, child_error = self.child_list[name].compare_to(connection)
chrisjbillington:                 if not result:
chrisjbillington:                     error.setdefault("children",{})
chrisjbillington:                     error["children"][name] = child_error
chrisjbillington:                 
chrisjbillington:         # We made it!
chrisjbillington:         if error != {}:
chrisjbillington:             return False, error
chrisjbillington:         else:
chrisjbillington:             return True, error
chrisjbillington:         
chrisjbillington:     def print_details(self,indent):
chrisjbillington:         for name, child in self.child_list.items():
chrisjbillington:             print(indent + name)
chrisjbillington:             child.print_details(indent + '  ')
chrisjbillington:     
chrisjbillington:     def find_child(self, parent_name, parent_port):
chrisjbillington:         for name, connection in self.child_list.items():
chrisjbillington:             if connection.parent_name == parent_name and connection.parent_port == parent_port:
chrisjbillington:                 return connection
chrisjbillington:         
chrisjbillington:         # This is done separately to the above iteration for speed. 
chrisjbillington:         # We search for all children first, before going down another layer.
chrisjbillington:         for name, connection in self.child_list.items():
chrisjbillington:             result = connection.find_child(parent_name, parent_port)
chrisjbillington:             if result is not None:
chrisjbillington:                 return result
chrisjbillington:         
chrisjbillington:         return None
chrisjbillington: 
chrisjbillington:     def find_by_name(self, name):
             jan:         name = _ensure_str(name)
chrisjbillington:         for device_name, connection in self.child_list.items():
chrisjbillington:             if device_name == name:
chrisjbillington:                 return connection
chrisjbillington:             else:
chrisjbillington:                 result = connection.find_by_name(name)
chrisjbillington:                 if result is not None:
chrisjbillington:                     return result
chrisjbillington:         return None    
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # if __name__ == '__main__':
chrisjbillington: #     a = ConnectionTable('/home/bilbo/labscript_suite/labconfig/bilbo-Precision-5520_BLACS.h5')
chrisjbillington: #     c = ConnectionTable('/home/bilbo/labscript_shared/Experiments/cjb7_dev/connectiontable.h5')
chrisjbillington: #     c.print_details()
chrisjbillington: #     d = ConnectionTable('/home/bilbo/labscript_shared/Experiments/cjb7_dev/connectiontable.h5')
chrisjbillington: #     list(d.toplevel_children.values())[0]._rowdict['properties']['test'] = 'fake_property'
chrisjbillington: #     del c.table['bragg_beam_0']
chrisjbillington: #     c.assert_superset(d)
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # /dict_diff.py                                                     #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript_utils, in the labscript suite  #
chrisjbillington: # (see http://labscriptsuite.org), and is licensed under the        #
chrisjbillington: # Simplified BSD License. See the license.txt file in the root of   #
chrisjbillington: # the project for the full license.                                 #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
chrisjbillington: import numpy as np
chrisjbillington: 
chrisjbillington: def dict_diff(dict1, dict2):
chrisjbillington:     """Return the difference between two dictionaries as a dictionary of key: [val1, val2] pairs.
chrisjbillington:     Keys unique to either dictionary are included as key: [val1, '-'] or key: ['-', val2]."""
chrisjbillington:     diff_keys = []
chrisjbillington:     common_keys = np.intersect1d(list(dict1.keys()), list(dict2.keys()))
chrisjbillington:     for key in common_keys:
chrisjbillington:         if np.iterable(dict1[key]):
chrisjbillington:             if np.any(dict1[key] != dict2[key]):
chrisjbillington:                 diff_keys.append(key)
chrisjbillington:         else:
chrisjbillington:             if dict1[key] != dict2[key]:
chrisjbillington:                 diff_keys.append(key)
chrisjbillington: 
chrisjbillington:     dict1_unique = [key for key in dict1.keys() if key not in common_keys]    
chrisjbillington:     dict2_unique = [key for key in dict2.keys() if key not in common_keys]
chrisjbillington:                 
chrisjbillington:     diff = {}
chrisjbillington:     for key in diff_keys:
chrisjbillington:         diff[key] = [dict1[key], dict2[key]]
chrisjbillington:     
chrisjbillington:     for key in dict1_unique:
chrisjbillington:         diff[key] = [dict1[key], '-']
chrisjbillington:         
chrisjbillington:     for key in dict2_unique:
chrisjbillington:         diff[key] = ['-', dict2[key]]       
chrisjbillington: 
chrisjbillington:     return diff
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # double_import_denier.py                                           #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2018, Chris Billington                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: from __future__ import print_function, absolute_import, division, unicode_literals
chrisjbillington: import sys
chrisjbillington: PY2 = sys.version_info.major == 2
chrisjbillington: import os
chrisjbillington: import imp
chrisjbillington: import traceback
chrisjbillington: import re
chrisjbillington: import pkgutil
chrisjbillington: 
chrisjbillington: DEBUG = False
chrisjbillington: 
chrisjbillington: if not PY2:
chrisjbillington:     from importlib._bootstrap import _call_with_frames_removed
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class Loader(pkgutil.ImpLoader):
chrisjbillington:     def __init__(self, fullname, fp, pathname, description):
chrisjbillington:         pkgutil.ImpLoader.__init__(self, fullname, fp, pathname, description)
chrisjbillington:         self.fp = fp
chrisjbillington:         self.pathname = pathname
chrisjbillington:         self.description = description
chrisjbillington: 
chrisjbillington:     def load_module(self, name):
chrisjbillington:         if DEBUG: print('loading', name, 'from', self.pathname)
chrisjbillington:         if PY2:
chrisjbillington:             return imp.load_module(name, self.fp, self.pathname, self.description)
chrisjbillington:         else:
chrisjbillington:             return _call_with_frames_removed(
chrisjbillington:                 imp.load_module, name, self.fp, self.pathname, self.description)
chrisjbillington: 
chrisjbillington:     if not PY2:
chrisjbillington:         # Functions that are part of the import machinery and should be excluded
chrisjbillington:         # from tracebacks, which Python does by detecting if the function's
chrisjbillington:         # __code__ object's _co_filename attr is "<frozen importlib._bootstrap>",
chrisjbillington:         # and that the stack ends with a call to _call_with_frames_removed.
chrisjbillington:         # It's not so bad to mess with the filename of these functions since they
chrisjbillington:         # are deprecated in Python 3.
chrisjbillington:         import_funcs = [load_module, imp.load_module, imp.load_source,
chrisjbillington:                         imp.load_compiled, imp.load_package]
chrisjbillington:         if imp.load_dynamic is not None:
chrisjbillington:             import_funcs.append(imp.load_dynamic)
chrisjbillington:         for func in import_funcs:
chrisjbillington:             imp._fix_co_filename(func.__code__, "<frozen importlib._bootstrap>")
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class DoubleImportDenier(object):
chrisjbillington:     """A module finder that tracks what's been imported and disallows multiple
chrisjbillington:     imports of the same module under different names, raising an exception
chrisjbillington:     upon detecting that this has occured"""
chrisjbillington:     def __init__(self):
chrisjbillington:         self.enabled = False
chrisjbillington:         self.names_by_filepath = {}
chrisjbillington:         self.tracebacks = {}
chrisjbillington:         UNKNOWN = ('<unknown: imported prior to double_import_denier.enable()>\n')
chrisjbillington:         for name, module in list(sys.modules.items()):
chrisjbillington:             if hasattr(module, '__file__'):
chrisjbillington:                 path = os.path.realpath(module.__file__)
chrisjbillington:                 self.names_by_filepath[path] = name
chrisjbillington:                 self.tracebacks[path] = [UNKNOWN, '']
chrisjbillington: 
chrisjbillington:     def find_module(self, fullname, path=None):
chrisjbillington:         if DEBUG: print('finding', fullname, 'in', path)
chrisjbillington:         name = fullname.split('.')[-1]
chrisjbillington:         try:
chrisjbillington:             fp, pathname, description = imp.find_module(name, path)
chrisjbillington:         except Exception as e:
chrisjbillington:             if DEBUG: print('Exception in imp.find_module ' + str(e))
chrisjbillington:             return None
chrisjbillington:         if pathname is not None:
chrisjbillington:             path = os.path.realpath(pathname)
chrisjbillington:             tb = traceback.format_stack()
chrisjbillington:             other_name = self.names_by_filepath.get(path, None)
chrisjbillington:             if other_name is not None and other_name != fullname:
chrisjbillington:                 other_tb = self.tracebacks[path]
chrisjbillington:                 self._raise_error(path, fullname, tb, other_name, other_tb)
chrisjbillington:             self.names_by_filepath[path] = fullname
chrisjbillington:             self.tracebacks[path] = tb
chrisjbillington:         return Loader(fullname, fp, pathname, description)
chrisjbillington: 
chrisjbillington:     def _format_tb(self, tb):
chrisjbillington:         """Take a formatted traceback as returned by traceback.format_stack()
chrisjbillington:         and remove lines that are solely about us and the Python machinery,
chrisjbillington:         leaving only lines pertaining to the user's code"""
chrisjbillington:         frames = [frame for frame in tb[:-1]
chrisjbillington:                   if 'importlib._bootstrap' not in frame
chrisjbillington:                   and 'imp.load_module' not in frame
chrisjbillington:                   and not ('imp.py' in frame
chrisjbillington:                            and ('load_module' in frame
chrisjbillington:                                 or 'load_source' in frame
chrisjbillington:                                 or 'load_package' in frame))]
chrisjbillington:         return ''.join(frames)
chrisjbillington: 
chrisjbillington:     def _restore_tracebacklimit_after_exception(self):
chrisjbillington:         """Record the current value of sys.tracebacklimit, if any, and set a
chrisjbillington:         temporary sys.excepthook to restore it to that value (or delete it)
chrisjbillington:         after the next exception."""
chrisjbillington:         orig_excepthook = sys.excepthook
chrisjbillington:         exists = hasattr(sys, 'tracebacklimit')
chrisjbillington:         orig_tracebacklimit = getattr(sys, 'tracebacklimit', None)
chrisjbillington:         def excepthook(*args, **kwargs):
chrisjbillington:             # Raise the error normally
chrisjbillington:             orig_excepthook(*args, **kwargs)
chrisjbillington:             # Restore sys.tracebacklimit
chrisjbillington:             if exists:
chrisjbillington:                 sys.tracebacklimit = orig_tracebacklimit
chrisjbillington:             else:
chrisjbillington:                 del sys.tracebacklimit
chrisjbillington:             # Restore sys.excepthook:
chrisjbillington:             sys.excepthook = orig_excepthook
chrisjbillington:         sys.excepthook = excepthook
chrisjbillington: 
chrisjbillington:     def _raise_error(self, path, name, tb, other_name, other_tb):
chrisjbillington:         msg = """Double import! The same file has been imported under two
chrisjbillington:         different names, resulting in two copies of the module. This is almost
chrisjbillington:         certainly a mistake. If you are running a script from within a package
chrisjbillington:         and want to import another submodule of that package, import it by its
chrisjbillington:         full path: 'import module.submodule' instead of just 'import
chrisjbillington:         submodule.'"""
chrisjbillington: 
chrisjbillington:         msg = re.sub(' +',' ', ' '.join(msg.splitlines()))
chrisjbillington: 
chrisjbillington:         tb = self._format_tb(tb)
chrisjbillington:         other_tb = self._format_tb(other_tb)
chrisjbillington:         msg += "\n\nPath imported: %s\n\n" % path
chrisjbillington:         msg += "Traceback (first time imported, as %s):\n" % other_name
chrisjbillington:         msg += "------------\n%s------------\n\n" % other_tb
chrisjbillington:         msg += "Traceback (second time imported, as %s):\n" % name
chrisjbillington:         msg += "------------\n%s------------" % tb
chrisjbillington: 
chrisjbillington:         # We set sys.tracebacklimit a small numberto not print all the
chrisjbillington:         # nonsense from the import machinary in the traceback, it is not
chrisjbillington:         # useful to the user in reporting this exception. But we have to jump
chrisjbillington:         # through this hoop to make sure sys.tracebacklimit is restored after
chrisjbillington:         # our exception is raised, since putting it in a finally: block
chrisjbillington:         # doesn't work:
chrisjbillington:         self._restore_tracebacklimit_after_exception()
chrisjbillington: 
chrisjbillington:         if PY2:
chrisjbillington:             sys.tracebacklimit = 1
chrisjbillington:             raise RuntimeError(msg)
chrisjbillington:         else:
chrisjbillington:             sys.tracebacklimit = 2
chrisjbillington:             exec('raise RuntimeError(msg) from None')
chrisjbillington: 
chrisjbillington: 
chrisjbillington: _denier = None
chrisjbillington: 
chrisjbillington: def enable():
chrisjbillington:     if '--allow-double-imports' in sys.argv:
chrisjbillington:         # Calls to enable/disable the double import denier are ignored if this
chrisjbillington:         # command line argument is present.
chrisjbillington:         return
chrisjbillington:     global _denier
chrisjbillington:     if _denier is None:
chrisjbillington:         _denier = DoubleImportDenier()
chrisjbillington:     if _denier.enabled:
chrisjbillington:         raise RuntimeError('already enabled')
chrisjbillington:     # This is here because it actually happened:
chrisjbillington:     for importer in sys.meta_path:
chrisjbillington:         if importer.__class__.__name__ == DoubleImportDenier.__name__:
chrisjbillington:             msg = 'Two DoubleImportDenier instances in sys.meta_path!'
chrisjbillington:             raise AssertionError(msg)
chrisjbillington:     sys.meta_path.insert(0, _denier)
chrisjbillington:     _denier.enabled = True
chrisjbillington: 
chrisjbillington: def disable():
chrisjbillington:     if '--allow-double-imports' in sys.argv:
chrisjbillington:         # Calls to enable/disable the double import denier are ignored if this
chrisjbillington:         # command line argument is present.
chrisjbillington:         return
chrisjbillington:     if not _denier.enabled:
chrisjbillington:         raise RuntimeError('not enabled')
chrisjbillington:     sys.meta_path.remove(_denier)
chrisjbillington:     _denier.enabled = False
chrisjbillington: 
chrisjbillington: 
chrisjbillington: if __name__ == '__main__':
chrisjbillington:     # Run from this directory as __main__:
chrisjbillington:     enable()
chrisjbillington: 
chrisjbillington:     def test1():
chrisjbillington:         # Import numpy.linalg twice under different names:
chrisjbillington:         import numpy as np
chrisjbillington:         # Add the numpy folder to the search path:
chrisjbillington:         sys.path.append(os.path.dirname(np.__file__))
chrisjbillington:         import linalg
chrisjbillington: 
chrisjbillington:     def test2():
chrisjbillington:         # This also gets detected, since this module already exists as
chrisjbillington:         # __main__ but this line would import it as double_import_denier.
chrisjbillington:         import double_import_denier
chrisjbillington: 
chrisjbillington:     test1()
chrisjbillington:     test2()
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __init__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the labscript suite (see                     #
        cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
        cbilling: # BSD License. See the license.txt file in the root of the project  #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: import sys
        cbilling: import os
        cbilling: import threading
        cbilling: import traceback
        cbilling: import subprocess
        cbilling: import warnings
        cbilling: 
        cbilling: # The maximum number of windows the excepthook will spawn:
        cbilling: MAX_WINDOWS = 10
        cbilling: 
        cbilling: subprocess_script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'tk_exception.py')
        cbilling: 
        cbilling: 
        cbilling: class l:
        cbilling:     logger = None
        cbilling: 
        cbilling: child_processes = []
        cbilling: 
        cbilling: 
        cbilling: def install_thread_excepthook():
        cbilling:     """
        cbilling:     Workaround for sys.excepthook thread bug
        cbilling:     (https://sourceforge.net/tracker/?func=detail&atid=105470&aid=1230540&group_id=5470).
        cbilling:     Call once from __main__ before creating any threads.
        cbilling:     """
        cbilling:     run_old = threading.Thread.run
        cbilling: 
        cbilling:     def run(*args, **kwargs):
        cbilling:         try:
        cbilling:             run_old(*args, **kwargs)
        cbilling:         except (KeyboardInterrupt, SystemExit):
        cbilling:             raise
        cbilling:         except:
        cbilling:             if sys is None:
        cbilling:                 # Interpreter is shutting down. Don't display graphical error.
        cbilling:                 # Let the threading module's code handle this however it normally does.
        cbilling:                 raise
        cbilling:             exc_type, exc_value, exc_traceback = sys.exc_info()
        cbilling:             # Cull the top frame so the user doesn't see this wrapping code in their traceback:
        cbilling:             exc_traceback = exc_traceback.tb_next
        cbilling:             sys.excepthook(exc_type, exc_value, exc_traceback)
        cbilling:     threading.Thread.run = run
        cbilling: 
        cbilling: 
        cbilling: def tkhandler(exceptclass, exception, exec_info, reraise=True):
        cbilling:     script = os.path.basename(sys.argv[0])
        cbilling:     if not script:
        cbilling:         script = 'python interactive shell'
        cbilling:     shortmessage = '%s: %s' % (exceptclass.__name__, exception)
        cbilling:     longmessage = ''.join(traceback.format_exception(exceptclass, exception, exec_info))
        cbilling:     if l.logger:
        cbilling:         l.logger.error('Got an exception:\n%s' % longmessage)
        cbilling:     if exceptclass in [KeyboardInterrupt, SystemExit]:
        cbilling:         sys.__excepthook__(exceptclass, exception, exec_info)
        cbilling:     else:
        cbilling:         for previous_process in child_processes[:]:
        cbilling:             if previous_process.poll() is not None:
        cbilling:                 child_processes.remove(previous_process)
        cbilling:         if len(child_processes) >= MAX_WINDOWS:
        cbilling:             shortmessage = "Too many errors"
        cbilling:             longmessage = ("Too many errors: Further errors will " +
        cbilling:                            "not be shown graphically until some error windows are closed")
        cbilling:         if len(child_processes) < MAX_WINDOWS + 1:
        cbilling:             process = subprocess.Popen([sys.executable, subprocess_script_path, script, shortmessage, longmessage])
        cbilling:             child_processes.append(process)
        cbilling:         if reraise:
        cbilling:             sys.__excepthook__(exceptclass, exception, exec_info)
        cbilling: 
        cbilling: 
        cbilling: def logwarning(message, category, filename, lineno, file=None, line=None):
        cbilling:     logmessage = warnings.formatwarning(message, category, filename, lineno, line)
        cbilling:     l.logger.warn(logmessage)
        cbilling:     warnings._showwarning(message, category, filename, lineno, file, line)
        cbilling: 
        cbilling: 
        cbilling: def set_logger(logger):
        cbilling:     l.logger = logger
        cbilling:     warnings._showwarning = warnings.showwarning
        cbilling:     warnings.showwarning = logwarning
        cbilling: 
        cbilling: # Check for tkinter availability. Tkinter is frustratingly not available
        cbilling: # by default for python 3.x on Debian systems, despite being considered
        cbilling: # part of the Python standard library. I'll make it a dependency for
        cbilling: # packaging, but this is an extra check at runtime so that if something
        cbilling: # goes wrong with that we get an error at import rather than later:
chrisjbillington: if sys.version_info[0] == 2:
        cbilling:     import Tkinter
        cbilling: else:
        cbilling:     import tkinter
        cbilling: sys.excepthook = tkhandler
        cbilling: install_thread_excepthook()
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # tk_exception.py                                                   #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the labscript suite (see                     #
        cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
        cbilling: # BSD License. See the license.txt file in the root of the project  #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
        cbilling: 
        cbilling: import sys
        cbilling: import os
        cbilling: 
        cbilling: if sys.version < '3':
        cbilling:     import Tkinter as tkinter
        cbilling:     import Tkconstants as constants
        cbilling: else:
        cbilling:     import tkinter
        cbilling:     import tkinter.constants as constants
        cbilling: 
        cbilling: error_im_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'error.gif')
        cbilling: 
        cbilling: 
        cbilling: class ErrorWindow(tkinter.Text):
        cbilling: 
        cbilling:     """Class to display the error in a textbox. Parts copied from Tkinter's ScrolledText widget"""
        cbilling: 
        cbilling:     def __init__(self, master=None, **kw):
        cbilling:         self.frame = tkinter.Frame(master, padx=10, pady=10)
        cbilling: 
        cbilling:         self.upperframe = tkinter.Frame(self.frame)
        cbilling:         self.upperframe.pack(side=constants.TOP, fill=constants.X)
        cbilling: 
        cbilling:         self.lowerframe = tkinter.Frame(self.frame, pady=10)
        cbilling:         self.lowerframe.pack(side=constants.TOP, fill=constants.BOTH, expand=True)
        cbilling: 
        cbilling:         self.imlabel = tkinter.Label(self.upperframe, borderwidth=10, image=error_im)
        cbilling:         self.imlabel.pack(side=constants.LEFT)
        cbilling:         self.textlabel = tkinter.Label(self.upperframe, text='It looks like an error has occured:\n%s' % sys.argv[2],
        cbilling:                                        borderwidth=10, wraplength=400, justify='left')
        cbilling:         self.textlabel.pack(side=constants.LEFT)
        cbilling: 
        cbilling:         self.vbar = tkinter.Scrollbar(self.lowerframe)
        cbilling:         self.vbar.pack(side=constants.RIGHT, fill=constants.Y)
        cbilling: 
        cbilling:         self.button = tkinter.Button(self.frame, text='Ok', command=self.ok_clicked, padx=20, pady=5)
        cbilling:         self.button.bind('<Return>', self.ok_clicked)
        cbilling:         self.button.pack(side=constants.BOTTOM)
        cbilling: 
        cbilling:         kw.update({'yscrollcommand': self.vbar.set})
        cbilling:         tkinter.Text.__init__(self, self.lowerframe, **kw)
        cbilling: 
        cbilling:         self.pack(side=constants.LEFT, fill=constants.BOTH, expand=True)
        cbilling:         self.vbar['command'] = self.yview
        cbilling: 
        cbilling:         # Copy geometry methods of self.frame without overriding Text
        cbilling:         # methods -- hack!
chrisjbillington:         text_meths = list(vars(tkinter.Text).keys())
        cbilling:         methods = list(vars(tkinter.Pack).keys()) + list(vars(tkinter.Grid).keys()) + list(vars(tkinter.Place).keys())
        cbilling:         methods = set(methods).difference(text_meths)
        cbilling: 
        cbilling:         for m in methods:
        cbilling:             if m[0] != '_' and m != 'config' and m != 'configure':
        cbilling:                 setattr(self, m, getattr(self.frame, m))
        cbilling: 
        cbilling:         self.button.bind('<<Copy>>', self.copy)
        cbilling: 
        cbilling:     def ok_clicked(self, *ignore):
        cbilling:         win.quit()
        cbilling: 
        cbilling:     def copy(self, event=None):
        cbilling:         self.clipboard_clear()
        cbilling:         text = self.get("sel.first", "sel.last")
        cbilling:         self.clipboard_append(text)
        cbilling: 
        cbilling: if __name__ == "__main__":
        cbilling:     win = tkinter.Tk()
        cbilling:     error_im = tkinter.PhotoImage(file=error_im_path)
        cbilling:     win.title('Unhandled exception in %s' % sys.argv[1])
        cbilling:     win.tk.call('wm', 'iconphoto', win._w, error_im)
        cbilling:     win.geometry('500x500')
        cbilling:     stext = ErrorWindow(master=win, bg='black', height=10, fg='red', font=("monospace", 10, "bold"))
        cbilling:     stext.insert(constants.END, sys.argv[3])
        cbilling:     stext.pack(fill=constants.BOTH, side=constants.LEFT, expand=True)
        cbilling:     stext.config(state=constants.DISABLED)
        cbilling:     stext.button.focus_set()
        cbilling:     stext.mainloop()
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # filewatcher.py                                                    #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   cbilling: 
   cbilling: import threading
   cbilling: import os
   cbilling: import time
   cbilling: 
   cbilling: class FileWatcher(object):
   pstarkey:     def __init__(self, callback, files=None, folders=None, modified_times=None):
   cbilling:         self.callback = callback
   pstarkey:         self.lock = threading.Lock()
   pstarkey:         
   pstarkey:         self.files = set()
   pstarkey:         self.folders = set()
   pstarkey:         if files:
   pstarkey:             self.add_files(files)
   pstarkey:         if folders:
   pstarkey:             self.add_folders(folders)
   pstarkey:         
   pstarkey:         # restore modified times
   pstarkey:         if modified_times is None:
   pstarkey:             modified_times = {}
   pstarkey:         self.modified_times = modified_times.copy()
   pstarkey:         self.update_files(trigger_callback=False)
   pstarkey:         
   pstarkey:         # remove entries in self.modified times that are not in files
   pstarkey:         for name in self.modified_times.copy():
   pstarkey:             if name not in self.files:
   pstarkey:                 del self.modified_times[name]
   pstarkey:         
   cbilling:         self.main = threading.Thread(target = self.mainloop)
   cbilling:         self.main.daemon = True
   cbilling:         self.running = True
   cbilling:         self.main.start()
   cbilling:         
   cbilling:     def mainloop(self):
   cbilling:         while self.running:
   cbilling:             time.sleep(1)
   cbilling:             with self.lock:
   cbilling:                 self.update_files()
   cbilling:                 self.check()
   cbilling:     
   cbilling:     def update_files(self,folders=None,trigger_callback=True):
   cbilling:         if folders is None:
   cbilling:             folders = self.folders
   cbilling:         for folder in folders:
   cbilling:             try:
   cbilling:                 for name in os.listdir(folder):
   cbilling:                     path = os.path.join(folder,name)
   cbilling:                     if os.path.isdir(path):
   cbilling:                         self.update_files([path],trigger_callback)
   cbilling:                     else:
   cbilling:                         if not path in self.files:
   cbilling:                             self.files.add(path)
   cbilling:                             if trigger_callback:
   cbilling:                                 self.callback(path,os.path.getmtime(path))
   cbilling:             except OSError:
   cbilling:                 # Folder has been deleted. File deletion will still be
   cbilling:                 # detected, so we can ignore this.
   cbilling:                 continue
   cbilling:     
   cbilling:     def check(self):
   cbilling:         for name in self.files:
   cbilling:             try:
   cbilling:                 modified_time = os.path.getmtime(name)
   cbilling:             except OSError:
   cbilling:                 if not os.path.exists(name):
   cbilling:                     modified_time = None
   shjohnst:                 else:
   shjohnst:                     # If we couldn't get the modified time but the path does exist,
   shjohnst:                     # there was probablly some race condition with the path becoming unavailable briefly
   shjohnst:                     # we'll skip the rest of the check for now, and leave it up to the next call of check()
   shjohnst:                     # to catch any file modification
   shjohnst:                     continue
   cbilling:             previous_modified_time = self.modified_times.setdefault(name, modified_time)
   cbilling:             self.modified_times[name] = modified_time
   cbilling:             if modified_time != previous_modified_time:
   cbilling:                 if name in self.modified_times:
   cbilling:                     del self.modified_times[name]
   cbilling:                     self.callback(name,modified_time)
   cbilling:                                     
   cbilling:     def stop(self):
   cbilling:         self.running = False
   cbilling:     
   cbilling:     def add_file(self, path):
   cbilling:         self.add_files(path)
   cbilling:         
   pstarkey:     def get_modified_times(self):
   pstarkey:         with self.lock:
   pstarkey:             times = self.modified_times.copy()
   pstarkey:         return times
   pstarkey:         
   cbilling:     def add_folder(self, folder):
   cbilling:         self.add_folders(folder)
   cbilling:         
   cbilling:     def add_files(self,files):
   cbilling:         with self.lock:
   cbilling:             if isinstance(files,str):
   cbilling:                 self.files.add(files)
   cbilling:             else:
   pstarkey:                self.files = self.files.union(set(files)) 
   cbilling:     
   cbilling:     def add_folders(self,folders):
   cbilling:         with self.lock:
   cbilling:             if isinstance(folders,str):
   cbilling:                 self.folders.add(folders)
   cbilling:             else:
   pstarkey:                self.folders = self.folders.union(set(folders))
   cbilling:             self.update_files(trigger_callback=False)
   cbilling:             
   cbilling:    
   cbilling: if __name__ == '__main__':
   cbilling:     # Example usage
   cbilling:     
   cbilling:     def callback(name,modified):
   cbilling:         if modified is None:
janwerkmann:             print(name,'has been deleted')
   cbilling:         else:
janwerkmann:             print(name, 'was modified at',modified)
janwerkmann: 
janwerkmann:     f = FileWatcher(callback, files='test.txt',folders='foobar')
   cbilling:     time.sleep(60)
   cbilling:     
cbilling: #####################################################################
cbilling: #                                                                   #
cbilling: # h5_lock.py                                                        #
cbilling: #                                                                   #
cbilling: # Copyright 2013, Monash University                                 #
cbilling: #                                                                   #
cbilling: # This file is part of the labscript suite (see                     #
cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
cbilling: # BSD License. See the license.txt file in the root of the project  #
cbilling: # for the full license.                                             #
cbilling: #                                                                   #
cbilling: #####################################################################
cbilling: 
cbilling: import threading
cbilling: import gtk
cbilling: import pango
cbilling: 
cbilling: import zmq
cbilling: 
cbilling: class OutputBox(object):
cbilling:     def __init__(self, container):
cbilling:     
cbilling:         self.output_view = gtk.TextView()
cbilling:         container.add(self.output_view)
cbilling:         self.output_adjustment = self.output_view.get_vadjustment()
cbilling:         self.output_buffer = self.output_view.get_buffer()
cbilling:         self.text_mark = self.output_buffer.create_mark(None, self.output_buffer.get_end_iter())
cbilling:         
cbilling:         self.output_view.modify_base(gtk.STATE_NORMAL, gtk.gdk.color_parse('black'))
cbilling:         self.output_view.modify_text(gtk.STATE_NORMAL, gtk.gdk.color_parse('white'))
cbilling:         self.output_view.modify_font(pango.FontDescription("monospace 10"))
cbilling:         self.output_view.set_indent(5)
cbilling:         self.output_view.set_wrap_mode(gtk.WRAP_CHAR)
cbilling:         self.output_view.set_editable(False)
cbilling:         self.output_view.show()
cbilling:                 
cbilling:         context = zmq.Context.instance()
cbilling:         socket = context.socket(zmq.PULL)
cbilling:         socket.setsockopt(zmq.LINGER, 0)
cbilling:         self.port = socket.bind_to_random_port('tcp://127.0.0.1')
cbilling:         
cbilling:         # Tread-local storage so we can have one push_sock per
cbilling:         # thread. push_sock is for sending data to the output queue in
cbilling:         # a non-blocking way from the same process as this object is
cbilling:         # instantiated in.  Providing the function OutputBox.output()
cbilling:         # for this is much easier than expecting every thread to have
cbilling:         # its own push socket that the user has to manage. Also we can't
cbilling:         # give callers direct access to the output code, because then
cbilling:         # it matters whether they hold the gtk lock, and we'll either
cbilling:         # have deadlocks when they already do, or have to have calling
cbilling:         # code peppered with lock acquisitions. Screw that.
cbilling:         self.local = threading.local()
cbilling:         
cbilling:         self.mainloop = threading.Thread(target=self.mainloop,args=(socket,))
cbilling:         self.mainloop.daemon = True
cbilling:         self.mainloop.start()
cbilling:     
cbilling:     def new_socket(self):
cbilling:         # One socket per thread, so we don't have to acquire a lock
cbilling:         # to send:
cbilling:         context = zmq.Context.instance()
cbilling:         self.local.push_sock = context.socket(zmq.PUSH)
cbilling:         self.local.push_sock.setsockopt(zmq.LINGER, 0)
cbilling:         self.local.push_sock.connect('tcp://127.0.0.1:%d'%self.port)
cbilling:         
cbilling:     def output(self, text,red=False):
cbilling:         if not hasattr(self.local, 'push_sock'):
cbilling:             self.new_socket()
cbilling:         # Queue the output on the socket:
cbilling:         self.local.push_sock.send_multipart(['stderr' if red else 'stdout',text.encode()])
cbilling:         
cbilling:     def mainloop(self,socket):
cbilling:         while True:
cbilling:             stream, text = socket.recv_multipart()
cbilling:             text = text.decode()
cbilling:             red = (stream == 'stderr')
cbilling:             with gtk.gdk.lock:
cbilling:                 # Check if the scrollbar is at the bottom of the textview:
cbilling:                 scrolling = self.output_adjustment.value == self.output_adjustment.upper - self.output_adjustment.page_size
cbilling:                 # We need the initial cursor position so we know what range to make red:
cbilling:                 offset = self.output_buffer.get_end_iter().get_offset()
cbilling:                 # Insert the text at the end:
cbilling:                 self.output_buffer.insert(self.output_buffer.get_end_iter(), text)
cbilling:                 if red:
cbilling:                     start = self.output_buffer.get_iter_at_offset(offset)
cbilling:                     end = self.output_buffer.get_end_iter()
cbilling:                     # Make the text red:
cbilling:                     self.output_buffer.apply_tag(self.output_buffer.create_tag(foreground='red'),start,end)
cbilling:                     self.output_buffer.apply_tag(self.output_buffer.create_tag(weight=pango.WEIGHT_BOLD),start,end)
cbilling: 
cbilling:                 # Automatically keep the textbox scrolled to the bottom, but
cbilling:                 # only if it was at the bottom to begin with. If the user has
cbilling:                 # scrolled up we won't jump them back to the bottom:
cbilling:                 if scrolling:
cbilling:                     end_iter = self.output_buffer.get_end_iter()
cbilling:                     # Move the iter forward to account for the fact that lines might be wrapped:
cbilling:                     self.output_view.forward_display_line_end(end_iter)
cbilling:                     end_mark = self.output_buffer.create_mark(None, end_iter)
cbilling:                     self.output_view.scroll_to_mark(end_mark,0)
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # h5_lock.py                                                        #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the labscript suite (see                     #
        cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
        cbilling: # BSD License. See the license.txt file in the root of the project  #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: 
        cbilling: import os
        cbilling: import sys
        cbilling: import socket
        cbilling: import threading
        cbilling: import subprocess
        cbilling: import weakref
        cbilling: 
        cbilling: import zmq
        pstarkey: import zprocess.locking
        pstarkey: from zprocess.locking import set_default_timeout
        cbilling: 
           Chris: from labscript_utils.shared_drive import path_to_agnostic
        pstarkey: from labscript_utils.labconfig import LabConfig
chrisjbillington: from labscript_utils import PY2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
        cbilling: 
        cbilling: if 'h5py' in sys.modules:
        cbilling:     raise ImportError('h5_lock must be imported prior to importing h5py')
        cbilling:         
        cbilling: import h5py
        cbilling: 
        pstarkey: DEFAULT_TIMEOUT = 45
        cbilling: 
        cbilling: def NetworkOnlyLock(name):
           Chris:     return zprocess.locking.NetworkOnlyLock(path_to_agnostic(name))
        cbilling:     
        cbilling: def hack_locks_onto_h5py():
        cbilling:     def __init__(self, name, mode=None, driver=None, libver=None, **kwds):
          rander:         if not isinstance(name, h5py._objects.ObjectID):
           Chris:             self.zlock = zprocess.locking.Lock(path_to_agnostic(name))
          rander:             self.zlock.acquire()
           Chris:         try:
           Chris:             _orig_init(self, name, mode, driver, libver, **kwds)
           Chris:         except:
           Chris:             if hasattr(self, 'zlock'):
           Chris:                 self.zlock.release()
           Chris:             raise
        cbilling: 
        cbilling:     def close(self):
        cbilling:         _orig_close(self)
          rander:         if hasattr(self, 'zlock'):
          rander:             self.zlock.release()
        cbilling: 
        cbilling:     # Store the original open and close methods so they can still be called
        cbilling:     # by our replacements:
        cbilling:     _orig_init = h5py.File.__init__
        cbilling:     _orig_close = h5py.File.close
        cbilling: 
        cbilling:     # Replace the h5py File open and close methods with our own, brand
        cbilling:     # new shiny locking ones:
        cbilling:     h5py.File.__init__ = __init__
        cbilling:     h5py.File.close = close 
        cbilling: 
        cbilling: def connect_to_zlock_server():
        pstarkey:     # setup connection with the zprocess.locking server, depending on labconfig settings: 
        cbilling:     config = LabConfig(required_params={'ports':['zlock'],'servers':['zlock']})
        cbilling:     host = config.get('servers','zlock')
        cbilling:     port = config.get('ports','zlock')
        cbilling:     if socket.gethostbyname(host) == socket.gethostbyname('localhost'):
        cbilling:         try:
        cbilling:             # short connection timeout if localhost, don't want to
        cbilling:             # waste time:
        pstarkey:             zprocess.locking.connect(host,port,timeout=0.05)
        cbilling:         except zmq.ZMQError:
        pstarkey:             # No zprocess.locking server running on localhost. Start one. It will run
        cbilling:             # forever, even after this program exits. This is important for
        cbilling:             # other programs which might be using it. I don't really consider
        cbilling:             # this bad practice since the server is typically supposed to
        cbilling:             # be running all the time:
        cbilling:             if os.name == 'nt':
        cbilling:                 creationflags=0x00000008 # DETACHED_PROCESS from the win32 API
        cbilling:                 # Note that we must not remain in same working directory, or we will hold a lock
        cbilling:                 # on it that prevents it from being deleted.
        cbilling:                 subprocess.Popen([sys.executable,'-m','zprocess.locking'],
        cbilling:                                  creationflags=creationflags, stdout=None, stderr=None,
        cbilling:                                  close_fds=True, cwd=os.getenv('temp'))
        cbilling:             else:
        cbilling:                 devnull = open(os.devnull,'w')
        cbilling:                 if not os.fork():
        cbilling:                     os.setsid()
        cbilling:                     subprocess.Popen([sys.executable,'-m','zprocess.locking'],
        cbilling:                                      stdin=devnull, stdout=devnull, stderr=devnull, close_fds=True)
        cbilling:                     os._exit(0)
        cbilling:             # Try again. Longer timeout this time, give it time to start up:
        pstarkey:             zprocess.locking.connect(host,port,timeout=15)
        cbilling:     else:
        pstarkey:         zprocess.locking.connect(host, port)
        cbilling: 
        cbilling:     # The user can call these functions to change the timeouts later if they
        cbilling:     # are not to their liking:
        cbilling:     set_default_timeout(DEFAULT_TIMEOUT)
        cbilling: 
        cbilling: 
        cbilling: connect_to_zlock_server()
        cbilling: hack_locks_onto_h5py()
        cbilling: 
        cbilling: 
chrisjbillington: 
chrisjbillington: def _patch_h5py_allow_unicode_list_attrs():
chrisjbillington:     """Monkeypatch to allow h5py to save lists of unicode strings as attributes.
chrisjbillington:     Upstream pull request submitted: https://github.com/h5py/h5py/pull/1032"""
chrisjbillington:     import functools
chrisjbillington:     import numpy as np
chrisjbillington:     orig_create = h5py._hl.attrs.AttributeManager.create
chrisjbillington:     @functools.wraps(orig_create)
chrisjbillington:     def create(self, name, data, shape=None, dtype=None):
chrisjbillington:         if not isinstance(data, np.ndarray) and shape is None and dtype is None:
chrisjbillington:             data = np.asarray(data)
chrisjbillington:             if data.dtype.type == np.unicode_:
chrisjbillington:                 dtype = h5py.special_dtype(vlen=str)
chrisjbillington:                 data = np.array(data, dtype=dtype)
chrisjbillington:         return orig_create(self, name, data, shape, dtype)
chrisjbillington: 
chrisjbillington:     h5py._hl.attrs.AttributeManager.create = create
chrisjbillington: 
chrisjbillington: _patch_h5py_allow_unicode_list_attrs()
chrisjbillington: 
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # horrible_fixed_length_strings_hack.py                             #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   cbilling: 
   cbilling: import h5py
   cbilling: 
   cbilling: def horribly_hack_fixed_length_strings():
   cbilling:     _guess_dtype = h5py._hl.base.guess_dtype
   cbilling: 
   cbilling:     def guess_dtype(data):
janwerkmann:         if type(data) not in [bytes, str]:
   cbilling:             return _guess_dtype(data)
   cbilling:             
   cbilling:     # I feel dirty:
   cbilling:     h5py._hl.base.guess_dtype = guess_dtype
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # impprof.py                                                        #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
   cbilling: import time
   cbilling: 
   cbilling: class _ProfilingImporter(object):
   cbilling:     def __init__(self):
   cbilling:         self.enabled = False
   cbilling:         self.normal_import = None
   cbilling:         self.depth = 0
   cbilling:         self.threshold = 0
   cbilling:         try:
   cbilling:             self.builtins_dict = __builtins__.__dict__
   cbilling:         except AttributeError:
   cbilling:             self.builtins_dict = __builtins__
   cbilling: 
   cbilling:     def profiling_import(self, name, *args,**kwargs):
   cbilling:         self.depth += 1
   cbilling:         start_time = time.time()
   cbilling:         try:
   cbilling:             result = self.normal_import(name, *args, **kwargs)
   cbilling:         finally:
   cbilling:             self.depth -= 1
   cbilling:         time_taken = time.time() - start_time
   cbilling:         if time_taken > self.threshold:
janwerkmann:             print(' '*self.depth + '[%.2f] import %s'%(time_taken, name))
   cbilling:         return result
   cbilling: 
   cbilling: 
   cbilling:     def enable(self, threshold=0.1):
   cbilling:         if self.enabled:
   cbilling:             raise RuntimeError('Already enabled')
   cbilling:         self.enabled = True
   cbilling:         self.threshold = threshold
   cbilling:         self.normal_import = __import__
   cbilling:         self.builtins_dict['__import__'] = self.profiling_import
   cbilling: 
   cbilling:     def disable(self):
   cbilling:         if not self.enabled:
   cbilling:             raise RuntimeError('Not enabled')
   cbilling:         self.enabled = False
   cbilling:         self.builtins_dict['__import__'] = self.normal_import
   cbilling:         self.normal_import = None
   cbilling: 
   cbilling: 
   cbilling: _profiling_importer = _ProfilingImporter()
   cbilling: enable = _profiling_importer.enable
   cbilling: disable = _profiling_importer.disable
   cbilling: 
   cbilling: if __name__ == '__main__':
   cbilling:     enable(threshold=0.05)
   cbilling:     import IPython
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # labconfig.py                                                      #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the labscript suite (see                     #
        cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
        cbilling: # BSD License. See the license.txt file in the root of the project  #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: 
           Chris: import sys
        pstarkey: import os
        cbilling: import socket
     janwerkmann: import subprocess
        cbilling: 
chrisjbillington: from labscript_utils import PY2
chrisjbillington: if PY2:
chrisjbillington:     import ConfigParser as configparser
chrisjbillington: else:
           Chris:     import configparser
           Chris: 
           Chris: from labscript_utils import labscript_suite_install_dir
        cbilling: # Look for a 'labconfig' folder in the labscript install directory:
           Chris: if labscript_suite_install_dir is not None:
           Chris:     config_prefix = os.path.join(labscript_suite_install_dir, 'labconfig')
        cbilling: else:
        cbilling:     # No labscript install directory found? Revert to system defaults
        cbilling:     if os.name == 'nt':
        cbilling:         config_prefix = os.path.abspath(r'C:\labconfig')
        cbilling:     else:
        cbilling:         config_prefix = os.path.join(os.getenv('HOME'),'labconfig')
        cbilling:         if not os.path.exists(config_prefix):
        cbilling:             config_prefix='/etc/labconfig/'
        cbilling: 
        cbilling: if not os.path.exists(config_prefix):
        cbilling:     message = (r"Couldn't find labconfig folder. Please ensure it exists. " +
        cbilling:                r"If the labscript suite is installed, labconfig must be <labscript_suite_install_dir>/labconfig/. " +
        cbilling:                r"If the labscript suite is not installed, then C:\labconfig\ is checked on Windows, " +
        cbilling:                r" and $HOME/labconfig/ then /etc/labconfig/ checked on unix.")
        cbilling:     raise IOError(message)
        cbilling: 
        cbilling: config_prefix = os.path.abspath(config_prefix)
        cbilling: 
     janwerkmann: if sys.platform == 'darwin':
     janwerkmann:     hostname = subprocess.check_output(['scutil', '--get', 'LocalHostName']).decode('utf8').strip()
     janwerkmann: else:
     janwerkmann:     hostname = socket.gethostname()
     janwerkmann: default_config_path = os.path.join(config_prefix,'%s.ini'%hostname)
        cbilling: 
           Chris: class LabConfig(configparser.SafeConfigParser):
           Chris:     NoOptionError = configparser.NoOptionError
           Chris:     NoSectionError = configparser.NoSectionError
            test: 
        pstarkey:     def __init__(self,config_path=default_config_path,required_params={},defaults={}):
        pstarkey:         if isinstance(config_path,list):
        pstarkey:             self.config_path = config_path[0]
        pstarkey:         else:
        pstarkey:             self.config_path = config_path
            test: 
          rander:         self.file_format = ""
          rander:         for section, options in required_params.items():
          rander:             self.file_format += "[%s]\n"%section
          rander:             for option in options:
          rander:                 self.file_format += "%s = <value>\n"%option
        cbilling: 
          rander:         # If the folder doesn't exist, create it
        pstarkey:         if not os.path.exists(os.path.dirname(self.config_path)):
        pstarkey:             os.mkdir(os.path.dirname(self.config_path))
        cbilling: 
        pstarkey:         # If the file doesn't exist, create it
        pstarkey:         if not os.path.exists(self.config_path):
        pstarkey:             with open(self.config_path,'a+') as f:
          rander:                 f.write(self.file_format)
        cbilling: 
        pstarkey:         # Load the config file
           Chris:         configparser.SafeConfigParser.__init__(self,defaults)
        pstarkey:         self.read(config_path) #read all files in the config path if it is a list (self.config_path only contains one string)
        cbilling: 
        pstarkey:         try:
        pstarkey:             for section, options in required_params.items():
        pstarkey:                 for option in options:
        pstarkey:                     self.get(section,option)
        cbilling: 
           Chris:         except configparser.NoOptionError as e:
          rander:             raise Exception('The experiment configuration file located at %s does not have the required keys. Make sure the config file containes the following structure:\n%s'%(config_path, self.file_format))
        cbilling: 
        pstarkey: 
        pstarkey:     # Overwrite the add_section method to only attempt to add a section if it doesn't
        pstarkey:     # exist. We don't ever care whether a section exists or not, only that it does exist
        pstarkey:     # when we try and save an attribute into it.
        pstarkey:     def add_section(self,section):
        pstarkey:         # Create the group if it doesn't exist
        cbilling:         if not section.lower() == 'default' and not self.has_section(section):
           Chris:             configparser.SafeConfigParser.add_section(self, section)
        cbilling: 
        pstarkey:     # Overwrite the set method so that it adds the section if it doesn't exist,
        pstarkey:     # and immediately saves the data to the file (to avoid data loss on program crash)
        pstarkey:     def set(self, section, option, value):
        cbilling:         self.add_section(section)
           Chris:         configparser.SafeConfigParser.set(self,section,option,value)
        pstarkey:         self.save()
        cbilling: 
        pstarkey:     # Overwrite the remove section function so that it immediately saves the change to disk
        pstarkey:     def remove_section(self,section):
           Chris:         configparser.SafeConfigParser.remove_section(self,section)
        pstarkey:         self.save()
        cbilling: 
        cbilling:     # Overwrite the remove option function so that it immediately saves the change to disk
        pstarkey:     def remove_option(self,section,option):
           Chris:         configparser.SafeConfigParser.remove_option(self,section,option)
        pstarkey:         self.save()
        cbilling: 
        pstarkey:     # Provide a convenience method to save the contents of the ConfigParser to disk
        pstarkey:     def save(self):
        pstarkey:         with open(self.config_path, 'w+') as f:
        pstarkey:             self.write(f)
     janwerkmann: #####################################################################
     janwerkmann: #                                                                   #
     janwerkmann: # memprof.py                                                        #
     janwerkmann: #                                                                   #
     janwerkmann: # Copyright 2013, Monash University                                 #
     janwerkmann: #                                                                   #
     janwerkmann: # This file is part of the labscript suite (see                     #
     janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
     janwerkmann: # BSD License. See the license.txt file in the root of the project  #
     janwerkmann: # for the full license.                                             #
     janwerkmann: #                                                                   #
     janwerkmann: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann: 
        cbilling: import gc
        cbilling: 
chrisjbillington: class MemoryProfiler(object):
chrisjbillington:     """Class to count number instances of each type in the interpreter in order to
chrisjbillington:     detect Python memory leaks"""
chrisjbillington:     def __init__(self):
chrisjbillington:         self.filepath = None
chrisjbillington:         self.initial_counts = None
chrisjbillington: 
chrisjbillington:     def count_types(self):
chrisjbillington:         types = {}
chrisjbillington:         for obj in gc.get_objects():
chrisjbillington:             try:
chrisjbillington:                 c = obj.__class__
chrisjbillington:             except AttributeError:
chrisjbillington:                 c = type(obj)
chrisjbillington:             try:
chrisjbillington:                 types[c] += 1
chrisjbillington:             except KeyError:
chrisjbillington:                 types[c] = 1
chrisjbillington:         self.write_to_file(types)
chrisjbillington:         return types
chrisjbillington:         
chrisjbillington:     def write_to_file(self, types):
chrisjbillington:         with open(self.filepath, 'w') as f:
chrisjbillington:             names = list(types.keys())
chrisjbillington:             names.sort(key=lambda name: -types[name])
chrisjbillington:             for name in names:
chrisjbillington:                 f.write(str(name).rjust(60) + ' ' +
chrisjbillington:                         str(types[name]).rjust(8) + '\n')
chrisjbillington:                 
chrisjbillington:     def start(self, filepath='memprof.txt'):
chrisjbillington:         self.filepath = filepath
chrisjbillington:         self.initial_counts = self.count_types()
chrisjbillington:               
chrisjbillington:     def check(self):
chrisjbillington:         diffs = {}
chrisjbillington:         types = self.count_types()
chrisjbillington:         for type_ in types:
chrisjbillington:             try:
chrisjbillington:                 diffs[type_] = types[type_] - self.initial_counts[type_]
chrisjbillington:             except KeyError:
chrisjbillington:                 diffs[type_] = types[type_]
chrisjbillington:         self.write_to_file(diffs)
chrisjbillington:         return True
        cbilling:     
        cbilling: 
chrisjbillington: _memory_profiler = MemoryProfiler()
chrisjbillington: start = _memory_profiler.start
chrisjbillington: check = _memory_profiler.check
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # modulewatcher.py                                                  #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
   cbilling: import sys
   cbilling: import threading
   cbilling: import time
   pstarkey: import os
   cbilling: import imp
   cbilling: 
   cbilling: class ModuleWatcher(object):
      Chris:     def __init__(self, debug=False):
      Chris:         self.debug = debug
   cbilling:         # A lock to hold whenever you don't want modules unloaded:
   cbilling:         self.lock = threading.Lock()
   cbilling:             
     beclab:         # The whitelist is the list of names of currently loaded modules:
     beclab:         self.whitelist = set(sys.modules)
     beclab:         self.modified_times = {}
     beclab:         self.main = threading.Thread(target=self.mainloop)
     beclab:         self.main.daemon = True
     beclab:         self.main.start()
   cbilling:         
     beclab:     def mainloop(self):
     beclab:         while True:
     beclab:             time.sleep(1)
   cbilling:             with self.lock:
   cbilling:                 self.check_and_unload()
   cbilling:             
     beclab:     def check_and_unload(self):
     beclab:         # Look through currently loaded modules:
   cbilling:         for name, module in sys.modules.copy().items():
   cbilling:             # Look only at the modules not in the the whitelist:
   cbilling:             if name not in self.whitelist and hasattr(module,'__file__'):
   cbilling:                 # Only consider modules which are .py files, no C extensions:
   cbilling:                 module_file = module.__file__.replace('.pyc', '.py')
   cbilling:                 if not module_file.endswith('.py') or not os.path.exists(module_file):
   cbilling:                     continue
   cbilling:                 # Check and store the modified time of the .py file:
   cbilling:                 modified_time = os.path.getmtime(module_file)
   cbilling:                 previous_modified_time = self.modified_times.setdefault(name, modified_time)
   cbilling:                 self.modified_times[name] = modified_time
   cbilling:                 if modified_time != previous_modified_time:
   cbilling:                     # A module has been modified! Unload all modules
   cbilling:                     # not in the whitelist:
   cbilling:                     message = '%s modified: all modules will be reloaded next run.\n'%module_file
   cbilling:                     sys.stderr.write(message)
      Chris:                     if self.debug:
      Chris:                         print("ModuleWatcher: whitelist is:")
      Chris:                         for name in sorted(self.whitelist):
      Chris:                             print("    " + name)
      Chris:                         print("\nModuleWatcher: modules unloaded:")
   cbilling:                     # Acquire the import lock so that we don't unload
   cbilling:                     # modules whilst an import is in progess:
   cbilling:                     imp.acquire_lock()
   cbilling:                     try:
      Chris:                         for name in sorted(sys.modules):
   cbilling:                             if name not in self.whitelist:
   cbilling:                                 # This unloads a module. This is slightly
   cbilling:                                 # more general than reload(module), but
   cbilling:                                 # has the same caveats regarding existing
   cbilling:                                 # references. This also means that any
   cbilling:                                 # exception in the import will occur later,
   cbilling:                                 # once the module is (re)imported, rather
   cbilling:                                 # than now where catching the exception
   cbilling:                                 # would have to be handled differently.
   cbilling:                                 del sys.modules[name]
   cbilling:                                 if name in self.modified_times:
   cbilling:                                     del self.modified_times[name]
      Chris:                                 if self.debug:
      Chris:                                     print("    " + name)
   cbilling:                     finally:
   cbilling:                         # We're done mucking around with the cached
   cbilling:                         # modules, normal imports in other threads
   cbilling:                         # may resume:
   cbilling:                         imp.release_lock()
   cbilling:                             
   cbilling:                             
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # numpy_dtype_workaround.py                                         #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: from labscript_utils import PY2
chrisjbillington: 
chrisjbillington: def dtype_workaround(dtypes):
chrisjbillington:     """Convert names specified in compound datatype tuples to the native
chrisjbillington:     string type. This is a workaround for numpy issue #2407 until the fix
chrisjbillington:     becomes available:
chrisjbillington:     https://github.com/numpy/numpy/issues/2407
chrisjbillington:     """
chrisjbillington:     if PY2:
chrisjbillington:         return [(bytes(name), dtype) for name, dtype in dtypes]
chrisjbillington:     return dtypes
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
        cbilling: import sys
        cbilling: import json
        cbilling: import numpy as np
chrisjbillington: import h5py
chrisjbillington: 
chrisjbillington: vlenstring = h5py.special_dtype(vlen=str)
        cbilling: 
        cbilling: JSON_IDENTIFIER = 'Content-Type: application/json '
        cbilling: 
        cbilling: VALID_PROPERTY_LOCATIONS = {
        cbilling:     "connection_table_properties",
        cbilling:     "device_properties",
        cbilling:     "unit_conversion_parameters"
        cbilling:     }
        cbilling: 
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann: 
chrisjbillington: 
chrisjbillington: def is_json(value):
chrisjbillington:     if isinstance(value, bytes):
chrisjbillington:         return value[:len(JSON_IDENTIFIER)] == JSON_IDENTIFIER.encode('utf8')
chrisjbillington:     elif isinstance(value, str):
chrisjbillington:         return value.startswith(JSON_IDENTIFIER)
chrisjbillington:     return False
        cbilling: 
        cbilling: 
        cbilling: def serialise(value):
        cbilling:     json_string = json.dumps(value)
        cbilling:     return JSON_IDENTIFIER + json_string
        cbilling: 
        cbilling: 
        cbilling: def deserialise(value):
chrisjbillington:     assert is_json(value)
        cbilling:     return json.loads(value[len(JSON_IDENTIFIER):])
        cbilling: 
        cbilling: 
        cbilling: def set_device_properties(h5_file, device_name, properties):
        cbilling:     gp = h5_file['devices/' + device_name]
        cbilling:     for key, val in properties.items():
        cbilling:         try:
        cbilling:             # Workaround for h5py not supporting None but not raising a TypeError:
        cbilling:             if val is None:
        cbilling:                 raise TypeError('has no native HDF5 equivalent')
        cbilling:             gp.attrs[key] = val
        cbilling:         except TypeError as e:
        cbilling:             # If type not supported by HDF5, store as JSON
     janwerkmann:             if 'has no native HDF5 equivalent' in str(e):
        cbilling:                 json_string = serialise(val)
chrisjbillington:                 gp.attrs[key] = json_string
        cbilling:             else:
        cbilling:                 raise
        cbilling: 
        cbilling: 
        cbilling: def _get_device_properties(h5_file, device_name):
        cbilling:     gp = h5_file['devices/' + device_name]
        cbilling:     properties = {}
        cbilling:     for key, val in gp.attrs.items():
        cbilling:         # Deserialize values if stored as JSON
             jan:         if is_json(val):
chrisjbillington:             properties[key] = deserialise(val)
        cbilling:         else:
        cbilling:             properties[key] = val
        cbilling:     return properties
        cbilling: 
chrisjbillington: 
        cbilling: def _get_con_table_properties(h5_file, device_name):
        cbilling:     dataset = h5_file['connection table']
chrisjbillington: 
chrisjbillington:     # Compare with the name in the connection table
chrisjbillington:     # whether it is np.bytes_ or vlenstr:
chrisjbillington:     namecol_dtype = dataset['name'].dtype
chrisjbillington:     if namecol_dtype.type is np.bytes_:
chrisjbillington:         device_name = device_name.encode('utf8')
chrisjbillington:     elif namecol_dtype is vlenstring:
chrisjbillington:         pass
chrisjbillington:     else:
chrisjbillington:         raise TypeError(namecol_dtype)
chrisjbillington: 
chrisjbillington:     row = dataset[dataset['name'] == device_name][0]
        cbilling:     json_string = row['properties']
        cbilling:     return deserialise(json_string)
        cbilling: 
        cbilling: 
        cbilling: def _get_unit_conversion_parameters(h5_file, device_name):
        cbilling:     dataset = h5_file['connection table']
chrisjbillington: 
chrisjbillington:     # Compare with the name in the connection table
chrisjbillington:     # whether it is np.bytes_ or vlenstr:
chrisjbillington:     namecol_dtype = dataset['name'].dtype
chrisjbillington:     if namecol_dtype.type is np.bytes_:
chrisjbillington:         device_name = device_name.encode('utf8')
chrisjbillington:     elif namecol_dtype is vlenstring:
chrisjbillington:         pass
chrisjbillington:     else:
chrisjbillington:         raise TypeError(namecol_dtype)
chrisjbillington: 
chrisjbillington:     row = dataset[dataset['name'] == device_name][0]
        cbilling:     json_string = row['unit conversion params']
        cbilling:     return deserialise(json_string)
        cbilling: 
        cbilling: 
        cbilling: def get(h5_file, device_name, location):
        cbilling:     if location == 'device_properties':
        cbilling:         return _get_device_properties(h5_file, device_name)
        cbilling:     elif location == 'connection_table_properties':
        cbilling:         return _get_con_table_properties(h5_file, device_name)
        cbilling:     elif location == 'unit_conversion_parameters':
        cbilling:         return _get_unit_conversion_parameters(h5_file, device_name)
        cbilling:     else:
        cbilling:         raise ValueError('location must be one of %s'%str(VALID_PROPERTY_LOCATIONS))
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __init__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the labscript suite (see                     #
        cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
        cbilling: # BSD License. See the license.txt file in the root of the project  #
        cbilling: # for the full license.                                             #
        cbilling: #                                                                   #
        cbilling: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        cbilling: 
     janwerkmann: try:
     janwerkmann:     from labscript_utils import check_version
     janwerkmann: except ImportError:
     janwerkmann:     raise ImportError('Require labscript_utils > 2.1.0')
     janwerkmann: 
chrisjbillington: check_version('qtutils', '2.1.0', '3.0.0')
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # analogoutput.py                                                   #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
chrisjbillington: 
        pstarkey: import sys
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
        pstarkey: 
chrisjbillington: 
chrisjbillington: class NoStealFocusDoubleSpinBox(QDoubleSpinBox):
chrisjbillington:     """A QDoubleSpinBox that doesn't steal focus as you scroll over it with a
chrisjbillington:     mouse wheel."""
chrisjbillington:     def __init__(self, *args, **kwargs):
chrisjbillington:         QDoubleSpinBox.__init__(self, *args, **kwargs)
chrisjbillington:         self.setFocusPolicy(Qt.StrongFocus)
chrisjbillington: 
chrisjbillington:     def focusInEvent(self, event):
chrisjbillington:         self.setFocusPolicy(Qt.WheelFocus)
chrisjbillington:         return QDoubleSpinBox.focusInEvent(self, event)
chrisjbillington: 
chrisjbillington:     def focusOutEvent(self, event):
chrisjbillington:         self.setFocusPolicy(Qt.StrongFocus)
chrisjbillington:         return QDoubleSpinBox.focusOutEvent(self, event)
chrisjbillington: 
chrisjbillington:     def wheelEvent(self, event):
chrisjbillington:         if self.hasFocus():
chrisjbillington:             return QDoubleSpinBox.wheelEvent(self, event)
chrisjbillington:         else:
chrisjbillington:             event.ignore()
chrisjbillington: 
        pstarkey: class AnalogOutput(QWidget):
        pstarkey:     def __init__(self, hardware_name, connection_name='-', display_name=None, horizontal_alignment=False, parent=None):
        pstarkey:         QWidget.__init__(self,parent)
        pstarkey:         
        pstarkey:         self._connection_name = connection_name
        pstarkey:         self._hardware_name = hardware_name
        pstarkey:         
        pstarkey:         label_text = (self._hardware_name + '\n' + self._connection_name) if display_name is None else display_name
        pstarkey:         self._label = QLabel(label_text)
        pstarkey:         self._label.setAlignment(Qt.AlignCenter)
        pstarkey:         self._label.setSizePolicy(QSizePolicy.Fixed,QSizePolicy.Minimum)
chrisjbillington:         self._spin_widget = NoStealFocusDoubleSpinBox()
        pstarkey:         self._spin_widget.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Minimum)
        pstarkey:         self._spin_widget.setKeyboardTracking(False)
        pstarkey:         self._combobox = QComboBox()
        pstarkey:         self._combobox.setSizePolicy(QSizePolicy.Minimum,QSizePolicy.Minimum)
        pstarkey:         self._combobox.currentIndexChanged.connect(self._on_combobox_change)
        pstarkey:         
        pstarkey:         self._value_changed_function = None
        pstarkey:         
        pstarkey:         self.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Minimum)
        pstarkey:         
        pstarkey:         # Handle spinbox context menu
        pstarkey:         # Lock/Unlock action
        pstarkey:         self._lock_action = QAction("Lock",self._spin_widget)
        pstarkey:         self._lock_action.triggered.connect(lambda:self._menu_triggered(self._lock_action))
        pstarkey:         #change step size action
        pstarkey:         self._stepsize_action = QAction("Set step size",self._spin_widget)
        pstarkey:         self._stepsize_action.triggered.connect(self._change_step)
        pstarkey:         # Stepup/down Actions
        pstarkey:         self._stepup_action = QAction("Step up",self._spin_widget)
        pstarkey:         self._stepup_action.triggered.connect(lambda:self._spin_widget.stepBy(1))
        pstarkey:         self._stepdown_action = QAction("Step down",self._spin_widget)
        pstarkey:         self._stepdown_action.triggered.connect(lambda:self._spin_widget.stepBy(-1))
chrisjbillington:             
chrisjbillington:         self.menu = None
chrisjbillington:                 
chrisjbillington:         def deletemenu(menu):
chrisjbillington:             menu.deleteLater()
chrisjbillington:             if menu == self.menu:
chrisjbillington:                 self.menu = None
        pstarkey:                         
        pstarkey:         def context_menu(pos):
        pstarkey:             self.menu = menu = self._spin_widget.lineEdit().createStandardContextMenu()
        pstarkey:             # Add Divider
        pstarkey:             menu.addSeparator()
        pstarkey:             # Add step up/Stepdown actions (grey out if at min/max or locked)
        pstarkey:             menu.addAction(self._stepup_action)
        pstarkey:             menu.addAction(self._stepdown_action)
        pstarkey:             if self._spin_widget.value() == self._spin_widget.minimum():
        pstarkey:                 self._stepdown_action.setEnabled(False)
        pstarkey:             else:
        pstarkey:                 self._stepdown_action.setEnabled(True)
        pstarkey:             if self._spin_widget.value() == self._spin_widget.maximum():
        pstarkey:                 self._stepup_action.setEnabled(False)
        pstarkey:             else:
        pstarkey:                 self._stepup_action.setEnabled(True)
        pstarkey:             
        pstarkey:             # Add divider
        pstarkey:             menu.addSeparator()
        pstarkey:             # Add lock action
        pstarkey:             menu.addAction(self._lock_action)
        pstarkey:             menu.addAction(self._stepsize_action)
chrisjbillington:             
chrisjbillington:             # connect signal for when menu is destroyed
chrisjbillington:             menu.aboutToHide.connect(lambda menu=menu: deletemenu(menu))
        pstarkey:             
        pstarkey:             # Show the menu
        pstarkey:             menu.popup(self.mapToGlobal(pos))
        pstarkey:             
        pstarkey:         self._spin_widget.lineEdit().setContextMenuPolicy(Qt.CustomContextMenu)
        pstarkey:         self._spin_widget.lineEdit().customContextMenuRequested.connect(context_menu)
        pstarkey:         
        pstarkey:         # Create widgets and layouts        
        pstarkey:         if horizontal_alignment:
        pstarkey:             self._layout = QHBoxLayout(self)
        pstarkey:             self._layout.addWidget(self._label)
        pstarkey:             self._layout.addWidget(self._spin_widget)
        pstarkey:             self._layout.addWidget(self._combobox)
chrisjbillington:             self._layout.setContentsMargins(0,0,0,0)
        pstarkey:         else:
        pstarkey:             self._layout = QGridLayout(self)
chrisjbillington:             self._layout.setVerticalSpacing(3)
        pstarkey:             self._layout.setHorizontalSpacing(0)
chrisjbillington:             self._layout.setContentsMargins(3,3,3,3)
        pstarkey:             
        pstarkey:             self._label.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Minimum)
        pstarkey:             
        pstarkey:             #self._layout.addWidget(self._label)            
        pstarkey:             #self._layout.addItem(QSpacerItem(0,0,QSizePolicy.MinimumExpanding,QSizePolicy.Minimum),0,1)
        pstarkey:             
        pstarkey:             h_widget = QWidget()            
        pstarkey:             h_layout = QHBoxLayout(h_widget)
        pstarkey:             h_layout.setContentsMargins(0,0,0,0)
        pstarkey:             h_layout.addWidget(self._spin_widget)
        pstarkey:             h_layout.addWidget(self._combobox)
        pstarkey:             
        pstarkey:             self._layout.addWidget(self._label,0,0)
        pstarkey:             self._layout.addWidget(h_widget,1,0)            
        pstarkey:             #self._layout.addItem(QSpacerItem(0,0,QSizePolicy.MinimumExpanding,QSizePolicy.Minimum),1,1)
        pstarkey:             self._layout.addItem(QSpacerItem(0,0,QSizePolicy.Minimum,QSizePolicy.MinimumExpanding),2,0)
        pstarkey:         
        pstarkey:         # Install the event filter that will allow us to catch right click mouse release events so we can popup a menu even when the button is disabled
        pstarkey:         self.installEventFilter(self)
        pstarkey:         
        pstarkey:         # The Analog Out object that is in charge of this button
        pstarkey:         self._AO = None
        pstarkey:     
        pstarkey:     # Setting and getting methods for the Digitl Out object in charge of this button
        pstarkey:     def set_AO(self,AO,notify_old_AO=True,notify_new_AO=True):
        pstarkey:         # If we are setting a new AO, remove this widget from the old one (if it isn't None) and add it to the new one (if it isn't None)
        pstarkey:         if AO != self._AO:
        pstarkey:             if self._AO is not None and notify_old_AO:
        pstarkey:                 self._AO.remove_widget(self,False)
        pstarkey:             if AO is not None and notify_new_AO:
        pstarkey:                 AO.add_widget(self)
        pstarkey:         # Store a reference to the digital out object
        pstarkey:         self._AO = AO
        pstarkey:         
        pstarkey:     def get_AO(self):
        pstarkey:         return self._AO
        pstarkey:     
        pstarkey:     def connect_value_change(self,func):
        pstarkey:         self._value_changed_function = lambda value,self=self: func(value,self.selected_unit,True)
        pstarkey:         self._spin_widget.valueChanged.connect(self._value_changed_function)
        pstarkey:         
        pstarkey:     def disconnect_value_change(self):
        pstarkey:         self._spin_widget.valueChanged.disconnect(self._value_changed_function)
        pstarkey:     
        pstarkey:     def set_combobox_model(self,model):
        pstarkey:         self._combobox.setModel(model)
        pstarkey:     
        pstarkey:     def _on_combobox_change(self):
        pstarkey:         selected_text = self.selected_unit
        pstarkey:         if self._AO is not None:
        pstarkey:             self._AO.change_unit(selected_text)
        pstarkey:             
        pstarkey:     def block_spinbox_signals(self):
        pstarkey:         return self._spin_widget.blockSignals(True)
        pstarkey:         
        pstarkey:     def unblock_spinbox_signals(self):
        pstarkey:         return self._spin_widget.blockSignals(False)
        pstarkey:     
        pstarkey:     def set_spinbox_value(self,value,unit):
        pstarkey:         if self._AO is not None:
        pstarkey:             # get the value in the selected unit
        pstarkey:             value = self._AO.convert_value_to_base(value,unit)
        pstarkey:             value = self._AO.convert_value_from_base(value,self.selected_unit)            
        pstarkey:         self._spin_widget.setValue(value)
        pstarkey:     
        pstarkey:     @property
        pstarkey:     def selected_unit(self):
        pstarkey:         return str(self._combobox.currentText())
        pstarkey: 
        pstarkey:     def block_combobox_signals(self):
        pstarkey:         return self._combobox.blockSignals(True)
        pstarkey:         
        pstarkey:     def unblock_combobox_signals(self):
        pstarkey:         return self._combobox.blockSignals(False)
        pstarkey:     
        pstarkey:     def set_selected_unit(self,unit):
        pstarkey:         if unit != self.selected_unit:
        pstarkey:             item = self._combobox.model().findItems(unit)
        pstarkey:             if item:
        pstarkey:                 model_index = self._combobox.model().indexFromItem(item[0])
        pstarkey:                 self._combobox.setCurrentIndex(model_index.row())
        pstarkey:                 
        pstarkey:     def set_num_decimals(self,decimals):
        pstarkey:         self._spin_widget.setDecimals(decimals)
        pstarkey:         
        pstarkey:     def set_limits(self,lower,upper):
        pstarkey:         self._spin_widget.setRange(lower,upper)
        pstarkey:         
        pstarkey:     def set_step_size(self,step):
        pstarkey:         self._spin_widget.setSingleStep(step)
        pstarkey:             
        pstarkey:     def _change_step(self):
        pstarkey:         maximum_step = abs(self._spin_widget.maximum()-self._spin_widget.minimum())
        pstarkey:         new_step,ok = QInputDialog.getDouble(self,"Set step size","Set step size",self._spin_widget.singleStep(),0.0,maximum_step,self._spin_widget.decimals())
        pstarkey:     
        pstarkey:         if ok:
        pstarkey:             self.set_step_size(new_step)
        pstarkey:             if self._AO:
        pstarkey:                 self._AO.set_step_size(new_step,self.selected_unit)
        pstarkey:     
        pstarkey:     # The event filter that pops up a context menu on a right click, even when the button is disabled
        pstarkey:     def eventFilter(self, obj, event):
        pstarkey:         if event.type() == QEvent.MouseButtonRelease and event.button() == Qt.RightButton:
        pstarkey:             menu = QMenu(self)
        pstarkey:             menu.addAction("Lock" if self._spin_widget.isEnabled() else "Unlock")
        pstarkey:             menu.triggered.connect(self._menu_triggered)
        pstarkey:             menu.popup(self.mapToGlobal(event.pos()))
        pstarkey:         
        pstarkey:         return QWidget.eventFilter(self, obj, event)
        pstarkey:      
        pstarkey:     # This method is called whenever an entry in the context menu is clicked
        pstarkey:     def _menu_triggered(self,action):
        pstarkey:         if action.text() == "Lock":
        pstarkey:             self.lock()
        pstarkey:         elif action.text() == "Unlock":
        pstarkey:             self.unlock()
        pstarkey:     
        pstarkey:     # This method locks (disables) the widget, and if the widget has a parent AO object, notifies it of the lock
        pstarkey:     def lock(self,notify_ao=True):        
        pstarkey:         self._spin_widget.setEnabled(False)
        pstarkey:         self._lock_action.setText("Unlock")
        pstarkey:         if self._AO is not None and notify_ao:
        pstarkey:             self._AO.lock()
        pstarkey:     
        pstarkey:     # This method unlocks (enables) the widget, and if the widget has a parent AO object, notifies it of the unlock    
        pstarkey:     def unlock(self,notify_ao=True):        
        pstarkey:         self._spin_widget.setEnabled(True)        
        pstarkey:         self._lock_action.setText("Lock")
        pstarkey:         if self._AO is not None and notify_ao:
        pstarkey:             self._AO.unlock()
        pstarkey:         
        pstarkey:     
        pstarkey: # A simple test!
        pstarkey: if __name__ == '__main__':
        pstarkey:     
        pstarkey:     qapplication = QApplication(sys.argv)
        pstarkey:     
        pstarkey:     window = QWidget()
        pstarkey:     layout = QVBoxLayout(window)
        pstarkey:     button = AnalogOutput('AO1')
        pstarkey:         
        pstarkey:     layout.addWidget(button)
        pstarkey:     
        pstarkey:     window.show()
        pstarkey:     
        pstarkey:     
        pstarkey:     sys.exit(qapplication.exec_())
     janwerkmann:     
           Chris: #####################################################################
           Chris: #                                                                   #
           Chris: # ddsoutput.py                                                      #
           Chris: #                                                                   #
           Chris: # Copyright 2013, Monash University                                 #
           Chris: #                                                                   #
           Chris: # This file is part of the labscript suite (see                     #
           Chris: # http://labscriptsuite.org) and is licensed under the Simplified   #
           Chris: # BSD License. See the license.txt file in the root of the project  #
           Chris: # for the full license.                                             #
           Chris: #                                                                   #
           Chris: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
           Chris: 
        pstarkey: import sys
        pstarkey: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
     janwerkmann: 
        cbilling: from labscript_utils.qtwidgets.analogoutput import AnalogOutput
        cbilling: from labscript_utils.qtwidgets.digitaloutput import DigitalOutput
        pstarkey: 
        pstarkey: class DDSOutput(QWidget):
        pstarkey:     def __init__(self, hardware_name, connection_name='-', parent=None):
        pstarkey:         QWidget.__init__(self,parent)
        pstarkey:         
        pstarkey:         self._connection_name = connection_name
        pstarkey:         self._hardware_name = hardware_name
        pstarkey:         
           Chris:         label_text = (self._hardware_name + '\n' + self._connection_name) 
        pstarkey:         self._label = QLabel(label_text)
        pstarkey:         self._label.setAlignment(Qt.AlignCenter)
        pstarkey:         self._label.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Minimum)
        pstarkey:         
        pstarkey:         
        pstarkey:         self.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Minimum)
        pstarkey:         
        pstarkey:         # Create widgets
        pstarkey:         self._widgets = {}
           Chris:         self._widgets['gate'] = DigitalOutput('Enable')
chrisjbillington:         self._widgets['freq'] = AnalogOutput('',display_name='<i>f&nbsp;</i>', horizontal_alignment=True)
chrisjbillington:         self._widgets['amp'] = AnalogOutput('',display_name='<i>A</i>', horizontal_alignment=True)
           Chris:         self._widgets['phase'] = AnalogOutput('',display_name=u'<i>&phi;</i>', horizontal_alignment=True)
        pstarkey:         
           Chris:         # Extra layout at the top level with horizontal stretches so that our
           Chris:         # widgets do not grow to take up all available horizontal space:
           Chris:         self._outer_layout = QHBoxLayout(self)
           Chris:         self._outer_layout.setContentsMargins(0, 0, 0, 0)
           Chris:         # self._layout.setHorizontalSpacing(3)
           Chris:         self._frame = QFrame(self)
           Chris:         self._outer_layout.addStretch()
           Chris:         self._outer_layout.addWidget(self._frame)
           Chris:         self._outer_layout.addStretch()
           Chris: 
        pstarkey:         # Create grid layout that keeps widgets from expanding and keeps label centred above the widgets
           Chris:         self._layout = QGridLayout(self._frame)
           Chris:         self._layout.setVerticalSpacing(6)
        pstarkey:         self._layout.setHorizontalSpacing(0)
        pstarkey:         self._layout.setContentsMargins(0,0,0,0)
        pstarkey:         
           Chris:         v_widget = QFrame()
           Chris:         v_widget.setFrameStyle(QFrame.StyledPanel)            
           Chris:         v_layout = QVBoxLayout(v_widget)
           Chris:         v_layout.setContentsMargins(6,6,6,6)
           Chris: 
           Chris:         # Extra widget with stretches around the enabled button so it doesn't
           Chris:         # stretch out to fill all horizontal space:
           Chris:         self.gate_container = QWidget()
           Chris:         gate_layout = QHBoxLayout(self.gate_container)
           Chris:         gate_layout.setContentsMargins(0,0,0,0)
           Chris:         gate_layout.setSpacing(0)
           Chris:         gate_layout.addStretch()
           Chris:         gate_layout.addWidget(self._widgets['gate'])
           Chris:         gate_layout.addStretch()
           Chris: 
           Chris:         self._widgets['gate'].setToolTip("Enable")
           Chris:         self._widgets['freq'].setToolTip("Frequency")
           Chris:         self._widgets['amp'].setToolTip("Amplitude")
           Chris:         self._widgets['phase'].setToolTip("Phase")
           Chris: 
           Chris:         v_layout.addWidget(self.gate_container)
           Chris:         v_layout.addWidget(self._widgets['freq'])
           Chris:         v_layout.addWidget(self._widgets['amp'])
           Chris:         v_layout.addWidget(self._widgets['phase'])
        pstarkey:         
        pstarkey:         self._layout.addWidget(self._label,0,0)
        pstarkey:         #self._layout.addItem(QSpacerItem(0,0,QSizePolicy.MinimumExpanding,QSizePolicy.Minimum),0,1)
           Chris:         self._layout.addWidget(v_widget,1,0)            
        pstarkey:         #self._layout.addItem(QSpacerItem(0,0,QSizePolicy.MinimumExpanding,QSizePolicy.Minimum),1,1)
        pstarkey:         self._layout.addItem(QSpacerItem(0,0,QSizePolicy.Minimum,QSizePolicy.MinimumExpanding),2,0)
        pstarkey:         
        pstarkey:         
        pstarkey:     def get_sub_widget(self,subchnl):
        pstarkey:         if subchnl in self._widgets:
        pstarkey:             return self._widgets[subchnl]
        pstarkey:         
        pstarkey:         raise RuntimeError('The sub-channel %s must be either gate, freq, amp or phase'%subchnl)
        pstarkey:         
        pstarkey:     def hide_sub_widget(self,subchnl):
        pstarkey:         if subchnl in self._widgets:
           Chris:             if subchnl == 'gate':
           Chris:                 self.gate_container.hide()
           Chris:             else:
           Chris:                 self._widgets[subchnl].hide()
        pstarkey:             return
        pstarkey:         
        pstarkey:         raise RuntimeError('The sub-channel %s must be either gate, freq, amp or phase'%subchnl)  
        pstarkey:     
        pstarkey:     def show_sub_widget(self,subchnl):
        pstarkey:         if subchnl in self._widgets:
           Chris:             if subchnl == 'gate':
           Chris:                 self.gate_container.show()
           Chris:             else:
           Chris:                 self._widgets[subchnl].show()
        pstarkey:             return
        pstarkey:         
        pstarkey:         raise RuntimeError('The sub-channel %s must be either gate, freq, amp or phase'%subchnl)
        pstarkey:         
        pstarkey: # A simple test!
        pstarkey: if __name__ == '__main__':
        pstarkey:     
        pstarkey:     qapplication = QApplication(sys.argv)
        pstarkey:     
        pstarkey:     window = QWidget()
        pstarkey:     layout = QVBoxLayout(window)
        pstarkey:     button = DDSOutput('DDS1')
        pstarkey:         
        pstarkey:     layout.addWidget(button)
        pstarkey:     
        pstarkey:     window.show()
        pstarkey:     
        pstarkey:     
        pstarkey:     sys.exit(qapplication.exec_())
     janwerkmann:     
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # digitaloutput.py                                                  #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2013, Monash University                                 #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the labscript suite (see                     #
janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
janwerkmann: # BSD License. See the license.txt file in the root of the project  #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
   pstarkey: import sys
   pstarkey: 
janwerkmann: from qtutils.qt.QtCore import *
janwerkmann: from qtutils.qt.QtGui import *
janwerkmann: from qtutils.qt import QT_ENV, PYQT5
janwerkmann: from qtutils.qt.QtWidgets import *
   pstarkey: 
   pstarkey: 
   pstarkey: class DigitalOutput(QPushButton):
   pstarkey:     def __init__(self,*args,**kwargs):
   pstarkey:         QPushButton.__init__(self,*args,**kwargs)
   pstarkey:         
   pstarkey:         # Install the event filter that will allow us to catch right click mouse release events so we can popup a menu even when the button is disabled
   pstarkey:         self.installEventFilter(self)
   pstarkey:         self.setCheckable(True)
   pstarkey:         
   pstarkey:         # The Digital Out object that is in charge of this button
   pstarkey:         self._DO = None
   pstarkey:     
   pstarkey:     # Setting and getting methods for the Digitl Out object in charge of this button
   pstarkey:     def set_DO(self,DO,notify_old_DO=True,notify_new_DO=True):
   pstarkey:         # If we are setting a new DO, remove this widget from the old one (if it isn't None) and add it to the new one (if it isn't None)
   pstarkey:         if DO != self._DO:
   pstarkey:             if self._DO is not None and notify_old_DO:
   pstarkey:                 self._DO.remove_widget(self)
   pstarkey:             if DO is not None and notify_new_DO:
   pstarkey:                 DO.add_widget(self)
   pstarkey:         # Store a reference to the digital out object
   pstarkey:         self._DO = DO
   pstarkey:         
   pstarkey:     def get_DO(self):
   pstarkey:         return self._DO
   pstarkey:     
   pstarkey:     # The event filter that pops up a context menu on a right click, even when the button is disabled
   pstarkey:     def eventFilter(self, obj, event):
   pstarkey:         if event.type() == QEvent.MouseButtonRelease and event.button() == Qt.RightButton:
   pstarkey:             menu = QMenu(self)
   pstarkey:             menu.addAction("Lock" if self.isEnabled() else "Unlock")
   pstarkey:             menu.triggered.connect(self._menu_triggered)
   pstarkey:             menu.popup(self.mapToGlobal(event.pos()))
janwerkmann:         
janwerkmann:         # pass scrollwheel events of disabled buttons through to the parent
janwerkmann:         # code adapted from: http://www.qtforum.org/article/28540/disabled-widgets-and-wheel-events.html
janwerkmann:         elif obj and not obj.isEnabled() and event.type() == QEvent.Wheel and QT_ENV != PYQT5:
janwerkmann:             newEvent = QWheelEvent(obj.mapToParent(event.pos()), event.globalPos(),
janwerkmann:                                    event.delta(), event.buttons(),
janwerkmann:                                    event.modifiers(), event.orientation())
janwerkmann:             QApplication.instance().postEvent(obj.parent(), newEvent)
janwerkmann:             return True
   pstarkey:         
   pstarkey:         return QPushButton.eventFilter(self, obj, event)
   pstarkey:      
   pstarkey:     # This method is called whenever an entry in the context menu is clicked
   pstarkey:     def _menu_triggered(self,action):
   pstarkey:         if action.text() == "Lock":
   pstarkey:             self.lock()
   pstarkey:         elif action.text() == "Unlock":
   pstarkey:             self.unlock()
   pstarkey:     
   pstarkey:     # This method locks (disables) the widget, and if the widget has a parent DO object, notifies it of the lock
   pstarkey:     def lock(self,notify_do=True):        
   pstarkey:         self.setEnabled(False)
   pstarkey:         if self._DO is not None and notify_do:
   pstarkey:             self._DO.lock()
   pstarkey:     
   pstarkey:     # This method unlocks (enables) the widget, and if the widget has a parent DO object, notifies it of the unlock    
   pstarkey:     def unlock(self,notify_do=True): 
   pstarkey:         self.setEnabled(True)
   pstarkey:         if self._DO is not None and notify_do:
   pstarkey:             self._DO.unlock()
   pstarkey:         
   pstarkey:     @property
   pstarkey:     def state(self):
   pstarkey:         return self.isChecked()
   pstarkey:         
   pstarkey:     @state.setter
   pstarkey:     def state(self,state):
   pstarkey:         # conversion to integer, then bool means we can safely pass in
   pstarkey:         # either a string '1' or '0', True or False or 1 or 0
   pstarkey:         self.setChecked(bool(int(state)))
   pstarkey:     
        jan:     
        jan: class InvertedDigitalOutput(DigitalOutput):
        jan:     @property
        jan:     def state(self):
        jan:         return not DigitalOutput.state.fget(self)
        jan: 
        jan:     @state.setter
        jan:     def state(self,state):
        jan:         DigitalOutput.state.fset(self, not state)
        jan: 
janwerkmann: 
   pstarkey: # A simple test!
   pstarkey: if __name__ == '__main__':
   pstarkey:     
   pstarkey:     qapplication = QApplication(sys.argv)
   pstarkey:     
   pstarkey:     window = QWidget()
   pstarkey:     layout = QVBoxLayout(window)
   pstarkey:     button = DigitalOutput('very very long Button')
   pstarkey:         
   pstarkey:     layout.addWidget(button)
   pstarkey:     
   pstarkey:     window.show()
   pstarkey:     
   pstarkey:     
   pstarkey:     sys.exit(qapplication.exec_())
janwerkmann:     
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # dragdroptab.py                                                    #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
chrisjbillington: 
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
chrisjbillington: 
chrisjbillington: import weakref
chrisjbillington: from collections import namedtuple, defaultdict
chrisjbillington: 
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
           Chris: from qtutils.qt.QtCore import *
           Chris: 
           Chris: 
           Chris: class debug(object):
           Chris:     DEBUG = False
           Chris:     depth = 0
           Chris:     @classmethod
           Chris:     def trace(cls, f):
           Chris:         """decorator to print function entries and exits"""
           Chris:         if not cls.DEBUG:
           Chris:             return f
           Chris:         def wrapper(*args, **kwargs):
           Chris:             print('    '*cls.depth + '->', f.__name__)
           Chris:             try:
           Chris:                 cls.depth += 1
           Chris:                 return f(*args, **kwargs)
           Chris:             finally:
           Chris:                 cls.depth -= 1
           Chris:                 print('    '*cls.depth + '<-', f.__name__)
           Chris:         return wrapper
           Chris: 
           Chris: 
           Chris: if debug.DEBUG:
           Chris:     import sys
           Chris:     print('sys.version:', sys.version)
           Chris:     print('PyQt4:', 'PyQt4' in sys.modules)
           Chris:     print('PyQt5:', 'PyQt5' in sys.modules)
           Chris:     print('PySide:', 'PySide' in sys.modules)
           Chris:     print('qtutils:', 'qtutils' in sys.modules)
           Chris:     print('qtutils.qt:', 'qtutils.qt' in sys.modules)
           Chris: 
chrisjbillington: 
chrisjbillington: 
chrisjbillington: Tab = namedtuple('Tab', ['widget', 'text', 'data', 'text_color', 'tooltip',
chrisjbillington:                          'whats_this', 'button_left', 'button_right', 'icon'])
chrisjbillington: 
chrisjbillington: 
           Chris: class _BaseDragDropTabBar(QTabBar):
chrisjbillington:     """Base class for Limbo and DragDropTabBar containing the common class
chrisjbillington:     attributes and  methods"""
chrisjbillington: 
chrisjbillington:     # The QPoint of the mouse relative to the top left corner the tab at the
chrisjbillington:     # time the drag began. Shared by all instances:
chrisjbillington:     _dragged_tab_grab_point = None
chrisjbillington: 
chrisjbillington:     @property
chrisjbillington:     def dragged_tab_grab_point(self):
chrisjbillington:         return self._dragged_tab_grab_point
chrisjbillington: 
chrisjbillington:     @dragged_tab_grab_point.setter
chrisjbillington:     def dragged_tab_grab_point(self, value):
chrisjbillington:         # Setter specifies the class because we want subclasses to all share
chrisjbillington:         # it:
chrisjbillington:         _BaseDragDropTabBar._dragged_tab_grab_point = value
            Phil: 
           Chris:     @debug.trace
chrisjbillington:     def remove_dragged_tab(self, index):
           Chris:         """Remove the tab at the given index and return all its configuration"""
chrisjbillington: 
chrisjbillington:         tab = Tab(widget=self.parent().widget(index),
chrisjbillington:                   text=self.tabText(index),
chrisjbillington:                   data=self.tabData(index),
chrisjbillington:                   text_color=self.tabTextColor(index),
chrisjbillington:                   tooltip=self.tabToolTip(index),
chrisjbillington:                   whats_this=self.tabWhatsThis(index),
chrisjbillington:                   button_left=self.tabButton(index, QTabBar.LeftSide),
chrisjbillington:                   button_right=self.tabButton(index, QTabBar.RightSide),
chrisjbillington:                   icon=self.tabIcon(index))
chrisjbillington: 
chrisjbillington:         self.parent().removeTab(index)
chrisjbillington:         if self.prev_active_tab is not None:
chrisjbillington:             self.setCurrentIndex(self.prev_active_tab)
chrisjbillington:             self.prev_active_tab = None
chrisjbillington: 
chrisjbillington:         return tab
chrisjbillington: 
           Chris:     @debug.trace
chrisjbillington:     def add_dragged_tab(self, index, tab):
chrisjbillington:         """Insert the tab at the given index and set all of its configuration"""
chrisjbillington:         self.prev_active_tab = self.currentIndex()
chrisjbillington: 
chrisjbillington:         self.parent().insertTab(index, tab.widget, tab.text)
chrisjbillington:         self.setCurrentIndex(index)
chrisjbillington: 
chrisjbillington:         if tab.data:
chrisjbillington:             self.setTabData(index, tab.data)
chrisjbillington:         self.setTabTextColor(index, tab.text_color)
chrisjbillington:         if tab.tooltip:
chrisjbillington:             self.setTabToolTip(index, tab.tooltip)
chrisjbillington:         if tab.whats_this:
chrisjbillington:             self.setTabWhatsThis(index, tab.whats_this)
chrisjbillington:         if tab.button_left:
chrisjbillington:             self.setTabButton(index, QTabBar.LeftSide, tab.button_left)
chrisjbillington:         if tab.button_right:
chrisjbillington:             self.setTabButton(index, QTabBar.RightSide, tab.button_right)
chrisjbillington:         if tab.icon:
chrisjbillington:             self.setTabIcon(index, tab.icon)
chrisjbillington: 
           Chris: 
           Chris: class _Limbo(_BaseDragDropTabBar):
           Chris:     """A floating TabBar to be the parent of the tab when it is not in a
           Chris:     DragDropTabBar"""
           Chris:     def __init__(self):
           Chris:         self.parent_tabwidget = QTabWidget()
chrisjbillington:         _BaseDragDropTabBar.__init__(self, self.parent_tabwidget)
           Chris:         self.parent_tabwidget.setTabBar(self)
           Chris:         self.previous_parent = None
           Chris:         self.previous_index = None
           Chris:         self.prev_active_tab = None
           Chris:         self.setWindowFlags(Qt.ToolTip)
           Chris:         self.setUsesScrollButtons(False)
chrisjbillington:         # For storing a pixmap to render during animations when we no longer
chrisjbillington:         # own the tab:
chrisjbillington:         self.pixmap = None
chrisjbillington:         self.animation_in_progress = False
            Phil: 
           Chris:     @debug.trace
           Chris:     def remove_dragged_tab(self, index):
chrisjbillington:         # Grab a pixmap of our current contents for rendering in case there is
chrisjbillington:         # animation of the tab flying back to a tab bar:
chrisjbillington:         self.pixmap = QPixmap(self.size())
chrisjbillington:         self.render(self.pixmap, QPoint(), QRegion(self.rect()))
           Chris:         result = _BaseDragDropTabBar.remove_dragged_tab(self, index)
           Chris:         self.hide()
           Chris:         return result
           Chris: 
           Chris:     @debug.trace
chrisjbillington:     def animation_starting(self):
chrisjbillington:         self.animation_in_progress = True
chrisjbillington:         self.show()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def animation_over(self):
chrisjbillington:         if self.animation_in_progress:
chrisjbillington:             self.pixmap = None
chrisjbillington:             self.animation_in_progress = False
chrisjbillington:             self.hide()
chrisjbillington: 
chrisjbillington:     @debug.trace
           Chris:     def add_dragged_tab(self, index, tab):
chrisjbillington:         self.animation_over() # cancel any animation in progress
           Chris:         result = _BaseDragDropTabBar.add_dragged_tab(self, index, tab)
           Chris:         self.show()
           Chris:         return result
           Chris: 
           Chris:     @debug.trace
           Chris:     def update_tab_index(self, index, pos):
           Chris:         """We only have one tab index, so it's not going to change."""
           Chris:         return index
           Chris: 
           Chris:     @debug.trace
           Chris:     def tabLayoutChange(self):
           Chris:         initial_size = self.size()
           Chris:         if self.count():
           Chris:             self.resize(self.tabSizeHint(0))
chrisjbillington:         self.update()
           Chris: 
           Chris:     @debug.trace
chrisjbillington:     def insertion_index_at(self, pos):
chrisjbillington:         # Only ever insert at zero:
chrisjbillington:         return 0
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def update(self):
chrisjbillington:         """Move to keep the tab grabbed by the mouse. grab_point is the
chrisjbillington:         position on the tab relative to its top left corner where it is
chrisjbillington:         grabbed by the mouse. Use current mouse position rather than that
chrisjbillington:         associated with any event triggering this, for maximal
chrisjbillington:         responsiveness."""
chrisjbillington:         if self.dragged_tab_grab_point is not None:
chrisjbillington:             self.move(QCursor.pos() - self.dragged_tab_grab_point)
chrisjbillington:         _BaseDragDropTabBar.update(self)
           Chris: 
chrisjbillington:     @debug.trace
chrisjbillington:     def paintEvent(self, event):
chrisjbillington:         if self.animation_in_progress:
chrisjbillington:             # Just draw the pixmap we've been given
chrisjbillington:             painter = QPainter(self)
chrisjbillington:             painter.drawPixmap(QPoint(), self.pixmap)
chrisjbillington:             painter.end()
chrisjbillington:         else:
chrisjbillington:             _BaseDragDropTabBar.paintEvent(self, event)
chrisjbillington: 
           Chris: 
chrisjbillington: class TabAnimation(QAbstractAnimation):
chrisjbillington: 
chrisjbillington:     # We move tabs with speed proportional to the distance from their target.
chrisjbillington: 
chrisjbillington:     # Animation timescale - has units of time (milliseconds), but can
chrisjbillington:     # be thought of as the velocity in pixels per millisecond per pixel of
chrisjbillington:     # displacement that the object is from its target.
           Chris:     tau = float(60)
chrisjbillington: 
chrisjbillington:     def __init__(self, parent):
chrisjbillington:         QAbstractAnimation.__init__(self, parent)
chrisjbillington:         # The left edges of where the tabs will be drawn. This animates over
chrisjbillington:         # time to approach the left edge as returned by parent.tabRect().
chrisjbillington:         self.positions = []
chrisjbillington:         # The position of the floating limbo tab, if it's in the process of being
chrisjbillington:         # sucked back into the tab bar that owns this animation object:
chrisjbillington:         self.limbo_position = None
chrisjbillington:         self.limbo_target_tab = None
chrisjbillington:         self.limbo = None
chrisjbillington:         self.previous_time = 0
chrisjbillington: 
           Chris:         # A flag to set to avoid recursion when we ask widgets to update:
           Chris:         self.callback_in_progress = False
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def duration(self):
chrisjbillington:         return -1
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def ensure_running(self):
           Chris:         # Don't recurse:
           Chris:         if self.callback_in_progress:
chrisjbillington:             return
chrisjbillington:         if self.state() == QAbstractAnimation.Stopped:
chrisjbillington:             self.start()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def target(self, i):
chrisjbillington:         """Return the target position we are animating toward for a tab"""
chrisjbillington:         return self.parent().tabRect(i).left()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def tabInserted(self, index):
           Chris:         self.positions.insert(index, self.parent().tabRect(index).left())
chrisjbillington:         self.ensure_running()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def tabRemoved(self, index):
chrisjbillington:         del self.positions[index]
chrisjbillington:         self.ensure_running()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def on_tab_moved(self, source_index, dest_index):
chrisjbillington:         self.positions.insert(dest_index, self.positions.pop(source_index))
chrisjbillington:         self.ensure_running()
            Phil: 
chrisjbillington:     @debug.trace
chrisjbillington:     def animate_limbo(self, limbo, index):
chrisjbillington:         """If the floating tab in limbo is being sucked back into one of our
chrisjbillington:         tabs, then we can animate that by hiding the relevant tab rect off to
chrisjbillington:         the side somwhere whilst the floating tab swoops in."""
chrisjbillington:         # floating tab doesn't own it anymore.
chrisjbillington:         self.limbo = limbo
chrisjbillington:         self.limbo.animation_starting()
chrisjbillington:         self.limbo_position = self.parent().mapFromGlobal(limbo.pos())
chrisjbillington:         self.limbo_target_tab = index
chrisjbillington:         self.ensure_running()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def updateCurrentTime(self, current_time):
chrisjbillington:         dt = current_time - self.previous_time
chrisjbillington:         self.previous_time = current_time
chrisjbillington: 
chrisjbillington:         finished = True
chrisjbillington: 
chrisjbillington:         # Move tabs toward their target:
chrisjbillington:         for i, pos in enumerate(self.positions):
chrisjbillington:             target_pos = self.target(i)
           Chris:             dx = target_pos - pos
           Chris:             # Animate while the tab is more than a pixel away from its target:
           Chris:             if abs(dx) > 1:
chrisjbillington:                 finished = False
           Chris:                 new_pos = pos + dx * dt / self.tau
           Chris:                 # Check for overshoot:
           Chris:                 if dx * (target_pos - new_pos) < 0:
chrisjbillington:                     new_pos = target_pos
chrisjbillington:                 self.positions[i] = new_pos
           Chris:             else:
           Chris:                 # Once it's close enough, snap it to the final value
           Chris:                 self.positions[i] = target_pos
chrisjbillington: 
chrisjbillington:         # move the floating tab toward its target, if applicable:
chrisjbillington:         if self.limbo is not None:
chrisjbillington:             pos_x = self.limbo_position.x()
chrisjbillington:             pos_y = self.limbo_position.y()
chrisjbillington:             target_pos = self.parent().tabRect(self.limbo_target_tab).topLeft()
chrisjbillington:             target_pos_x = target_pos.x()
chrisjbillington:             target_pos_y = target_pos.y()
           Chris:             dx = target_pos_x - pos_x
           Chris:             dy = target_pos_y - pos_y 
chrisjbillington: 
           Chris:             # Animate while the floating tab is more 15  pixels of taxicab-
           Chris:             # metric distance away from its target:
           Chris:             if abs(dx) + abs(dy) > 15:
chrisjbillington: 
chrisjbillington:                 finished = False
chrisjbillington: 
           Chris:                 new_pos_x = pos_x + dx * dt / self.tau
           Chris:                 new_pos_y = pos_y + dy * dt / self.tau
chrisjbillington: 
           Chris:                 # Check for overshoot:
           Chris:                 if dx * (target_pos_x - new_pos_x) < 0:
chrisjbillington:                     new_pos_x = target_pos_x
           Chris:                 if dy * (target_pos_y - new_pos_y) < 0:
chrisjbillington:                     new_pos_y = target_pos_y
chrisjbillington: 
chrisjbillington:                 self.limbo_position = QPoint(new_pos_x, new_pos_y)
chrisjbillington:             else:
chrisjbillington:                 self.limbo.animation_over()
chrisjbillington:                 self.limbo = None
chrisjbillington:                 self.limbo_position = None
chrisjbillington:                 self.limbo_target_tab = None
chrisjbillington:         if finished:
chrisjbillington:             self.previous_time = 0
chrisjbillington:             self.stop()
chrisjbillington:         # Update the parent whilst blocking signals back to us to prevent
chrisjbillington:         # recursion:
           Chris:         self.callback_in_progress = True
chrisjbillington:         if self.limbo is not None:
           Chris:             self.limbo.move(self.parent().mapToGlobal(self.limbo_position))
chrisjbillington:             self.limbo.update()
chrisjbillington:         self.parent().update()
           Chris:         self.callback_in_progress = False
chrisjbillington: 
chrisjbillington: 
           Chris: class DragDropTabBar(_BaseDragDropTabBar):
           Chris: 
chrisjbillington:     # Keeping track of which tab widgets are in each group (that is, share a
chrisjbillington:     # common group_id):
           Chris:     tab_widgets = defaultdict(weakref.WeakSet)
chrisjbillington: 
chrisjbillington:     # Whether or not a drag is in progress. It is important to have this in
chrisjbillington:     # addition to the below information so that we can set it to False when a
chrisjbillington:     # drag is about to be cancelled, even though we are not going to set the
chrisjbillington:     # below variables to None until after some processing. During that
chrisjbillington:     # processing, re-entrant event processing can see that there is no drag in
chrisjbillington:     # progress even though the below variables are still not None, and know
chrisjbillington:     # not to act as if there is a drag in progress (since the drag is in the
chrisjbillington:     # process of being cancelled).
chrisjbillington:     _drag_in_progress = False
chrisjbillington: 
chrisjbillington:     # The index and parent TabBar of the dragged tab, or None if no drag is in
chrisjbillington:     # progress. Shared by all instances:
chrisjbillington:     _dragged_tab_index = None
chrisjbillington:     _dragged_tab_parent = None
chrisjbillington: 
chrisjbillington:     # A TabWidget to hold the tab being dragged. Shared by all instances, but
chrisjbillington:     # not instantiated until first instance is created, since there may not be
chrisjbillington:     # a QApplication at import time.
           Chris:     limbo = None
           Chris: 
chrisjbillington:     SCROLL_BUTTON_WIDTH = 15
chrisjbillington:     FLUSH_GAP = 5
chrisjbillington:     SCROLL_BUTTON_GAP = 2
chrisjbillington: 
           Chris:     def __init__(self, parent, group_id):
chrisjbillington:         _BaseDragDropTabBar.__init__(self, parent)
           Chris: 
           Chris:         self.group_id = group_id
           Chris:         self.tab_widgets[group_id].add(self.parent())
           Chris: 
           Chris:         self.prev_active_tab = None
           Chris:         if self.limbo is None:
           Chris:             # One Limbo object for all instances:
           Chris:             self.__class__.limbo = _Limbo()
           Chris: 
chrisjbillington:         self.animation = TabAnimation(self)
chrisjbillington:         self.tabMoved.connect(self.animation.on_tab_moved)
chrisjbillington:         self.scroll_offset = 0
chrisjbillington:         self.left_scrollbutton = QToolButton(self)
chrisjbillington:         self.right_scrollbutton = QToolButton(self)
chrisjbillington:         self.left_scrollbutton.setArrowType(Qt.LeftArrow)
chrisjbillington:         self.right_scrollbutton.setArrowType(Qt.RightArrow)
chrisjbillington:         self.left_scrollbutton.setAutoRepeat(True)
chrisjbillington:         self.right_scrollbutton.setAutoRepeat(True)
chrisjbillington:         self.left_scrollbutton.clicked.connect(
chrisjbillington:            lambda: self.on_scroll_button_clicked(self.left_scrollbutton))
chrisjbillington:         self.right_scrollbutton.clicked.connect(
chrisjbillington:             lambda: self.on_scroll_button_clicked(self.right_scrollbutton))
chrisjbillington:         self.currentChanged.connect(self.ensure_visible)
chrisjbillington:         self.left_scrollbutton.hide()
chrisjbillington:         self.right_scrollbutton.hide()
chrisjbillington:         _BaseDragDropTabBar.setUsesScrollButtons(self, False)
chrisjbillington:         self.setElideMode(Qt.ElideRight)
chrisjbillington:         self.uses_scrollbuttons = False
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def setUsesScrollButtons(self, uses_scrollbuttons):
chrisjbillington:         self.uses_scrollbuttons = uses_scrollbuttons
chrisjbillington:         if uses_scrollbuttons:
chrisjbillington:             # No elision if we are scrollable:
chrisjbillington:             self.setElideMode(Qt.ElideNone)
chrisjbillington:         else:
chrisjbillington:             self.setElideMode(Qt.ElideRight)
chrisjbillington:         self.update_scroll_button_state()
chrisjbillington:         self.update()
chrisjbillington: 
chrisjbillington:     def _leftflush(self):
chrisjbillington:         """The position a tab's left edge should be when it is otherwise' made
chrisjbillington:         flush with the left of the tabBar"""
chrisjbillington:         return self.FLUSH_GAP
chrisjbillington: 
chrisjbillington:     def _rightflush(self):
chrisjbillington:         """The position a tab's right edge should be when it is otherwise made
chrisjbillington:         flush with the right edge of the tabBar. Includes space for the scroll
chrisjbillington:         buttons"""
chrisjbillington:         return (self.width() - 2 * self.SCROLL_BUTTON_WIDTH - 
chrisjbillington:                 self.FLUSH_GAP - self.SCROLL_BUTTON_GAP)
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def ensure_visible(self, index, prefer_left=True):
chrisjbillington:         # Ensure the tab is visible if we're using scrollbuttons:
chrisjbillington:         if index == -1 or not self.uses_scrollbuttons:
chrisjbillington:             return
chrisjbillington:         left_protruding_width = -self.tabRect(index).left() + self._leftflush()
chrisjbillington:         right_protruding_width = self.tabRect(index).right() - self._rightflush()
chrisjbillington:         if left_protruding_width > 0 and not right_protruding_width > 0:
chrisjbillington:             self.scroll_offset -= left_protruding_width
chrisjbillington:         elif right_protruding_width > 0 and not left_protruding_width > 0:
chrisjbillington:             self.scroll_offset += right_protruding_width
chrisjbillington:         elif left_protruding_width > 0 and right_protruding_width > 0:
chrisjbillington:             # Both edges are out of bounds. Which way do we move?
chrisjbillington:             if prefer_left:
chrisjbillington:                 self.scroll_offset -= left_protruding_width
chrisjbillington:             else:
chrisjbillington:                 self.scroll_offset += right_protruding_width
chrisjbillington: 
chrisjbillington:         self.update_scroll_button_state()
chrisjbillington:         self.update()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def sizeHint(self):
chrisjbillington:         hint = _BaseDragDropTabBar.sizeHint(self)
chrisjbillington:         hint.setWidth(self.parent().width())
chrisjbillington:         return hint
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def minimumSizeHint(self):
chrisjbillington:         hint = _BaseDragDropTabBar.minimumSizeHint(self)
chrisjbillington:         if self.uses_scrollbuttons:
chrisjbillington:             # No minimum if we are scrollable
chrisjbillington:             hint.setWidth(0)
chrisjbillington:         return hint
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def update(self):
chrisjbillington:         _BaseDragDropTabBar.update(self)
chrisjbillington:         self.animation.ensure_running()
chrisjbillington: 
chrisjbillington:     # Setters and getters for the class variables:
chrisjbillington:     @property
chrisjbillington:     def drag_in_progress(self):
chrisjbillington:         return self._drag_in_progress
chrisjbillington: 
chrisjbillington:     @drag_in_progress.setter
chrisjbillington:     def drag_in_progress(self, value):
chrisjbillington:         self.__class__._drag_in_progress = value
chrisjbillington: 
chrisjbillington:     @property
chrisjbillington:     def dragged_tab_index(self):
chrisjbillington:         return self._dragged_tab_index
chrisjbillington: 
chrisjbillington:     @dragged_tab_index.setter
chrisjbillington:     def dragged_tab_index(self, value):
chrisjbillington:         self.__class__._dragged_tab_index = value
chrisjbillington: 
chrisjbillington:     @property
chrisjbillington:     def dragged_tab_parent(self):
chrisjbillington:         return self._dragged_tab_parent
chrisjbillington: 
chrisjbillington:     @dragged_tab_parent.setter
chrisjbillington:     def dragged_tab_parent(self, value):
chrisjbillington:         self.__class__._dragged_tab_parent = value
chrisjbillington: 
           Chris:     @debug.trace
chrisjbillington:     def set_tab_parent(self, dest, index=None, pos=None):
chrisjbillington:         """Move the tab to the given parent DragDropTabBar if it's not already
chrisjbillington:         there. index=None will determined the insertion index from the
chrisjbillington:         given mouse position."""
chrisjbillington:         if index is None:
chrisjbillington:             assert pos is not None
chrisjbillington:             index = dest.insertion_index_at(self.mapToGlobal(pos -
chrisjbillington:                                                              self.dragged_tab_grab_point))
chrisjbillington:         if self.dragged_tab_parent != dest:
chrisjbillington:             tab = self.dragged_tab_parent.remove_dragged_tab(self.dragged_tab_index)
chrisjbillington:             dest.add_dragged_tab(index, tab)
           Chris:             if dest is self.limbo:
           Chris:                 self.limbo.previous_parent = self.dragged_tab_parent
           Chris:                 self.limbo.previous_index = self.dragged_tab_index
chrisjbillington:             self.dragged_tab_parent = dest
chrisjbillington:             self.dragged_tab_index = index
chrisjbillington:              # Tell parent to redraw to reflect the new position:
chrisjbillington:             dest.update()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def insertion_index_at(self, pos):
chrisjbillington:         """Compute at which index the tab with given upper left corner
chrisjbillington:         position in global coordinates should be inserted into the tabBar."""
chrisjbillington:         left = self.mapFromGlobal(pos).x()
chrisjbillington:         for other in range(self.count()):
chrisjbillington:             other_midpoint = self.tabRect(other).center().x()
chrisjbillington:             if other_midpoint > left:
chrisjbillington:                 return other
chrisjbillington:         return self.count()
chrisjbillington: 
           Chris:     @debug.trace
chrisjbillington:     def update_dragged_tab_animation_pos(self, pos):
chrisjbillington:         # update the animation position of the dragged tab so that it can be
chrisjbillington:         # correctly animated once released.
chrisjbillington:         assert self.dragged_tab_parent is self
chrisjbillington:         pinned_rect = self.tabRect(self.dragged_tab_index)
chrisjbillington:         pinned_rect.translate(pos - self.dragged_tab_grab_point - pinned_rect.topLeft())
chrisjbillington:         left = pinned_rect.left()
chrisjbillington:         self.animation.positions[self.dragged_tab_index] = left
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def update_tab_index(self, index, pos):
chrisjbillington:         """Check if the tab at the given index, being dragged by the mouse at
chrisjbillington:         the given position, needs to be moved. Move it and return the new
chrisjbillington:         index."""
chrisjbillington: 
chrisjbillington:         # If the tab rect were pinned to the mouse at the point it was
chrisjbillington:         # grabbed, where would it be?
chrisjbillington:         pinned_rect = self.tabRect(index)
chrisjbillington:         pinned_rect.translate(pos-self.dragged_tab_grab_point - pinned_rect.topLeft())
chrisjbillington:         left = pinned_rect.left()
chrisjbillington:         self.animation.positions[index] = left
chrisjbillington:         right = pinned_rect.right()
chrisjbillington: 
chrisjbillington:         move_target = None
chrisjbillington: 
chrisjbillington:         for other in range(self.count()):
chrisjbillington:             other_midpoint = self.tabRect(other).center().x()
chrisjbillington:             if other < index and left < other_midpoint:
chrisjbillington:                 move_target = other
chrisjbillington:                 # break to move as far left as warranted:
chrisjbillington:                 break
chrisjbillington:             elif other > index and right > other_midpoint:
chrisjbillington:                 move_target = other
chrisjbillington:                 # Don't break because we might move further right
chrisjbillington:         if move_target is not None:
chrisjbillington:             self.moveTab(index, move_target)
chrisjbillington: 
chrisjbillington:             # Workaround for bug in PyQt4 - the tabWdiget does not update its
chrisjbillington:             # child StackedWidget's current widget when it gets a tabMoved
chrisjbillington:             # signal durint a mouseMove event:
chrisjbillington:             if self.currentIndex() == move_target:
chrisjbillington:                 stack = self.parent().findChild(QStackedWidget, 'qt_tabwidget_stackedwidget')
chrisjbillington:                 stack.setCurrentWidget(self.parent().widget(move_target))
chrisjbillington: 
chrisjbillington:             return move_target
chrisjbillington:         return index
chrisjbillington: 
           Chris:     @debug.trace
chrisjbillington:     def widgetAt(self, pos):
chrisjbillington:         """If the given position is over a DragDropTabBar belonging to the
chrisjbillington:         current group, return the DragDropTabBar. If it is over a TabWidget in
chrisjbillington:         the same group that has no tabs, or the dragged tab as its only tab,
chrisjbillington:         return its DragDropTabBar. Otherwise return the limbo object."""
chrisjbillington:         for tab_widget in self.tab_widgets[self.group_id]:
chrisjbillington:             count = tab_widget.tabBar().count()
            Phil:             
chrisjbillington:             if tab_widget.accept_drops_bar_only:
chrisjbillington:                 if count == 0:
chrisjbillington:                     widget = tab_widget
chrisjbillington:                     rect = widget.rect()
chrisjbillington:                     # The region at the top of the TabWidget equal to the height
chrisjbillington:                     # of a tab:
chrisjbillington:                     height = self.dragged_tab_parent.tabRect(self.dragged_tab_index).height()
chrisjbillington:                     rect.setHeight(height)
chrisjbillington:                 else:
chrisjbillington:                     widget = tab_widget.tabBar()
chrisjbillington:                     rect = widget.rect()
chrisjbillington:                     # Include the whole horizontal part of the tabBar:
chrisjbillington:                     rect.setLeft(widget.parent().rect().left())
chrisjbillington:                     rect.setRight(widget.parent().rect().right())
chrisjbillington:                     # If we're leaving, add a buffer region so that we don't leave
chrisjbillington:                     # until we have passed a certain distance:
chrisjbillington:                     if self.drag_in_progress and self.dragged_tab_parent is widget:
chrisjbillington:                         rect.setLeft(rect.left() - 10)
chrisjbillington:                         rect.setRight(rect.right() + 10)
chrisjbillington:                     # No buffer in the vertical directions, but make the tab bars
chrisjbillington:                     # a slightly bigger target for both coming and going:
chrisjbillington:                     rect.setTop(rect.top() - 10)
chrisjbillington:                     rect.setBottom(rect.bottom() + 10)
chrisjbillington: 
chrisjbillington:             else:
chrisjbillington:                 widget = tab_widget
chrisjbillington:                 rect = widget.rect()
chrisjbillington:                 # If we're leaving, add a buffer region so that we don't leave
chrisjbillington:                 # until we have passed a certain distance:
chrisjbillington:                 if self.drag_in_progress and self.dragged_tab_parent is widget:
chrisjbillington:                     rect.setLeft(rect.left() - 10)
chrisjbillington:                     rect.setRight(rect.right() + 10)
chrisjbillington:                     rect.setTop(rect.top() - 10)
chrisjbillington:                     rect.setBottom(rect.bottom() + 10)
chrisjbillington: 
chrisjbillington:             other_local_pos = widget.mapFromGlobal(self.mapToGlobal(pos))
chrisjbillington:             if rect.contains(other_local_pos):
chrisjbillington:                 return tab_widget.tabBar()
chrisjbillington:         return self.limbo
chrisjbillington: 
           Chris:     @debug.trace
chrisjbillington:     def tabRect(self, index):
chrisjbillington:         rect = _BaseDragDropTabBar.tabRect(self, index)
chrisjbillington:         rect.translate(-self.scroll_offset, 0)
chrisjbillington:         return rect
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def tabAt(self, pos):
chrisjbillington:         for i in range(self.count()):
chrisjbillington:             if self.tabRect(i).contains(pos):
chrisjbillington:                 return i
chrisjbillington:         return -1
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def mousePressEvent(self, event):
chrisjbillington:         """Take note of the tab that was clicked so it can be dragged on
chrisjbillington:         mouseMoveEvents"""
chrisjbillington:         if event.button() != Qt.LeftButton:
chrisjbillington:             return
chrisjbillington:         event.accept()
chrisjbillington:         index = self.tabAt(event.pos())
chrisjbillington:         if index == -1:
chrisjbillington:             return
chrisjbillington:         self.setCurrentIndex(index)
chrisjbillington:         self.ensure_visible(index)
chrisjbillington:         self.drag_in_progress = True
chrisjbillington:         # Ensure we get all mouse events until the mouse is released:
chrisjbillington:         self.grabMouse()
chrisjbillington:         self.dragged_tab_index = index
chrisjbillington:         self.dragged_tab_parent = self
chrisjbillington:         self.dragged_tab_grab_point = (event.pos()
chrisjbillington:                                        - self.tabRect(self.dragged_tab_index).topLeft())
            Phil:         
           Chris:     @debug.trace
chrisjbillington:     def mouseMoveEvent(self, event):
chrisjbillington:         """Update the parent of the tab to be the DragDropTabWidget under the
chrisjbillington:         mouse, if any, otherwise update it to the limbo object. Update the
chrisjbillington:         position of the tab in the widget it's in."""
chrisjbillington:         _BaseDragDropTabBar.mouseMoveEvent(self, event)
           Chris:         if not self.drag_in_progress:
chrisjbillington:             self.update()
chrisjbillington:             return
chrisjbillington:         event.accept()
chrisjbillington:         if self.group_id is not None:
chrisjbillington:             widget = self.widgetAt(event.pos())
chrisjbillington:             self.set_tab_parent(widget, pos=event.pos())
chrisjbillington:             other_local_pos = widget.mapFromGlobal(self.mapToGlobal(event.pos()))
chrisjbillington:             self.dragged_tab_index = widget.update_tab_index(self.dragged_tab_index,
chrisjbillington:                                                              other_local_pos)
chrisjbillington:             if self.dragged_tab_parent is not self.limbo:
chrisjbillington:                 self.dragged_tab_parent.update_dragged_tab_animation_pos(other_local_pos)
chrisjbillington:             widget.update()
chrisjbillington: 
           Chris:     @debug.trace
chrisjbillington:     def mouseReleaseEvent(self, event):
chrisjbillington:         """Same as mouseMove event - update the DragDropTabWidget and position of
chrisjbillington:         the tab to the current mouse position. Unless the mouse position is
chrisjbillington:         outside of any widgets at the time of mouse release, in which case
chrisjbillington:         move the tab to its last known parent and position."""
chrisjbillington:         _BaseDragDropTabBar.mouseReleaseEvent(self, event)
chrisjbillington:         if not self.drag_in_progress or event.button() != Qt.LeftButton:
chrisjbillington:             return
chrisjbillington:         event.accept()
           Chris:         # Cancel the drag:
           Chris:         self.drag_in_progress = False
chrisjbillington:         widget = self.widgetAt(event.pos())
chrisjbillington:         # Tell Qt to no longer send all mouse events to this widget:
chrisjbillington:         self.releaseMouse()
chrisjbillington:         # If the tab and the mouse are both in limbo, then put the tab
chrisjbillington:         # back at its last known place:
           Chris:         if widget is self.limbo and self.dragged_tab_parent is self.limbo:
chrisjbillington:             index = self.limbo.previous_index
chrisjbillington:             self.set_tab_parent(self.limbo.previous_parent, index)
chrisjbillington:             self.limbo.previous_parent.animation.animate_limbo(self.limbo, index)
chrisjbillington:         # But if we're above a tab bar that it's not already in, put it there.
chrisjbillington:         # Otherwise leave it where it is (don't move it into limbo)
chrisjbillington:         elif widget is not self.limbo and widget is not self.dragged_tab_parent:
chrisjbillington:             self.set_tab_parent(widget, pos=event.pos())
            Phil:         else:
chrisjbillington:             # It's already in this widget. Store the position of the tab so it
chrisjbillington:             # can animate:
chrisjbillington:             other_local_pos = self.dragged_tab_parent.mapFromGlobal(
chrisjbillington:                                   self.mapToGlobal(event.pos()))
chrisjbillington:             self.dragged_tab_parent.update_dragged_tab_animation_pos(other_local_pos)
chrisjbillington: 
chrisjbillington:         # Tell the parent to redraw the tabs:
chrisjbillington:         self.dragged_tab_parent.update()
chrisjbillington: 
chrisjbillington:         # Clear the variables about which tab is being dragged:
chrisjbillington:         self.dragged_tab_index = None
chrisjbillington:         self.dragged_tab_parent = None
chrisjbillington:         self.dragged_tab_grab_point = None
            Phil: 
chrisjbillington:     @debug.trace
chrisjbillington:     def is_dragged_tab(self, index):
chrisjbillington:         """Return whether the tab at the given index is currently being dragged"""
chrisjbillington:         return (self.drag_in_progress
chrisjbillington:                 and self.dragged_tab_parent is self
chrisjbillington:                 and self.dragged_tab_index == index)
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def tabInserted(self, index):
chrisjbillington:         _BaseDragDropTabBar.tabInserted(self, index)
chrisjbillington:         self.animation.tabInserted(index)
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def tabRemoved(self, index):
chrisjbillington:         _BaseDragDropTabBar.tabRemoved(self, index)
chrisjbillington:         self.animation.tabRemoved(index)
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def tabLayoutChange(self):
chrisjbillington:         _BaseDragDropTabBar.tabLayoutChange(self)
chrisjbillington:         self.animation.ensure_running()
chrisjbillington:         self.update_scroll_button_state()
chrisjbillington:         self.ensure_visible(self.currentIndex())
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def update_scroll_button_state(self):
chrisjbillington:         if not self.uses_scrollbuttons:
chrisjbillington:             self.left_scrollbutton.hide()
chrisjbillington:             self.right_scrollbutton.hide()
chrisjbillington:             return
chrisjbillington:         all_tabs_right_edge = self.tabRect(self.count() - 1).right()
chrisjbillington:         all_tabs_left_edge = self.tabRect(0).left()
chrisjbillington:         total_width_of_all_tabs =  all_tabs_right_edge - all_tabs_left_edge
chrisjbillington:         min_scroll_offset = 0
chrisjbillington:         max_scroll_offset = max(0, total_width_of_all_tabs - 
chrisjbillington:                                    self.parent().width() + 
chrisjbillington:                                    2 * self.SCROLL_BUTTON_WIDTH + 
chrisjbillington:                                    2 * self.SCROLL_BUTTON_GAP)
chrisjbillington:         if self.scroll_offset <= min_scroll_offset:
chrisjbillington:             self.scroll_offset = min_scroll_offset
chrisjbillington:             self.left_scrollbutton.setEnabled(False)
chrisjbillington:         else:
chrisjbillington:             self.left_scrollbutton.setEnabled(True)
chrisjbillington:         if self.scroll_offset >= max_scroll_offset:
chrisjbillington:             self.scroll_offset = max_scroll_offset
chrisjbillington:             self.right_scrollbutton.setEnabled(False)
chrisjbillington:         else:
chrisjbillington:             self.right_scrollbutton.setEnabled(True)
chrisjbillington:         self.left_scrollbutton.resize(self.SCROLL_BUTTON_WIDTH,
chrisjbillington:                                           self.height() - 6)
chrisjbillington:         self.right_scrollbutton.resize(self.SCROLL_BUTTON_WIDTH,
chrisjbillington:                                        self.height() - 6)
chrisjbillington:         self.left_scrollbutton.move(self.parent().width() - 
chrisjbillington:                                     2*self.SCROLL_BUTTON_WIDTH, 3)
chrisjbillington:         self.right_scrollbutton.move(self.parent().width() - 
chrisjbillington:                                      self.SCROLL_BUTTON_WIDTH, 3)
chrisjbillington: 
chrisjbillington:         if self.left_scrollbutton.isEnabled() or self.right_scrollbutton.isEnabled():
chrisjbillington:             self.left_scrollbutton.show()
chrisjbillington:             self.right_scrollbutton.show()
chrisjbillington:         else:
chrisjbillington:             self.left_scrollbutton.hide()
chrisjbillington:             self.right_scrollbutton.hide()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def on_scroll_button_clicked(self, button):
chrisjbillington:         if button is self.left_scrollbutton:
chrisjbillington:             for i in range(self.count() - 1, -1, -1):
chrisjbillington:                 if self.tabRect(i).left() < self._leftflush():
chrisjbillington:                     self.ensure_visible(i, prefer_left=True)
chrisjbillington:                     break
chrisjbillington:         elif button is self.right_scrollbutton:
chrisjbillington:             for i in range(self.count()):
chrisjbillington:                 if self.tabRect(i).right() > self._rightflush():
chrisjbillington:                     self.ensure_visible(i, prefer_left=False)
chrisjbillington:                     break
chrisjbillington:         self.update_scroll_button_state()
chrisjbillington:         self.update()
            Phil: 
chrisjbillington:     @debug.trace
chrisjbillington:     def paint_tab(self, index, painter, option):
chrisjbillington:         # Don't paint the tab if it's the floating tab's target whilst it is
chrisjbillington:         # animated flying in:
chrisjbillington:         if index == self.animation.limbo_target_tab:
chrisjbillington:             return
chrisjbillington:         painter.save()
chrisjbillington:         if self.is_dragged_tab(index):
chrisjbillington:             # The dragged tab is pinned to the mouse:
chrisjbillington:             xpos = self.mapFromGlobal(QCursor.pos()).x() - self.dragged_tab_grab_point.x()
chrisjbillington:         else:
chrisjbillington:             # Other tabs are at their current animated position:
           Chris:             xpos = self.animation.positions[index]
chrisjbillington:         tabrect = self.tabRect(index)
chrisjbillington:         painter.translate(xpos - tabrect.left() - self.scroll_offset, 0)
chrisjbillington:         self.initStyleOption(option, index)
chrisjbillington:         painter.drawControl(QStyle.CE_TabBarTab, option)
chrisjbillington:         painter.restore()
chrisjbillington: 
chrisjbillington:     @debug.trace
chrisjbillington:     def paintEvent(self, event):
chrisjbillington:         painter = QStylePainter(self)
chrisjbillington:         option = QStyleOptionTab()
chrisjbillington:         # Draw in reverse order so if there is overlap, tabs to the left are
chrisjbillington:         # on top:
chrisjbillington:         for index in range(self.count() - 1, -1, -1):
chrisjbillington:             if self.currentIndex() == index:
chrisjbillington:                 # Draw the active tab last so it's on top:
chrisjbillington:                 continue
chrisjbillington:             self.paint_tab(index, painter, option)
chrisjbillington:         if self.currentIndex() != -1:
chrisjbillington:             self.paint_tab(self.currentIndex(), painter, option)
chrisjbillington:         # Erase the region where the buttons need to be:
chrisjbillington:         if self.left_scrollbutton.isEnabled() or self.right_scrollbutton.isEnabled():
chrisjbillington:             rect = self.rect()
chrisjbillington:             rect.moveLeft(self.width() - 2 * self.SCROLL_BUTTON_WIDTH - 
chrisjbillington:                           self.SCROLL_BUTTON_GAP)
chrisjbillington:             rect.moveBottom(rect.bottom() - 2)
chrisjbillington:             painter.eraseRect(rect)
chrisjbillington:         painter.end()
chrisjbillington: 
            Phil: 
            Phil: class DragDropTabWidget(QTabWidget):
chrisjbillington:     """A tab widget that supports dragging and dropping of tabs between tab
chrisjbillington:     widgets that share a group_id. a group_id of None indicates that tab
chrisjbillington:     dragging is disabled."""
           Chris:     def __init__(self, group_id=None, accept_drops_bar_only=False):
            Phil:         QTabWidget.__init__(self)
chrisjbillington:         self.setTabBar(DragDropTabBar(self, group_id))
chrisjbillington:         self.tabBar().setExpanding(False)
chrisjbillington:         self.tab_bar = self.tabBar() # Backward compatibility for BLACS
chrisjbillington: 
chrisjbillington:         # Whether to accept drops only on the tab bar at the top,
chrisjbillington:         # as opposed to accepting them anywhere on the tabWidget:
chrisjbillington:         self.accept_drops_bar_only = accept_drops_bar_only
chrisjbillington: 
chrisjbillington:         # Use scroll buttons by default:
chrisjbillington:         self.setUsesScrollButtons(True)
chrisjbillington: 
chrisjbillington:     def setUsesScrollButtons(self, uses_scrollbuttons):
chrisjbillington:         self.tabBar().setUsesScrollButtons(uses_scrollbuttons)
chrisjbillington: 
chrisjbillington:     def setElideMode(self, mode):
chrisjbillington:         # Ignored. Elision is set entirely depending on whether scroll buttons
chrisjbillington:         # are used (ElideRight if they are not, no elision if they are)
chrisjbillington:         pass
chrisjbillington: 
            Phil: if __name__ == '__main__':    
            Phil:     class ViewPort(object):
            Phil:         def __init__(self, id, container_layout,i):
        pstarkey:             #ui = UiLoader().load('viewport.ui')
            Phil:             self.tab_widget = DragDropTabWidget(id)
            Phil:             container_layout.addWidget(self.tab_widget)
           Chris:             self.tab_widget.addTab(QLabel("foo %d"%i), 'foo %d 1' % i)
           Chris:             self.tab_widget.addTab(QLabel("bar %d"%i), 'bar bar bar %d 1' % i)
     janwerkmann:             self.tab_widget.tabBar().setTabTextColor(0, QColor(255, 0, 0))
     janwerkmann:             self.tab_widget.tabBar().setTabTextColor(1, QColor(0, 255, 0))
           Chris: 
           Chris:             self.tab_widget.tabBar().setTabIcon(1, lyse_icon)
           Chris:             self.tab_widget.tabBar().setTabIcon(0, runmanager_icon)
           Chris: 
           Chris: 
            Phil:     class RunViewer(object):
            Phil:         def __init__(self):
            Phil:             # Load the gui:
            Phil:             self.moving_tab = None
            Phil:             self.moving_tab_index = -1
            Phil:             
        pstarkey:             self.window = QWidget()
        pstarkey:             container = QVBoxLayout(self.window)
        pstarkey:             
            Phil:             self.viewports = []
        pstarkey:             for i in range(3):               
        pstarkey:                 viewport = ViewPort(3,container,i)
            Phil:                 self.viewports.append(viewport)
        pstarkey:             #button = QPushButton("launch iPython")
        pstarkey:             #button.clicked.connect(embed)
        pstarkey:             #ui.verticalLayout_6.addWidget(button)
            Phil:             
            Phil:             self.window.show()
            Phil:         
            Phil: 
            Phil:     qapplication = QApplication([])
           Chris: 
           Chris:     import qtutils.icons
           Chris: 
           Chris:     lyse_icon = QIcon(':/qtutils/custom/lyse')
           Chris:     runmanager_icon = QIcon(':/qtutils/custom/runmanager')
           Chris: 
            Phil:     app = RunViewer()
           Chris:     
           Chris:     timer = QTimer()
           Chris:     timer.start(500)
           Chris: 
           Chris:     import time
            Phil: 
           Chris:     def change_text():
           Chris:         if DragDropTabBar.limbo is not None:
           Chris:             limbo = DragDropTabBar.limbo
           Chris:             if limbo.count():
           Chris:                 tab_text = limbo.tabText(0)
           Chris:                 split = str(tab_text).split()
           Chris:                 text = ' '.join(split[:-1])
           Chris:                 number = int(split[-1])
           Chris:                 number = number + 1
           Chris:                 limbo.setTabText(0, text + ' ' + str(number))
           Chris:                 if number % 2:
           Chris:                     limbo.setTabIcon(0, lyse_icon)
           Chris:                 else:
           Chris:                     limbo.setTabIcon(0, runmanager_icon)
            Phil: 
           Chris:     timer.timeout.connect(change_text)
chrisjbillington:     qapplication.exec_()
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
           Chris: import sys
     janwerkmann: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
           Chris: 
           Chris: from qtutils import *
           Chris: 
chrisjbillington: 
chrisjbillington: ELLIPSIS = u'\u2026'
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ElideScrollArea(QScrollArea):
chrisjbillington:     """A ScrollArea for containing a label that we want to elide. The elision
chrisjbillington:     is attained by just letting the text we don't want to see be scrolled off
chrisjbillington:     to the side with the scrollbars hidden."""
           Chris:     def __init__(self, *args, **kwargs):
chrisjbillington:         QScrollArea.__init__(self, *args, **kwargs)
           Chris:         self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
           Chris:         self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
chrisjbillington:         self.setFrameStyle(QFrame.NoFrame)
           Chris:         self.setStyleSheet("background-color:transparent;")
           Chris:         self.setElideMode(Qt.ElideNone)
chrisjbillington:         self.setWidgetResizable(True)
           Chris: 
chrisjbillington:     def event(self, event):
chrisjbillington:         if event.type() == QEvent.LayoutRequest:
chrisjbillington:             self.updateGeometry()
chrisjbillington:         return QScrollArea.event(self, event)
chrisjbillington: 
chrisjbillington:     def setElideMode(self, elideMode):
chrisjbillington:         if not isinstance(elideMode, Qt.TextElideMode):
chrisjbillington:             raise TypeError("Argument must be of type Qt.TextElideMode")
chrisjbillington:         if elideMode == Qt.ElideMiddle:
chrisjbillington:             raise NotImplementedError("The hack being used to elidetext does not work for ElideMiddle")
chrisjbillington: 
chrisjbillington:         self._elideMode = elideMode
chrisjbillington:         
chrisjbillington:     def minimumSizeHint(self):
chrisjbillington:         if self.widget is None or self._elideMode == Qt.ElideNone:
chrisjbillington:             return QScrollArea.minimumSizeHint(self)
chrisjbillington:         else:
chrisjbillington:             actual_minimum_sizehint = self.widget().minimumSizeHint()
chrisjbillington:             return QSize(0, actual_minimum_sizehint.height())
chrisjbillington: 
chrisjbillington:     def sizeHint(self):
chrisjbillington:         if self.widget is None or self._elideMode == Qt.ElideNone:
chrisjbillington:             return QScrollArea.sizeHint(self)
chrisjbillington:         else:
chrisjbillington:             actual_sizehint = self.widget().sizeHint()
chrisjbillington:             return QSize(0, actual_sizehint.height())
chrisjbillington: 
chrisjbillington:     def setWidget(self, widget):
chrisjbillington:         QScrollArea.setWidget(self, widget)
chrisjbillington:         self.setSizePolicy(QSizePolicy(self.sizePolicy().horizontalPolicy(), widget.sizePolicy().verticalPolicy()))
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ElidedLabelContainer(QWidget):
chrisjbillington:     """A QWidget to contain a QLabel with a single line of (possibly rich)
chrisjbillington:     text that we want to elide. The elision is obtained by putting the QLabel
chrisjbillington:     in a QScrollArea and having the QScrollarea only show the part of the text
chrisjbillington:     we want to see. An extra label with the elision indication "..." is also
chrisjbillington:     inserted next to the QScrollArea.
chrisjbillington:     """
chrisjbillington:     def __init__(self, label):
chrisjbillington:         QWidget.__init__(self)
chrisjbillington:         if label.wordWrap():
chrisjbillington:             raise ValueError("Cannot elide label with word wrapping enabled")
chrisjbillington:         self.label = label
chrisjbillington:         self.layout = QHBoxLayout(self)
chrisjbillington:         self.layout.setSpacing(0)
chrisjbillington:         self.layout.setContentsMargins(0,0,0,0)
chrisjbillington:         self.ellipsis_label = QLabel(ELLIPSIS)
chrisjbillington:         self.scroll_area = ElideScrollArea()
chrisjbillington:         self.scroll_area.setWidget(self.label)
chrisjbillington:         self.setElideMode(Qt.ElideNone)
chrisjbillington:         self.setSizePolicy(label.sizePolicy())
chrisjbillington:         self.scroll_area.horizontalScrollBar().rangeChanged.connect(self.update_elide_widget)
chrisjbillington:         # self.scroll_area.horizontalScrollBar().valueChanged.connect(self.update_elide_widget)
chrisjbillington:         self.update_elide_widget()
           Chris: 
           Chris:     def event(self, event):
           Chris:         if event.type() == QEvent.ToolTip:
           Chris:             self.setToolTip(self.label.text())
           Chris:         return QWidget.event(self, event)
           Chris: 
           Chris:     def elideMode(self):
           Chris:         return self._elideMode
           Chris: 
           Chris:     def setElideMode(self, elideMode):
           Chris:         if not isinstance(elideMode, Qt.TextElideMode):
           Chris:             raise TypeError("Argument must be of type Qt.TextElideMode")
           Chris:         if elideMode == Qt.ElideMiddle:
           Chris:             raise NotImplementedError("The hack being used to elidetext does not work for ElideMiddle")
chrisjbillington: 
           Chris:         self._elideMode = elideMode
chrisjbillington:         self.scroll_area.setElideMode(self._elideMode)
           Chris: 
chrisjbillington:         if self.layout.count():
chrisjbillington:             self.layout.removeWidget(self.ellipsis_label)
chrisjbillington:             self.layout.removeWidget(self.scroll_area)
chrisjbillington:         if self._elideMode == Qt.ElideLeft:
chrisjbillington:             self.layout.addWidget(self.ellipsis_label)
chrisjbillington:             self.layout.addWidget(self.scroll_area)
chrisjbillington:         elif self._elideMode == Qt.ElideRight:
chrisjbillington:             self.layout.addWidget(self.scroll_area)
chrisjbillington:             self.layout.addWidget(self.ellipsis_label)
           Chris: 
chrisjbillington:     # def resizeEvent(self, event):
chrisjbillington:     #     result = QWidget.resizeEvent(self, event)
chrisjbillington:     #     self.update_elide_widget()
chrisjbillington:     #     return result
chrisjbillington: 
chrisjbillington:     def update_elide_widget(self):
chrisjbillington:         label_width = self.label.minimumSizeHint().width()
           Chris: 
chrisjbillington:         width = self.width()
chrisjbillington:         if label_width > width:
chrisjbillington:             self.ellipsis_label.setText(ELLIPSIS)
chrisjbillington:         else:
chrisjbillington:             self.ellipsis_label.setText('')
           Chris: 
chrisjbillington:         if self._elideMode == Qt.ElideNone:
chrisjbillington:             return
chrisjbillington:         elif self._elideMode == Qt.ElideLeft:
chrisjbillington:             self.scroll_area.ensureVisible(label_width, 0, 0, 0)
chrisjbillington:         elif self._elideMode == Qt.ElideRight:
chrisjbillington:             self.scroll_area.ensureVisible(0, 0, 0, 0)
           Chris: 
           Chris:     def minimumSizeHint(self):
           Chris:         return self.scroll_area.minimumSizeHint()
           Chris: 
           Chris:     def sizeHint(self):
           Chris:         return self.scroll_area.minimumSizeHint()
           Chris: 
           Chris: 
chrisjbillington: def elide_label(label, layout, elide_mode):
chrisjbillington:     """Take an existing label that is in a layout, and wrap it in our widgets
chrisjbillington:     that elide the text, and insert it back into the layout. This is a hack
chrisjbillington:     that allows us to elide a QLabel with a single line of (possibly rich)
chrisjbillington:     text, a task that seems pretty much impossible to do in any kosher way.
           Chris: 
chrisjbillington:     This function is for modifying an existing label already in a layout, but
chrisjbillington:     if you are programatically creating a label, then you can wrap it in
chrisjbillington:     ElidedLabelContainer(label) before inserting it into a layout or other
chrisjbillington:     container widget, which is more flexible than this function which only
chrisjbillington:     works if the label is in a QBoxLayout"""
chrisjbillington:     if not (isinstance(layout, QBoxLayout) or isinstance(layout, QSplitter)):
chrisjbillington:         raise NotImplementedError("Only labels that are in QBoxLayouts or QSplitters supported")
chrisjbillington:     index = layout.indexOf(label)
chrisjbillington:     if index == -1:
chrisjbillington:         raise ValueError("Label not found in given layout")
chrisjbillington:     container = ElidedLabelContainer(label)
           Chris:     label.setParent(container.scroll_area)
           Chris:     label.setVisible(False)
           Chris:     label.setVisible(True)
chrisjbillington:     layout.insertWidget(index, container)
chrisjbillington:     container.setElideMode(elide_mode)
           Chris: 
           Chris: 
           Chris: if __name__ == '__main__':
           Chris:     # test:
           Chris:     
chrisjbillington:     test_text = "The <b>quick</b> brown fox <b>jumped over the lazy dog</b>"
           Chris:     app = QApplication(sys.argv)
           Chris:     window = QWidget()
chrisjbillington:     hlayout = QHBoxLayout(window)
           Chris:     tabwidget = QTabWidget()
chrisjbillington:     widget = QWidget()
           Chris:     tabwidget.addTab(widget, 'test')
chrisjbillington:     layout = QVBoxLayout(widget)
chrisjbillington:     normal_label = QLabel("Normal label")
chrisjbillington:     normal_label.setStyleSheet("QLabel { background-color : red; color : blue; }")
chrisjbillington:     hlayout.addWidget(normal_label)
           Chris:     hlayout.addWidget(tabwidget)
           Chris: 
chrisjbillington:     elide_left = QLabel("ElideLeft: " + test_text)
chrisjbillington:     elide_left.setAlignment(Qt.AlignCenter)
chrisjbillington:     elide_right = QLabel("ElideRight: " + test_text)
chrisjbillington:     smaller_label = QLabel("Smaller label")
chrisjbillington:     smaller_label2 = QLabel("Smaller label")
chrisjbillington:     smaller_label3 = QLabel("Smaller label")
chrisjbillington:     smaller_label.setStyleSheet("QLabel { background-color : red; color : blue; }")
chrisjbillington:     smaller_label2.setStyleSheet("QLabel { background-color : red; color : blue; }")
chrisjbillington:     smaller_label3.setStyleSheet("QLabel { background-color : red; color : blue; }")
           Chris: 
chrisjbillington:     layout.setSpacing(0)
chrisjbillington: 
chrisjbillington:     layout.addWidget(smaller_label)
           Chris:     layout.addWidget(elide_left)
chrisjbillington:     layout.addWidget(smaller_label2)
           Chris:     layout.addWidget(elide_right)
chrisjbillington:     layout.addWidget(smaller_label3)
           Chris: 
           Chris:     window.show()
chrisjbillington:     window.resize(20, 20)
chrisjbillington: 
chrisjbillington:     elide_label(elide_left, layout, Qt.ElideLeft)
chrisjbillington:     elide_label(elide_right, layout, Qt.ElideRight)
chrisjbillington: 
chrisjbillington:     def foo():
chrisjbillington:         elide_left.setText("The <b>quick</b><br>brown fox <b>jumped <br>over the lazy dog</b>")
chrisjbillington: 
chrisjbillington:     QTimer.singleShot(3000, foo)
           Chris:     app.exec_()
   pstarkey: # Code by LegoStormtroopr
   pstarkey: #
   pstarkey: # License:
janwerkmann: # This [trivial fingertab gist](https://gist.github.com/LegoStormtroopr/5075267) is released
janwerkmann: # as Public Domain, but boy would it beswell if you could credit me, or tweet me
   pstarkey: # [@LegoStormtoopr](http://www.twitter.com/legostormtroopr) to say thanks!
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   pstarkey: 
   pstarkey: import sys
janwerkmann: from qtutils.qt import QtCore, QtGui, QtWidgets
janwerkmann: 
janwerkmann: 
janwerkmann: class FingerTabBarWidget(QtWidgets.QTabBar):
   pstarkey:     def __init__(self, parent=None, *args, **kwargs):
janwerkmann:         self.tabSize = QtCore.QSize(kwargs.pop('width', 100), kwargs.pop('height', 25))
janwerkmann:         QtWidgets.QTabBar.__init__(self, parent, *args, **kwargs)
janwerkmann: 
   pstarkey:     def paintEvent(self, event):
janwerkmann:         painter = QtWidgets.QStylePainter(self)
janwerkmann:         option = QtWidgets.QStyleOptionTab()
janwerkmann: 
   pstarkey:         for index in range(self.count()):
   pstarkey:             self.initStyleOption(option, index)
   pstarkey:             tabRect = self.tabRect(index)
   pstarkey:             tabRect.moveLeft(10)
janwerkmann:             painter.drawControl(QtWidgets.QStyle.CE_TabBarTabShape, option)
janwerkmann:             painter.drawText(tabRect, QtCore.Qt.AlignVCenter |
janwerkmann:                              QtCore.Qt.TextDontClip,
janwerkmann:                              self.tabText(index))
   pstarkey:         painter.end()
janwerkmann: 
janwerkmann:     def tabSizeHint(self, index):
   pstarkey:         return self.tabSize
janwerkmann: 
   pstarkey: # Shamelessly stolen from this thread:
   pstarkey: #   http://www.riverbankcomputing.com/pipermail/pyqt/2005-December/011724.html
janwerkmann: class FingerTabWidget(QtWidgets.QTabWidget):
   pstarkey:     """A QTabWidget equivalent which uses our FingerTabBarWidget"""
janwerkmann: 
   pstarkey:     def __init__(self, parent, *args):
janwerkmann:         QtWidgets.QTabWidget.__init__(self, parent, *args)
janwerkmann:         self.setTabBar(FingerTabBarWidget(self))
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from qtutils.qt import QtCore, QtGui, QtWidgets
   cbilling: 
   cbilling: 
janwerkmann: class HorizontalHeaderViewWithWidgets(QtWidgets.QHeaderView):
   cbilling: 
   cbilling:     """A QHeaderView that supports inserting arbitrary
   cbilling:     widgets into sections. Use setWidget(logical_index, widget)
   cbilling:     to set and setWidget(logical_index, None) to unset.
   cbilling:     Decorations, checkboxes or anything other than text in the
   cbilling:     headers containing widgets is unsupported, and may result
   cbilling:     in garbled output"""
   cbilling: 
   cbilling:     thinspace = u'\u2009'  # For indenting text
   cbilling: 
   cbilling:     stylesheet = """
   cbilling:                  QHeaderView::section {
   cbilling:                  /* Will be set dynamically: */
   cbilling:                  padding-top: %dpx;
   cbilling:                  padding-bottom: %dpx;
   cbilling:                  /* Required, otherwise set to zero upon setting any stylesheet at all: */
   cbilling:                  padding-left: 4px;
   cbilling:                  /* Required for some reason, otherwise other settings ignored: */
   cbilling:                  color: black;
   cbilling:                  }
   cbilling: 
   cbilling:                  /* Any other style goes here: */
   cbilling:                  %s
   cbilling:                  """
   cbilling: 
   cbilling:     def __init__(self, model, parent=None):
   cbilling:         self.widgets = {}
   cbilling:         self.indents = {}
   cbilling:         self.model = model
janwerkmann:         QtWidgets.QHeaderView.__init__(self, QtCore.Qt.Horizontal, parent)
   cbilling:         self.setDefaultAlignment(QtCore.Qt.AlignLeft)
   cbilling:         self.sectionMoved.connect(self.update_widget_positions)
   cbilling:         self.sectionResized.connect(self.update_widget_positions)
   cbilling:         self.geometriesChanged.connect(self.update_widget_positions)
   cbilling:         self.sectionCountChanged.connect(self.update_widget_positions)
   cbilling:         self.model.columnsInserted.connect(self.on_columnsInserted)
   cbilling:         self.model.columnsRemoved.connect(self.on_columnsRemoved)
janwerkmann:         self.setSectionsMovable(True)
   cbilling:         self.vertical_padding = 0
   cbilling:         self.position_update_required = False
   cbilling:         self.custom_style = ''
   cbilling:         self.update_indents()
   cbilling: 
   cbilling:     def setStyleSheet(self, custom_style):
   cbilling:         self.custom_style = custom_style
   cbilling:         self.update_indents()
   cbilling: 
   cbilling:     def showSection(self, *args, **kwargs):
janwerkmann:         result = QtWidgets.QHeaderView.showSection(self, *args, **kwargs)
   cbilling:         self.update_indents()
   cbilling:         self.update_widget_positions()
   cbilling:         return result
   cbilling: 
   cbilling:     def hideSection(self, *args, **kwargs):
janwerkmann:         result = QtWidgets.QHeaderView.hideSection(self, *args, **kwargs)
   cbilling:         self.update_indents()
   cbilling:         self.update_widget_positions()
   cbilling:         return result
   cbilling: 
   cbilling:     def setSectionHidden(self, *args, **kwargs):
janwerkmann:         result = QtWidgets.QHeaderView.setSectionHidden(self, *args, **kwargs)
   cbilling:         self.update_indents()
   cbilling:         self.update_widget_positions()
   cbilling:         return result
   cbilling: 
   cbilling:     def viewportEvent(self, event):
   cbilling:         if event.type() == QtCore.QEvent.Paint:
   cbilling:             self.update_widget_positions()
janwerkmann:         return QtWidgets.QHeaderView.viewportEvent(self, event)
   cbilling: 
   cbilling:     def setWidget(self, logical_index, widget=None):
   cbilling:         header_item = self.model.horizontalHeaderItem(logical_index)
   cbilling:         if header_item is None:
   cbilling:             self.model.setHorizontalHeaderItem(logical_index, QtGui.QStandardItem())
   cbilling:         if widget is None:
   cbilling:             if logical_index in self.widgets:
   cbilling:                 widget = self.widgets[logical_index]
   cbilling:                 widget.setParent(None)
   cbilling:                 del self.widgets[logical_index]
   cbilling:                 widget.removeEventFilter(self)
   cbilling:                 del self.indents[widget]
   cbilling:                 label_text = self.model.headerData(logical_index, QtCore.Qt.Horizontal, QtCore.Qt.DisplayRole)
   cbilling:                 # Compatibility with both API types:
   cbilling:                 if isinstance(label_text, QtCore.QVariant):
   cbilling:                     if label_text.isNull():
   cbilling:                         return
   cbilling:                     else:
   cbilling:                         label_text = label_text.toString()
   cbilling:                 if label_text is None:
   cbilling:                     return
   cbilling:                 else:
   cbilling:                     raw_label_text = label_text.replace(self.thinspace, '')
   cbilling:                     self.model.setHeaderData(logical_index, QtCore.Qt.Horizontal, raw_label_text, QtCore.Qt.DisplayRole)
   cbilling:         else:
   cbilling:             self.widgets[logical_index] = widget
   cbilling:             widget.setParent(self)
   cbilling:             widget.installEventFilter(self)
   cbilling:             if not self.isSectionHidden(logical_index) and not widget.isVisible():
   cbilling:                 widget.show()
   cbilling:         self.update_indents()
   cbilling:         self.update_widget_positions()
   cbilling: 
   cbilling:     def showEvent(self, event):
janwerkmann:         QtWidgets.QHeaderView.showEvent(self, event)
   cbilling:         self.update_indents()
   cbilling:         self.update_widget_positions()
   cbilling: 
   cbilling:     def update_indents(self):
   cbilling:         max_widget_height = 0
   cbilling:         for visual_index in range(self.count()):
   cbilling:             logical_index = self.logicalIndex(visual_index)
   cbilling:             if logical_index in self.widgets:
   cbilling:                 widget = self.widgets[logical_index]
   cbilling:                 if not self.isSectionHidden(logical_index):
   cbilling:                     max_widget_height = max(max_widget_height, widget.size().height())
   cbilling:                 desired_indent = widget.size().width()
   cbilling:                 item = self.model.horizontalHeaderItem(logical_index)
   cbilling:                 font = item.font()
   cbilling:                 fontmetrics = QtGui.QFontMetrics(font, self)
   cbilling:                 indent = ''
   cbilling:                 while fontmetrics.width(indent) < desired_indent:
   cbilling:                     indent += self.thinspace
   cbilling:                 self.indents[widget] = indent
   cbilling:         font = self.font()
   cbilling:         fontmetrics = QtGui.QFontMetrics(font, self)
   cbilling:         height = fontmetrics.height()
   cbilling:         required_padding = (max_widget_height + 2 - height) // 2
   cbilling:         required_padding = max(required_padding, 3)
janwerkmann:         QtWidgets.QHeaderView.setStyleSheet(self, self.stylesheet % (required_padding, required_padding, self.custom_style))
   cbilling: 
   cbilling:     def sectionSizeFromContents(self, logical_index):
janwerkmann:         base_size = QtWidgets.QHeaderView.sectionSizeFromContents(self, logical_index)
   cbilling:         width, height = base_size.width(), base_size.height()
   cbilling:         if logical_index in self.widgets:
   cbilling:             widget_size = self.widgets[logical_index].size()
   cbilling:             widget_width, widget_height = widget_size.width(), widget_size.height()
   cbilling:             height = max(height, widget_height + 2)
   cbilling:             width = max(width, widget_width + 7)
   cbilling:         return QtCore.QSize(width, height)
   cbilling: 
   cbilling:     def update_widget_positions(self):
   cbilling:         # Do later and compress events, so as not to call
   cbilling:         # self.do_update_widget_positions multiple times:
   cbilling:         if not self.position_update_required:
   cbilling:             timer = QtCore.QTimer.singleShot(0, self.do_update_widget_positions)
   cbilling:             self.position_update_required = True
   cbilling: 
   cbilling:     def do_update_widget_positions(self):
   cbilling:         self.position_update_required = False
   cbilling:         if not self.count():
   cbilling:             return
   cbilling:         max_height = max(self.sectionSizeFromContents(i).height()
   cbilling:                          for i in range(self.count())
   cbilling:                          if not self.isSectionHidden(i))
   cbilling:         for visual_index in range(self.count()):
   cbilling:             logical_index = self.logicalIndex(visual_index)
   cbilling:             if logical_index in self.widgets:
   cbilling:                 widget = self.widgets[logical_index]
   cbilling:                 if not self.isSectionHidden(logical_index) and not widget.isVisible():
   cbilling:                     widget.show()
   cbilling:                 elif self.isSectionHidden(logical_index) and widget.isVisible():
   cbilling:                     widget.hide()
   cbilling:                 section_position = self.sectionViewportPosition(logical_index)
   cbilling:                 widget_size = widget.size()
   cbilling:                 widget_width, widget_height = widget_size.width(), widget_size.height()
   cbilling:                 widget_target_x = section_position + 3
   cbilling:                 widget_target_y = (max_height - widget_height) // 2 - 1
   cbilling:                 widget_current_pos = widget.pos()
   cbilling:                 widget_current_x, widget_current_y = widget_current_pos.x(), widget_current_pos.y()
   cbilling:                 if (widget_target_x, widget_target_y) != (widget_current_x, widget_current_y):
   cbilling:                     widget.move(widget_target_x, widget_target_y)
   cbilling:                 try:
   cbilling:                     indent = self.indents[widget]
   cbilling:                 except KeyError:
   cbilling:                     return
   cbilling:                 label_text = self.model.headerData(logical_index, QtCore.Qt.Horizontal, QtCore.Qt.DisplayRole)
   cbilling:                 # Compatibility with both API types:
   cbilling:                 if isinstance(label_text, QtCore.QVariant):
   cbilling:                     if not label_text.isNull():
   cbilling:                         label_text = label_text.toString()
   cbilling:                     else:
   cbilling:                         label_text = ''
   cbilling:                 if label_text is None:
   cbilling:                     label_text = ''
   cbilling:                 raw_label_text = label_text.replace(self.thinspace, '')
   cbilling:                 if label_text != indent + raw_label_text:
   cbilling:                     self.model.setHeaderData(
   cbilling:                         logical_index, QtCore.Qt.Horizontal, indent + raw_label_text, QtCore.Qt.DisplayRole)
   cbilling: 
   cbilling:     def eventFilter(self, target, event):
   cbilling:         """Ensure we don't leave the curor set as a resize
   cbilling:         handle when the mouse moves onto a child widget:"""
   cbilling:         if event.type() == QtCore.QEvent.Enter:
   cbilling:             self.unsetCursor()
   cbilling:         return False
   cbilling: 
   cbilling:     def on_columnsInserted(self, parent, logical_first, logical_last):
   cbilling:         n_inserted = logical_last - logical_first + 1
   cbilling:         widgets_with_offset = {}
   cbilling:         for logical_index, widget in self.widgets.items():
   cbilling:             if logical_index < logical_first:
   cbilling:                 widgets_with_offset[logical_index] = widget
   cbilling:             else:
   cbilling:                 widgets_with_offset[logical_index + n_inserted] = widget
   cbilling:         self.widgets = widgets_with_offset
   cbilling:         self.update_widget_positions()
   cbilling: 
   cbilling:     def on_columnsRemoved(self, parent, logical_first, logical_last):
   cbilling:         n_removed = logical_last - logical_first + 1
   cbilling:         widgets_with_offset = {}
   cbilling:         for logical_index, widget in self.widgets.items():
   cbilling:             if logical_index < logical_first:
   cbilling:                 widgets_with_offset[logical_index] = widget
   cbilling:             elif logical_index <= logical_last:
   cbilling:                 self.setWidget(logical_index, None)
   cbilling:             else:
   cbilling:                 widgets_with_offset[logical_index - n_removed] = widget
   cbilling:         self.widgets = widgets_with_offset
   cbilling:         self.update_widget_positions()
   cbilling: 
   cbilling: 
   cbilling: if __name__ == '__main__':
   cbilling: 
   cbilling:     import sys
   cbilling:     import qtutils.icons
   cbilling: 
   cbilling:     class TestApp(object):
   cbilling: 
   cbilling:         def __init__(self):
   cbilling:             self.window = QtGui.QWidget()
   cbilling:             self.window.resize(640, 480)
   cbilling:             layout = QtGui.QVBoxLayout(self.window)
   cbilling:             self.model = QtGui.QStandardItemModel()
   cbilling:             self.treeview = QtGui.QTreeView(self.window)
   cbilling:             self.header = HorizontalHeaderViewWithWidgets(self.model)
   cbilling: 
   cbilling:             self.treeview.setSortingEnabled(True)
   cbilling: 
   cbilling:             self.model.setHorizontalHeaderLabels(['Delete', 'Name', 'Value', 'Units', 'Expansion'])
   cbilling:             self.button = QtGui.QPushButton('hello, world!')
   cbilling:             self.button.setIcon(QtGui.QIcon(':qtutils/fugue/smiley-lol'))
   cbilling: 
   cbilling:             self.button2 = QtGui.QToolButton()
   cbilling:             self.button2.setIcon(QtGui.QIcon(':qtutils/fugue/plus'))
   cbilling: 
   cbilling:             self.button3 = QtGui.QToolButton()
   cbilling:             self.button3.setMinimumHeight(50)
   cbilling:             self.button3.setIcon(QtGui.QIcon(':qtutils/fugue/minus'))
   cbilling: 
   cbilling:             self.button4 = QtGui.QCheckBox()
   cbilling: 
   cbilling:             self.header.setWidget(0, self.button)
   cbilling:             self.header.setWidget(1, self.button2)
   cbilling:             self.header.setWidget(2, self.button3)
   cbilling:             self.header.setWidget(4, self.button4)
   cbilling:             self.treeview.setHeader(self.header)
   cbilling:             self.treeview.setModel(self.model)
   cbilling:             layout.addWidget(self.treeview)
   cbilling:             self.model.insertColumn(2, [QtGui.QStandardItem('test')])
   cbilling:             self.window.show()
   cbilling: 
   cbilling:             for col in range(self.model.columnCount()):
   cbilling:                 self.treeview.resizeColumnToContents(col)
   cbilling: 
   cbilling:             QtCore.QTimer.singleShot(2000, lambda: self.header.hideSection(3))
   cbilling:             QtCore.QTimer.singleShot(4000, lambda: self.header.showSection(3))
   cbilling:             QtCore.QTimer.singleShot(6000, lambda: self.header.setWidget(0, None))
   cbilling:             QtCore.QTimer.singleShot(8000, lambda: self.header.setWidget(0, self.button))
   cbilling: 
   cbilling:     qapplication = QtGui.QApplication(sys.argv)
   cbilling:     qapplication.setAttribute(QtCore.Qt.AA_DontShowIconsInMenus, False)
   cbilling:     app = TestApp()
   cbilling:     qapplication.exec_()
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # imageoutput.py                                                    #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the labscript suite (see                     #
   pstarkey: # http://labscriptsuite.org) and is licensed under the Simplified   #
   pstarkey: # BSD License. See the license.txt file in the root of the project  #
   pstarkey: # for the full license.                                             #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   pstarkey: 
   pstarkey: import base64
   pstarkey: import sys
   pstarkey: import os
   pstarkey: 
janwerkmann: from qtutils.qt.QtCore import *
janwerkmann: from qtutils.qt.QtGui import *
janwerkmann: from qtutils.qt.QtWidgets import *
janwerkmann: from qtutils.qt.QtCore import pyqtSignal as Signal
   pstarkey: 
   pstarkey: class BrowseButton(QPushButton):
   pstarkey:     def __init__(self, image_output, *args, **kwargs):
   pstarkey:         QPushButton.__init__(self, *args, **kwargs)
   pstarkey:         self.image_output = image_output
   pstarkey:         self.installEventFilter(self)
   pstarkey:         self.clicked.connect(self.browse)
   pstarkey:         self.last_opened_folder = ""
   pstarkey:         
   pstarkey:     def browse(self):
   pstarkey:         # supported_images = "Image files (*.png *.bmp *.gif *.jpg *.jpeg *.pbm *.pgm *.ppm *.xbm *.xpm)"
   pstarkey:         supported_images = "Image files ("
   pstarkey:         
   pstarkey:         for format in QImageReader.supportedImageFormats():
   pstarkey:             supported_images += "*.%s "%format
   pstarkey:             
   pstarkey:         supported_images = supported_images [:-1]
   pstarkey:         supported_images += ")"
   pstarkey:         
   pstarkey:         image_file = QFileDialog.getOpenFileName(self, 'Select image file to load', self.last_opened_folder, supported_images)
janwerkmann:         if type(image_file) is tuple:
janwerkmann:             image_file, _ = image_file
   shjohnst:         if image_file == None or image_file == "":
   shjohnst:             return
   pstarkey:         image_file = os.path.abspath(image_file)
   pstarkey:         if not os.path.exists(image_file):
   pstarkey:             return 
   pstarkey:             
   pstarkey:         self.last_opened_folder = os.path.dirname(image_file)
   pstarkey:         
   pstarkey:         # read the file
   pstarkey:         raw_data = u''
   pstarkey:         with open(image_file, 'rb') as f:
   pstarkey:             raw_data = f.read()
   pstarkey: 
   shjohnst:         
   pstarkey:         data = base64.b64encode(raw_data)
   shjohnst:         
   pstarkey:         self.image_output.value = data
   pstarkey:         
   pstarkey:     def eventFilter(self, obj, event):
   pstarkey:         if event.type() == QEvent.MouseButtonRelease and event.button() == Qt.RightButton:
   pstarkey:             menu = QMenu(self)
   pstarkey:             menu.addAction("Lock" if not self.image_output.lock_state else "Unlock")
   pstarkey:             menu.triggered.connect(self.image_output._menu_triggered)
   pstarkey:             menu.popup(self.mapToGlobal(event.pos()))
   pstarkey:             return True
   pstarkey:             
   pstarkey:         return QPushButton.eventFilter(self, obj, event)
   pstarkey:     
   pstarkey:     
   pstarkey: class ImageView(QGraphicsView):
   pstarkey:     def __init__(self, *args, **kwargs):
   pstarkey:         QGraphicsView.__init__(self, *args, **kwargs)
   pstarkey:         self.installEventFilter(self)
   pstarkey:         
   pstarkey:     def contextMenuEvent(self, event):
   pstarkey:         menu = QMenu(self)
   pstarkey:         menu.addAction("Lock" if not self.parent().lock_state else "Unlock")
   pstarkey:         menu.triggered.connect(self.parent()._menu_triggered)
   pstarkey:         menu.popup(self.mapToGlobal(event.pos()))
   pstarkey:         
   pstarkey:     
   pstarkey:     # def eventFilter(self, obj, event):
   pstarkey:         # if event.type() == QEvent.ContextMenu:
   pstarkey:             # print 'a'
   pstarkey:             # menu = QMenu(self)
   pstarkey:             # menu.addAction("Lock" if self.parent().lock_state else "Unlock")
   pstarkey:             # menu.triggered.connect(self.parent()._menu_triggered)
   pstarkey:             # menu.popup(self.mapToGlobal(event.pos()))
   pstarkey:             # return True
   pstarkey:             
   pstarkey:         # return QGraphicsView.eventFilter(self, obj, event)
   pstarkey:     
   pstarkey:     
   pstarkey: class ImageOutput(QWidget):
   pstarkey:     
janwerkmann:     imageUpdated = Signal(str)
   pstarkey: 
   pstarkey:     def __init__(self, name, width, height, *args, **kwargs):
   pstarkey:         QWidget.__init__(self, *args, **kwargs)        
   pstarkey:         self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Minimum)
   pstarkey:         
   pstarkey:         
   pstarkey:         # create the layout
   pstarkey:         self._layout = QVBoxLayout(self)
   pstarkey:         self._layout.setSpacing(0)
   pstarkey:         self._layout.setContentsMargins(0, 0, 0, 0)
   pstarkey:         
   pstarkey:         # Create a layout for the header of this ImageOutput widget
   pstarkey:         header_widget = QWidget(self)
   pstarkey:         header_layout = QHBoxLayout(header_widget)        
   pstarkey:         
   pstarkey:         # Add the label
   pstarkey:         self._label = QLabel(name)
   pstarkey:         header_layout.addWidget(self._label)
   pstarkey:         
   pstarkey:         # Add the browse button
   pstarkey:         self._browse_button = BrowseButton(self, 'Select Image')
   shjohnst:         self._browse_button.setIcon(QIcon(':/qtutils/fugue/image-import'))
   pstarkey:         header_layout.addWidget(self._browse_button)
   pstarkey:        
   pstarkey:         # Add a spacer item to keep everything bunched
   pstarkey:         header_layout.addItem(QSpacerItem(0,0,QSizePolicy.MinimumExpanding,QSizePolicy.Minimum))
   pstarkey:         
   pstarkey:         # add the header widget to the layout
   pstarkey:         self._layout.addWidget(header_widget)
   pstarkey:         
   pstarkey:         self.image_size = QSize(width,height)
   pstarkey:         
   pstarkey:         # Create the graphics scene and view
   pstarkey:         self._scene = QGraphicsScene(0, 0, width, height)
   pstarkey:         self._scene.setBackgroundBrush(Qt.black)
   pstarkey:         self._view = ImageView(self._scene)
   pstarkey:         self._view.setAlignment(Qt.AlignLeft | Qt.AlignTop)        
   pstarkey:         self._view.setStyleSheet("border: 0px")
   pstarkey:         # self._view.setStyleSheet("background-color:#000000; border: 0px;")
   pstarkey:         self._view.setMinimumSize(self.image_size)
   pstarkey:         self._view.setMaximumSize(self.image_size)
   pstarkey:         self._layout.addWidget(self._view)
   pstarkey:         
   pstarkey:         # Install the event filter that will allow us to catch right click mouse release events so we can popup a menu even when the button is disabled
   pstarkey:         self.installEventFilter(self)
   pstarkey:         
   pstarkey:         # The Image Out object that is in charge of this button
   pstarkey:         self._Image = None
   pstarkey:         
   pstarkey:         # the base64encoded value
janwerkmann:         self._value = str("")
   pstarkey:         
   pstarkey:         # The image item to be added to the scene
   pstarkey:         self._pixmap_item = None
   pstarkey:         
   pstarkey:         # The current lock state
   pstarkey:         self.lock_state = False
   pstarkey:     
   pstarkey:     # Setting and getting methods for the Image Out object in charge of this button
   pstarkey:     def set_Image(self,Image,notify_old_Image=True,notify_new_Image=True):
   pstarkey:         # If we are setting a new Image, remove this widget from the old one (if it isn't None) and add it to the new one (if it isn't None)
   pstarkey:         if Image != self._Image:
   pstarkey:             if self._Image is not None and notify_old_Image:
   pstarkey:                 self._Image.remove_widget(self)
   pstarkey:             if Image is not None and notify_new_Image:
   pstarkey:                 Image.add_widget(self)
   pstarkey:         # Store a reference to the Image out object
   pstarkey:         self._Image = Image
   pstarkey:         
   pstarkey:     def get_Image(self):
   pstarkey:         return self._Image
   pstarkey:     
   pstarkey:     # The event filter that pops up a context menu on a right click, even when the button is disabled
   pstarkey:     def eventFilter(self, obj, event):
   pstarkey:         if event.type() == QEvent.MouseButtonRelease and event.button() == Qt.RightButton:
   pstarkey:             menu = QMenu(self)
   pstarkey:             menu.addAction("Lock" if not self.lock_state else "Unlock")
   pstarkey:             menu.triggered.connect(self._menu_triggered)
   pstarkey:             menu.popup(self.mapToGlobal(event.pos()))
   pstarkey:             return True
   pstarkey:         
   pstarkey:         # pass scrollwheel events of disabled buttons through to the parent
   pstarkey:         # code adapted from: http://www.qtforum.org/article/28540/disabled-widgets-and-wheel-events.html
   pstarkey:         elif obj and not obj.isEnabled() and event.type() == QEvent.Wheel:
   pstarkey:             newEvent = QWheelEvent(obj.mapToParent(event.pos()), event.globalPos(),
   pstarkey:                                    event.delta(), event.buttons(),
   pstarkey:                                    event.modifiers(), event.orientation())
   pstarkey:             QApplication.instance().postEvent(obj.parent(), newEvent)
   pstarkey:             return True
   pstarkey:         
   pstarkey:         return QWidget.eventFilter(self, obj, event)
   pstarkey:      
   pstarkey:     # This method is called whenever an entry in the context menu is clicked
   pstarkey:     def _menu_triggered(self,action):
   pstarkey:         if action.text() == "Lock":
   pstarkey:             self.lock()
   pstarkey:         elif action.text() == "Unlock":
   pstarkey:             self.unlock()
   pstarkey:     
   pstarkey:     # This method locks (disables) the widget, and if the widget has a parent Image object, notifies it of the lock
   pstarkey:     def lock(self,notify_Image=True):        
   pstarkey:         self._browse_button.setEnabled(False)
   pstarkey:         self.lock_state = True
   pstarkey:         if self._Image is not None and notify_Image:
   pstarkey:             self._Image.lock()
   pstarkey:     
   pstarkey:     # This method unlocks (enables) the widget, and if the widget has a parent Image object, notifies it of the unlock    
   pstarkey:     def unlock(self,notify_Image=True): 
   pstarkey:         self._browse_button.setEnabled(True)
   pstarkey:         self.lock_state = False
   pstarkey:         if self._Image is not None and notify_Image:
   pstarkey:             self._Image.unlock()
   pstarkey:         
   pstarkey:     @property
   pstarkey:     def value(self):
janwerkmann:         return str(self._value)
   pstarkey:         
   pstarkey:     @value.setter
   pstarkey:     def value(self, value):
janwerkmann:         decoded_image = base64.b64decode(str(value))
   pstarkey:         pixmap = QPixmap()
   pstarkey:         pixmap.loadFromData(decoded_image, flags=Qt.AvoidDither | Qt.ThresholdAlphaDither | Qt.ThresholdDither)
   pstarkey:         # print decoded_image
   pstarkey:         if pixmap.size() != self.image_size:
   pstarkey:             QMessageBox.warning(self, "Failed to load image", 'The image size was incorrect. It must be %dx%d pixels.'%(self.image_size.width(), self.image_size.height()), QMessageBox.Ok, QMessageBox.Ok)
   pstarkey:             return
   shjohnst:         
janwerkmann:         self._value = str(value)
   pstarkey:         pixmap_item = QGraphicsPixmapItem(pixmap)
   pstarkey:         
   pstarkey:         if self._pixmap_item is not None:
   pstarkey:             self._scene.removeItem(self._pixmap_item)
   pstarkey:         self._scene.addItem(pixmap_item)
   pstarkey:         self._pixmap_item = pixmap_item
   pstarkey:         
   pstarkey:         # Tell the Image object that the value has been updated
   pstarkey:         self.imageUpdated.emit(self._value)
   pstarkey:     
   pstarkey:     
   pstarkey: # A simple test!
   pstarkey: if __name__ == '__main__':
   pstarkey:     
   pstarkey:     qapplication = QApplication(sys.argv)
   pstarkey:     
   pstarkey:     window = QWidget()
   pstarkey:     layout = QVBoxLayout(window)
   pstarkey:     button = ImageOutput('hello', 200, 200)
   pstarkey:         
   pstarkey:     layout.addWidget(button)
   pstarkey:     
   pstarkey:     window.show()
   pstarkey:     
   pstarkey:     
   pstarkey:     sys.exit(qapplication.exec_())
   pstarkey:     
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # toolpalette.py                                                    #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2013, Monash University                                 #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
chrisjbillington: import sys
chrisjbillington: 
     janwerkmann: from qtutils.qt.QtCore import *
     janwerkmann: from qtutils.qt.QtGui import *
     janwerkmann: from qtutils.qt.QtWidgets import *
chrisjbillington: 
chrisjbillington: EXPAND_ICON = ':/qtutils/fugue/toggle-small-expand'
chrisjbillington: CONTRACT_ICON = ':/qtutils/fugue/toggle-small'
chrisjbillington: 
chrisjbillington: class ToolPaletteGroup(QVBoxLayout):
chrisjbillington:     
chrisjbillington:     def __init__(self,*args,**kwargs):
chrisjbillington:         QVBoxLayout.__init__(self,*args,**kwargs)
chrisjbillington:         self._widget_groups = {}
chrisjbillington:         self._width_groups = {}
chrisjbillington:         self._all_widths_linked = False
chrisjbillington:     
chrisjbillington:     # Creates and appends a new ToolPalette to this group
chrisjbillington:     # A reference to the new ToolPalette is returned
chrisjbillington:     def append_new_palette(self,name,*args,**kwargs):
chrisjbillington:         if name in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette group already has a palette named %s'%name)
chrisjbillington:             
chrisjbillington:         # Create the tool palette and store a reference to it and an index indicating the order of Tool Palettes
chrisjbillington:         tool_palette = ToolPalette(self,name,*args,**kwargs)
chrisjbillington:         push_button = QPushButton(name)        
chrisjbillington:         push_button.setIcon(QIcon(CONTRACT_ICON))
chrisjbillington:         push_button.setFocusPolicy(Qt.NoFocus)
chrisjbillington:         push_button.setToolTip('Click to hide')
chrisjbillington: 
chrisjbillington:         frame = QFrame()
chrisjbillington:         frame.setFrameStyle(QFrame.StyledPanel)
chrisjbillington:         frame_layout = QVBoxLayout(frame)
chrisjbillington:         frame_layout.setContentsMargins(0,0,0,0)
chrisjbillington:         frame_layout.setSpacing(0)
chrisjbillington: 
chrisjbillington:         header_widget = QWidget()
chrisjbillington:         header_layout = QHBoxLayout()
chrisjbillington:         header_layout.addWidget(push_button)
chrisjbillington:         header_layout.addStretch(1)
chrisjbillington:         header_widget.setLayout(header_layout)
chrisjbillington:         header_layout.setContentsMargins(3,3,3,3)
chrisjbillington:         
chrisjbillington:         def create_callback(name):
chrisjbillington:             return lambda: self._on_button_clicked(name)
chrisjbillington:             
chrisjbillington:         push_button.clicked.connect(create_callback(name))
chrisjbillington:         self._widget_groups[name] = (len(self._widget_groups), tool_palette, push_button)
chrisjbillington:         
chrisjbillington:         frame_layout.addWidget(header_widget)
chrisjbillington:         frame_layout.addWidget(tool_palette)
chrisjbillington:         
chrisjbillington:         # append to the layout
chrisjbillington:         self.addWidget(frame)
chrisjbillington:         return tool_palette
chrisjbillington:      
chrisjbillington:     def _on_button_clicked(self,name):
chrisjbillington:         # work out if it is shown or hidden
chrisjbillington:         #call show or hide method
chrisjbillington:         if self._widget_groups[name][1].isHidden():
chrisjbillington:             self.show_palette(name)
chrisjbillington:         else:
chrisjbillington:             self.hide_palette(name)
chrisjbillington:         
chrisjbillington:         
chrisjbillington:     def show_palette(self,name):
chrisjbillington:         if name not in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette does not have a palette named %s'%name)
chrisjbillington:         _, palette, push_button = self._widget_groups[name]
chrisjbillington:         palette.show()
chrisjbillington:         push_button.setIcon(QIcon(CONTRACT_ICON))
chrisjbillington:         push_button.setToolTip('Click to hide')
chrisjbillington:             
chrisjbillington:     def show_palette_by_index(self,index):
chrisjbillington:         self.show_palette(self.get_name_from_index(index))
chrisjbillington:     
chrisjbillington:     def hide_palette(self,name):    
chrisjbillington:         if name not in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette does not have a palette named %s'%name)
chrisjbillington:         
chrisjbillington:         _, palette, push_button = self._widget_groups[name]
chrisjbillington:         palette.hide()
chrisjbillington:         push_button.setIcon(QIcon(EXPAND_ICON))
chrisjbillington:         push_button.setToolTip('Click to show')
chrisjbillington:     
chrisjbillington:     def hide_palette_by_index(self,index):
chrisjbillington:         self.hide_palette(self.get_name_from_index(index))
chrisjbillington:      
chrisjbillington:     # Creates and inserts a new ToolPalette at the specified index.
chrisjbillington:     # A reference to the new ToolPalette is returned
chrisjbillington:     def insert_new_palette(self,index,name,*args,**kwargs):
chrisjbillington:         # insert ...
chrisjbillington:         pass
chrisjbillington:     
chrisjbillington:     def has_palette(self,name):
chrisjbillington:         if name in self._widget_groups:
chrisjbillington:             return True
chrisjbillington:         return False
chrisjbillington:     
chrisjbillington:     def get_palette(self,name):        
chrisjbillington:         if name not in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette group does not contain a palette named %s'%name)
chrisjbillington:             
chrisjbillington:         return self._widget_groups[name][1]
chrisjbillington:     
chrisjbillington:     def get_palette_by_index(self,index):
chrisjbillington:         return self.get_palette(self.get_name_from_index(index))
chrisjbillington:     
chrisjbillington:     def reorder_palette(self,name,new_index):
chrisjbillington:         if name not in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette group does not contain a palette named %s'%name)
chrisjbillington:             
chrisjbillington:         return self.reorder_palette_by_index(self.get_index_from_name(name),new_index)
chrisjbillington:     
chrisjbillington:     def reorder_palette_by_index(self,old_index,new_index):
chrisjbillington:         if old_index < 0 or old_index >= count(self._widget_groups):
chrisjbillington:             raise RuntimeError('The specified old_index is out of bounds')
chrisjbillington:             
chrisjbillington:         if new_index < 0 or new_index >= count(self._widget_groups):
chrisjbillington:             raise RuntimeError('The specified new_index is out of bounds')    
chrisjbillington:             
chrisjbillington:         # TODO: now perform the reorder
chrisjbillington:         
chrisjbillington:         # TODO: recreate the layout
chrisjbillington:         
chrisjbillington:     def remove(self,name):
chrisjbillington:         if name not in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette group does not contain a palette named %s'%name)
chrisjbillington:             
chrisjbillington:         # TODO: Remove
chrisjbillington:         
chrisjbillington:     def remove_by_index(self,index):
chrisjbillington:        return self.remove(self.get_name_from_index(index))
chrisjbillington:     
chrisjbillington:     def get_name_from_index(self,index):
chrisjbillington:         for name, palette_data in self._widget_groups.items():
chrisjbillington:             if palette_data[0] == index:
chrisjbillington:                 return name
chrisjbillington:                 
chrisjbillington:         raise RuntimeError('The tool palette group does not contain a palette with index %d'%index)
chrisjbillington:         
chrisjbillington:     def get_index_from_name(self,name):
chrisjbillington:         if name not in self._widget_groups:
chrisjbillington:             raise RuntimeError('The tool palette group does not contain a palette named %s'%name)
chrisjbillington:             
chrisjbillington:         return self._widget_groups[name][0]
chrisjbillington:     
chrisjbillington:     ############################################################################################################################
chrisjbillington:     # The code below is related solely to linking the widths of items within several tool palettes that are part of this group #
chrisjbillington:     ############################################################################################################################
chrisjbillington:     
chrisjbillington:     # This property links the widths of all ToolPalettes in the ToolPalette group
chrisjbillington:     # It is a convenience property so that you don't have to create a linked_width_group conatining all Tool palettes in the tool palette group
chrisjbillington:     # and maintain the linked_width_group after ading new Tool Palettes to the Tool Palette Group
chrisjbillington:     @property
chrisjbillington:     def widths_linked(self):
chrisjbillington:         return self._all_widths_linked
chrisjbillington:     
chrisjbillington:     @widths_linked.setter
chrisjbillington:     def widths_linked(self,value):
chrisjbillington:         if self._width_groups and self._all_widths_linked:
chrisjbillington:             raise RuntimeError('You cannot link the widths of all tool palettes if you have already created a linked width group')
chrisjbillington:     
chrisjbillington:         self._all_widths_linked = value
chrisjbillington:     
chrisjbillington:     # This function links the widths of items in several ToolPalettes.
chrisjbillington:     def create_linked_width_group(self,width_group_name,names):
chrisjbillington:         if self._all_widths_linked:
chrisjbillington:             raise RuntimeError('You cannot create a linked_width_group if you have already linked all widths via the widths_linked_property')
chrisjbillington:     
chrisjbillington:         if width_group_name in self._width_groups:
chrisjbillington:             raise RuntimeError('The tool palette group already has a width group named %s'%width_group_name)
chrisjbillington:         
chrisjbillington:         # check if anything in names is already in another width group
chrisjbillington:         for width_group_name,width_group_data in self._width_groups.items():
chrisjbillington:             for name in names:
chrisjbillington:                 if name in width_group_data[1]:
chrisjbillington:                     raise RuntimeError('The tool pallete named %s is already in the linked width group %s'%(name,width_group_name))
chrisjbillington:         
chrisjbillington:         # create width group
chrisjbillington:         self._width_groups[width_group_name] = (self._create_find_max_function(width_group_name),names)
chrisjbillington:     
chrisjbillington:     # This function adds the toolpallete called 'name' to the linked_width_group 'width_group_name'
chrisjbillington:     def add_to_linked_width_group(self,width_group_name,name):
chrisjbillington:         if self._all_widths_linked:
chrisjbillington:             raise RuntimeError('You cannot add to a linked_width_group if you have already linked all widths via the widths_linked_property')
chrisjbillington:             
chrisjbillington:         if width_group_name not in self._width_groups:
chrisjbillington:             raise RuntimeError('The tool palette group does not have a width group named %s'%width_group_name)
chrisjbillington:     
chrisjbillington:         for width_group_name,width_group_data in self._width_groups.items():
chrisjbillington:             if name in width_group_data[1]:
chrisjbillington:                 raise RuntimeError('The tool pallete named %s is already in the linked width group %s'%(name,width_group_name))
chrisjbillington:         
chrisjbillington:         self._width_groups[width_group_name][1].append(name)
chrisjbillington:         # recreate the find_max_item_width function
chrisjbillington:         self._width_groups[width_group_name] = (self._create_find_max_function(width_group_name),self._width_groups[width_group_name][1])
chrisjbillington:     
chrisjbillington:     def remove_from_linked_width_group(self,width_group_name,name):
chrisjbillington:         pass
chrisjbillington:         #TODO:
chrisjbillington:     
chrisjbillington:     # This function creates and returns a reference to a function which finds the widest item in all Tool palettes in the specified
chrisjbillington:     # linked_width_group.
chrisjbillington:     def _create_find_max_function(self,width_group_name):
chrisjbillington:         def find_max_item_width():
chrisjbillington:             largest_item_width = 0
chrisjbillington:             for tp_name in self._width_groups[width_group_name][1]:
chrisjbillington:                 item_width = self._widget_groups[tp_name][1]._find_max_item_width()
chrisjbillington:                 if item_width > largest_item_width:
chrisjbillington:                     largest_item_width = item_width                    
chrisjbillington:             return largest_item_width            
chrisjbillington:         return find_max_item_width
chrisjbillington:         
chrisjbillington:     # This function gives the tool palletes a function to call to find out the widest item in their linked_width_group
chrisjbillington:     def _find_max_item_width(self,name):
chrisjbillington:         if self._all_widths_linked:
chrisjbillington:             return lambda: max([palette[1]._find_max_item_width() for palette in self._widget_groups.values()])
chrisjbillington:             
chrisjbillington:         # Look up to see if the tool palette is in a linked_width_group
chrisjbillington:         width_group = None
chrisjbillington:         for width_group_name,width_group_list in self._width_groups.items():
chrisjbillington:             if name in width_group_list[1]:
chrisjbillington:                 width_group = width_group_name
chrisjbillington:                 break
chrisjbillington:         
chrisjbillington:         if width_group:
chrisjbillington:             return self._width_groups[width_group][0]
chrisjbillington:         else:
chrisjbillington:             return self._widget_groups[name][1]._find_max_item_width
chrisjbillington:         
chrisjbillington:         
chrisjbillington: class ToolPalette(QScrollArea):
chrisjbillington:     def __init__(self,parent,name,*args,**kwargs):
chrisjbillington:         QScrollArea.__init__(self,*args,**kwargs)
chrisjbillington:         self.setSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.Minimum)
           Chris:         self.setFrameStyle(QFrame.NoFrame)
chrisjbillington:         # create the grid layout
chrisjbillington:         #self.setWidget(QWidget(self))
chrisjbillington:         #self.widget().setSizePolicy(QSizePolicy.Preferred,QSizePolicy.Preferred)
chrisjbillington:         self._layout = QGridLayout(self) 
chrisjbillington:         self._layout.setContentsMargins(3,0,3,3)
           Chris:         self._layout.setHorizontalSpacing(3)
           Chris:         self._layout.setVerticalSpacing(3)
chrisjbillington:         #self._layout.setMaximumSize(QSize(524287,524287))
chrisjbillington:         #self._layout.setSizeConstraint(QLayout.SetMinAndMaxSize)
chrisjbillington:         self._widget_list = []
chrisjbillington:         self._parent_group = parent
chrisjbillington:         self._name = name
chrisjbillington:         
chrisjbillington:         # need to keep track of these internally because the GridLayout returns the number of 
chrisjbillington:         # allocated rows/columns with columnCount()/RowCount() rather than the number of visible ones
chrisjbillington:         self._column_count = 0
chrisjbillington:         self._row_count = 0
chrisjbillington:         
chrisjbillington:     def addWidget(self,widget,force_relayout=True):
chrisjbillington:         # Append to end of tool pallete
chrisjbillington:         #widget.clicked.connect(embed)
chrisjbillington:         self._widget_list.append(widget)
chrisjbillington:         self._layout_widgets(force_relayout)
chrisjbillington:         
chrisjbillington:     def insertWidget(self,index,widget,force_relayout=True):
chrisjbillington:         # Insert into position 'index'
chrisjbillington:         self._widget_list.insert(index,widget)
chrisjbillington:         self._layout_widgets(force_relayout)
chrisjbillington:     
chrisjbillington:     def _find_max_item_width(self):
chrisjbillington:         # find the minimum size of the widest widget in the grid layout
chrisjbillington:         w_size_hints = [w.minimumSizeHint().width() for w in self._widget_list]
chrisjbillington:         if len(w_size_hints) < 1:
chrisjbillington:             return 0
chrisjbillington:         max_width = max(w_size_hints)
chrisjbillington:         return max_width
chrisjbillington:     
chrisjbillington:     def _layout_widgets(self,force_relayout = False):
chrisjbillington:         h_size_hints = [w.sizeHint().height() for w in self._widget_list]
chrisjbillington:         max_width = self._parent_group._find_max_item_width(self._name)()
chrisjbillington:         
chrisjbillington:         # find the width of the gridlayout
chrisjbillington:         layout_width = self.size().width()
chrisjbillington:         #layout_width = self._layout.sizeHint().width()
chrisjbillington:         layout_spacing = self._layout.horizontalSpacing()
chrisjbillington:         
chrisjbillington:         # How many widgets can fit in a row?
chrisjbillington:         # TODO: Work out hwy I need layout_spacing*3 here (we are getting the width of the scroll area, 
chrisjbillington:         # so need to take into account the borders around the grid layout? What are they?)
chrisjbillington:         num_widgets_per_row = (layout_width-layout_spacing*3)//(max_width+layout_spacing)
     janwerkmann: 
chrisjbillington:         # print self._name
chrisjbillington:         # print 'number_of_widgets: %d'%len(self._widget_list)
chrisjbillington:         # print 'layout_width: %d'%layout_width
chrisjbillington:         # print 'layout_spacing: %d'%layout_spacing
chrisjbillington:         # print 'max_width: %d'%max_width
chrisjbillington:         # print '(layout_width-layout_spacing*3)/(max_width+layout_spacing): %.3f'%((layout_width-layout_spacing*3)/(max_width+layout_spacing))
chrisjbillington:         # print 'num_widgets_per_row: %d'%num_widgets_per_row 
chrisjbillington:         
chrisjbillington:         if num_widgets_per_row < 1:
chrisjbillington:             num_widgets_per_row = 1
chrisjbillington:         elif num_widgets_per_row > len(self._widget_list):
chrisjbillington:             num_widgets_per_row = len(self._widget_list)
chrisjbillington:             
chrisjbillington:         if num_widgets_per_row != self._column_count or force_relayout:            
chrisjbillington:             #print 'changing number of columns'
chrisjbillington:             # remove all widgets
chrisjbillington:             for widget in self._widget_list:
chrisjbillington:                 self._layout.removeWidget(widget)
chrisjbillington:             
chrisjbillington:             # re add all widgets into the grid layout
chrisjbillington:             row = 0
chrisjbillington:             column = 0
chrisjbillington:             for widget in self._widget_list:
chrisjbillington:                 self._layout.addWidget(widget,row,column)
chrisjbillington:                 column += 1
chrisjbillington:                 if column >= num_widgets_per_row:
chrisjbillington:                     column = 0
chrisjbillington:                     row += 1
chrisjbillington:                     
chrisjbillington:             # This is here because the row count may have been increased at the end of the insertion
chrisjbillington:             # loop
chrisjbillington:             if column != 0:
chrisjbillington:                 row += 1
chrisjbillington:             # update the row/column count
chrisjbillington:             self._column_count = num_widgets_per_row
chrisjbillington:             self._row_count = row
chrisjbillington:             
chrisjbillington:             # print (max(h_size_hints)+self._layout.verticalSpacing())*self._row_count+self._layout.verticalSpacing()*2
chrisjbillington:             # print max(h_size_hints)
chrisjbillington:             # print self._layout.verticalSpacing()
chrisjbillington:             # print self._row_count
chrisjbillington:             
chrisjbillington:             total_height = max(h_size_hints) * self._row_count
chrisjbillington:             total_height += self._layout.verticalSpacing() * (self._row_count - 1)
chrisjbillington:             total_height += self._layout.contentsMargins().top()
chrisjbillington:             total_height += self._layout.contentsMargins().bottom()
chrisjbillington:             self.setMinimumSize(QSize(self.minimumSize().width(), total_height))
chrisjbillington:             for i in range(self._layout.rowCount()):
chrisjbillington:                 if i < self._row_count:
chrisjbillington:                     self._layout.setRowMinimumHeight(i,max(h_size_hints))
chrisjbillington:                 else:
chrisjbillington:                     self._layout.setRowMinimumHeight(i,0)
chrisjbillington:         
chrisjbillington: 
chrisjbillington:     def minimumSize(self):
chrisjbillington:         # Get the widgets minimum size:
chrisjbillington:         widget_size = QWidget.minimumSize(self)
chrisjbillington:         
chrisjbillington:         # now get the smallest minimum size width of all child widgets:
chrisjbillington:         widths = [w.minimumSizeHint().width() for w in self._widget_list]
chrisjbillington:         #heights = [w.minimumSize().height() for w in self._widget_list]
chrisjbillington:         #print 'number of widgets %d'%len(self._widget_list)
chrisjbillington:         if len(widths) > 0:
chrisjbillington:             max_width = max(widths)
chrisjbillington:             #print 'max_width: %d'%max_width
chrisjbillington:             #print 'widget width: %d'%widget_size.width()
chrisjbillington:             if max_width > widget_size.width():
chrisjbillington:                 widget_size = QSize(max_width,widget_size.height())
chrisjbillington:                 #print 'modifying minimum size width'
chrisjbillington:         
chrisjbillington:         #print 'minimum size is %s'%str(widget_size)
chrisjbillington:             
chrisjbillington:         return widget_size
chrisjbillington:         
chrisjbillington:     def updateMinimumSize(self):
chrisjbillington:         self.setMinimumSize(self.minimumSize())
chrisjbillington:         
chrisjbillington:     def sizeHint(self):
chrisjbillington:         width = QScrollArea.sizeHint(self).width()
chrisjbillington:         height = self.minimumSize().height()
chrisjbillington:         return QSize(width, height)
chrisjbillington: 
chrisjbillington:     def minimumSizeHint(self):
chrisjbillington:         width = QScrollArea.minimumSizeHint(self).width()
chrisjbillington:         height = self.minimumSize().height()
chrisjbillington:         return QSize(width, height)
chrisjbillington: 
chrisjbillington:     def resizeEvent(self, event):
chrisjbillington:         # overwrite the resize event!
chrisjbillington:         # print '--------- %s'%self._name
chrisjbillington:         # print self._widget_list[0].size()
chrisjbillington:         # print self._widget_list[0].sizeHint()
chrisjbillington:         # print self._widget_list[0].minimumSizeHint()
chrisjbillington:         # print self._layout.rowMinimumHeight(0)
chrisjbillington:         # print self.size()
chrisjbillington:         # print self.minimumSize()
chrisjbillington:         # print self.sizeHint()
chrisjbillington:         # print self.minimumSizeHint()
chrisjbillington:         #pass resize event on to qwidget
chrisjbillington:         # call layout()
           Chris:         QWidget.resizeEvent(self, event)
chrisjbillington:         size = event.size()
           Chris:         if size.width() == self.size().width() and size.height() == self.size().height():
chrisjbillington:             # print 'relaying out widgets'
chrisjbillington:             self._layout_widgets()
chrisjbillington: 
chrisjbillington: 
chrisjbillington: # A simple test!
chrisjbillington: if __name__ == '__main__':
chrisjbillington:     
chrisjbillington:     qapplication = QApplication(sys.argv)
     janwerkmann: 
     janwerkmann:     from .ddsoutput import DDSOutput
     janwerkmann: 
chrisjbillington:     window = QWidget()
chrisjbillington:     layout = QVBoxLayout(window)
chrisjbillington:     widget = QWidget()
chrisjbillington:     layout.addWidget(widget)
chrisjbillington:     tpg = ToolPaletteGroup(widget)
chrisjbillington:     toolpalette = tpg.append_new_palette('Digital Outputs')
chrisjbillington:     toolpalette2 = tpg.append_new_palette('Digital Outputs 2')
chrisjbillington:     #toolpalette = ToolPalette()
chrisjbillington:     #layout.addWidget(toolpalette)
chrisjbillington:     #layout.addItem(tpg)
chrisjbillington:     #toolpalette.show()
chrisjbillington:     
chrisjbillington:     layout.addItem(QSpacerItem(0,0,QSizePolicy.Minimum,QSizePolicy.MinimumExpanding))
chrisjbillington:     for i in range(20):
chrisjbillington:         #button = QPushButton('Button %d'%i)
chrisjbillington:         button = DDSOutput('DDS %d'%i)
chrisjbillington:         #button.setSizePolicy(QSizePolicy.Minimum,QSizePolicy.Minimum)
chrisjbillington:         toolpalette.addWidget(button)
chrisjbillington:         
chrisjbillington:     for i in range(20):
chrisjbillington:         button = QPushButton('very very long Button %d'%i)
chrisjbillington:         
chrisjbillington:         button.setSizePolicy(QSizePolicy.Minimum,QSizePolicy.Minimum)
chrisjbillington:         toolpalette2.addWidget(button)
chrisjbillington:     
chrisjbillington:     #tpg.create_linked_width_group("Digital outs", ['Digital Outputs','Digital Outputs 2'])
chrisjbillington:     
chrisjbillington:     window.show()
chrisjbillington:     
chrisjbillington:     
chrisjbillington:     sys.exit(qapplication.exec_())
chrisjbillington:     
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # settings.py                                                       #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2013, Monash University                                 #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the labscript suite (see                     #
janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
janwerkmann: # BSD License. See the license.txt file in the root of the project  #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
janwerkmann: 
janwerkmann: try:
janwerkmann:     from labscript_utils import check_version
janwerkmann: except ImportError:
janwerkmann:     raise ImportError('Require labscript_utils > 2.1.0')
janwerkmann: 
janwerkmann: check_version('qtutils', '2.0.0', '3.0.0')
janwerkmann: 
janwerkmann: from qtutils.qt.QtCore import *
janwerkmann: from qtutils.qt.QtGui import *
janwerkmann: from qtutils.qt.QtWidgets import *
   pstarkey: 
janwerkmann: import labscript_utils.h5_lock, h5py
   cbilling: from labscript_utils.qtwidgets.fingertab import FingerTabWidget
   pstarkey: 
   pstarkey: # Create a generic interface for displaying pages of settings
   pstarkey: class Settings(object):
   pstarkey:     
   pstarkey:     def __init__(self,storage='hdf5',file=None,parent = None,page_classes = []):
   pstarkey:         self.pages = {}
   pstarkey:         self.instantiated_pages = {}
   pstarkey:         self.dialog_open = False
   pstarkey:         self.parent = parent
   pstarkey:         self.storage = storage
   pstarkey:         self.file = file
   pstarkey:         self.callback_list = []
   pstarkey:         
   pstarkey:         if not self.file:
   pstarkey:             raise Exception('You must specify a file to load/save preferences from')
   pstarkey:         
   pstarkey:         for c in page_classes:
   pstarkey:             self.add_settings_interface(c)
   pstarkey:             
   pstarkey:     # This function can be called to add a interface
   pstarkey:     # Each one of these will display as a seperate page in the settings window
   pstarkey:     # You can not add a class more than once!
   pstarkey:     # Classes must have unique Class.name attributes! (This might change later...)
   pstarkey:     def add_settings_interface(self,setting_class):
   pstarkey:         if setting_class.name in self.pages:
   pstarkey:             return False
   pstarkey:                    
   pstarkey:         self.pages[setting_class.name] = setting_class(self.load(setting_class.name))   
   pstarkey:         return True
   pstarkey:         
   pstarkey:     def load(self,name):
   pstarkey:         if self.storage == 'hdf5':
   pstarkey:             with h5py.File(self.file,'r+') as h5file: 
   pstarkey:                 # does the settings group exist?
   pstarkey:                 if 'preferences' not in h5file:
   pstarkey:                     h5file['/'].create_group('preferences')
   pstarkey:                     
   pstarkey:                 # is there an entry for this preference type?
   pstarkey:                 group = h5file['/preferences']
   pstarkey:                 if name not in group.attrs:
janwerkmann:                     group.attrs[name] = repr({})
   pstarkey:                 try:
janwerkmann:                     data = eval(group.attrs[name])
janwerkmann:                 except Exception:
janwerkmann:                     # TODO: log this properly
janwerkmann:                     print('Could not load settings data for %s. It may contain data that could not be evaluated. All settings have now been lost'%name)
janwerkmann:                     data = {}
janwerkmann:             return data
   pstarkey:         else:
   pstarkey:             raise Exception("the Settings module cannot handle the storage type: %s"%str(self.storage))
   pstarkey:         
   pstarkey:     # A simple interface for accessing values in the settings interface
   pstarkey:     def get_value(self,settings_class,value_name):
   pstarkey:         return self.pages[settings_class.name].get_value(value_name)
   pstarkey:         
   pstarkey:     # goto_page should be the CLASS which you wish to go to!
   pstarkey:     def create_dialog(self,goto_page=None):
   pstarkey:         if not self.dialog_open:
   pstarkey:             self.instantiated_pages = {}
   pstarkey:             
   pstarkey:             # Create the dialog
   pstarkey:             self.dialog = QDialog(self.parent)
   pstarkey:             self.dialog.setModal(True)
   pstarkey:             self.dialog.accepted.connect(self.on_save)
   pstarkey:             self.dialog.rejected.connect(self.on_cancel)
   pstarkey:             self.dialog.setMinimumSize(800,600)
   pstarkey:             self.dialog.setWindowTitle("Preferences")
   pstarkey:             # Remove the help flag next to the [X] close button
   pstarkey:             self.dialog.setWindowFlags(self.dialog.windowFlags() & ~Qt.WindowContextHelpButtonHint)
   pstarkey:             
   pstarkey:             # Create the layout
   pstarkey:             layout = QVBoxLayout(self.dialog)
   pstarkey:             #Create the Notebook
   pstarkey:             self.notebook = FingerTabWidget(self.dialog)            
   pstarkey:             self.notebook.setTabPosition(QTabWidget.West)
   pstarkey:             self.notebook.show() 
   pstarkey:             layout.addWidget(self.notebook)
   pstarkey:             
   pstarkey:             # Create the button box
   pstarkey:             widget = QWidget()
   pstarkey:             hlayout = QHBoxLayout(widget)
   pstarkey:             button_box = QDialogButtonBox()
   pstarkey:             button_box.setStandardButtons(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
   pstarkey:             button_box.accepted.connect(self.dialog.accept)
   pstarkey:             button_box.rejected.connect(self.dialog.reject)
   pstarkey:             hlayout.addItem(QSpacerItem(0,0,QSizePolicy.MinimumExpanding,QSizePolicy.Minimum))
   pstarkey:             hlayout.addWidget(button_box)
   pstarkey:             layout.addWidget(widget)
   pstarkey:             
   pstarkey:             #sorted(a.items(),key=lambda x: x[1])
   pstarkey:             set_page = None
   pstarkey:             #self.temp_pages = []
   pstarkey:             for name, c in sorted(self.pages.items()):
   pstarkey:                 page,icon = c.create_dialog(self.notebook)
   pstarkey:                 
   pstarkey:                 # save page
   pstarkey:                 self.instantiated_pages[c.__class__] = page
   pstarkey:                 
   pstarkey:                 # Create label
   pstarkey:                 #if isinstance(icon,gtk.Image):
   pstarkey:                     # use their icon
   pstarkey:                 #    pass
   pstarkey:                 #else:
   pstarkey:                     # use default icon
   pstarkey:                 #    pass
   pstarkey:                     
   pstarkey:                 self.notebook.addTab(page,c.name)
   pstarkey:                 
   pstarkey:                 if goto_page and isinstance(c,goto_page):
   pstarkey:                     # this is the page we want to go to!
   pstarkey:                     set_page = page
   pstarkey:         
   pstarkey:             # We do this here in case one of the settings pages specifically inserts itself in an out of order place (eg first)
   pstarkey:             # We hope that everything will be in alphabetical order, but maybe not!
   pstarkey:             if set_page:
   pstarkey:                 self.notebook.tabBar().setCurrentIndex(self.notebook.indexOf(set_page))
   pstarkey:                 pass
   pstarkey:             
   pstarkey:             self.dialog.show()
   pstarkey:             self.dialog_open = True
   pstarkey:         else:
   pstarkey:             if goto_page and goto_page in self.instantiated_pages:
   pstarkey:                 self.notebook.tabBar().setCurrentIndex(self.notebook.indexOf(self.instantiated_pages[goto_page]))
   pstarkey:                 
   pstarkey:     
   pstarkey:     def register_callback(self,callback):
   pstarkey:         self.callback_list.append(callback)
   pstarkey:         
   pstarkey:     def remove_callback(self,callback):
   pstarkey:         self.callback_list.remove(callback)
   pstarkey:     
   pstarkey:     def on_save(self,*args,**kwargs):
   pstarkey:         # Save the settings
   pstarkey:         if self.storage == 'hdf5':
   pstarkey:             with h5py.File(self.file,'r+') as h5file:
   pstarkey:                 group = h5file['/preferences']
   pstarkey:                 for page in self.pages.values():
   pstarkey:                     group.attrs[page.__class__.name] = repr(page.save()) 
   pstarkey:         else:
   pstarkey:             # this should never happen as the exception will have been raised on load!
   pstarkey:             pass
   pstarkey:             
   pstarkey:         # run callback functions!
   pstarkey:         # Notifies other areas of the program that settings have changed
   pstarkey:         for callback in self.callback_list:
   pstarkey:             callback()
   pstarkey:         
   pstarkey:         self.close()
   pstarkey:             
   pstarkey:     def on_cancel(self,*args,**kwargs):
   pstarkey:         self.close()
   pstarkey:     
   pstarkey:     def close(self,*args,**kwargs):
   pstarkey:         if self.dialog_open:
   pstarkey:             # Close the setting classes
   pstarkey:             for page in self.pages.values():
   pstarkey:                 page.close()   
   cbilling:             self.dialog_open = False
   pstarkey:             self.dialog.deleteLater()
   pstarkey:             self.dialog = None
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /setup_logging.py                                                 #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        cbilling: # This file is part of labscript_utils, in the labscript suite      #
        pstarkey: # (see http://labscriptsuite.org), and is licensed under the        #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: 
        pstarkey: import sys, os
        pstarkey: import logging, logging.handlers
        pstarkey: import __main__
        pstarkey: 
          rander: 
chrisjbillington: class LessThanFilter(logging.Filter):
chrisjbillington:     def __init__(self, less_than):
chrisjbillington:         self.less_than = less_than
chrisjbillington:         logging.Filter.__init__(self)
chrisjbillington:     def filter(self, record):
chrisjbillington:         return record.levelno < self.less_than
chrisjbillington: 
chrisjbillington: 
          rander: def setup_logging(program_name, log_level=logging.DEBUG, terminal_level=logging.INFO, maxBytes=1024*1024*50, backupCount=1):
        pstarkey:     logger = logging.getLogger(program_name)
chrisjbillington:     # Clear any previously added handlers from the logger:
chrisjbillington:     for handler in logger.handlers[:]:
chrisjbillington:         logger.removeHandler(handler)
           Chris:     try:
           Chris:         try:
           Chris:             program_module = __import__(program_name)
           Chris:         except ImportError:
           Chris:             program_module = __import__(program_name.lower())
           Chris:         main_path = program_module.__file__
           Chris:     except ImportError:
           Chris:         main_path = __main__.__file__ if hasattr(__main__, '__file__') else __file__
           Chris: 
          rander:     log_dir = os.path.dirname(os.path.realpath(main_path))
          rander:     log_path = os.path.join(log_dir, '%s.log' % program_name)
          rander:     handler = logging.handlers.RotatingFileHandler(log_path, maxBytes=maxBytes, backupCount=backupCount)
        pstarkey:     formatter = logging.Formatter('%(asctime)s %(levelname)s %(name)s: %(message)s')
        pstarkey:     handler.setFormatter(formatter)
        pstarkey:     handler.setLevel(log_level)
        pstarkey:     logger.addHandler(handler)
chrisjbillington:     if sys.stdout is not None and sys.stdout.fileno() >= 0:
chrisjbillington:         stdout_handler = logging.StreamHandler(sys.stdout)
chrisjbillington:         stdout_handler.setFormatter(formatter)
chrisjbillington:         stdout_handler.setLevel(terminal_level)
chrisjbillington:         logger.addHandler(stdout_handler)
chrisjbillington:         if sys.stderr is not None and sys.stderr.fileno() >= 0:
chrisjbillington:             # Send warnings and greater to stderr instead of stdout:
chrisjbillington:             stdout_handler.addFilter(LessThanFilter(logging.WARNING))
chrisjbillington:             sterr_handler = logging.StreamHandler(sys.stderr)
chrisjbillington:             sterr_handler.setFormatter(formatter)
chrisjbillington:             sterr_handler.setLevel(logging.WARNING)
chrisjbillington:             logger.addHandler(sterr_handler)
        pstarkey:     else:
        pstarkey:         # Prevent bug on windows where writing to stdout without a command
        pstarkey:         # window causes a crash:
          rander:         sys.stdout = sys.stderr = open(os.devnull, 'w')
        pstarkey:     logger.setLevel(logging.DEBUG)
        pstarkey:     return logger
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # shared_drive.py                                                   #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
   cbilling: import os
   cbilling: from labscript_utils.labconfig import LabConfig
   cbilling: 
   cbilling: _config = LabConfig(required_params={'paths':['shared_drive']})
   cbilling: prefix = _config.get('paths','shared_drive')
   cbilling: 
   cbilling: # ensure prefix ends with a slash:
   cbilling: if not prefix.endswith(os.path.sep):
   cbilling:     prefix += os.path.sep
   cbilling:     
   cbilling: def path_to_agnostic(path):
   cbilling:     path = os.path.abspath(path)
   cbilling:     if path.startswith(prefix):
   cbilling:         path = path.split(prefix, 1)[1]
   cbilling:         path = 'Z:\\' + path
   martijnj:         path = path.replace(os.path.sep, '\\')
   cbilling:     return path
   cbilling:     
   cbilling: def path_to_local(path):
   cbilling:     if path.startswith('Z:\\'):
   cbilling:         path = path.split('Z:\\', 1)[1]
   cbilling:         path = path.replace('\\', os.path.sep)
   cbilling:         path = os.path.join(prefix, path)
   cbilling:     return path
   cbilling: 
   cbilling: if __name__ == '__main__':
   cbilling:     # test: 
   cbilling:     path = os.path.join(prefix, 'foo','bar','baz')
   cbilling:     agnostic_path = path_to_agnostic(path)
   cbilling:     local_path = path_to_local(agnostic_path)
   cbilling:     assert local_path == path
chrisjbillington: #####################################################################
chrisjbillington: #                                                                   #
chrisjbillington: # testing_utils.py                                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # Copyright 2017, Chris Billington                                  #
chrisjbillington: #                                                                   #
chrisjbillington: # This file is part of the labscript suite (see                     #
chrisjbillington: # http://labscriptsuite.org) and is licensed under the Simplified   #
chrisjbillington: # BSD License. See the license.txt file in the root of the project  #
chrisjbillington: # for the full license.                                             #
chrisjbillington: #                                                                   #
chrisjbillington: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
chrisjbillington: 
chrisjbillington: import os
chrisjbillington: import sys
chrisjbillington: import time
chrisjbillington: import threading
chrisjbillington: import unittest
           Chris: if PY2:
chrisjbillington:     import Queue as queue
chrisjbillington:     import mock
chrisjbillington: else:
chrisjbillington:     import queue
chrisjbillington:     import unittest.mock as mock
chrisjbillington: 
chrisjbillington: from unittest import TestCase
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class monkeypatch(object):
chrisjbillington:     """Context manager to temporarily monkeypatch an object attribute with
chrisjbillington:     some mocked attribute"""
chrisjbillington: 
chrisjbillington:     def __init__(self, obj, name, mocked_attr):
chrisjbillington:         self.obj = obj
chrisjbillington:         self.name = name
chrisjbillington:         self.real_attr = getattr(obj, name)
chrisjbillington:         self.mocked_attr = mocked_attr
chrisjbillington: 
chrisjbillington:     def __enter__(self):
chrisjbillington:         setattr(self.obj, self.name, self.mocked_attr)
chrisjbillington: 
chrisjbillington:     def __exit__(self, *args):
chrisjbillington:         setattr(self.obj, self.name, self.real_attr)
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class dotdict(dict):
chrisjbillington:     """dot.notation access to dictionary attributes"""
chrisjbillington:     __getattr__ = dict.get
chrisjbillington:     __setattr__ = dict.__setitem__
chrisjbillington:     __delattr__ = dict.__delitem__
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class Any(object):
chrisjbillington:     """A class whose instances equal any object of the given type or tuple of
chrisjbillington:     types. For use with mock.Mock.assert_called_with when you don't care what
chrisjbillington:     some of the arguments are"""
chrisjbillington:     def __init__(self, types=object):
chrisjbillington:         if isinstance(types, type):
chrisjbillington:             self.types = (types,)
chrisjbillington:         else:
chrisjbillington:             self.types = types
chrisjbillington: 
chrisjbillington:     def __eq__(self, other):
chrisjbillington:         return any(isinstance(other, type_) for type_ in self.types)
chrisjbillington: 
chrisjbillington: # Instance of Any() that does not specify type:
chrisjbillington: ANY = Any()
chrisjbillington: 
chrisjbillington: 
chrisjbillington: class ThreadTestCase(TestCase):
chrisjbillington:     """Test case that runs tests in a new thread whilst providing a mainloop
chrisjbillington:     that allows running scripts in the current thread. Those scripts can then
chrisjbillington:     be tested from the testing thread."""
chrisjbillington: 
chrisjbillington:     def __init__(self, *args, **kwargs):
chrisjbillington:         TestCase.__init__(self, *args, **kwargs)
chrisjbillington:         self._thread_return_value = queue.Queue()
chrisjbillington:         self._command_queue = queue.Queue()
chrisjbillington: 
chrisjbillington:     def run_script_as_main(self, filepath):
chrisjbillington:         globals_dict = dotdict()
chrisjbillington:         self._command_queue.put([filepath, globals_dict])
chrisjbillington:         return globals_dict
chrisjbillington: 
chrisjbillington:     def quit_mainloop(self):
chrisjbillington:         self._command_queue.put([None, None])
chrisjbillington: 
chrisjbillington:     def _run(self, *args, **kwargs):
chrisjbillington:         """Called in a thread to run the tests"""
chrisjbillington:         exception = None
chrisjbillington:         try:
chrisjbillington:             print('about to run')
chrisjbillington:             result = TestCase.run(self, *args, **kwargs)
chrisjbillington:         except:
chrisjbillington:             print('got exception')
chrisjbillington:             self.quit_mainloop()
chrisjbillington:             # Store for re-raising the exception in the calling thread:
chrisjbillington:             exception = sys.exc_info()
chrisjbillington:             result = None
chrisjbillington:         finally:
chrisjbillington:             self._thread_return_value.put([result, exception])
chrisjbillington: 
chrisjbillington:     def run(self, *args, **kwargs):
chrisjbillington:         test_thread = threading.Thread(target=self._run, args=args, kwargs=kwargs)
chrisjbillington:         test_thread.start()
           Chris:         self._mainloop()
chrisjbillington:         test_thread.join()
chrisjbillington:         result, exception = self._thread_return_value.get()
chrisjbillington:         if exception is not None:
chrisjbillington:             type, value, traceback = exception
           Chris:             if PY2:
chrisjbillington:                 exec('raise type, value, traceback')
chrisjbillington:             else:
chrisjbillington:                 raise value.with_traceback(traceback)
chrisjbillington:         return result
chrisjbillington: 
           Chris:     def _mainloop(self):
chrisjbillington:         while True:
chrisjbillington:             filepath, globals_dict = self._command_queue.get()
chrisjbillington:             if filepath is None:
chrisjbillington:                 break
chrisjbillington:             
           Chris:             if PY2:
chrisjbillington:                 filepath_native_string = filepath.encode(sys.getfilesystemencoding())
chrisjbillington:             else:
chrisjbillington:                 filepath_native_string = filepath
chrisjbillington: 
chrisjbillington:             globals_dict['__name__'] ='__main__'
chrisjbillington:             globals_dict['__file__']= os.path.basename(filepath_native_string)
chrisjbillington:                                        
chrisjbillington:             # Save the current working directory before changing it to the
chrisjbillington:             # location of the script:
chrisjbillington:             cwd = os.getcwd()
chrisjbillington:             os.chdir(os.path.dirname(filepath))
chrisjbillington: 
chrisjbillington:             # Run the script:
chrisjbillington:             try:
chrisjbillington:                 with open(filepath) as f:
chrisjbillington:                     code = compile(f.read(), os.path.basename(filepath_native_string),
chrisjbillington:                                    'exec', dont_inherit=True)
chrisjbillington:                     exec(code, globals_dict)
chrisjbillington:             finally:
chrisjbillington:                 os.chdir(cwd)
chrisjbillington: 
chrisjbillington:     @staticmethod
chrisjbillington:     def wait_for(condition_func, timeout=5,
chrisjbillington:                  initial_poll_interval=0.005, max_poll_interval=0.5):
chrisjbillington:         """Busy wait for a condition to be true. Uses exponential backoff so
chrisjbillington:         it's fast when things are fast and not a complete hog when they're
chrisjbillington:         not"""
chrisjbillington:         poll_interval = initial_poll_interval
chrisjbillington:         start_time = time.time()
chrisjbillington:         while not condition_func():
chrisjbillington:             if time.time() - start_time > timeout:
chrisjbillington:                 raise Exception
chrisjbillington:             time.sleep(poll_interval)
chrisjbillington:             poll_interval = min(2*poll_interval, max_poll_interval)
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # tracelog.py                                                       #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from labscript_utils import PY2
janwerkmann: if PY2:
janwerkmann:     str = unicode
   cbilling: 
   cbilling: import os, sys
   cbilling: import inspect
   cbilling: import threading
   cbilling: from datetime import datetime
   cbilling: import traceback 
   cbilling: 
   cbilling: def log(log_path=None, module_names=(), sub=False, all=False, mode='w'):
   cbilling:     """Trace and log Python execution.
   cbilling:     
   cbilling:     output includes the time, thread name, containing function name, line number and source line. 
   cbilling:     Indentation before the thread name represents stack depth, indentation before source line is as in the source line itself.
   cbilling:     
   cbilling:     log_path: the path of the desired output file to write to, or None for stdout (default=None)
   cbilling:     module_names: list of module names that tracing is desired for (default=())
   cbilling:     sub: whether submodules of the above modules should be traced (default=False)
   cbilling:     all: whether all modules should be traced, in which case module_names is ignored (default=False)
   cbilling:     mode: mode to open the output file in, if log_path is not None (default='w')
   cbilling:     """
   cbilling:     
   cbilling:     if log_path is None:
   cbilling:         outfile = sys.stdout
   cbilling:     else:
   cbilling:         outfile = open(log_path, mode, 1)
   cbilling:     
   cbilling:     threadlocal = threading.local()
   cbilling:     
   cbilling:     def per_thread_init():
   cbilling:         threadlocal.stack_depth = 0
   cbilling:         threadlocal.threadname = threading.current_thread().name
   cbilling:         threadlocal.is_initialised = True
   cbilling:         
   cbilling:     def write(module_name, lineno, function, message):
   cbilling:         timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3] # chop microseconds to milliseconds
   cbilling:         indentation = ' '*(2*threadlocal.stack_depth - 1)
   cbilling:         output = "[%s]%s%s: %s:%s in %s: " % (timestamp, indentation, threadlocal.threadname, module_name, lineno, function)
   cbilling:         if isinstance(message, list):
   cbilling:             indent = len(output)
   cbilling:             output += message[0]
   cbilling:             for line in message[1:]:
   cbilling:                 output += ' '*indent + line
   cbilling:         else:
   cbilling:             output += message + '\n'
   cbilling:         
   cbilling:         # This is atomic, thanks to the GIL, so we don't need to serialise access from multiple threads:
   cbilling:         outfile.write(output)
   cbilling:         
   cbilling:     def traceit(frame, event, arg):
   cbilling:         if sys is None:
   cbilling:             # Interpreter is shutting down
   cbilling:             return
   cbilling:         try:
   cbilling:             assert threadlocal.is_initialised
   cbilling:         except AttributeError:
   cbilling:             per_thread_init()
   cbilling:         if event == "call":
   cbilling:             threadlocal.stack_depth += 1
   cbilling:         elif event == "return":
   cbilling:             threadlocal.stack_depth -= 1
   cbilling:         else:
   cbilling:             filename, lineno, function, code_context, index = inspect.getframeinfo(frame, context=1)
   cbilling:             try:
   cbilling:                 module_name = frame.f_globals["__name__"]
   cbilling:             except KeyError:
   cbilling:                 module_name = '<string>'
   pstarkey:             if module_name in module_names or all or (sub and any([module_name.startswith(s) for s in module_names])):
   cbilling:                 line = code_context[0].rstrip() if code_context else '<within exec() or eval()>'
   cbilling:                 if event == 'line':
   cbilling:                     write(module_name, lineno, function, line)
   cbilling:                 elif event == 'exception':
   cbilling:                     exc_type, exc_value, _ = arg
   cbilling:                     exception = traceback.format_exception_only(exc_type, exc_value)
   cbilling:                     write(module_name, lineno, function, exception)
   cbilling:         return traceit
   cbilling:              
   cbilling:     per_thread_init()
   cbilling:     write('tracelog','','','\n\n***starting***\n')
   cbilling:     threading.settrace(traceit)
   cbilling:     sys.settrace(traceit)
   cbilling:     
   cbilling:     
   cbilling:     
   cbilling:     
   cbilling: 
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # NovaTechDDS9m.py                                                  #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2013, Monash University                                 #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the labscript suite (see                     #
janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
janwerkmann: # BSD License. See the license.txt file in the root of the project  #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: #####################################################################
janwerkmann: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: from .UnitConversionBase import *
   pstarkey: 
   pstarkey: class NovaTechDDS9mFreqConversion(UnitConversion):
   pstarkey:     # This must be defined outside of init, and must match the default hardware unit specified within the BLACS tab
   pstarkey:     base_unit = 'Hz'
   pstarkey: 
   pstarkey:     def __init__(self,calibration_parameters = None):            
   pstarkey:         self.parameters = calibration_parameters        
   pstarkey:         if hasattr(self,'derived_units'):
   pstarkey:             self.derived_units.append('MHz')
   pstarkey:         else:
   pstarkey:             self.derived_units = ['MHz']        
   pstarkey:         UnitConversion.__init__(self,self.parameters)
   pstarkey: 
   pstarkey:     def MHz_to_base(self,MHz):
   pstarkey:         Hz = MHz*10.0**6
   pstarkey:         return Hz
   pstarkey:     def MHz_from_base(self,Hz):
   pstarkey:         MHz = Hz/10.0**6
   pstarkey:         return MHz
   pstarkey:     
   pstarkey:         
   pstarkey: class NovaTechDDS9mAmpConversion(UnitConversion):
   pstarkey:     # This must be defined outside of init, and must match the default hardware unit specified within the BLACS tab
   pstarkey:     base_unit = 'Arb'
   pstarkey:     
   pstarkey:     def __init__(self,calibration_parameters = None):            
   pstarkey:         self.parameters = calibration_parameters
   pstarkey:         
   pstarkey:         if hasattr(self,'derived_units'):
   pstarkey:             self.derived_units.append('hardware')
   pstarkey:         else:
   pstarkey:             self.derived_units = ['hardware']        
   pstarkey:         
   pstarkey:         UnitConversion.__init__(self,self.parameters)
   pstarkey: 
   pstarkey:     def hardware_to_base(self,hardware):
   pstarkey:         arb = hardware/1023.0
   pstarkey:         return arb
   pstarkey:     def hardware_from_base(self,arb):
   pstarkey:         hardware = arb*1023.0
   pstarkey:         return hardware
     janwerkmann: # -*- coding: UTF-8 -*-
     janwerkmann: #####################################################################
     janwerkmann: #                                                                   #
     janwerkmann: # UnitConversionBase.py                                             #
     janwerkmann: #                                                                   #
     janwerkmann: # Copyright 2013, Monash University                                 #
     janwerkmann: #                                                                   #
     janwerkmann: # This file is part of the labscript suite (see                     #
     janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
     janwerkmann: # BSD License. See the license.txt file in the root of the project  #
     janwerkmann: # for the full license.                                             #
     janwerkmann: #                                                                   #
     janwerkmann: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: 
          rander: import copy
     janwerkmann: from types import MethodType
          rander: import math
          rander: from numpy import iterable, array
          rander: 
chrisjbillington: 
chrisjbillington: class _MultiplicativeConversion(object):
chrisjbillington:     """Callable for conversion functions that are just multiplicative
chrisjbillington:        transformations of another conversion function"""
chrisjbillington:     def __init__(self, name, unprefixed_method, factor, to_base):
chrisjbillington:         self.unprefixed_method = unprefixed_method
chrisjbillington:         self.factor = float(factor)
chrisjbillington:         self.to_base = bool(to_base)
chrisjbillington:         self.__name__ = name
chrisjbillington: 
chrisjbillington:     def __get__(self, instance, class_):
chrisjbillington:         """Bind like an instance method"""
chrisjbillington:         return MethodType(self, instance)
chrisjbillington: 
chrisjbillington:     def __call__(self, value):
chrisjbillington:         if self.to_base:
chrisjbillington:             return self.unprefixed_method(value) * self.factor
chrisjbillington:         else:
chrisjbillington:             return self.unprefixed_method(value / self.factor)
chrisjbillington: 
chrisjbillington: 
          rander: def vectorise(method):
          rander:     def f(instance, arg):
          rander:         if iterable(arg):
          rander:             return array([method(instance, el) for el in arg])
          rander:         else:
          rander:             return method(instance, arg)
          rander:     return f
          rander:             
chrisjbillington: 
          rander: class UnitConversion(object):
chrisjbillington:     _magnitude_list = {'p': 1e-12,'n':1e-9, 'u':1e-6,'m': 1e-3,
chrisjbillington:                        'k': 1e3, 'M': 1e6,'G': 1e9,'T': 1e12}
chrisjbillington: 
chrisjbillington:     unit_list = _magnitude_list # alias for backward compat
chrisjbillington: 
chrisjbillington:     def __init__(self, params):
chrisjbillington:         magnitudes = params.get('magnitudes', [])
          rander:         
chrisjbillington:         # Convert any unicode 'mu' symbol to a 'u':
chrisjbillington:         magnitudes = [p if p != '\u03bc' else 'u' for p in magnitudes]
chrisjbillington:         self._magnitudes = {prefix: self._magnitude_list[prefix] for prefix in magnitudes}
chrisjbillington: 
chrisjbillington:         # A list of tuples we will use to sort the list of derived units once
chrisjbillington:         # we produce the units for the provided magnitudes:
chrisjbillington:         derived_units_sortlist = []
chrisjbillington: 
chrisjbillington:         for i, derived_unit in enumerate(self.derived_units):
chrisjbillington:             # Append the unit magnitude derived unit to the list:
chrisjbillington:             sortinfo = (i, 1)
chrisjbillington:             derived_units_sortlist.append((sortinfo, derived_unit))
     janwerkmann: 
chrisjbillington:             # Dynamically create instance methods for each other magnitude:
chrisjbillington:             unprefixed_to_base = getattr(self, derived_unit + "_to_base")
chrisjbillington:             unprefixed_from_base = getattr(self, derived_unit + "_from_base")
chrisjbillington:             for prefix, factor in self._magnitudes.items():
chrisjbillington:                 unit = prefix + derived_unit
chrisjbillington:                 to_base_name = unit + "_to_base"
chrisjbillington:                 from_base_name = unit + "_from_base"
chrisjbillington:                 self.__dict__[to_base_name] = _MultiplicativeConversion(to_base_name, unprefixed_to_base, factor, to_base=True)
chrisjbillington:                 self.__dict__[from_base_name] = _MultiplicativeConversion(from_base_name, unprefixed_from_base, factor, to_base=False)
chrisjbillington: 
chrisjbillington:                 # Append to the sortlist:
chrisjbillington:                 sortinfo = (i, factor)
chrisjbillington:                 derived_units_sortlist.append((sortinfo, unit))
chrisjbillington: 
chrisjbillington:         # Sort derived units first by position of the unit in the original
chrisjbillington:         # list of derived_units without prefixes, then by magnitude:
chrisjbillington:         derived_units_sortlist.sort()
chrisjbillington:         self.derived_units = [unit for sortinfo, unit in derived_units_sortlist]
chrisjbillington: 
chrisjbillington:         self.units = self._magnitudes # alias for backward compat
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # __init__.py                                                       #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: import os
janwerkmann: for module in os.listdir(os.path.split(__file__)[0]):
janwerkmann:     if module.endswith('.py'):
janwerkmann:         exec('from .%s import *'%module[:-3])
janwerkmann: del module
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # aom.py                                                            #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: from .UnitConversionBase import *
janwerkmann: from .NovaTechDDS9m import NovaTechDDS9mAmpConversion
   mikhaile: from numpy import *
   mikhaile: 
   pstarkey: class SineAom(NovaTechDDS9mAmpConversion):
   mikhaile:     """
   mikhaile:     AOM calibration P(A) is very close to a sine for dipole trap AOM!
   mikhaile:     """
   mikhaile:     base_unit = "Arb"
   mikhaile: 
   mikhaile:     def __init__(self, calibration_parameters=None):
   mikhaile:         # These parameters are loaded from a globals.h5 type file automatically
   pstarkey:         self.parameters = calibration_parameters        
   pstarkey:         self.derived_units = ["Power", "fraction"]
   mikhaile:         # P(x) = A * cos(2*pi*f * x + phase) + c
   mikhaile:         # Saturates at saturation Volts
   pstarkey:         self.parameters.setdefault('A', 1.969)
   pstarkey:         self.parameters.setdefault('f', 0.527)
   pstarkey:         self.parameters.setdefault('phase', 3.262)
   pstarkey:         self.parameters.setdefault('c', 1.901)
   mikhaile:         
   pstarkey:         self.parameters['phase'] = self.parameters['phase']%(2*pi)
   pstarkey:         
   pstarkey:         NovaTechDDS9mAmpConversion.__init__(self,self.parameters)
   mikhaile: 
   mikhaile:     def Power_to_base(self, power):
   mikhaile:         A = self.parameters["A"]
   mikhaile:         f = self.parameters["f"]
   mikhaile:         phase = self.parameters["phase"]
   mikhaile:         c = self.parameters["c"]
   pstarkey:         if ((phase / pi) % 2) == 0:
   pstarkey:             phi = (arccos((power - c) / A) - phase) % (2*pi)
   pstarkey:         else:
   pstarkey:             phi = (2*pi - arccos((power - c) / A) - phase) % (2*pi)
   pstarkey:         return phi / (2*pi*f)
   pstarkey:     
   mikhaile:     def Power_from_base(self, amp):
   mikhaile:         A = self.parameters["A"]
   mikhaile:         f = self.parameters["f"]
   mikhaile:         phase = self.parameters["phase"]
   mikhaile:         c = self.parameters["c"]
   mikhaile: 
   pstarkey:         return A * cos(2*pi*f*amp + phase) + c        
   pstarkey: 
   pstarkey:     def fraction_to_base(self, fraction):
   pstarkey:         Pmax = self.parameters["A"] + self.parameters["c"]
   pstarkey:         Pmin = max(self.parameters["c"] - self.parameters["A"], 0)
   pstarkey:         P = (Pmax - Pmin) * fraction + Pmin
   pstarkey:         Amp = self.Power_to_base(P)
   pstarkey:         return Amp
   pstarkey:     
   pstarkey:     def fraction_from_base(self, amp):
   pstarkey:         f = self.parameters["f"]
   pstarkey:         phase = self.parameters["phase"]
   pstarkey:         
   pstarkey:         if 2*pi*f*amp + phase > 2*pi:
   pstarkey:             amp = (2*pi - phase) / (2*pi*f)
   pstarkey:         
   pstarkey:         P = self.Power_from_base(amp)
   pstarkey:         Pmax = self.parameters["A"] + self.parameters["c"]
   pstarkey:         Pmin = max(self.parameters["c"] - self.parameters["A"], 0)
   pstarkey:         fraction = (P - Pmin) / (Pmax - Pmin)
   pstarkey:         return fraction
   pstarkey: 
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # detuning.py                                                       #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: from .UnitConversionBase import *
     rander: 
     rander: class detuning(UnitConversion):
     rander:     base_unit = 'Hz'
     rander:     derived_units = ['MHz', 'd_MHz', 'linewidths']
     rander:     
     rander:     def __init__(self, calibration_parameters=None):            
     rander:         self.parameters = calibration_parameters
     rander:         
     rander:         self.parameters.setdefault('pass', 1)        # specify single- or double-pass with sign
     rander:         self.parameters.setdefault('detuning_0', 0)  # detuning of input light in MHz
     rander:         self.parameters.setdefault('gamma', 6.065)   # natural linewidth in MHz
     rander:         self.parameters.setdefault('aom_f0', False)  # rf frequency corrresponding to resonance in MHz
     rander:         
     rander:         UnitConversion.__init__(self,self.parameters)
     rander: 
     rander:     def MHz_to_base(self, aom_frequency_MHz):
     rander:         return 1e6*aom_frequency_MHz
     rander:         
     rander:     def MHz_from_base(self, aom_frequency):
     rander:         return 1e-6*aom_frequency
     rander:         
     rander:     def d_MHz_to_base(self, detuning_MHz):
     rander:         if not self.parameters['aom_f0']:
     rander:             aom_frequency_MHz = (detuning_MHz - self.parameters['detuning_0'])/self.parameters['pass']
     rander:         else:
     rander:             aom_frequency_MHz = detuning_MHz/self.parameters['pass'] + self.parameters['aom_f0']
     rander:         return self.MHz_to_base(aom_frequency_MHz)
     rander:         
     rander:     def d_MHz_from_base(self, aom_frequency):
     rander:         aom_frequency_MHz = self.MHz_from_base(aom_frequency)
     rander:         if not self.parameters['aom_f0']:
     rander:             detuning_MHz = self.parameters['pass']*aom_frequency_MHz + self.parameters['detuning_0']
     rander:         else:
     rander:             detuning_MHz = self.parameters['pass']*(aom_frequency_MHz - self.parameters['aom_f0']) 
     rander:         return detuning_MHz
     rander:         
     rander:     def linewidths_to_base(self, linewidths):
     rander:         aom_frequency = self.d_MHz_to_base(self.parameters['gamma'] * linewidths)
     rander:         return aom_frequency
     rander:         
     rander:     def linewidths_from_base(self, aom_frequency):
     rander:         linewidths = self.d_MHz_from_base(aom_frequency) / self.parameters['gamma']
     rander:         return linewidths
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # example.py                                                        #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2013, Monash University                                 #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the labscript suite (see                     #
janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
janwerkmann: # BSD License. See the license.txt file in the root of the project  #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
janwerkmann: from .UnitConversionBase import *
   pstarkey: 
   pstarkey: class example1(UnitConversion):
   pstarkey:     # This must be defined outside of init, and must match the default hardware unit specified within the BLACS tab
   pstarkey:     base_unit = 'V'
   pstarkey:     
   pstarkey:     # You can pass a dictionary at class instantiation with some parameters to use in your unit converstion.
   pstarkey:     # You can also place a list of "order of magnitude" prefixes (eg, k, m, M, u, p) you also want available
   pstarkey:     # and the UnitConversion class will automatically generate the conversion function based on the functions 
   pstarkey:     # you specify for the "derived units". This list should be stored in the 'magnitudes' key of the parameters
   pstarkey:     # dictionary
   pstarkey:     
   pstarkey:     def __init__(self,calibration_parameters = None):            
   pstarkey:         self.parameters = calibration_parameters
   pstarkey:         
   pstarkey:         self.derived_units = ['A', 'Gauss']
   pstarkey:         
   pstarkey:         # Set default parameters if they are not speficied in calibration_parameters
   pstarkey:         self.parameters.setdefault('a',2)
   pstarkey:         self.parameters.setdefault('b',3)        
   pstarkey:         
   pstarkey:         UnitConversion.__init__(self,self.parameters)
   pstarkey: 
   pstarkey:     def A_to_base(self,amps):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         volts = amps/self.parameters['a']
   pstarkey:         return volts
   pstarkey:     def A_from_base(self,volts):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         amps = volts * self.parameters['a']
   pstarkey:         return amps
   pstarkey:     def Gauss_to_base(self,gauss):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         volts = gauss/self.parameters['b']
   pstarkey:         return volts
   pstarkey:     def Gauss_from_base(self,volts):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         gauss = (volts)*self.parameters['b']
   pstarkey:         return gauss
   pstarkey:         
   pstarkey: class example2(UnitConversion):
   pstarkey:     # This must be defined outside of init, and must match the default hardware unit specified within the BLACS tab
   pstarkey:     base_unit = 'MHz'
   pstarkey:     
   pstarkey:     # You can pass a dictionary at class instantiation with some parameters to use in your unit converstion.
   pstarkey:     # You can also place a list of "order of magnitude" prefixes (eg, k, m, M, u, p) you also want available
   pstarkey:     # and the UnitConversion class will automatically generate the conversion function based on the functions 
   pstarkey:     # you specify for the "derived units". This list should be stored in the 'magnitudes' key of the parameters
   pstarkey:     # dictionary
   pstarkey:     
   pstarkey:     def __init__(self,calibration_parameters = None):            
   pstarkey:         self.parameters = calibration_parameters
   pstarkey:         
   pstarkey:         self.derived_units = ['detuned_MHz']
   pstarkey:         
   pstarkey:         # Set default parameters if they are not speficied in calibration_parameters
   pstarkey:         self.parameters.setdefault('offset',32.7)      
   pstarkey:         
   pstarkey:         UnitConversion.__init__(self,self.parameters)
   pstarkey: 
   pstarkey:     def detuned_MHz_to_base(self,d_mhz):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         mhz = d_mhz - self.parameters['offset']
   pstarkey:         return mhz
   pstarkey:     def detuned_MHz_from_base(self,mhz):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         d_mhz = mhz + self.parameters['offset']
   pstarkey:         return d_mhz
   pstarkey: 
   pstarkey: class example3(UnitConversion):
   pstarkey:     # This must be defined outside of init, and must match the default hardware unit specified within the BLACS tab
   pstarkey:     base_unit = 'Vpp'
   pstarkey:     
   pstarkey:     # You can pass a dictionary at class instantiation with some parameters to use in your unit converstion.
   pstarkey:     # You can also place a list of "order of magnitude" prefixes (eg, k, m, M, u, p) you also want available
   pstarkey:     # and the UnitConversion class will automatically generate the conversion function based on the functions 
   pstarkey:     # you specify for the "derived units". This list should be stored in the 'magnitudes' key of the parameters
   pstarkey:     # dictionary
   pstarkey:     
   pstarkey:     def __init__(self,calibration_parameters = None):            
   pstarkey:         self.parameters = calibration_parameters
   pstarkey:         
   pstarkey:         self.derived_units = ['W']
   pstarkey:         
   pstarkey:         # Set default parameters if they are not speficied in calibration_parameters
   pstarkey:         self.parameters.setdefault('grad',2)      
   pstarkey:         self.parameters.setdefault('int',0.05)      
   pstarkey:         
   pstarkey:         UnitConversion.__init__(self,self.parameters)
   pstarkey: 
   pstarkey:     def W_to_base(self,watts):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         vpp = float(watts - self.parameters['int'])/self.parameters['grad']
   pstarkey:         return vpp
   pstarkey:     def W_from_base(self,vpp):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         watts = self.parameters['grad']*vpp + self.parameters['int']
   pstarkey:         return watts
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # linear_coil_driver.py                                             #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: from .UnitConversionBase import *
janwerkmann: from numpy import int16
janwerkmann: 
   cbilling: class BidirectionalCoilDriver(UnitConversion):
   cbilling:     base_unit = 'V'
   cbilling:     derived_units = ['A']
   cbilling:     
   cbilling:     def __init__(self, calibration_parameters=None):
   cbilling:         # These parameters are loaded from a globals.h5 type file automatically
   cbilling:         self.parameters = calibration_parameters
   cbilling:         
   cbilling:         # I[A] = slope * V[V] + shift
   cbilling:         # Saturates at saturation Volts
   cbilling:         self.parameters.setdefault('slope', 1) # A/V
   cbilling:         self.parameters.setdefault('shift', 0) # A
   cbilling:         self.parameters.setdefault('saturation', 10) # V
   cbilling:         
   cbilling:         UnitConversion.__init__(self,self.parameters)
   cbilling:         # We should probably also store some hardware limits here, and use them accordingly 
   cbilling:         # (or maybe load them from a globals file, or specify them in the connection table?)
   cbilling: 
   cbilling:     def A_to_base(self,amps):
   cbilling:         #here is the calibration code that may use self.parameters
   cbilling:         volts = (amps - self.parameters['shift']) / self.parameters['slope']
   cbilling:         return volts
   cbilling:         
   cbilling:     def A_from_base(self,volts):
   cbilling:         volts = min(volts, self.parameters['saturation']) # FIXME this doesn't work with ndarrays
   cbilling:         amps = self.parameters['slope'] * volts + self.parameters['shift']
   cbilling:         return amps 
   cbilling:         
   cbilling:         
   cbilling: class UnidirectionalCoilDriver(BidirectionalCoilDriver):
   cbilling:     
   cbilling:     def A_to_base(self,amps):
   cbilling:         return BidirectionalCoilDriver.A_to_base(self, amps)* int16(amps>0)
   cbilling:         
   cbilling:     def A_from_base(self,volts):
   cbilling:         return BidirectionalCoilDriver.A_from_base(self, volts)* int16(volts>0)
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # optotunelens.py                                                   #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2013, Monash University                                 #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the labscript suite (see                     #
janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
janwerkmann: # BSD License. See the license.txt file in the root of the project  #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
janwerkmann: from .UnitConversionBase import *
   pstarkey: from scipy.special import lambertw
   pstarkey: from numpy import exp, abs
   pstarkey: class OptotuneLens(UnitConversion):
   pstarkey:     base_unit = 'V'
   pstarkey:     derived_units = ['distance','I']
   pstarkey:     
   pstarkey:     def __init__(self, calibration_parameters=None):
   pstarkey:         # These parameters are loaded from a globals.h5 type file automatically
   pstarkey:         self.parameters = calibration_parameters
   pstarkey:         
   pstarkey:         # I[A] = slope * V[V] + shift
   pstarkey:         # Saturates at saturation Volts
   pstarkey:         self.parameters.setdefault('current_cal', 0.05) # A/V
   pstarkey:         self.parameters.setdefault('I_Max', 0.3)
   pstarkey:         
   pstarkey:         # we fit the function Pos(I) = a*exp(b*I)+c*I+d
   pstarkey:         self.parameters.setdefault('a', 0)
   pstarkey:         self.parameters.setdefault('b', 0)
   pstarkey:         self.parameters.setdefault('c', 0)
   pstarkey:         
   pstarkey:         UnitConversion.__init__(self,self.parameters)
   pstarkey:         # We should probably also store some hardware limits here, and use them accordingly 
   pstarkey:         # (or maybe load them from a globals file, or specify them in the connection table?)
   pstarkey: 
   pstarkey:     def distance_to_base(self,percentage):
   pstarkey:         #here is the calibration code that may use self.parameters
   pstarkey:         
   pstarkey:         # The inverse function is I = 1/(b*c)(-c*W((a*b/c)*exp((b/c)*P+a))+b/P+ba)
   pstarkey:         # Where W is the product log (Lambert W) function
   pstarkey:         
   pstarkey:         amps = 1.0/(self.parameters['b']*self.parameters['c']) \
   pstarkey:         *(-self.parameters['c']*lambertw((self.parameters['a']*self.parameters['b']/self.parameters['c'])*exp((self.parameters['b']/self.parameters['c'])*(percentage+self.parameters['a']))) \
   pstarkey:         +self.parameters['b']*percentage \
   pstarkey:         +self.parameters['b']*self.parameters['a'])
   pstarkey:         
   pstarkey:         volts = amps/ self.parameters['current_cal']
   pstarkey:         return (volts > 0) * abs(volts)
   pstarkey:         
   pstarkey:     def distance_from_base(self,volts):
   pstarkey:         amps = max(min(self.parameters['current_cal'] * volts,self.parameters['I_Max']),0)
   pstarkey:         
   pstarkey:         percentage = self.parameters['a']*exp(self.parameters['b']*amps) + self.parameters['c']*amps - self.parameters['a']
   pstarkey:         
   pstarkey:         return percentage
   pstarkey: 
   pstarkey:     def I_to_base(self,current):
   pstarkey:         return current/self.parameters['current_cal']
   pstarkey:         
   pstarkey:     def I_from_base(self,volts):
janwerkmann:         return volts*self.parameters['current_cal']
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # quad_driver.py                                                    #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: from .UnitConversionBase import *
     rander: 
     rander: class quad_driver(UnitConversion):
     rander:     base_unit = 'V'
     rander:     derived_units = ['A', 'Gcm']
     rander:     
     rander:     def __init__(self,calibration_parameters = {'A_per_V':19.9757, 'Gcm_per_A':1.88679, 'A_offset':-0.642724, 'A_min':-0.09}):            
     rander:         self.parameters = calibration_parameters
     rander:      
     rander:         self.parameters.setdefault('A_per_V',19.9757)
     rander:         self.parameters.setdefault('Gcm_per_A',1.88679)
     rander:         self.parameters.setdefault('A_offset',-0.642724)
     rander:         self.parameters.setdefault('A_min',-0.09)
     rander:         
     rander:         UnitConversion.__init__(self,self.parameters)
     rander: 
     rander:     @vectorise
     rander:     def A_to_base(self,amps):
     rander:         V_min = (self.parameters['A_min'] - self.parameters['A_offset'])/self.parameters['A_per_V']
     rander:         if amps < 0.001:
     rander:             volts = 0
     rander:         elif amps <= self.parameters['A_min']:
     rander:             volts = V_min
     rander:         else:
     rander:             volts = (amps - self.parameters['A_offset'])/self.parameters['A_per_V']
     rander:         return volts
     rander:     def A_from_base(self,volts):
     rander:         amps = max(volts * self.parameters['A_per_V'] + self.parameters['A_offset'], self.parameters['A_min'])
     rander:         return amps
     rander:     def Gcm_to_base(self,gauss_per_cm):
     rander:         volts = self.A_to_base(gauss_per_cm/self.parameters['Gcm_per_A'])
     rander:         return volts
     rander:     def Gcm_from_base(self,volts):
     rander:         gauss_per_cm = self.parameters['Gcm_per_A'] * self.A_from_base(volts)
     rander:         return gauss_per_cm
     rander:         
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # quad_monitor.py                                                   #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Monash University                                 #
   cbilling: #                                                                   #
   cbilling: # This file is part of the labscript suite (see                     #
   cbilling: # http://labscriptsuite.org) and is licensed under the Simplified   #
   cbilling: # BSD License. See the license.txt file in the root of the project  #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
   cbilling: 
janwerkmann: from .UnitConversionBase import *
     rander: class quad_monitor(UnitConversion):
     rander:     base_unit = 'V'
     rander:     derived_units = ['A', 'Gcm']
     rander:     
     rander:     def __init__(self,calibration_parameters = {'A_per_V':20.032, 'Gcm_per_A':1.88679, 'A_offset':0.0968-0.14}):            
     rander:         self.parameters = calibration_parameters
     rander:      
     rander:         self.parameters.setdefault('A_per_V',20.032)
     rander:         self.parameters.setdefault('Gcm_per_A',1.88679)
     rander:         self.parameters.setdefault('A_offset',0.0968-0.14)
     rander:         
     rander:         UnitConversion.__init__(self,self.parameters)
     rander: 
     rander:     def A_to_base(self,amps):
     rander:         volts = (amps - self.parameters['A_offset'])/self.parameters['A_per_V']
     rander:         return volts
     rander:     def A_from_base(self,volts):
     rander:         amps = volts * self.parameters['A_per_V'] + self.parameters['A_offset']
     rander:         return amps
     rander:     def Gcm_to_base(self,gauss_per_cm):
     rander:         volts = self.A_to_base(gauss_per_cm/self.parameters['Gcm_per_A'])
     rander:         return volts
     rander:     def Gcm_from_base(self,volts):
     rander:         gauss_per_cm = self.parameters['Gcm_per_A'] * self.A_from_base(volts)
     rander:         return gauss_per_cm
     rander:         
janwerkmann: #####################################################################
janwerkmann: #                                                                   #
janwerkmann: # test.py                                                           #
janwerkmann: #                                                                   #
janwerkmann: # Copyright 2013, Monash University                                 #
janwerkmann: #                                                                   #
janwerkmann: # This file is part of the labscript suite (see                     #
janwerkmann: # http://labscriptsuite.org) and is licensed under the Simplified   #
janwerkmann: # BSD License. See the license.txt file in the root of the project  #
janwerkmann: # for the full license.                                             #
janwerkmann: #                                                                   #
janwerkmann: #####################################################################
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
janwerkmann: from .UnitConversionBase import *
     rander: class test(UnitConversion):
     rander:     # This must be defined outside of init, and must match the default hardware unit specified within the BLACS tab
     rander:     base_unit = 'MHz'
     rander:     derived_units = ['A', 'Gauss']
     rander:     
     rander:     # You can pass a dictionary at class instantiation with some parameters to use in your unit converstion.
     rander:     # You can also place a list of "order of magnitude" prefixes (eg, k, m, M, u, p) you also want available
     rander:     # and the UnitConversion class will automatically generate the conversion function based on the functions 
     rander:     # you specify for the "derived units". This list should be stored in the 'magnitudes' key of the parameters
     rander:     # dictionary
     rander:     
     rander:     def __init__(self,calibration_parameters = None):            
     rander:         # These parameters are loaded from a globals.h5 type file automatically
     rander:         self.parameters = calibration_parameters
     rander:         
     rander:         self.parameters.setdefault('a',2)
     rander:         self.parameters.setdefault('b',3)        
     rander:         
     rander:         UnitConversion.__init__(self,self.parameters)
     rander:         # We should probably also store some hardware limits here, and use them accordingly 
     rander:         # (or maybe load them from a globals file, or specify them in the connection table?)
     rander: 
     rander:     def A_to_base(self,amps):
     rander:         #here is the calibration code that may use self.parameters
     rander:         volts = amps/self.parameters['a']
     rander:         return volts
     rander:     def A_from_base(self,volts):
     rander:         #here is the calibration code that may use self.parameters
     rander:         amps = volts * self.parameters['a']
     rander:         return amps
     rander:     def Gauss_to_base(self,gauss):
     rander:         #here is the calibration code that may use self.parameters
     rander:         volts = gauss/self.parameters['b']
     rander:         return volts
     rander:     def Gauss_from_base(self,volts):
     rander:         #here is the calibration code that may use self.parameters
     rander:         gauss = (volts)*self.parameters['b']
     rander:         return gauss
     rander:         
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
   cbilling: import os
   cbilling: import sys
   cbilling: import subprocess
   cbilling: 
   cbilling: this_folder = os.path.realpath(os.path.dirname(__file__))
   cbilling: Win7AppId = os.path.join(this_folder, 'Win7AppId1.1.exe')
   cbilling: 
   cbilling: for path in sys.path:
   cbilling:     if os.path.exists(os.path.join(path, '.is_labscript_suite_install_dir')):
   cbilling:         labscript_installation = os.path.abspath(path)
   cbilling:         break
   cbilling: else:
   cbilling:     labscript_installation = '<not_installed>'
   cbilling: 
   cbilling: # Including the install directory in the below AppId strings ensures they are unique
   cbilling: # to the install. If they are not, then installing to one directory, uninstalling,
   cbilling: # and reinstalling to another makes the Windows AppId API behave unpredictably.
   cbilling: # Shortcuts don't work, and icons are broken.
   cbilling: # This if of particular importance when developing on the same machine as you are
   cbilling: # deploying to.
   cbilling: appids = {'runmanager': 'Monashbec.Labscript.Runmanager.%s'%labscript_installation,
   cbilling:          'runviewer': 'Monashbec.Labscript.Runviewer.%s'%labscript_installation,
   cbilling:          'blacs': 'Monashbec.Labscript.Blacs.%s'%labscript_installation,
      Chris:          'lyse': 'Monashbec.Labscript.Lyse.%s'%labscript_installation}
   cbilling: 
   cbilling: app_descriptions = {'runmanager': 'runmanager - the labscript suite',
   cbilling:                    'runviewer': 'runviewer - the labscript suite',
   cbilling:                    'blacs': 'blacs - the labscript suite',
      Chris:                    'lyse': 'lyse - the labscript suite'}
   cbilling: 
   cbilling: def make_shortcut(path, target, arguments, working_directory, icon_path, description, appid):
   cbilling:     import sys, os
   cbilling:     from win32com.client import Dispatch
   cbilling:     shell = Dispatch('WScript.Shell')
   cbilling:     shortcut = shell.CreateShortcut(path)
   cbilling:     shortcut.TargetPath = target
   cbilling:     shortcut.Arguments = arguments
   cbilling:     shortcut.WorkingDirectory = working_directory
   cbilling:     shortcut.IconLocation = icon_path
   cbilling:     shortcut.Description = description
   cbilling:     shortcut.save()
   cbilling:     # The normal windows API calls don't seem to be able to set the appid of the shortcut.
   cbilling:     # The required API calls are either absent or not wrapped by pywin32. So we use this
   cbilling:     # command line utility that does it in C++:
   cbilling:     child = subprocess.Popen([Win7AppId, path, appid],
   cbilling:                              stdout = subprocess.PIPE, stderr = subprocess.PIPE)
   cbilling:     stdout, stderr = child.communicate()
   cbilling:     if child.returncode != 0:
   cbilling:         raise OSError('Failed to set UserModelAppId of shortcut.\n' + stdout + stderr)
   cbilling: 
   cbilling: def set_appusermodel(window_id, appid, icon_path, relaunch_command, relaunch_display_name):
   cbilling:     from win32com.propsys import propsys, pscon
   cbilling:     store = propsys.SHGetPropertyStoreForWindow(window_id, propsys.IID_IPropertyStore)
   cbilling:     id = store.GetValue(pscon.PKEY_AppUserModel_ID)
   cbilling:     store.SetValue(pscon.PKEY_AppUserModel_ID, propsys.PROPVARIANTType(appid))
   cbilling:     store.SetValue(pscon.PKEY_AppUserModel_RelaunchCommand, propsys.PROPVARIANTType(relaunch_command))
   cbilling:     store.SetValue(pscon.PKEY_AppUserModel_RelaunchDisplayNameResource, propsys.PROPVARIANTType(relaunch_display_name))
   cbilling:     store.SetValue(pscon.PKEY_AppUserModel_RelaunchIconResource, propsys.PROPVARIANTType(icon_path))
   cbilling: 
   cbilling: def add_to_start_menu(shortcut):
   cbilling:     from win32com.client import Dispatch
   cbilling:     import shutil
   cbilling:     objShell = Dispatch("WScript.Shell")
   cbilling:     start_menu_programs = objShell.SpecialFolders("Programs")
   cbilling:     shutil.copy(shortcut, start_menu_programs)
   cbilling: 
   cbilling: def remove_from_start_menu(name):
   cbilling:     """Removes given .lnk file from the start menu.
   cbilling:     If entry not present, does nothing."""
   cbilling:     from win32com.client import Dispatch
   cbilling:     import shutil
   cbilling:     name = os.path.basename(name)
   cbilling:     objShell = Dispatch("WScript.Shell")
   cbilling:     start_menu_programs = objShell.SpecialFolders("Programs")
   cbilling:     if name in os.listdir(start_menu_programs):
   cbilling:         os.unlink(os.path.join(start_menu_programs, name))
   cbilling: 
