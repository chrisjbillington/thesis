        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /__init__.py                                                      #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program runmanager, in the labscript     #
        pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
        pstarkey: 
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann: 
        pstarkey: import itertools
        pstarkey: import os
        pstarkey: import sys
        pstarkey: import random
        pstarkey: import time
        pstarkey: import subprocess
        pstarkey: import types
        pstarkey: import threading
        pstarkey: import traceback
        pstarkey: 
        cbilling: import labscript_utils.h5_lock
        cbilling: import h5py
        cbilling: import numpy as np
        pstarkey: 
        pstarkey: import zprocess
        pstarkey: 
           Chris: __version__ = '2.1.0'
        cbilling: 
        cbilling: 
             jan: def _ensure_str(s):
             jan:     """convert bytestrings and numpy strings to python strings"""
             jan:     return s.decode() if isinstance(s, bytes) else str(s)
             jan: 
             jan: 
        cbilling: def is_valid_python_identifier(name):
        cbilling:     import tokenize
     janwerkmann:     if PY2:
     janwerkmann:         import StringIO as io
     janwerkmann:     else:
     janwerkmann:         import io
        cbilling:     try:
     janwerkmann:         tokens = list(tokenize.generate_tokens(io.StringIO(name).readline))
        cbilling:     except tokenize.TokenError:
        cbilling:         return False
        cbilling:     if len(tokens) == 2:
        cbilling:         (token_type, _, _, _, _), _ = tokens
        cbilling:         return token_type == tokenize.NAME
        cbilling:     return False
        cbilling: 
        cbilling: 
        pstarkey: class ExpansionError(Exception):
        cbilling: 
        pstarkey:     """An exception class so that error handling code can tell when a
        pstarkey:     parsing exception was caused by a mismatch with the expansion mode"""
        pstarkey:     pass
        pstarkey: 
        cbilling: 
        pstarkey: class TraceDictionary(dict):
        cbilling: 
        cbilling:     def __init__(self, *args, **kwargs):
        pstarkey:         self.trace_data = None
        cbilling:         dict.__init__(self, *args, **kwargs)
        cbilling: 
        pstarkey:     def start_trace(self):
        pstarkey:         self.trace_data = []
        cbilling: 
        cbilling:     def __getitem__(self, key):
        pstarkey:         if self.trace_data is not None:
        pstarkey:             if key not in self.trace_data:
        pstarkey:                 self.trace_data.append(key)
        cbilling:         return dict.__getitem__(self, key)
        cbilling: 
        pstarkey:     def stop_trace(self):
        pstarkey:         trace_data = self.trace_data
        pstarkey:         self.trace_data = None
        pstarkey:         return trace_data
        cbilling: 
        cbilling: 
        pstarkey: def new_globals_file(filename):
        cbilling:     with h5py.File(filename, 'w') as f:
        pstarkey:         f.create_group('globals')
        pstarkey: 
        cbilling: 
        pstarkey: def add_expansion_groups(filename):
        pstarkey:     """backward compatability, for globals files which don't have
        pstarkey:     expansion groups. Create them if they don't exist. Guess expansion
        pstarkey:     settings based on datatypes, if possible."""
        cbilling:     # DEPRECATED
        pstarkey:     # Don't open in write mode unless we have to:
        cbilling:     with h5py.File(filename, 'r') as f:
        pstarkey:         requires_expansion_group = []
        pstarkey:         for groupname in f['globals']:
        pstarkey:             group = f['globals'][groupname]
        pstarkey:             if not 'expansion' in group:
        pstarkey:                 requires_expansion_group.append(groupname)
        pstarkey:     if requires_expansion_group:
        cbilling:         group_globalslists = [get_globalslist(filename, groupname) for groupname in requires_expansion_group]
        cbilling:         with h5py.File(filename, 'a') as f:
        pstarkey:             for groupname, globalslist in zip(requires_expansion_group, group_globalslists):
        pstarkey:                 group = f['globals'][groupname]
        pstarkey:                 subgroup = group.create_group('expansion')
        pstarkey:                 # Initialise all expansion settings to blank strings:
        pstarkey:                 for name in globalslist:
        pstarkey:                     subgroup.attrs[name] = ''
        pstarkey:         groups = {group_name: filename for group_name in get_grouplist(filename)}
        pstarkey:         sequence_globals = get_globals(groups)
        pstarkey:         evaled_globals, global_hierarchy, expansions = evaluate_globals(sequence_globals, raise_exceptions=False)
        pstarkey:         for group_name in evaled_globals:
        pstarkey:             for global_name in evaled_globals[group_name]:
        pstarkey:                 value = evaled_globals[group_name][global_name]
        pstarkey:                 expansion = guess_expansion_type(value)
        pstarkey:                 set_expansion(filename, group_name, global_name, expansion)
        cbilling: 
        cbilling: 
        pstarkey: def get_grouplist(filename):
        pstarkey:     # For backward compatability, add 'expansion' settings to this
        pstarkey:     # globals file, if it doesn't contain any.  Guess expansion settings
        pstarkey:     # if possible.
        cbilling:     # DEPRECATED
        pstarkey:     add_expansion_groups(filename)
        cbilling:     with h5py.File(filename, 'r') as f:
        pstarkey:         grouplist = f['globals']
        pstarkey:         # File closes after this function call, so have to
        pstarkey:         # convert the grouplist generator to a list of strings
        pstarkey:         # before its file gets dereferenced:
        pstarkey:         return list(grouplist)
        cbilling: 
        cbilling: 
        pstarkey: def new_group(filename, groupname):
        cbilling:     with h5py.File(filename, 'a') as f:
        cbilling:         if groupname in f['globals']:
        cbilling:             raise Exception('Can\'t create group: target name already exists.')
        pstarkey:         group = f['globals'].create_group(groupname)
        pstarkey:         group.create_group('units')
        pstarkey:         group.create_group('expansion')
        cbilling: 
        cbilling: 
     janwerkmann: def copy_group(source_globals_file, source_groupname, dest_globals_file, delete_source_group=False):
     janwerkmann:     """ This function copies the group source_groupname from source_globals_file
     janwerkmann:         to dest_globals_file and renames the new group so that there is no name
     janwerkmann:         collision. If delete_source_group is False the copyied files have
     janwerkmann:         a suffix '_copy'."""
     janwerkmann:     with h5py.File(source_globals_file, 'a') as source_f:
     janwerkmann:         # check if group exists
     janwerkmann:         if source_groupname not in source_f['globals']:
     janwerkmann:             raise Exception('Can\'t copy there is no group "{}"!'.format(source_groupname))
     janwerkmann: 
     janwerkmann:         # Are we coping from one file to another?
     janwerkmann:         if dest_globals_file is not None and source_globals_file != dest_globals_file:
     janwerkmann:             dest_f = h5py.File(dest_globals_file, 'a')  # yes -> open dest_globals_file
     janwerkmann:         else:
     janwerkmann:             dest_f = source_f  # no -> dest files is source file
     janwerkmann: 
     janwerkmann:         # rename Group until there is no name collisions
     janwerkmann:         i = 0 if not delete_source_group else 1
     janwerkmann:         dest_groupname = source_groupname
     janwerkmann:         while dest_groupname in dest_f['globals']:
     janwerkmann:             dest_groupname = "{}({})".format(dest_groupname, i) if i > 0 else "{}_copy".format(dest_groupname)
     janwerkmann:             i += 1
     janwerkmann: 
     janwerkmann:         # copy group
     janwerkmann:         dest_f.copy(source_f['globals'][source_groupname], '/globals/%s' % dest_groupname)
     janwerkmann: 
     janwerkmann:         # close opend file
     janwerkmann:         if dest_f != source_f:
     janwerkmann:             dest_f.close()
     janwerkmann: 
     janwerkmann:     return dest_groupname
     janwerkmann: 
     janwerkmann: 
        pstarkey: def rename_group(filename, oldgroupname, newgroupname):
        pstarkey:     if oldgroupname == newgroupname:
        pstarkey:         # No rename!
        pstarkey:         return
        cbilling:     with h5py.File(filename, 'a') as f:
        cbilling:         if newgroupname in f['globals']:
        cbilling:             raise Exception('Can\'t rename group: target name already exists.')
        cbilling:         f.copy(f['globals'][oldgroupname], '/globals/%s' % newgroupname)
        pstarkey:         del f['globals'][oldgroupname]
        cbilling: 
        cbilling: 
        pstarkey: def delete_group(filename, groupname):
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         del f['globals'][groupname]
        cbilling: 
        cbilling: 
        pstarkey: def get_globalslist(filename, groupname):
        cbilling:     with h5py.File(filename, 'r') as f:
        pstarkey:         group = f['globals'][groupname]
        pstarkey:         # File closes after this function call, so have to convert
        pstarkey:         # the attrs to a dict before its file gets dereferenced:
        pstarkey:         return dict(group.attrs)
        cbilling: 
        cbilling: 
        pstarkey: def new_global(filename, groupname, globalname):
        cbilling:     if not is_valid_python_identifier(globalname):
        cbilling:         raise ValueError('%s is not a valid Python variable name'%globalname)
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         group = f['globals'][groupname]
        pstarkey:         if globalname in group.attrs:
        pstarkey:             raise Exception('Can\'t create global: target name already exists.')
        pstarkey:         group.attrs[globalname] = ''
        pstarkey:         f['globals'][groupname]['units'].attrs[globalname] = ''
        pstarkey:         f['globals'][groupname]['expansion'].attrs[globalname] = ''
        cbilling: 
        cbilling: 
        pstarkey: def rename_global(filename, groupname, oldglobalname, newglobalname):
        pstarkey:     if oldglobalname == newglobalname:
        pstarkey:         # No rename!
        pstarkey:         return
        cbilling:     if not is_valid_python_identifier(newglobalname):
        cbilling:         raise ValueError('%s is not a valid Python variable name'%newglobalname)
        pstarkey:     value = get_value(filename, groupname, oldglobalname)
        pstarkey:     units = get_units(filename, groupname, oldglobalname)
        pstarkey:     expansion = get_expansion(filename, groupname, oldglobalname)
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         group = f['globals'][groupname]
        pstarkey:         if newglobalname in group.attrs:
        cbilling:             raise Exception('Can\'t rename global: target name already exists.')
        cbilling:         group.attrs[newglobalname] = value
        cbilling:         group['units'].attrs[newglobalname] = units
        cbilling:         group['expansion'].attrs[newglobalname] = expansion
        pstarkey:         del group.attrs[oldglobalname]
        pstarkey:         del group['units'].attrs[oldglobalname]
        pstarkey:         del group['expansion'].attrs[oldglobalname]
        cbilling: 
        cbilling: 
        pstarkey: def get_value(filename, groupname, globalname):
        cbilling:     with h5py.File(filename, 'r') as f:
        pstarkey:         value = f['globals'][groupname].attrs[globalname]
        cbilling:         # Replace numpy strings with python unicode strings.
        cbilling:         # DEPRECATED, for backward compat with old files
             jan:         value = _ensure_str(value)
        cbilling:         return value
        cbilling: 
        cbilling: 
        pstarkey: def set_value(filename, groupname, globalname, value):
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         f['globals'][groupname].attrs[globalname] = value
        cbilling: 
        cbilling: 
        pstarkey: def get_units(filename, groupname, globalname):
        cbilling:     with h5py.File(filename, 'r') as f:
        pstarkey:         value = f['globals'][groupname]['units'].attrs[globalname]
        cbilling:         # Replace numpy strings with python unicode strings.
        cbilling:         # DEPRECATED, for backward compat with old files
             jan:         value = _ensure_str(value)
        cbilling:         return value
        pstarkey: 
        cbilling: 
        pstarkey: def set_units(filename, groupname, globalname, units):
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         f['globals'][groupname]['units'].attrs[globalname] = units
        pstarkey: 
        cbilling: 
        pstarkey: def get_expansion(filename, groupname, globalname):
        cbilling:     with h5py.File(filename, 'r') as f:
        pstarkey:         value = f['globals'][groupname]['expansion'].attrs[globalname]
        cbilling:         # Replace numpy strings with python unicode strings.
        cbilling:         # DEPRECATED, for backward compat with old files
             jan:         value = _ensure_str(value)
        cbilling:         return value
        cbilling: 
        cbilling: 
        pstarkey: def set_expansion(filename, groupname, globalname, expansion):
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         f['globals'][groupname]['expansion'].attrs[globalname] = expansion
        cbilling: 
        cbilling: 
        pstarkey: def delete_global(filename, groupname, globalname):
        cbilling:     with h5py.File(filename, 'a') as f:
        pstarkey:         group = f['globals'][groupname]
        pstarkey:         del group.attrs[globalname]
        pstarkey: 
        cbilling: 
        pstarkey: def guess_expansion_type(value):
        cbilling:     if isinstance(value, np.ndarray) or isinstance(value, list):
        cbilling:         return u'outer'
        pstarkey:     else:
        cbilling:         return u''
        pstarkey: 
        cbilling: 
        pstarkey: def iterator_to_tuple(iterator, max_length=1000000):
        pstarkey:     # We want to prevent infinite length tuples, but we cannot know
        pstarkey:     # whether they are infinite or not in advance. So we'll convert to
        pstarkey:     # a tuple only if the length is less than max_length:
        pstarkey:     temp_list = []
        pstarkey:     for i, element in enumerate(iterator):
        pstarkey:         temp_list.append(element)
        pstarkey:         if i == max_length:
        pstarkey:             raise ValueError('This iterator is very long, possibly infinite. ' +
        cbilling:                              'Runmanager cannot create an infinite number of shots. ' +
        cbilling:                              'If you really want an iterator longer than %d, ' % max_length +
        pstarkey:                              'please modify runmanager.iterator_to_tuple and increase max_length.')
        pstarkey:     return tuple(temp_list)
        cbilling: 
        cbilling: 
        pstarkey: def get_all_groups(h5_files):
        pstarkey:     """returns a dictionary of group_name: h5_path pairs from a list of h5_files."""
             jan:     if isinstance(h5_files, bytes) or isinstance(h5_files, str):
        pstarkey:         h5_files = [h5_files]
        pstarkey:     groups = {}
        pstarkey:     for path in h5_files:
        pstarkey:         for group_name in get_grouplist(path):
        pstarkey:             if group_name in groups:
        cbilling:                 raise ValueError('Error: group %s is defined in both %s and %s. ' % (group_name, groups[group_name], path) +
        pstarkey:                                  'Only uniquely named groups can be used together '
        pstarkey:                                  'to make a run file.')
        pstarkey:             groups[group_name] = path
        pstarkey:     return groups
        cbilling: 
        cbilling: 
        pstarkey: def get_globals(groups):
        pstarkey:     """Takes a dictionary of group_name: h5_file pairs and pulls the
        pstarkey:     globals out of the groups in their files.  The globals are strings
        pstarkey:     storing python expressions at this point. All these globals are
        pstarkey:     packed into a new dictionary, keyed by group_name, where the values
        pstarkey:     are dictionaries which look like {global_name: (expression, units, expansion), ...}"""
        pstarkey:     # get a list of filepaths:
        pstarkey:     filepaths = set(groups.values())
        pstarkey:     sequence_globals = {}
        pstarkey:     for filepath in filepaths:
        cbilling:         groups_from_this_file = [g for g, f in groups.items() if f == filepath]
        cbilling:         with h5py.File(filepath, 'r') as f:
        pstarkey:             for group_name in groups_from_this_file:
        pstarkey:                 sequence_globals[group_name] = {}
        pstarkey:                 globals_group = f['globals'][group_name]
        cbilling:                 values = dict(globals_group.attrs)
        cbilling:                 units = dict(globals_group['units'].attrs)
        cbilling:                 expansions = dict(globals_group['expansion'].attrs)
        cbilling:                 for global_name, value in values.items():
        cbilling:                     unit = units[global_name]
        cbilling:                     expansion = expansions[global_name]
        cbilling:                     # Replace numpy strings with python unicode strings.
        cbilling:                     # DEPRECATED, for backward compat with old files
             jan:                     value = _ensure_str(value)
             jan:                     unit = _ensure_str(unit)
             jan:                     expansion = _ensure_str(expansion)
        cbilling:                     sequence_globals[group_name][global_name] = value, unit, expansion
        pstarkey:     return sequence_globals
        pstarkey: 
        cbilling: 
        pstarkey: def evaluate_globals(sequence_globals, raise_exceptions=True):
        pstarkey:     """Takes a dictionary of globals as returned by get_globals. These
        pstarkey:     globals are unevaluated strings.  Evaluates them all in the same
        pstarkey:     namespace so that the expressions can refer to each other. Iterates
        pstarkey:     to allow for NameErrors to be resolved by subsequently defined
        pstarkey:     globals. Throws an exception if this does not result in all errors
        pstarkey:     going away. The exception contains the messages of all exceptions
        pstarkey:     which failed to be resolved. If raise_exceptions is False, any
        pstarkey:     evaluations resulting in an exception will instead return the
        pstarkey:     exception object in the results dictionary"""
        pstarkey: 
        pstarkey:     # Flatten all the groups into one dictionary of {global_name:
        pstarkey:     # expression} pairs. Also create the group structure of the results
        pstarkey:     # dict, which has the same structure as sequence_globals:
        pstarkey:     all_globals = {}
        pstarkey:     results = {}
        pstarkey:     expansions = {}
        pstarkey:     global_hierarchy = {}
        pstarkey:     # Pre-fill the results dictionary with groups, this is needed for
        pstarkey:     # storing exceptions in the case of globals with the same name being
        pstarkey:     # defined in multiple groups (all of them get the exception):
        pstarkey:     for group_name in sequence_globals:
        pstarkey:         results[group_name] = {}
        pstarkey:     multiply_defined_globals = set()
        pstarkey:     for group_name in sequence_globals:
        pstarkey:         for global_name in sequence_globals[group_name]:
        pstarkey:             if global_name in all_globals:
        pstarkey:                 # The same global is defined twice. Either raise an
        pstarkey:                 # exception, or store the exception for each place it is
        pstarkey:                 # defined, depending on whether raise_exceptions is True:
        pstarkey:                 groups_with_same_global = []
        pstarkey:                 for other_group_name in sequence_globals:
        pstarkey:                     if global_name in sequence_globals[other_group_name]:
        pstarkey:                         groups_with_same_global.append(other_group_name)
        cbilling:                 exception = ValueError('Global named \'%s\' is defined in multiple active groups:\n    ' % global_name +
        pstarkey:                                        '\n    '.join(groups_with_same_global))
        pstarkey:                 if raise_exceptions:
        pstarkey:                     raise exception
        pstarkey:                 for other_group_name in groups_with_same_global:
        pstarkey:                     results[other_group_name][global_name] = exception
        pstarkey:                 multiply_defined_globals.add(global_name)
        pstarkey:             all_globals[global_name], units, expansion = sequence_globals[group_name][global_name]
        pstarkey:             expansions[global_name] = expansion
        cbilling: 
        pstarkey:     # Do not attempt to evaluate globals which are multiply defined:
        pstarkey:     for global_name in multiply_defined_globals:
        pstarkey:         del all_globals[global_name]
        pstarkey: 
        cbilling:     # Eval the expressions in the same namespace as each other:
        pstarkey:     evaled_globals = {}
        pstarkey:     # we use a "TraceDictionary" to track which globals another global depends on
        pstarkey:     sandbox = TraceDictionary()
        cbilling:     exec('from pylab import *', sandbox, sandbox)
        cbilling:     exec('from runmanager.functions import *', sandbox, sandbox)
        pstarkey:     globals_to_eval = all_globals.copy()
        pstarkey:     previous_errors = -1
        pstarkey:     while globals_to_eval:
        pstarkey:         errors = []
        pstarkey:         for global_name, expression in globals_to_eval.copy().items():
        pstarkey:             # start the trace to determine which globals this global depends on
        pstarkey:             sandbox.start_trace()
        pstarkey:             try:
chrisjbillington:                 code = compile(expression, '<string>', 'eval', dont_inherit=True)
chrisjbillington:                 value = eval(code, sandbox)
        pstarkey:                 # Need to know the length of any generators, convert to tuple:
        cbilling:                 if isinstance(value, types.GeneratorType):
        pstarkey:                     value = iterator_to_tuple(value)
        pstarkey:                 # Make sure if we're zipping or outer-producting this value, that it can
        pstarkey:                 # be iterated over:
        pstarkey:                 if expansions[global_name] == 'outer':
        pstarkey:                     try:
        cbilling:                         iter(value)
        pstarkey:                     except Exception as e:
        pstarkey:                         raise ExpansionError(str(e))
        pstarkey:             except Exception as e:
        pstarkey:                 # Don't raise, just append the error to a list, we'll display them all later.
        cbilling:                 errors.append((global_name, e))
        pstarkey:                 sandbox.stop_trace()
        pstarkey:                 continue
        pstarkey:             # Put the global into the namespace so other globals can use it:
        pstarkey:             sandbox[global_name] = value
        pstarkey:             del globals_to_eval[global_name]
        pstarkey:             evaled_globals[global_name] = value
        cbilling: 
        pstarkey:             # get the results from the global trace
        pstarkey:             trace_data = sandbox.stop_trace()
        pstarkey:             # Only store names of globals (not other functions)
        cbilling:             for key in list(trace_data):  # copy the list before iterating over it
        pstarkey:                 if key not in all_globals:
        cbilling:                     trace_data.remove(key)
        pstarkey:             if trace_data:
        pstarkey:                 global_hierarchy[global_name] = trace_data
        cbilling: 
        pstarkey:         if len(errors) == previous_errors:
        pstarkey:             # Since some globals may refer to others, we expect maybe
        pstarkey:             # some NameErrors to have occured.  There should be fewer
        pstarkey:             # NameErrors each iteration of this while loop, as globals
        pstarkey:             # that are required become defined. If there are not fewer
        pstarkey:             # errors, then there is something else wrong and we should
        pstarkey:             # raise it.
        pstarkey:             if raise_exceptions:
        pstarkey:                 message = 'Error parsing globals:\n'
        pstarkey:                 for global_name, exception in errors:
chrisjbillington:                     message += '%s: %s: %s\n' % (global_name, exception.__class__.__name__, exception.message if PY2 else str(exception))
        pstarkey:                 raise Exception(message)
        pstarkey:             else:
        pstarkey:                 for global_name, exception in errors:
        pstarkey:                     evaled_globals[global_name] = exception
        pstarkey:                 break
        pstarkey:         previous_errors = len(errors)
        cbilling: 
        pstarkey:     # Assemble results into a dictionary of the same format as sequence_globals:
        pstarkey:     for group_name in sequence_globals:
        pstarkey:         for global_name in sequence_globals[group_name]:
        pstarkey:             # Do not attempt to override exception objects already stored
        pstarkey:             # as the result of multiply defined globals:
        pstarkey:             if not global_name in results[group_name]:
        pstarkey:                 results[group_name][global_name] = evaled_globals[global_name]
        pstarkey: 
        pstarkey:     return results, global_hierarchy, expansions
        pstarkey: 
        cbilling: 
        pstarkey: def expand_globals(sequence_globals, evaled_globals, expansion_config = None, return_dimensions = False):
        pstarkey:     """Expands iterable globals according to their expansion
        pstarkey:     settings. Creates a number of 'axes' which are to be outer product'ed
        pstarkey:     together. Some of these axes have only one element, these are globals
        pstarkey:     that do not vary. Some have a set of globals being zipped together,
        pstarkey:     iterating in lock-step. Others contain a single global varying
        pstarkey:     across its values (the globals set to 'outer' expansion). Returns
        pstarkey:     a list of shots, each element of which is a dictionary for that
        pstarkey:     shot's globals."""
             jan: 
        pstarkey:     if expansion_config is None:
        pstarkey:         order = {}
        pstarkey:         shuffle = {}
        pstarkey:     else:
        pstarkey:         order = {k:v['order'] for k,v in expansion_config.items() if 'order' in v}
        pstarkey:         shuffle = {k:v['shuffle'] for k,v in expansion_config.items() if 'shuffle' in v}
             jan: 
        pstarkey:     values = {}
        pstarkey:     expansions = {}
        pstarkey:     for group_name in sequence_globals:
        pstarkey:         for global_name in sequence_globals[group_name]:
        pstarkey:             expression, units, expansion = sequence_globals[group_name][global_name]
        pstarkey:             value = evaled_globals[group_name][global_name]
        pstarkey:             values[global_name] = value
        pstarkey:             expansions[global_name] = expansion
        cbilling: 
        pstarkey:     # Get a list of the zip keys in use:
        pstarkey:     zip_keys = set(expansions.values())
        pstarkey:     try:
        pstarkey:         zip_keys.remove('outer')
        pstarkey:     except KeyError:
        pstarkey:         pass
        pstarkey: 
        pstarkey:     axes = {}
        pstarkey:     global_names = {}
        pstarkey:     dimensions = {}
        pstarkey:     for zip_key in zip_keys:
        pstarkey:         axis = []
        pstarkey:         zip_global_names = []
        pstarkey:         for global_name in expansions:
        pstarkey:             if expansions[global_name] == zip_key:
        pstarkey:                 value = values[global_name]
        pstarkey:                 if not zip_key:
        pstarkey:                     # Wrap up non-iterating globals (with zip_key = '') in a
        pstarkey:                     # one-element list. When zipped and then outer product'ed,
        pstarkey:                     # this will give us the result we want:
        pstarkey:                     value = [value]
        pstarkey:                 axis.append(value)
        pstarkey:                 zip_global_names.append(global_name)
             jan:         axis = list(zip(*axis))
        pstarkey:         dimensions['zip '+zip_key] = len(axis)
        pstarkey:         axes['zip '+zip_key] = axis
        pstarkey:         global_names['zip '+zip_key] = zip_global_names
        cbilling: 
        pstarkey:     # Give each global being outer-product'ed its own axis. It gets
        pstarkey:     # wrapped up in a list and zipped with itself so that it is in the
        pstarkey:     # same format as the zipped globals, ready for outer-producting
        pstarkey:     # together:
        pstarkey:     for global_name in expansions:
        pstarkey:         if expansions[global_name] == 'outer':
        pstarkey:             value = values[global_name]
        pstarkey:             axis = [value]
             jan:             axis = list(zip(*axis))
        pstarkey:             dimensions['outer '+global_name] = len(axis)
        pstarkey:             axes['outer '+global_name] = axis
        pstarkey:             global_names['outer '+global_name] = [global_name]
             jan: 
        pstarkey:     # add any missing items to order and dimensions
        pstarkey:     for key, value in axes.items():
        pstarkey:         if key not in order:
        pstarkey:             order[key] = -1
        pstarkey:         if key not in shuffle:
        pstarkey:             shuffle[key] = False
        pstarkey:         if key not in dimensions:
        pstarkey:             dimensions[key] = 1
             jan: 
        pstarkey:     # shuffle relevant axes
        pstarkey:     for axis_name, axis_values in axes.items():
        pstarkey:         if shuffle[axis_name]:
        pstarkey:             random.shuffle(axis_values)
             jan: 
        pstarkey:     # sort axes and global names by order
        pstarkey:     axes = [axes.get(key) for key in sorted(order, key=order.get)]
        pstarkey:     global_names = [global_names.get(key) for key in sorted(order, key=order.get)]
             jan: 
        pstarkey:     # flatten the global names
        pstarkey:     global_names = [global_name for global_list in global_names for global_name in global_list]
             jan: 
        pstarkey: 
        pstarkey:     shots = []
        pstarkey:     for axis_values in itertools.product(*axes):
        pstarkey:         # values here is a tuple of tuples, with the outer list being over
        pstarkey:         # the axes. We need to flatten it to get our individual values out
        pstarkey:         # for each global, since we no longer care what axis they are on:
        pstarkey:         global_values = [value for axis in axis_values for value in axis]
        cbilling:         shot_globals = dict(zip(global_names, global_values))
        pstarkey:         shots.append(shot_globals)
        cbilling: 
        pstarkey:     if return_dimensions:
        pstarkey:         return shots, dimensions
        pstarkey:     else:
        pstarkey:         return shots
        cbilling: 
        pstarkey: def generate_sequence_id(scriptname):
        pstarkey:     """Our convention for generating sequence ids. Just a timestamp and
        pstarkey:     the name of the labscript that the run file is to be compiled with."""
        cbilling:     timestamp = time.strftime('%Y%m%dT%H%M%S', time.localtime())
        pstarkey:     scriptbase = os.path.basename(scriptname).split('.py')[0]
        cbilling:     return timestamp + '_' + scriptbase
        cbilling: 
        cbilling: 
        pstarkey: def make_run_files(output_folder, sequence_globals, shots, sequence_id, shuffle=False):
        pstarkey:     """Does what it says. sequence_globals and shots are of the datatypes
        pstarkey:     returned by get_globals and get_shots, one is a nested dictionary with
        pstarkey:     string values, and the other a flat dictionary. sequence_id should
        pstarkey:     be some identifier unique to this sequence, use generate_sequence_id
        pstarkey:     to follow convention. shuffle will randomise the order that the run
        pstarkey:     files are generated in with respect to which element of shots they
        pstarkey:     come from. This function returns a *generator*. The run files are
        pstarkey:     not actually created until you loop over this generator (which gives
        pstarkey:     you the filepaths). This is useful for not having to clean up as many
        pstarkey:     unused files in the event of failed compilation of labscripts. If you
        pstarkey:     want all the run files to be created at some point, simply convert
        pstarkey:     the returned generator to a list. The filenames the run files are
        pstarkey:     given is simply the sequence_id with increasing integers appended."""
        cbilling:     basename = os.path.join(output_folder, sequence_id)
        pstarkey:     nruns = len(shots)
        cbilling:     ndigits = int(np.ceil(np.log10(nruns)))
        pstarkey:     if shuffle:
        pstarkey:         random.shuffle(shots)
        pstarkey:     for i, shot_globals in enumerate(shots):
        cbilling:         runfilename = ('%s_%0' + str(ndigits) + 'd.h5') % (basename, i)
        cbilling:         make_single_run_file(runfilename, sequence_globals, shot_globals, sequence_id, i, nruns)
        pstarkey:         yield runfilename
        cbilling: 
        cbilling: 
        pstarkey: def make_single_run_file(filename, sequenceglobals, runglobals, sequence_id, run_no, n_runs):
        pstarkey:     """Does what it says. runglobals is a dict of this run's globals,
        pstarkey:     the format being the same as that of one element of the list returned
        pstarkey:     by expand_globals.  sequence_globals is a nested dictionary of the
        pstarkey:     type returned by get_globals. Every run file needs a sequence ID,
        pstarkey:     generate one with generate_sequence_id. This doesn't have to match
        pstarkey:     the filename of the run file you end up using, though is usually does
        pstarkey:     (exceptions being things like connection tables). run_no and n_runs
        pstarkey:     must be provided, if this run file is part of a sequence, then they
        pstarkey:     should reflect how many run files are being generated which share
        pstarkey:     this sequence_id."""
        cbilling:     with h5py.File(filename, 'w') as f:
        pstarkey:         f.attrs['sequence_id'] = sequence_id
        pstarkey:         f.attrs['run number'] = run_no
        pstarkey:         f.attrs['n_runs'] = n_runs
        pstarkey:         f.create_group('globals')
        pstarkey:         if sequenceglobals is not None:
        pstarkey:             for groupname, groupvars in sequenceglobals.items():
        pstarkey:                 group = f['globals'].create_group(groupname)
        pstarkey:                 unitsgroup = group.create_group('units')
        pstarkey:                 expansiongroup = group.create_group('expansion')
        pstarkey:                 for name, (value, units, expansion) in groupvars.items():
        pstarkey:                     group.attrs[name] = value
        pstarkey:                     unitsgroup.attrs[name] = units
        pstarkey:                     expansiongroup.attrs[name] = expansion
        pstarkey:         for name, value in runglobals.items():
        cbilling:             if value is None:
        cbilling:                 # Store it as a null object reference:
        cbilling:                 value = h5py.Reference()
        pstarkey:             try:
        pstarkey:                 f['globals'].attrs[name] = value
        cbilling:             except Exception as e:
        cbilling:                 message = ('Global %s cannot be saved as an hdf5 attribute. ' % name +
        cbilling:                            'Globals can only have relatively simple datatypes, with no nested structures. ' +
        cbilling:                            'Original error was:\n' +
chrisjbillington:                            '%s: %s' % (e.__class__.__name__, e.message if PY2 else str(e)))
        pstarkey:                 raise ValueError(message)
        cbilling: 
        cbilling: 
        pstarkey: def make_run_file_from_globals_files(labscript_file, globals_files, output_path):
        pstarkey:     """Creates a run file output_path, using all the globals from
        pstarkey:     globals_files. Uses labscript_file only to generate a sequence ID"""
        pstarkey:     groups = get_all_groups(globals_files)
        pstarkey:     sequence_globals = get_globals(groups)
        pstarkey:     evaled_globals, global_hierarchy, expansions = evaluate_globals(sequence_globals)
        pstarkey:     shots = expand_globals(sequence_globals, evaled_globals)
        pstarkey:     if len(shots) > 1:
        pstarkey:         scanning_globals = []
        pstarkey:         for global_name in evaled_globals:
        pstarkey:             if len(evaled_globals[global_name]) > 1:
        pstarkey:                 scanning_globals.append(global_name)
        pstarkey:         raise ValueError('Cannot compile to a single run file: The following globals are a sequence: ' +
        pstarkey:                          ' '.join(scanning_globals))
        pstarkey:     sequence_id = generate_sequence_id(labscript_file)
        cbilling:     make_single_run_file(output_path, sequence_globals, shots[0], sequence_id, 1, 1)
        cbilling: 
        pstarkey: 
        pstarkey: def compile_labscript(labscript_file, run_file):
        pstarkey:     """Compiles labscript_file with the run file, returning
        pstarkey:     the processes return code, stdout and stderr."""
        cbilling:     proc = subprocess.Popen([sys.executable, labscript_file, run_file], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        pstarkey:     stdout, stderr = proc.communicate()
        pstarkey:     return proc.returncode, stdout, stderr
        cbilling: 
        cbilling: 
        pstarkey: def compile_labscript_with_globals_files(labscript_file, globals_files, output_path):
        pstarkey:     """Creates a run file output_path, using all the globals from
        pstarkey:     globals_files. Compiles labscript_file with the run file, returning
        pstarkey:     the processes return code, stdout and stderr."""
        pstarkey:     make_run_file_from_globals_files(labscript_file, globals_files, output_path)
        pstarkey:     returncode, stdout, stderr = compile_labscript(labscript_file, output_path)
        pstarkey:     return returncode, stdout, stderr
        cbilling: 
        cbilling: 
        pstarkey: def compile_labscript_async(labscript_file, run_file, stream_port, done_callback):
        pstarkey:     """Compiles labscript_file with run_file. This function is designed
        pstarkey:     to be called in a thread.  The stdout and stderr from the compilation
        pstarkey:     will be shoveled into stream_port via zmq push as it spews forth, and
        pstarkey:     when compilation is complete, done_callback will be called with a
        pstarkey:     boolean argument indicating success."""
        pstarkey:     compiler_path = os.path.join(os.path.dirname(__file__), 'batch_compiler.py')
        pstarkey:     to_child, from_child, child = zprocess.subprocess_with_queues(compiler_path, stream_port)
        cbilling:     to_child.put(['compile', [labscript_file, run_file]])
        pstarkey:     while True:
        pstarkey:         signal, data = from_child.get()
        pstarkey:         if signal == 'done':
        pstarkey:             success = data
        cbilling:             to_child.put(['quit', None])
        cbilling:             child.communicate()
        cbilling:             done_callback(success)
        pstarkey:             break
        pstarkey:         else:
        pstarkey:             raise RuntimeError((signal, data))
        cbilling: 
        cbilling: 
        pstarkey: def compile_multishot_async(labscript_file, run_files, stream_port, done_callback):
        pstarkey:     """Compiles labscript_file with run_files. This function is designed
        pstarkey:     to be called in a thread.  The stdout and stderr from the compilation
        pstarkey:     will be shoveled into stream_port via zmq push as it spews forth,
        pstarkey:     and when each compilation is complete, done_callback will be called
        pstarkey:     with a boolean argument indicating success. Compilation will stop
        pstarkey:     after the first failure."""
        pstarkey:     compiler_path = os.path.join(os.path.dirname(__file__), 'batch_compiler.py')
        pstarkey:     to_child, from_child, child = zprocess.subprocess_with_queues(compiler_path, stream_port)
        pstarkey:     try:
        pstarkey:         for run_file in run_files:
        cbilling:             to_child.put(['compile', [labscript_file, run_file]])
        pstarkey:             while True:
        pstarkey:                 signal, data = from_child.get()
        pstarkey:                 if signal == 'done':
        pstarkey:                     success = data
        pstarkey:                     done_callback(data)
        pstarkey:                     break
        pstarkey:             if not success:
        pstarkey:                 break
        pstarkey:     except Exception:
        pstarkey:         error = traceback.format_exc()
             jan:         zprocess.zmq_push_multipart(stream_port, data=[b'stderr', error.encode('utf-8')])
        cbilling:         to_child.put(['quit', None])
        cbilling:         child.communicate()
        pstarkey:         raise
        cbilling:     to_child.put(['quit', None])
        cbilling:     child.communicate()
        cbilling: 
        cbilling: 
        cbilling: def compile_labscript_with_globals_files_async(labscript_file, globals_files, output_path, stream_port, done_callback):
        pstarkey:     """Same as compile_labscript_with_globals_files, except it launches
        pstarkey:     a thread to do the work and does not return anything. Instead,
        pstarkey:     stderr and stdout will be put to stream_port via zmq push in
        pstarkey:     the multipart message format ['stdout','hello, world\n'] etc. When
        pstarkey:     compilation is finished, the function done_callback will be called
        pstarkey:     a boolean argument indicating success or failure."""
        pstarkey:     try:
        pstarkey:         make_run_file_from_globals_files(labscript_file, globals_files, output_path)
        cbilling:         thread = threading.Thread(
        cbilling:             target=compile_labscript_async, args=[labscript_file, output_path, stream_port, done_callback])
        pstarkey:         thread.daemon = True
        pstarkey:         thread.start()
        pstarkey:     except Exception:
        pstarkey:         error = traceback.format_exc()
             jan:         zprocess.zmq_push_multipart(stream_port, data=[b'stderr', error.encode('utf-8')])
        cbilling:         t = threading.Thread(target=done_callback, args=(False,))
        cbilling:         t.daemon = True
        pstarkey:         t.start()
        pstarkey: 
        cbilling: 
        cbilling: def get_shot_globals(filepath):
        cbilling:     """Returns the evaluated globals for a shot, for use by labscript or lyse.
        cbilling:     Simple dictionary access as in dict(h5py.File(filepath).attrs) would be fine
        cbilling:     except we want to apply some hacks, so it's best to do that in one place."""
        cbilling:     params = {}
           Chris:     with h5py.File(filepath, 'r') as f:
        cbilling:         for name, value in f['globals'].attrs.items():
        cbilling:             # Convert numpy bools to normal bools:
        cbilling:             if isinstance(value, np.bool_):
        cbilling:                 value = bool(value)
        cbilling:             # Convert null HDF references to None:
        cbilling:             if isinstance(value, h5py.Reference) and not value:
        cbilling:                 value = None
        cbilling:             # Convert numpy strings to Python ones.
        cbilling:             # DEPRECATED, for backward compat with old files.
        cbilling:             if isinstance(value, np.str_):
        cbilling:                 value = str(value)
             jan:             if isinstance(value, bytes):
             jan:                 value = value.decode()
        cbilling:             params[name] = value
        cbilling:     return params
        cbilling: 
        cbilling: 
        pstarkey: def dict_diff(dict1, dict2):
        pstarkey:     """Return the difference between two dictionaries as a dictionary of key: [val1, val2] pairs.
        pstarkey:     Keys unique to either dictionary are included as key: [val1, '-'] or key: ['-', val2]."""
        pstarkey:     diff_keys = []
     janwerkmann:     common_keys = np.intersect1d(list(dict1.keys()), list(dict2.keys()))
        pstarkey:     for key in common_keys:
        cbilling:         if np.iterable(dict1[key]) or np.iterable(dict2[key]):
        cbilling:             if not np.array_equal(dict1[key], dict2[key]):
        pstarkey:                 diff_keys.append(key)
        pstarkey:         else:
        pstarkey:             if dict1[key] != dict2[key]:
        pstarkey:                 diff_keys.append(key)
        pstarkey: 
        cbilling:     dict1_unique = [key for key in dict1.keys() if key not in common_keys]
        pstarkey:     dict2_unique = [key for key in dict2.keys() if key not in common_keys]
        cbilling: 
        pstarkey:     diff = {}
        pstarkey:     for key in diff_keys:
        pstarkey:         diff[key] = [dict1[key], dict2[key]]
        cbilling: 
        pstarkey:     for key in dict1_unique:
        pstarkey:         diff[key] = [dict1[key], '-']
        cbilling: 
        pstarkey:     for key in dict2_unique:
        cbilling:         diff[key] = ['-', dict2[key]]
        pstarkey: 
        cbilling:     return diff
          rander: 
          rander: 
          rander: def remove_comments_and_tokenify(line):
          rander:     """Removed EOL comments from a line, leaving it otherwise intact,
          rander:     and returns it. Also returns the raw tokens for the line, allowing
          rander:     comparisons between lines to be made without being sensitive to
          rander:     whitespace."""
          rander:     import tokenize
     janwerkmann:     if PY2:
     janwerkmann:         import StringIO as io
     janwerkmann:     else:
     janwerkmann:         import io
          rander:     result_expression = ''
          rander:     result_tokens = []
          rander:     error_encountered = False
          rander:     # This never fails because it produces a generator, syntax errors
          rander:     # come out when looping over it:
     janwerkmann:     tokens = tokenize.generate_tokens(io.StringIO(line).readline)
          rander:     try:
          rander:         for token_type, token_value, (_, start), (_, end), _ in tokens:
          rander:             if token_type == tokenize.COMMENT and not error_encountered:
          rander:                 break
          rander:             if token_type == tokenize.ERRORTOKEN:
          rander:                 error_encountered = True
          rander:             result_expression = result_expression.ljust(start)
          rander:             result_expression += token_value
          rander:             if token_value:
          rander:                 result_tokens.append(token_value)
          rander:     except tokenize.TokenError:
          rander:         # Means EOF was reached without closing brackets or something.
          rander:         # We don't care, return what we've got.
          rander:         pass
          rander:     return result_expression, result_tokens
          rander: 
          rander: 
          rander: def flatten_globals(sequence_globals, evaluated=False):
          rander:     """Flattens the data structure of the globals. If evaluated=False,
          rander:     saves only the value expression string of the global, not the
          rander:     units or expansion."""
          rander:     flattened_sequence_globals = {}
          rander:     for globals_group in sequence_globals.values():
          rander:         for name, value in globals_group.items():
          rander:             if evaluated:
          rander:                 flattened_sequence_globals[name] = value
          rander:             else:
          rander:                 value_expression, units, expansion = value
          rander:                 flattened_sequence_globals[name] = value_expression
          rander:     return flattened_sequence_globals
          rander: 
          rander: 
          rander: def globals_diff_groups(active_groups, other_groups, max_cols=1000, return_string=True):
     janwerkmann:     """Given two sets of globals groups, perform a diff of the raw
          rander:     and evaluated globals."""
          rander:     our_sequence_globals = get_globals(active_groups)
          rander:     other_sequence_globals = get_globals(other_groups)
          rander: 
          rander:     # evaluate globals
          rander:     our_evaluated_sequence_globals, _, _ = evaluate_globals(our_sequence_globals, raise_exceptions=False)
          rander:     other_evaluated_sequence_globals, _, _ = evaluate_globals(other_sequence_globals, raise_exceptions=False)
          rander: 
          rander:     # flatten globals dictionaries
          rander:     our_globals = flatten_globals(our_sequence_globals, evaluated=False)
          rander:     other_globals = flatten_globals(other_sequence_globals, evaluated=False)
          rander:     our_evaluated_globals = flatten_globals(our_evaluated_sequence_globals, evaluated=True)
          rander:     other_evaluated_globals = flatten_globals(other_evaluated_sequence_globals, evaluated=True)
          rander: 
          rander:     # diff the *evaluated* globals
          rander:     value_differences = dict_diff(other_evaluated_globals, our_evaluated_globals)
          rander: 
          rander:     # We are interested only in displaying globals where *both* the
          rander:     # evaluated global *and* its unevaluated expression (ignoring comments
          rander:     # and whitespace) differ. This will minimise false positives where a
          rander:     # slight change in an expression still leads to the same value, or
          rander:     # where an object has a poorly defined equality operator that returns
          rander:     # False even when the two objects are identical.
          rander:     filtered_differences = {}
          rander:     for name, (other_value, our_value) in value_differences.items():
          rander:         our_expression = our_globals.get(name, '-')
          rander:         other_expression = other_globals.get(name, '-')
          rander:         # Strip comments, get tokens so we can diff without being sensitive to comments or whitespace:
          rander:         our_expression, our_tokens = remove_comments_and_tokenify(our_expression)
          rander:         other_expression, other_tokens = remove_comments_and_tokenify(other_expression)
          rander:         if our_tokens != other_tokens:
          rander:             filtered_differences[name] = [repr(other_value), repr(our_value), other_expression, our_expression]
          rander:     if filtered_differences:
          rander:         import pandas as pd
          rander:         df = pd.DataFrame.from_dict(filtered_differences, 'index')
           Chris:         df = df.sort_index()
          rander:         df.columns = ['Prev (Eval)', 'Current (Eval)', 'Prev (Raw)', 'Current (Raw)']
          rander:         df_string = df.to_string(max_cols=max_cols)
          rander:         payload = df_string + '\n\n'
          rander:     else:
          rander:         payload = 'Evaluated globals are identical to those of selected file.\n'
          rander:     if return_string:
          rander:         return payload
          rander:     else:
          rander:         print(payload)
          rander:         return df
          rander: 
          rander: 
          rander: def globals_diff_shots(file1, file2, max_cols=100):
          rander:     # Get file's globals groups
          rander:     active_groups = get_all_groups(file1)
          rander: 
          rander:     # Get other file's globals groups
          rander:     other_groups = get_all_groups(file2)
          rander: 
          rander:     print('Globals diff between:\n%s\n%s\n\n' % (file1, file2))
             jan:     return globals_diff_groups(active_groups, other_groups, max_cols=max_cols, return_string=False)
        cbilling: #####################################################################
        cbilling: #                                                                   #
        cbilling: # __main__.py                                                       #
        cbilling: #                                                                   #
        cbilling: # Copyright 2013, Monash University                                 #
        cbilling: #                                                                   #
        cbilling: # This file is part of the program runmanager, in the labscript     #
        cbilling: # suite (see http://labscriptsuite.org), and is licensed under the  #
        cbilling: # Simplified BSD License. See the license.txt file in the root of   #
        cbilling: # the project for the full license.                                 #
        cbilling: #                                                                   #
        cbilling: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
     janwerkmann: from labscript_utils import PY2
     janwerkmann: if PY2:
     janwerkmann:     str = unicode
     janwerkmann:     import Queue as queue
     janwerkmann: else:
     janwerkmann:     import queue
        cbilling: 
        cbilling: import os
        cbilling: import sys
        cbilling: import errno
        cbilling: import labscript_utils.excepthook
        cbilling: 
        cbilling: import time
        cbilling: import contextlib
        cbilling: import subprocess
        cbilling: import threading
        cbilling: import socket
        cbilling: import ast
        cbilling: import pprint
        cbilling: 
        cbilling: # Evaluation of globals happens in a thread with the pylab module imported.
        cbilling: # Although we don't care about plotting, importing pylab makes Qt calls. We
        cbilling: # can't have that from a non main thread, so we'll just disable matplotlib's
        cbilling: # GUI integration:
        cbilling: import matplotlib
        cbilling: matplotlib.use('Agg')
        cbilling: 
        cbilling: import signal
        cbilling: # Quit on ctrl-c
        cbilling: signal.signal(signal.SIGINT, signal.SIG_DFL)
        cbilling: 
        cbilling: try:
        cbilling:     from labscript_utils import check_version
        cbilling: except ImportError:
        cbilling:     raise ImportError('Require labscript_utils > 2.1.0')
     janwerkmann: 
        cbilling: check_version('labscript_utils', '2', '3')
     janwerkmann: check_version('qtutils', '2.0.0', '3.0.0')
           Chris: check_version('zprocess', '1.1.5', '3.0')
        cbilling: check_version('pandas', '0.13', '2')
        cbilling: 
           Chris: from qtutils.qt import QtCore, QtGui, QtWidgets
           Chris: from qtutils.qt.QtCore import pyqtSignal as Signal
           Chris: 
        cbilling: import zprocess.locking
        cbilling: from zmq import ZMQError
        cbilling: 
        cbilling: from labscript_utils.labconfig import LabConfig, config_prefix
        cbilling: from labscript_utils.setup_logging import setup_logging
        cbilling: import labscript_utils.shared_drive as shared_drive
        cbilling: import runmanager
        cbilling: 
        cbilling: from qtutils import inmain, inmain_decorator, UiLoader, inthread, DisconnectContextManager
        cbilling: from qtutils.outputbox import OutputBox
        cbilling: import qtutils.icons
        cbilling: 
        cbilling: # Set working directory to runmanager folder, resolving symlinks
        cbilling: runmanager_dir = os.path.dirname(os.path.realpath(__file__))
        cbilling: os.chdir(runmanager_dir)
        cbilling: 
        cbilling: # Set a meaningful name for zprocess.locking's client id:
        cbilling: zprocess.locking.set_client_process_name('runmanager')
        cbilling: 
        cbilling: 
        pstarkey: def log_if_global(g, g_list, message):
        pstarkey:     """logs a message if the global name "g" is in "g_list"
        pstarkey:     
        pstarkey:     useful if you want to print out a message inside a loop over globals,
        pstarkey:     but only for a particular global (or set of globals).
        pstarkey:     
        pstarkey:     If g_list is empty, then it will use the hardcoded list below
        pstarkey:     (useful if you want to change the behaviour globally)    
        pstarkey:     """
        pstarkey:     if not isinstance(g_list, list):
        pstarkey:         g_list = [g_list]
        pstarkey:         
        pstarkey:     if not g_list:
        pstarkey:         g_list = [] # add global options here
        pstarkey:     
        pstarkey:     if g in g_list:
        pstarkey:         logger.info(message)
        pstarkey: 
        pstarkey:     
        cbilling: def set_win_appusermodel(window_id):
        cbilling:     from labscript_utils.winshell import set_appusermodel, appids, app_descriptions
        cbilling:     icon_path = os.path.abspath('runmanager.ico')
        cbilling:     executable = sys.executable.lower()
        cbilling:     if not executable.endswith('w.exe'):
        cbilling:         executable = executable.replace('.exe', 'w.exe')
        cbilling:     relaunch_command = executable + ' ' + os.path.abspath(__file__.replace('.pyc', '.py'))
        cbilling:     relaunch_display_name = app_descriptions['runmanager']
        cbilling:     set_appusermodel(window_id, appids['runmanager'], icon_path, relaunch_command, relaunch_display_name)
        cbilling: 
        cbilling: 
        cbilling: @inmain_decorator()
        cbilling: def error_dialog(message):
     janwerkmann:     QtWidgets.QMessageBox.warning(app.ui, 'runmanager', message)
        cbilling: 
        cbilling: 
        cbilling: @inmain_decorator()
        cbilling: def question_dialog(message):
     janwerkmann:     reply = QtWidgets.QMessageBox.question(app.ui, 'runmanager', message,
     janwerkmann:                                        QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
     janwerkmann:     return (reply == QtWidgets.QMessageBox.Yes)
        cbilling: 
        cbilling: 
        cbilling: def mkdir_p(path):
        cbilling:     try:
        cbilling:         os.makedirs(path)
        cbilling:     except OSError as exc:
        cbilling:         if exc.errno == errno.EEXIST and os.path.isdir(path):
        cbilling:             pass
        cbilling:         else:
        cbilling:             raise
        cbilling: 
        cbilling: 
        cbilling: @contextlib.contextmanager
        cbilling: def nested(*contextmanagers):
        cbilling:     if contextmanagers:
        cbilling:         with contextmanagers[0]:
        cbilling:             with nested(*contextmanagers[1:]):
        cbilling:                 yield
        cbilling:     else:
        cbilling:         yield
        cbilling: 
        cbilling: 
        cbilling: def scroll_treeview_to_row_if_current(treeview, item):
        cbilling:     """Checks to see if the item is in the row of the current item.
        cbilling:     If it is, scrolls vertically to ensure that row is visible.
        cbilling:     This is done by recording the horizontal scroll position,
        cbilling:     then using QTreeView.scrollTo(), and then restoring the horizontal
        cbilling:     position"""
        cbilling:     horizontal_scrollbar = treeview.horizontalScrollBar()
        cbilling:     existing_horizontal_position = horizontal_scrollbar.value()
        cbilling:     index = item.index()
        cbilling:     current_row = treeview.currentIndex().row()
        cbilling:     if index.row() == current_row:
        cbilling:         treeview.scrollTo(index)
        cbilling:         horizontal_scrollbar.setValue(existing_horizontal_position)
        cbilling: 
        cbilling: 
     janwerkmann: class FingerTabBarWidget(QtWidgets.QTabBar):
        cbilling: 
        cbilling:     """A TabBar with the tabs on the left and the text horizontal. Credit to
        cbilling:     @LegoStormtroopr, https://gist.github.com/LegoStormtroopr/5075267. We will
        cbilling:     promote the TabBar from the ui file to one of these."""
        cbilling: 
        cbilling:     def __init__(self, parent=None, minwidth=180, minheight=30, **kwargs):
     janwerkmann:         QtWidgets.QTabBar.__init__(self, parent, **kwargs)
        cbilling:         self.minwidth = minwidth
        cbilling:         self.minheight = minheight
     janwerkmann:         self.iconPosition = kwargs.pop('iconPosition', QtWidgets.QTabWidget.West)
        cbilling:         self._movable = None
        cbilling:         self.tab_movable = {}
        cbilling:         self.paint_clip = None
        cbilling: 
        cbilling:     def setMovable(self, movable, index=None):
        cbilling:         """Set tabs movable on an individual basis, or set for all tabs if no
        cbilling:         index specified"""
        cbilling:         if index is None:
        cbilling:             self._movable = movable
        cbilling:             self.tab_movable = {}
     janwerkmann:             QtWidgets.QTabBar.setMovable(self, movable)
        cbilling:         else:
        cbilling:             self.tab_movable[int(index)] = bool(movable)
        cbilling: 
        cbilling:     def isMovable(self, index=None):
        cbilling:         if index is None:
        cbilling:             if self._movable is None:
     janwerkmann:                 self._movable = QtWidgets.QTabBar.isMovable(self)
        cbilling:             return self._movable
        cbilling:         return self.tab_movable.get(index, self._movable)
        cbilling: 
        cbilling:     def indexAtPos(self, point):
        cbilling:         for index in range(self.count()):
        cbilling:             if self.tabRect(index).contains(point):
        cbilling:                 return index
        cbilling: 
        cbilling:     def mousePressEvent(self, event):
        cbilling:         index = self.indexAtPos(event.pos())
        cbilling:         if not self.tab_movable.get(index, self.isMovable()):
     janwerkmann:             QtWidgets.QTabBar.setMovable(self, False)  # disable dragging until they release the mouse
     janwerkmann:         return QtWidgets.QTabBar.mousePressEvent(self, event)
        cbilling: 
        cbilling:     def mouseReleaseEvent(self, event):
        cbilling:         if self.isMovable():
        cbilling:             # Restore this in case it was temporarily disabled by mousePressEvent
     janwerkmann:             QtWidgets.QTabBar.setMovable(self, True)
     janwerkmann:         return QtWidgets.QTabBar.mouseReleaseEvent(self, event)
        cbilling: 
        cbilling:     def tabLayoutChange(self):
        cbilling:         total_height = 0
        cbilling:         for index in range(self.count()):
        cbilling:             tabRect = self.tabRect(index)
        cbilling:             total_height += tabRect.height()
        cbilling:         if total_height > self.parent().height():
        cbilling:             # Don't paint over the top of the scroll buttons:
     janwerkmann:             scroll_buttons_area_height = 2*max(self.style().pixelMetric(QtWidgets.QStyle.PM_TabBarScrollButtonWidth),
        cbilling:                                                qapplication.globalStrut().width())
        cbilling:             self.paint_clip = self.width(), self.parent().height() - scroll_buttons_area_height
        cbilling:         else:
        cbilling:             self.paint_clip = None
        cbilling: 
        cbilling:     def paintEvent(self, event):
     janwerkmann:         painter = QtWidgets.QStylePainter(self)
        cbilling:         if self.paint_clip is not None:
        cbilling:             painter.setClipRect(0, 0, *self.paint_clip)
        cbilling: 
     janwerkmann:         option = QtWidgets.QStyleOptionTab()
        cbilling:         for index in range(self.count()):
        cbilling:             tabRect = self.tabRect(index)
        cbilling:             self.initStyleOption(option, index)
     janwerkmann:             painter.drawControl(QtWidgets.QStyle.CE_TabBarTabShape, option)
        cbilling:             if not self.tabIcon(index).isNull():
        cbilling:                 icon = self.tabIcon(index).pixmap(self.iconSize())
        cbilling:                 alignment = QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter
        cbilling:                 tabRect.moveLeft(10)
        cbilling:                 painter.drawItemPixmap(tabRect, alignment, icon)
        cbilling:                 tabRect.moveLeft(self.iconSize().width() + 15)
        cbilling:             else:
        cbilling:                 tabRect.moveLeft(10)
        cbilling:             painter.drawText(tabRect, QtCore.Qt.AlignVCenter, self.tabText(index))
        cbilling:         if self.paint_clip is not None:
        cbilling:             x_clip, y_clip = self.paint_clip
        cbilling:             painter.setClipping(False)
        cbilling:             palette = self.palette()
        cbilling:             mid_color = palette.color(QtGui.QPalette.Mid)
        cbilling:             painter.setPen(mid_color)
        cbilling:             painter.drawLine(0, y_clip, x_clip, y_clip)
        cbilling:         painter.end()
        cbilling: 
        cbilling: 
        cbilling:     def tabSizeHint(self, index):
        cbilling:         fontmetrics = QtGui.QFontMetrics(self.font())
        cbilling:         text_width = fontmetrics.width(self.tabText(index))
        cbilling:         text_height = fontmetrics.height()
        cbilling:         height = text_height + 15
        cbilling:         height = max(self.minheight, height)
        cbilling:         width = text_width + 15
        cbilling: 
     janwerkmann:         button = self.tabButton(index, QtWidgets.QTabBar.RightSide)
        cbilling:         if button is not None:
        cbilling:             height = max(height, button.height() + 7)
        cbilling:             # Same amount of space around the button horizontally as it has vertically:
        cbilling:             width += button.width() + height - button.height()
        cbilling:         width = max(self.minwidth, width)
        cbilling:         return QtCore.QSize(width, height)
        cbilling: 
        cbilling:     def setTabButton(self, index, geometry, button):
        cbilling:         if not isinstance(button, TabToolButton):
        cbilling:             raise TypeError('Not a TabToolButton, won\'t paint correctly. Use a TabToolButton')
     janwerkmann:         result = QtWidgets.QTabBar.setTabButton(self, index, geometry, button)
        cbilling:         button.move(*button.get_correct_position())
        cbilling:         return result
        cbilling: 
        cbilling: 
     janwerkmann: class TabToolButton(QtWidgets.QToolButton):
        cbilling:     def __init__(self, *args, **kwargs):
     janwerkmann:         QtWidgets.QToolButton.__init__(self, *args, **kwargs)
        cbilling: 
        cbilling:     def paintEvent(self, event):
     janwerkmann:         painter = QtWidgets.QStylePainter(self)
        cbilling:         paint_clip = self.parent().paint_clip
        cbilling:         if paint_clip is not None:
        cbilling:             point = QtCore.QPoint(*paint_clip)
        cbilling:             global_point = self.parent().mapToGlobal(point)
        cbilling:             local_point = self.mapFromGlobal(global_point)
        cbilling:             painter.setClipRect(0, 0, local_point.x(), local_point.y())
     janwerkmann:         option = QtWidgets.QStyleOptionToolButton()
        cbilling:         self.initStyleOption(option)
     janwerkmann:         painter.drawComplexControl(QtWidgets.QStyle.CC_ToolButton, option)
        cbilling: 
        cbilling:     def get_correct_position(self):
        cbilling:         parent = self.parent()
        cbilling:         for index in range(parent.count()):
     janwerkmann:             if parent.tabButton(index, QtWidgets.QTabBar.RightSide) is self:
        cbilling:                 break
        cbilling:         else:
        cbilling:             raise LookupError('Tab not found')
        cbilling:         tabRect = parent.tabRect(index)
        cbilling:         tab_x, tab_y, tab_width, tab_height = tabRect.x(), tabRect.y(), tabRect.width(), tabRect.height()
        cbilling:         size = self.sizeHint()
        cbilling:         width = size.width()
        cbilling:         height = size.height()
        cbilling:         padding = int((tab_height - height) / 2)
        cbilling:         correct_x = tab_x + tab_width - width - padding
        cbilling:         correct_y = tab_y + padding
        cbilling:         return correct_x, correct_y
        cbilling: 
        cbilling:     def moveEvent(self, event):
        cbilling:         try:
        cbilling:             correct_x, correct_y = self.get_correct_position()
        cbilling:         except LookupError:
        cbilling:             return # Things aren't initialised yet
        cbilling:         if self.x() != correct_x or self.y() != correct_y:
        cbilling:             # Move back! I shall not be moved!
        cbilling:             self.move(correct_x, correct_y)
     janwerkmann:         return QtWidgets.QToolButton.moveEvent(self, event)
        cbilling: 
        cbilling: 
     janwerkmann: class FingerTabWidget(QtWidgets.QTabWidget):
        cbilling: 
        cbilling:     """A QTabWidget equivalent which uses our FingerTabBarWidget"""
        cbilling: 
        cbilling:     def __init__(self, parent, *args):
     janwerkmann:         QtWidgets.QTabWidget.__init__(self, parent, *args)
        cbilling:         self.setTabBar(FingerTabBarWidget(self))
        cbilling: 
        cbilling:     def addTab(self, *args, **kwargs):
        cbilling:         closeable = kwargs.pop('closable', False)
     janwerkmann:         index = QtWidgets.QTabWidget.addTab(self, *args, **kwargs)
        cbilling:         self.setTabClosable(index, closeable)
        cbilling:         return index
        cbilling: 
        cbilling:     def setTabClosable(self, index, closable):
     janwerkmann:         right_button = self.tabBar().tabButton(index, QtWidgets.QTabBar.RightSide)
        cbilling:         if closable:
        cbilling:             if not right_button:
        cbilling:                 # Make one:
        cbilling:                 close_button = TabToolButton(self.parent())
        cbilling:                 close_button.setIcon(QtGui.QIcon(':/qtutils/fugue/cross'))
     janwerkmann:                 self.tabBar().setTabButton(index, QtWidgets.QTabBar.RightSide, close_button)
        cbilling:                 close_button.clicked.connect(lambda: self._on_close_button_clicked(close_button))
        cbilling:         else:
        cbilling:             if right_button:
        cbilling:                 # Get rid of it:
     janwerkmann:                 self.tabBar().setTabButton(index, QtWidgets.QTabBar.RightSide, None)
        cbilling: 
        cbilling:     def _on_close_button_clicked(self, button):
        cbilling:         for index in range(self.tabBar().count()):
     janwerkmann:             if self.tabBar().tabButton(index, QtWidgets.QTabBar.RightSide) is button:
        cbilling:                 self.tabCloseRequested.emit(index)
        cbilling:                 break
        cbilling: 
        cbilling: 
     janwerkmann: class TreeView(QtWidgets.QTreeView):
        cbilling:     leftClicked = Signal(QtCore.QModelIndex)
        cbilling:     doubleLeftClicked = Signal(QtCore.QModelIndex)
        cbilling:     """A QTreeview that emits a custom signal leftClicked(index) after a left
        cbilling:     click on a valid index, and doubleLeftClicked(index) (in addition) on
        cbilling:     double click. Also has modified tab and arrow key behaviour."""
        cbilling: 
        cbilling:     def __init__(self, *args):
     janwerkmann:         QtWidgets.QTreeView.__init__(self, *args)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         self._ROLE_IGNORE_TABNEXT = None
        cbilling:         self.setAutoScroll(False)
        cbilling: 
        cbilling:     def setRoleIgnoreTabNext(self, role):
        cbilling:         """Tell the Treeview what model role it should look in for a boolean
        cbilling:         saying whether to ignore the MoveNext cursor action. This will cause
        cbilling:         cells marked as such to simply end editing when tab is pressed,
        cbilling:         without starting editing on any other call."""
        cbilling:         self._ROLE_IGNORE_TABNEXT = role
        cbilling: 
        cbilling:     def mousePressEvent(self, event):
     janwerkmann:         result = QtWidgets.QTreeView.mousePressEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid():
        cbilling:             self._pressed_index = self.indexAt(event.pos())
        cbilling:         return result
        cbilling: 
        cbilling:     def leaveEvent(self, event):
     janwerkmann:         result = QtWidgets.QTreeView.leaveEvent(self, event)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         return result
        cbilling: 
        cbilling:     def mouseDoubleClickEvent(self, event):
        cbilling:         # Ensure our left click event occurs regardless of whether it is the
        cbilling:         # second click in a double click or not
     janwerkmann:         result = QtWidgets.QTreeView.mouseDoubleClickEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid():
        cbilling:             self._pressed_index = self.indexAt(event.pos())
        cbilling:             self._double_click = True
        cbilling:         return result
        cbilling: 
        cbilling:     def mouseReleaseEvent(self, event):
     janwerkmann:         result = QtWidgets.QTreeView.mouseReleaseEvent(self, event)
        cbilling:         index = self.indexAt(event.pos())
        cbilling:         if event.button() == QtCore.Qt.LeftButton and index.isValid() and index == self._pressed_index:
        cbilling:             self.leftClicked.emit(index)
        cbilling:             if self._double_click:
        cbilling:                 self.doubleLeftClicked.emit(index)
        cbilling:         self._pressed_index = None
        cbilling:         self._double_click = False
        cbilling:         return result
        cbilling: 
        cbilling:     def event(self, event):
        cbilling:         if (event.type() == QtCore.QEvent.ShortcutOverride
        cbilling:                 and event.key() in [QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]):
        cbilling:             event.accept()
        cbilling:             item = self.model().itemFromIndex(self.currentIndex())
        cbilling:             if item is not None and item.isEditable():
     janwerkmann:                 if self.state() != QtWidgets.QTreeView.EditingState:
        cbilling:                     self.edit(self.currentIndex())
        cbilling:             else:
        cbilling:                 # Enter on non-editable items simulates a left click:
        cbilling:                 self.leftClicked.emit(self.currentIndex())
        cbilling:             return True
        cbilling:         else:
     janwerkmann:             return QtWidgets.QTreeView.event(self, event)
        cbilling: 
        cbilling:     def keyPressEvent(self, event):
        cbilling:         if event.key() == QtCore.Qt.Key_Space:
        cbilling:             item = self.model().itemFromIndex(self.currentIndex())
        cbilling:             if not item.isEditable():
        cbilling:                 # Space on non-editable items simulates a left click:
        cbilling:                 self.leftClicked.emit(self.currentIndex())
     janwerkmann:         return QtWidgets.QTreeView.keyPressEvent(self, event)
        cbilling: 
        cbilling:     def moveCursor(self, cursor_action, keyboard_modifiers):
        cbilling:         current_index = self.currentIndex()
        cbilling:         current_row, current_column = current_index.row(), current_index.column()
     janwerkmann:         if cursor_action == QtWidgets.QTreeView.MoveUp:
        cbilling:             return current_index.sibling(current_row - 1, current_column)
     janwerkmann:         elif cursor_action == QtWidgets.QTreeView.MoveDown:
        cbilling:             return current_index.sibling(current_row + 1, current_column)
     janwerkmann:         elif cursor_action == QtWidgets.QTreeView.MoveLeft:
        cbilling:             return current_index.sibling(current_row, current_column - 1)
     janwerkmann:         elif cursor_action == QtWidgets.QTreeView.MoveRight:
        cbilling:             return current_index.sibling(current_row, current_column + 1)
     janwerkmann:         elif cursor_action == QtWidgets.QTreeView.MovePrevious:
        cbilling:             return current_index.sibling(current_row, current_column - 1)
     janwerkmann:         elif cursor_action == QtWidgets.QTreeView.MoveNext:
        cbilling:             item = self.model().itemFromIndex(self.currentIndex())
        cbilling:             if (item is not None and self._ROLE_IGNORE_TABNEXT is not None
        cbilling:                     and item.data(self._ROLE_IGNORE_TABNEXT)):
        cbilling:                 # A null index means end editing and don't go anywhere:
        cbilling:                 return QtCore.QModelIndex()
        cbilling:             return current_index.sibling(current_row, current_column + 1)
        cbilling:         else:
     janwerkmann:             return QtWidgets.QTreeView.moveCursor(self, cursor_action, keyboard_modifiers)
        cbilling: 
        cbilling: 
        cbilling: class AlternatingColorModel(QtGui.QStandardItemModel):
        cbilling: 
        cbilling:     def __init__(self, treeview):
        cbilling:         QtGui.QStandardItemModel.__init__(self)
        cbilling:         # How much darker in each channel is the alternate base color compared
        cbilling:         # to the base color?
        cbilling:         palette = treeview.palette()
        cbilling:         normal_color = palette.color(QtGui.QPalette.Base)
        cbilling:         alternate_color = palette.color(QtGui.QPalette.AlternateBase)
        cbilling:         r, g, b, a = normal_color.getRgb()
        cbilling:         alt_r, alt_g, alt_b, alt_a = alternate_color.getRgb()
        cbilling:         self.delta_r = alt_r - r
        cbilling:         self.delta_g = alt_g - g
        cbilling:         self.delta_b = alt_b - b
        cbilling:         self.delta_a = alt_a - a
        cbilling: 
        cbilling:         # A cache, store brushes so we don't have to recalculate them. Is faster.
        cbilling:         self.alternate_brushes = {}
        cbilling: 
        cbilling:     def data(self, index, role):
        cbilling:         """When background color data is being requested, returns modified
        cbilling:        colours for every second row, according to the palette of the treeview.
        cbilling:        This has the effect of making the alternate colours visible even when
        cbilling:        custom colors have been set - the same shading will be applied to the
        cbilling:        custom colours. Only really looks sensible when the normal and
        cbilling:        alternate colors are similar."""
        cbilling:         if role == QtCore.Qt.BackgroundRole and index.row() % 2:
        cbilling:             normal_brush = QtGui.QStandardItemModel.data(self, index, QtCore.Qt.BackgroundRole)
        cbilling:             if normal_brush is not None:
        cbilling:                 normal_color = normal_brush.color()
        cbilling:                 try:
        cbilling:                     return self.alternate_brushes[normal_color.rgb()]
        cbilling:                 except KeyError:
        cbilling:                     r, g, b, a = normal_color.getRgb()
        cbilling:                     alt_r = min(max(r + self.delta_r, 0), 255)
        cbilling:                     alt_g = min(max(g + self.delta_g, 0), 255)
        cbilling:                     alt_b = min(max(b + self.delta_b, 0), 255)
        cbilling:                     alt_a = min(max(a + self.delta_a, 0), 255)
        cbilling:                     alternate_color = QtGui.QColor(alt_r, alt_g, alt_b, alt_a)
        cbilling:                     alternate_brush = QtGui.QBrush(alternate_color)
        cbilling:                     self.alternate_brushes[normal_color.rgb()] = alternate_brush
        cbilling:                     return alternate_brush
        cbilling:         return QtGui.QStandardItemModel.data(self, index, role)
        cbilling: 
        cbilling: 
     janwerkmann: class ItemDelegate(QtWidgets.QStyledItemDelegate):
        cbilling: 
        cbilling:     """An item delegate with a fixed height and faint grey vertical lines
        cbilling:     between columns"""
        cbilling:     EXTRA_ROW_HEIGHT = 7
        cbilling: 
        cbilling:     def __init__(self, treeview, *args, **kwargs):
     janwerkmann:         QtWidgets.QStyledItemDelegate.__init__(self, *args, **kwargs)
        cbilling:         self._pen = QtGui.QPen()
        cbilling:         self._pen.setWidth(1)
        cbilling:         self._pen.setColor(QtGui.QColor.fromRgb(128, 128, 128, 64))
        cbilling:         fontmetrics = QtGui.QFontMetrics(treeview.font())
        cbilling:         text_height = fontmetrics.height()
        cbilling:         self.height = text_height + self.EXTRA_ROW_HEIGHT
        cbilling: 
        cbilling:     def sizeHint(self, *args):
     janwerkmann:         size = QtWidgets.QStyledItemDelegate.sizeHint(self, *args)
        cbilling:         return QtCore.QSize(size.width(), self.height)
        cbilling: 
        cbilling:     def paint(self, painter, option, index):
     janwerkmann:         QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)
        cbilling:         if index.column() > 0:
        cbilling:             painter.setPen(self._pen)
        cbilling:             painter.drawLine(option.rect.topLeft(), option.rect.bottomLeft())
        cbilling: 
        cbilling: 
        cbilling: class GroupTab(object):
        cbilling:     GLOBALS_COL_DELETE = 0
        cbilling:     GLOBALS_COL_NAME = 1
        cbilling:     GLOBALS_COL_VALUE = 2
        cbilling:     GLOBALS_COL_UNITS = 3
        cbilling:     GLOBALS_COL_EXPANSION = 4
        cbilling: 
        cbilling:     GLOBALS_ROLE_IS_DUMMY_ROW = QtCore.Qt.UserRole + 1
        cbilling:     GLOBALS_ROLE_SORT_DATA = QtCore.Qt.UserRole + 2
        cbilling:     GLOBALS_ROLE_PREVIOUS_TEXT = QtCore.Qt.UserRole + 3
        cbilling:     GLOBALS_ROLE_IS_BOOL = QtCore.Qt.UserRole + 4
        cbilling:     GLOBALS_ROLE_IGNORE_TABNEXT = QtCore.Qt.UserRole + 5
        cbilling: 
        cbilling:     COLOR_ERROR = '#FF9999'  # light red
        cbilling:     COLOR_OK = '#AAFFCC'  # light green
        cbilling:     COLOR_BOOL_ON = '#66FF33'  # bright green
        cbilling:     COLOR_BOOL_OFF = '#608060'  # dark green
        cbilling:     COLOR_NAME = '#EFEFEF'  # light grey
        cbilling: 
        cbilling:     GLOBALS_DUMMY_ROW_TEXT = '<Click to add global>'
        cbilling: 
        cbilling:     def __init__(self, tabWidget, globals_file, group_name):
        cbilling: 
        cbilling:         self.tabWidget = tabWidget
        cbilling: 
        cbilling:         loader = UiLoader()
        cbilling:         loader.registerCustomWidget(TreeView)
        cbilling:         self.ui = loader.load('group.ui')
        cbilling: 
        cbilling:         # Add the ui to the parent tabWidget:
        cbilling:         self.tabWidget.addTab(self.ui, group_name, closable=True)
        cbilling: 
        cbilling:         self.set_file_and_group_name(globals_file, group_name)
        cbilling: 
        cbilling:         self.globals_model = AlternatingColorModel(treeview=self.ui.treeView_globals)
        cbilling:         self.globals_model.setHorizontalHeaderLabels(['Delete', 'Name', 'Value', 'Units', 'Expansion'])
        cbilling:         self.globals_model.setSortRole(self.GLOBALS_ROLE_SORT_DATA)
        cbilling: 
        cbilling:         self.item_delegate = ItemDelegate(self.ui.treeView_globals)
        cbilling:         for col in range(self.globals_model.columnCount()):
        cbilling:             self.ui.treeView_globals.setItemDelegateForColumn(col, self.item_delegate)
        cbilling: 
        cbilling:         self.ui.treeView_globals.setModel(self.globals_model)
        cbilling:         self.ui.treeView_globals.setRoleIgnoreTabNext(self.GLOBALS_ROLE_IGNORE_TABNEXT)
     janwerkmann:         self.ui.treeView_globals.setSelectionMode(QtWidgets.QTreeView.ExtendedSelection)
        cbilling:         self.ui.treeView_globals.setSortingEnabled(True)
        cbilling:         # Make it so the user can just start typing on an item to edit:
     janwerkmann:         self.ui.treeView_globals.setEditTriggers(QtWidgets.QTreeView.AnyKeyPressed |
     janwerkmann:                                                  QtWidgets.QTreeView.EditKeyPressed)
        cbilling:         # Ensure the clickable region of the delete button doesn't extend forever:
        cbilling:         self.ui.treeView_globals.header().setStretchLastSection(False)
        cbilling:         # Setup stuff for a custom context menu:
        cbilling:         self.ui.treeView_globals.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        cbilling:         # Make the actions for the context menu:
     janwerkmann:         self.action_globals_delete_selected = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/minus'), 'Delete selected global(s)',  self.ui)
     janwerkmann:         self.action_globals_set_selected_true = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box'), 'Set selected Booleans True',  self.ui)
     janwerkmann:         self.action_globals_set_selected_false = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box-uncheck'), 'Set selected Booleans False',  self.ui)
        cbilling: 
        cbilling:         self.connect_signals()
        cbilling: 
        cbilling:         # Populate the model with globals from the h5 file:
        cbilling:         self.populate_model()
        cbilling:         # Set sensible column widths:
        cbilling:         for col in range(self.globals_model.columnCount()):
        cbilling:             self.ui.treeView_globals.resizeColumnToContents(col)
        cbilling:         if self.ui.treeView_globals.columnWidth(self.GLOBALS_COL_NAME) < 200:
        cbilling:             self.ui.treeView_globals.setColumnWidth(self.GLOBALS_COL_NAME, 200)
        cbilling:         if self.ui.treeView_globals.columnWidth(self.GLOBALS_COL_VALUE) < 200:
        cbilling:             self.ui.treeView_globals.setColumnWidth(self.GLOBALS_COL_VALUE, 200)
        cbilling:         if self.ui.treeView_globals.columnWidth(self.GLOBALS_COL_UNITS) < 100:
        cbilling:             self.ui.treeView_globals.setColumnWidth(self.GLOBALS_COL_UNITS, 100)
        cbilling:         if self.ui.treeView_globals.columnWidth(self.GLOBALS_COL_EXPANSION) < 100:
        cbilling:             self.ui.treeView_globals.setColumnWidth(self.GLOBALS_COL_EXPANSION, 100)
        cbilling:         self.ui.treeView_globals.resizeColumnToContents(self.GLOBALS_COL_DELETE)
        cbilling: 
        cbilling:     def connect_signals(self):
        cbilling:         self.ui.treeView_globals.leftClicked.connect(self.on_treeView_globals_leftClicked)
        cbilling:         self.ui.treeView_globals.customContextMenuRequested.connect(self.on_treeView_globals_context_menu_requested)
        cbilling:         self.action_globals_set_selected_true.triggered.connect(
        cbilling:             lambda: self.on_globals_set_selected_bools_triggered('True'))
        cbilling:         self.action_globals_set_selected_false.triggered.connect(
        cbilling:             lambda: self.on_globals_set_selected_bools_triggered('False'))
        cbilling:         self.action_globals_delete_selected.triggered.connect(self.on_globals_delete_selected_triggered)
        cbilling:         self.globals_model.itemChanged.connect(self.on_globals_model_item_changed)
        cbilling:         # A context manager with which we can temporarily disconnect the above connection.
        cbilling:         self.globals_model_item_changed_disconnected = DisconnectContextManager(
        cbilling:             self.globals_model.itemChanged, self.on_globals_model_item_changed)
        cbilling: 
        cbilling:     def set_file_and_group_name(self, globals_file, group_name):
        cbilling:         """Provided as a separate method so the main app can call it if the
        cbilling:         group gets renamed"""
        cbilling:         self.globals_file = globals_file
        cbilling:         self.group_name = group_name
        cbilling:         self.ui.label_globals_file.setText(globals_file)
        cbilling:         self.ui.label_group_name.setText(group_name)
        cbilling:         index = self.tabWidget.indexOf(self.ui)
        cbilling:         self.tabWidget.setTabText(index, group_name)
        cbilling:         self.tabWidget.setTabToolTip(index, '%s\n(%s)' % (group_name, globals_file))
        cbilling: 
        cbilling:     def set_tab_icon(self, icon_string):
        cbilling:         index = self.tabWidget.indexOf(self.ui)
        cbilling:         if icon_string is not None:
        cbilling:             icon = QtGui.QIcon(icon_string)
        cbilling:         else:
        cbilling:             icon = QtGui.QIcon()
        cbilling:         if self.tabWidget.tabIcon(index).cacheKey() != icon.cacheKey():
        cbilling:             logger.info('setting tab icon')
        cbilling:             self.tabWidget.setTabIcon(index, icon)
        cbilling: 
        cbilling:     def populate_model(self):
        cbilling:         globals = runmanager.get_globals({self.group_name: self.globals_file})[self.group_name]
        cbilling:         for name, (value, units, expansion) in globals.items():
        cbilling:             row = self.make_global_row(name, value, units, expansion)
        cbilling:             self.globals_model.appendRow(row)
        cbilling:             value_item = row[self.GLOBALS_COL_VALUE]
        cbilling:             self.check_for_boolean_values(value_item)
        cbilling:             expansion_item = row[self.GLOBALS_COL_EXPANSION]
        cbilling:             self.on_globals_model_expansion_changed(expansion_item)
        cbilling: 
        cbilling:         # Add the dummy item at the end:
        cbilling:         dummy_delete_item = QtGui.QStandardItem()
        cbilling:         # This lets later code know that this row does not correspond to an
        cbilling:         # actual global:
        cbilling:         dummy_delete_item.setData(True, self.GLOBALS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_delete_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling:         dummy_delete_item.setToolTip('Click to add global')
        cbilling: 
        cbilling:         dummy_name_item = QtGui.QStandardItem(self.GLOBALS_DUMMY_ROW_TEXT)
        cbilling:         dummy_name_item.setToolTip('Click to add global')
        cbilling:         dummy_name_item.setData(True, self.GLOBALS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_name_item.setData(self.GLOBALS_DUMMY_ROW_TEXT, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         dummy_name_item.setFlags(QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsEditable)  # Clears the 'selectable' flag
        cbilling:         dummy_name_item.setBackground(QtGui.QColor(self.COLOR_NAME))
        cbilling: 
        cbilling:         dummy_value_item = QtGui.QStandardItem()
        cbilling:         dummy_value_item.setData(True, self.GLOBALS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_value_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling:         dummy_value_item.setToolTip('Click to add global')
        cbilling: 
        cbilling:         dummy_units_item = QtGui.QStandardItem()
        cbilling:         dummy_units_item.setData(True, self.GLOBALS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_units_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling:         dummy_units_item.setToolTip('Click to add global')
        cbilling: 
        cbilling:         dummy_expansion_item = QtGui.QStandardItem()
        cbilling:         dummy_expansion_item.setData(True, self.GLOBALS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_expansion_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling:         dummy_expansion_item.setToolTip('Click to add global')
        cbilling: 
        cbilling:         self.globals_model.appendRow(
        cbilling:             [dummy_delete_item, dummy_name_item, dummy_value_item, dummy_units_item, dummy_expansion_item])
        cbilling: 
        cbilling:         # Sort by name:
        cbilling:         self.ui.treeView_globals.sortByColumn(self.GLOBALS_COL_NAME, QtCore.Qt.AscendingOrder)
        cbilling: 
        cbilling:     def make_global_row(self, name, value='', units='', expansion=''):
        cbilling:         logger.debug('%s:%s - make global row: %s ' % (self.globals_file, self.group_name, name))
        cbilling:         # We just set some data here, other stuff is set in
        cbilling:         # self.update_parse_indication after runmanager has a chance to parse
        cbilling:         # everything and get back to us about what that data should be.
        cbilling: 
        cbilling:         delete_item = QtGui.QStandardItem()
        cbilling:         delete_item.setIcon(QtGui.QIcon(':qtutils/fugue/minus'))
        cbilling:         # Must be set to something so that the dummy row doesn't get sorted first:
        cbilling:         delete_item.setData(False, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:         delete_item.setEditable(False)
        cbilling:         delete_item.setToolTip('Delete global from group.')
        cbilling: 
        cbilling:         name_item = QtGui.QStandardItem(name)
        cbilling:         name_item.setData(name, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:         name_item.setData(name, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         name_item.setToolTip(name)
        cbilling:         name_item.setBackground(QtGui.QColor(self.COLOR_NAME))
        cbilling: 
        cbilling:         value_item = QtGui.QStandardItem(value)
        cbilling:         value_item.setData(value, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:         value_item.setData(str(value), self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         value_item.setToolTip('Evaluating...')
        cbilling: 
        cbilling:         units_item = QtGui.QStandardItem(units)
        cbilling:         units_item.setData(units, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:         units_item.setData(units, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         units_item.setData(False, self.GLOBALS_ROLE_IS_BOOL)
        cbilling:         # Treeview.moveCursor will see this and not go to the expansion item
        cbilling:         # when tab is pressed after editing:
        cbilling:         units_item.setData(True, self.GLOBALS_ROLE_IGNORE_TABNEXT)
        cbilling:         units_item.setToolTip('')
        cbilling: 
        cbilling:         expansion_item = QtGui.QStandardItem(expansion)
        cbilling:         expansion_item.setData(expansion, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:         expansion_item.setData(expansion, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         expansion_item.setToolTip('')
        cbilling: 
        cbilling:         row = [delete_item, name_item, value_item, units_item, expansion_item]
        cbilling:         return row
        cbilling: 
        cbilling:     def on_treeView_globals_leftClicked(self, index):
        cbilling:         if qapplication.keyboardModifiers() != QtCore.Qt.NoModifier:
        cbilling:             # Only handle mouseclicks with no keyboard modifiers.
        cbilling:             return
        cbilling:         item = self.globals_model.itemFromIndex(index)
        cbilling:         # The 'name' item in the same row:
        cbilling:         name_index = index.sibling(index.row(), self.GLOBALS_COL_NAME)
        cbilling:         name_item = self.globals_model.itemFromIndex(name_index)
        cbilling:         global_name = name_item.text()
        cbilling:         if item.data(self.GLOBALS_ROLE_IS_DUMMY_ROW):
        cbilling:             # They clicked on an 'add new global' row. Enter editing mode on
        cbilling:             # the name item so they can enter a name for the new global:
        cbilling:             self.ui.treeView_globals.setCurrentIndex(name_index)
        cbilling:             self.ui.treeView_globals.edit(name_index)
        cbilling:         elif item.data(self.GLOBALS_ROLE_IS_BOOL):
        cbilling:             # It's a bool indicator. Toggle it
        cbilling:             value_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_VALUE)
        cbilling:             if value_item.text() == 'True':
        cbilling:                 value_item.setText('False')
        cbilling:             elif value_item.text() == 'False':
        cbilling:                 value_item.setText('True')
        cbilling:             else:
        cbilling:                 raise AssertionError('expected boolean value')
        cbilling:         elif item.column() == self.GLOBALS_COL_DELETE:
        cbilling:             # They clicked a delete button.
        cbilling:             self.delete_global(global_name)
        cbilling:         elif not item.data(self.GLOBALS_ROLE_IS_BOOL):
        cbilling:             # Edit whatever it is:
        cbilling:             if (self.ui.treeView_globals.currentIndex() != index
     janwerkmann:                     or self.ui.treeView_globals.state() != QtWidgets.QTreeView.EditingState):
        cbilling:                 self.ui.treeView_globals.setCurrentIndex(index)
        cbilling:                 self.ui.treeView_globals.edit(index)
        cbilling: 
        cbilling:     def on_globals_model_item_changed(self, item):
        cbilling:         if item.column() == self.GLOBALS_COL_NAME:
        cbilling:             self.on_globals_model_name_changed(item)
        cbilling:         elif item.column() == self.GLOBALS_COL_VALUE:
        cbilling:             self.on_globals_model_value_changed(item)
        cbilling:         elif item.column() == self.GLOBALS_COL_UNITS:
        cbilling:             self.on_globals_model_units_changed(item)
        cbilling:         elif item.column() == self.GLOBALS_COL_EXPANSION:
        cbilling:             self.on_globals_model_expansion_changed(item)
        cbilling: 
        cbilling:     def on_globals_model_name_changed(self, item):
        cbilling:         """Handles global renaming and creation of new globals due to the user
        cbilling:         editing the <click to add global> item"""
        cbilling:         item_text = item.text()
        cbilling:         if item.data(self.GLOBALS_ROLE_IS_DUMMY_ROW):
        cbilling:             if item_text != self.GLOBALS_DUMMY_ROW_TEXT:
        cbilling:                 # The user has made a new global by editing the <click to add
        cbilling:                 # global> item
        cbilling:                 global_name = item_text
        cbilling:                 self.new_global(global_name)
        cbilling:         else:
        cbilling:             # User has renamed a global.
        cbilling:             new_global_name = item_text
        cbilling:             previous_global_name = item.data(self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:             # Ensure the name actually changed, rather than something else
        cbilling:             # about the item:
        cbilling:             if new_global_name != previous_global_name:
        cbilling:                 self.rename_global(previous_global_name, new_global_name)
        cbilling: 
        cbilling:     def on_globals_model_value_changed(self, item):
        cbilling:         index = item.index()
        cbilling:         new_value = item.text()
        cbilling:         previous_value = item.data(self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         name_index = index.sibling(index.row(), self.GLOBALS_COL_NAME)
        cbilling:         name_item = self.globals_model.itemFromIndex(name_index)
        cbilling:         global_name = name_item.text()
        cbilling:         # Ensure the value actually changed, rather than something else about
        cbilling:         # the item:
        cbilling:         if new_value != previous_value:
        cbilling:             self.change_global_value(global_name, previous_value, new_value)
        cbilling: 
        cbilling:     def on_globals_model_units_changed(self, item):
        cbilling:         index = item.index()
        cbilling:         new_units = item.text()
        cbilling:         previous_units = item.data(self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         name_index = index.sibling(index.row(), self.GLOBALS_COL_NAME)
        cbilling:         name_item = self.globals_model.itemFromIndex(name_index)
        cbilling:         global_name = name_item.text()
        cbilling:         # If it's a boolean value, ensure the check state matches the bool state:
        cbilling:         if item.data(self.GLOBALS_ROLE_IS_BOOL):
        cbilling:             value_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_VALUE)
        cbilling:             if value_item.text() == 'True':
        cbilling:                 item.setCheckState(QtCore.Qt.Checked)
        cbilling:             elif value_item.text() == 'False':
        cbilling:                 item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:             else:
        cbilling:                 raise AssertionError('expected boolean value')
        cbilling:         # Ensure the value actually changed, rather than something else about
        cbilling:         # the item:
        cbilling:         if new_units != previous_units:
        cbilling:             self.change_global_units(global_name, previous_units, new_units)
        cbilling: 
        cbilling:     def on_globals_model_expansion_changed(self, item):
        cbilling:         index = item.index()
        cbilling:         new_expansion = item.text()
        cbilling:         previous_expansion = item.data(self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         name_index = index.sibling(index.row(), self.GLOBALS_COL_NAME)
        cbilling:         name_item = self.globals_model.itemFromIndex(name_index)
        cbilling:         global_name = name_item.text()
        cbilling:         # Don't want icon changing to recurse - which happens even if it is
        cbilling:         # the same icon. So disconnect the signal temporarily:
        cbilling:         with self.globals_model_item_changed_disconnected:
        cbilling:             if new_expansion == 'outer':
        cbilling:                 item.setIcon(QtGui.QIcon(':qtutils/custom/outer'))
        cbilling:                 item.setToolTip('This global will be interpreted as a list of values, and will ' +
        cbilling:                                 'be outer producted with other lists to form a larger parameter space.')
        cbilling:             elif new_expansion:
        cbilling:                 item.setIcon(QtGui.QIcon(':qtutils/custom/zip'))
        cbilling:                 item.setToolTip('This global will be interpreted as a list of values, and will ' +
        cbilling:                                 'be iterated over in lock-step with other globals in the ' +
        cbilling:                                 '\'%s\' zip group.' % new_expansion)
        cbilling:             else:
        cbilling:                 item.setData(None, QtCore.Qt.DecorationRole)
        cbilling:                 item.setToolTip('This global will be interpreted as a single value and passed to compilation as-is.')
        cbilling:         # Ensure the value actually changed, rather than something else about
        cbilling:         # the item:
        cbilling:         if new_expansion != previous_expansion:
        cbilling:             self.change_global_expansion(global_name, previous_expansion, new_expansion)
        cbilling: 
        cbilling:     def on_treeView_globals_context_menu_requested(self, point):
     janwerkmann:         menu = QtWidgets.QMenu(self.ui)
        cbilling:         menu.addAction(self.action_globals_set_selected_true)
        cbilling:         menu.addAction(self.action_globals_set_selected_false)
        cbilling:         menu.addAction(self.action_globals_delete_selected)
        cbilling:         menu.exec_(QtGui.QCursor.pos())
        cbilling: 
        cbilling:     def on_globals_delete_selected_triggered(self):
        cbilling:         selected_indexes = self.ui.treeView_globals.selectedIndexes()
        cbilling:         selected_items = (self.globals_model.itemFromIndex(index) for index in selected_indexes)
        cbilling:         name_items = [item for item in selected_items if item.column() == self.GLOBALS_COL_NAME]
        cbilling:         # If multiple selected, show 'delete n groups?' message. Otherwise,
        cbilling:         # pass confirm=True to self.delete_global so it can show the regular
        cbilling:         # message.
        cbilling:         confirm_multiple = (len(name_items) > 1)
        cbilling:         if confirm_multiple:
        cbilling:             if not question_dialog("Delete %d globals?" % len(name_items)):
        cbilling:                 return
        cbilling:         for item in name_items:
        cbilling:             global_name = item.text()
        cbilling:             self.delete_global(global_name, confirm=not confirm_multiple)
        cbilling: 
        cbilling:     def on_globals_set_selected_bools_triggered(self, state):
        cbilling:         selected_indexes = self.ui.treeView_globals.selectedIndexes()
        cbilling:         selected_items = [self.globals_model.itemFromIndex(index) for index in selected_indexes]
        cbilling:         value_items = [item for item in selected_items if item.column() == self.GLOBALS_COL_VALUE]
        cbilling:         units_items = [item for item in selected_items if item.column() == self.GLOBALS_COL_UNITS]
        cbilling:         for value_item, units_item in zip(value_items, units_items):
        cbilling:             if units_item.data(self.GLOBALS_ROLE_IS_BOOL):
        cbilling:                 value_item.setText(state)
        cbilling: 
        cbilling:     def close(self):
        cbilling:         # It is up to the main runmanager class to drop references to this
        cbilling:         # instance before or after calling this method, so that after the
        cbilling:         # tabWidget no longer owns our widgets, both the widgets and the
        cbilling:         # instance will be garbage collected.
        cbilling:         index = self.tabWidget.indexOf(self.ui)
        cbilling:         self.tabWidget.removeTab(index)
        cbilling: 
        cbilling:     def get_global_item_by_name(self, global_name, column, previous_name=None):
        cbilling:         """Returns an item from the row representing a global in the globals model.
        cbilling:         Which item is returned is set by the column argument."""
        cbilling:         possible_name_items = self.globals_model.findItems(global_name, column=self.GLOBALS_COL_NAME)
        cbilling:         if previous_name is not None:
        cbilling:             # Filter by previous name, useful for telling rows apart when a
        cbilling:             # rename is in progress and two rows may temporarily contain the
        cbilling:             # same name (though the rename code with throw an error and revert
        cbilling:             # it).
        cbilling:             possible_name_items = [item for item in possible_name_items
        cbilling:                                    if item.data(self.GLOBALS_ROLE_PREVIOUS_TEXT) == previous_name]
        cbilling:         elif global_name != self.GLOBALS_DUMMY_ROW_TEXT:
        cbilling:             # Don't return the dummy item unless they asked for it explicitly
        cbilling:             # - if a new global is being created, its name might be
        cbilling:             # simultaneously present in its own row and the dummy row too.
        cbilling:             possible_name_items = [item for item in possible_name_items
        cbilling:                                    if not item.data(self.GLOBALS_ROLE_IS_DUMMY_ROW)]
        cbilling:         if len(possible_name_items) > 1:
        cbilling:             raise LookupError('Multiple items found')
        cbilling:         elif not possible_name_items:
        cbilling:             raise LookupError('No item found')
        cbilling:         name_item = possible_name_items[0]
        cbilling:         name_index = name_item.index()
        cbilling:         # Found the name item, get the sibling item for the column requested:
        cbilling:         item_index = name_index.sibling(name_index.row(), column)
        cbilling:         item = self.globals_model.itemFromIndex(item_index)
        cbilling:         return item
        cbilling: 
        cbilling:     def do_model_sort(self):
        cbilling:         header = self.ui.treeView_globals.header()
        cbilling:         sort_column = header.sortIndicatorSection()
        cbilling:         sort_order = header.sortIndicatorOrder()
        cbilling:         self.ui.treeView_globals.sortByColumn(sort_column, sort_order)
        cbilling: 
        cbilling:     def new_global(self, global_name):
        cbilling:         logger.info('%s:%s - new global: %s', self.globals_file, self.group_name, global_name)
        cbilling:         item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_NAME,
        cbilling:                                             previous_name=self.GLOBALS_DUMMY_ROW_TEXT)
        cbilling:         try:
        cbilling:             runmanager.new_global(self.globals_file, self.group_name, global_name)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:         else:
        cbilling:             # Insert the newly created global into the model:
        cbilling:             global_row = self.make_global_row(global_name)
        cbilling:             last_index = self.globals_model.rowCount()
        cbilling:             # Insert it as the row before the last (dummy) row:
        cbilling:             self.globals_model.insertRow(last_index - 1, global_row)
        cbilling:             self.do_model_sort()
        cbilling:             # Go into edit mode on the 'value' item:
        cbilling:             value_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_VALUE,
        cbilling:                                                       previous_name=global_name)
        cbilling:             value_item_index = value_item.index()
        cbilling:             self.ui.treeView_globals.setCurrentIndex(value_item_index)
        cbilling:             self.ui.treeView_globals.edit(value_item_index)
        cbilling:             self.globals_changed()
        cbilling:         finally:
        cbilling:             # Set the dummy row's text back ready for another group to be created:
        cbilling:             item.setText(self.GLOBALS_DUMMY_ROW_TEXT)
        cbilling: 
        cbilling:     def rename_global(self, previous_global_name, new_global_name):
        cbilling:         logger.info('%s:%s - rename global: %s -> %s',
        cbilling:                     self.globals_file, self.group_name, previous_global_name, new_global_name)
        cbilling:         item = self.get_global_item_by_name(new_global_name, self.GLOBALS_COL_NAME,
        cbilling:                                             previous_name=previous_global_name)
        cbilling:         try:
        cbilling:             runmanager.rename_global(self.globals_file, self.group_name, previous_global_name, new_global_name)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:             # Set the item text back to the old name, since the rename failed:
        cbilling:             item.setText(previous_global_name)
        cbilling:         else:
        cbilling:             item.setData(new_global_name, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:             item.setData(new_global_name, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:             self.do_model_sort()
        cbilling:             item.setToolTip(new_global_name)
        cbilling:             self.globals_changed()
        cbilling:             value_item = self.get_global_item_by_name(new_global_name, self.GLOBALS_COL_VALUE)
        cbilling:             value = value_item.text()
        cbilling:             if not value:
        cbilling:                 # Go into editing the units item automatically:
        cbilling:                 value_item_index = value_item.index()
        cbilling:                 self.ui.treeView_globals.setCurrentIndex(value_item_index)
        cbilling:                 self.ui.treeView_globals.edit(value_item_index)
        cbilling:             else:
        cbilling:                 # If this changed the sort order, ensure the item is still visible:
        cbilling:                 scroll_treeview_to_row_if_current(self.ui.treeView_globals, item)
        cbilling: 
        cbilling:     def change_global_value(self, global_name, previous_value, new_value):
        cbilling:         logger.info('%s:%s - change global value: %s = %s -> %s' %
        cbilling:                     (self.globals_file, self.group_name, global_name, previous_value, new_value))
        cbilling:         item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_VALUE)
        cbilling:         previous_background = item.background()
        cbilling:         previous_icon = item.icon()
        cbilling:         item.setData(new_value, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:         item.setData(new_value, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:         item.setData(None, QtCore.Qt.BackgroundRole)
        cbilling:         item.setIcon(QtGui.QIcon(':qtutils/fugue/hourglass'))
        cbilling:         args = global_name, previous_value, new_value, item, previous_background, previous_icon
        cbilling:         QtCore.QTimer.singleShot(1, lambda: self.complete_change_global_value(*args))
     janwerkmann: 
        cbilling:     def complete_change_global_value(self, global_name, previous_value, new_value, item, previous_background, previous_icon):
        cbilling:         try:
        cbilling:             runmanager.set_value(self.globals_file, self.group_name, global_name, new_value)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:             # Set the item text back to the old name, since the change failed:
        cbilling:             with self.globals_model_item_changed_disconnected:
        cbilling:                 item.setText(previous_value)
        cbilling:                 item.setData(previous_value, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:                 item.setData(previous_value, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:                 item.setData(previous_background, QtCore.Qt.BackgroundRole)
        cbilling:                 item.setIcon(previous_icon)
        cbilling:         else:
        cbilling:             self.check_for_boolean_values(item)
        cbilling:             self.do_model_sort()
        cbilling:             item.setToolTip('Evaluating...')
        cbilling:             self.globals_changed()
        cbilling:             units_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_UNITS)
        cbilling:             units = units_item.text()
        cbilling:             if not units:
        cbilling:                 # Go into editing the units item automatically:
        cbilling:                 units_item_index = units_item.index()
        cbilling:                 self.ui.treeView_globals.setCurrentIndex(units_item_index)
        cbilling:                 self.ui.treeView_globals.edit(units_item_index)
        cbilling:             else:
        cbilling:                 # If this changed the sort order, ensure the item is still visible:
        cbilling:                 scroll_treeview_to_row_if_current(self.ui.treeView_globals, item)
        cbilling: 
        cbilling:     def change_global_units(self, global_name, previous_units, new_units):
        cbilling:         logger.info('%s:%s - change units: %s = %s -> %s' %
        cbilling:                     (self.globals_file, self.group_name, global_name, previous_units, new_units))
        cbilling:         item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_UNITS)
        cbilling:         try:
        cbilling:             runmanager.set_units(self.globals_file, self.group_name, global_name, new_units)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:             # Set the item text back to the old units, since the change failed:
        cbilling:             item.setText(previous_units)
        cbilling:         else:
        cbilling:             item.setData(new_units, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:             item.setData(new_units, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:             self.do_model_sort()
        cbilling:             # If this changed the sort order, ensure the item is still visible:
        cbilling:             scroll_treeview_to_row_if_current(self.ui.treeView_globals, item)
        cbilling: 
        cbilling:     def change_global_expansion(self, global_name, previous_expansion, new_expansion):
        cbilling:         logger.info('%s:%s - change expansion: %s = %s -> %s' %
        cbilling:                     (self.globals_file, self.group_name, global_name, previous_expansion, new_expansion))
        cbilling:         item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_EXPANSION)
        cbilling:         try:
        cbilling:             runmanager.set_expansion(self.globals_file, self.group_name, global_name, new_expansion)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:             # Set the item text back to the old units, since the change failed:
        cbilling:             item.setText(previous_expansion)
        cbilling:         else:
        cbilling:             item.setData(new_expansion, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:             item.setData(new_expansion, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:             self.do_model_sort()
        cbilling:             self.globals_changed()
        cbilling:             # If this changed the sort order, ensure the item is still visible:
        cbilling:             scroll_treeview_to_row_if_current(self.ui.treeView_globals, item)
        cbilling: 
        cbilling:     def check_for_boolean_values(self, item):
        cbilling:         """Checks if the value is 'True' or 'False'. If either, makes the
        cbilling:         units cell checkable, uneditable, and coloured to indicate the state.
        cbilling:         The units cell can then be clicked to toggle the value."""
        cbilling:         index = item.index()
        cbilling:         value = item.text()
        cbilling:         name_index = index.sibling(index.row(), self.GLOBALS_COL_NAME)
        cbilling:         units_index = index.sibling(index.row(), self.GLOBALS_COL_UNITS)
        cbilling:         name_item = self.globals_model.itemFromIndex(name_index)
        cbilling:         units_item = self.globals_model.itemFromIndex(units_index)
        cbilling:         global_name = name_item.text()
        cbilling:         logger.debug('%s:%s - check for boolean values: %s' %
        cbilling:                      (self.globals_file, self.group_name, global_name))
        cbilling:         if value == 'True':
        cbilling:             units_item.setData(True, self.GLOBALS_ROLE_IS_BOOL)
        cbilling:             units_item.setText('Bool')
        cbilling:             units_item.setData('!1', self.GLOBALS_ROLE_SORT_DATA)
        cbilling:             units_item.setEditable(False)
        cbilling:             units_item.setCheckState(QtCore.Qt.Checked)
        cbilling:             units_item.setBackground(QtGui.QBrush(QtGui.QColor(self.COLOR_BOOL_ON)))
        cbilling:         elif value == 'False':
        cbilling:             units_item.setData(True, self.GLOBALS_ROLE_IS_BOOL)
        cbilling:             units_item.setText('Bool')
        cbilling:             units_item.setData('!0', self.GLOBALS_ROLE_SORT_DATA)
        cbilling:             units_item.setEditable(False)
        cbilling:             units_item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:             units_item.setBackground(QtGui.QBrush(QtGui.QColor(self.COLOR_BOOL_OFF)))
        cbilling:         else:
        cbilling:             was_bool = units_item.data(self.GLOBALS_ROLE_IS_BOOL)
        cbilling:             units_item.setData(False, self.GLOBALS_ROLE_IS_BOOL)
        cbilling:             units_item.setEditable(True)
        cbilling:             # Checkbox still visible unless we do the following:
        cbilling:             units_item.setData(None, QtCore.Qt.CheckStateRole)
        cbilling:             units_item.setData(None, QtCore.Qt.BackgroundRole)
        cbilling:             if was_bool:
        cbilling:                 # If the item was a bool and now isn't, clear the
        cbilling:                 # units and go into editing so the user can enter a
        cbilling:                 # new units string:
        cbilling:                 units_item.setText('')
        cbilling:                 self.ui.treeView_globals.setCurrentIndex(units_item.index())
        cbilling:                 self.ui.treeView_globals.edit(units_item.index())
        cbilling: 
        cbilling:     def globals_changed(self):
        cbilling:         """Called whenever something about a global has changed. call
        cbilling:         app.globals_changed to inform the main application that it needs to
        cbilling:         parse globals again. self.update_parse_indication will be called by
        cbilling:         the main app when parsing is done, and will set the colours and
        cbilling:         tooltips appropriately"""
        cbilling:         # Tell the main app about it:
        cbilling:         app.globals_changed()
        cbilling: 
        cbilling:     def delete_global(self, global_name, confirm=True):
        cbilling:         logger.info('%s:%s - delete global: %s' %
        cbilling:                     (self.globals_file, self.group_name, global_name))
        cbilling:         if confirm:
        cbilling:             if not question_dialog("Delete the global '%s'?" % global_name):
        cbilling:                 return
        cbilling:         runmanager.delete_global(self.globals_file, self.group_name, global_name)
        cbilling:         # Find the entry for this global in self.globals_model and remove it:
        cbilling:         name_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_NAME)
        cbilling:         self.globals_model.removeRow(name_item.row())
        cbilling:         self.globals_changed()
        cbilling: 
        cbilling:     def update_parse_indication(self, active_groups, sequence_globals, evaled_globals):
        cbilling:         # Check that we are an active group:
        cbilling:         if self.group_name in active_groups and active_groups[self.group_name] == self.globals_file:
        cbilling:             tab_contains_errors = False
        cbilling:             # for global_name, value in evaled_globals[self.group_name].items():
        cbilling:             for i in range(self.globals_model.rowCount()):
        cbilling:                 name_item = self.globals_model.item(i, self.GLOBALS_COL_NAME)
        cbilling:                 if name_item.data(self.GLOBALS_ROLE_IS_DUMMY_ROW):
        cbilling:                     continue
        cbilling:                 value_item = self.globals_model.item(i, self.GLOBALS_COL_VALUE)
        cbilling:                 expansion_item = self.globals_model.item(i, self.GLOBALS_COL_EXPANSION)
        cbilling:                 # value_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_VALUE)
        cbilling:                 # expansion_item = self.get_global_item_by_name(global_name, self.GLOBALS_COL_EXPANSION)
        cbilling:                 global_name = name_item.text()
        cbilling:                 value = evaled_globals[self.group_name][global_name]
     janwerkmann: 
        cbilling:                 ignore, ignore, expansion = sequence_globals[self.group_name][global_name]
        cbilling:                 # Temporarily disconnect the item_changed signal on the model
        cbilling:                 # so that we can set the expansion type without triggering
        cbilling:                 # another preparse - the parsing has already been done with
        cbilling:                 # the new expansion type.
        cbilling:                 with self.globals_model_item_changed_disconnected:
        cbilling:                     if expansion_item.data(self.GLOBALS_ROLE_PREVIOUS_TEXT) != expansion:
        cbilling:                         # logger.info('expansion previous text set')
     janwerkmann:                         expansion_item.setData(expansion, self.GLOBALS_ROLE_PREVIOUS_TEXT)
        cbilling:                     if expansion_item.data(self.GLOBALS_ROLE_SORT_DATA) != expansion:
        cbilling:                         # logger.info('sort data role set')
        cbilling:                         expansion_item.setData(expansion, self.GLOBALS_ROLE_SORT_DATA)
        cbilling:                 # The next line will now trigger item_changed, but it will not
        cbilling:                 # be detected as an actual change to the expansion type,
        cbilling:                 # because previous_text will match text. So it will not look
        cbilling:                 # like a change and will not trigger preparsing. However It is
        cbilling:                 # still important that other triggers be processed, such as
        cbilling:                 # setting the icon in the expansion item, so that will still
        cbilling:                 # occur in the callback.
        cbilling:                 expansion_item.setText(expansion)
        cbilling:                 if isinstance(value, Exception):
        cbilling:                     value_item.setBackground(QtGui.QBrush(QtGui.QColor(self.COLOR_ERROR)))
        cbilling:                     value_item.setIcon(QtGui.QIcon(':qtutils/fugue/exclamation'))
             jan:                     tooltip = '%s: %s' % (value.__class__.__name__, str(value))
        cbilling:                     tab_contains_errors = True
        cbilling:                 else:
        cbilling:                     if value_item.background().color().name().lower() != self.COLOR_OK.lower():
        cbilling:                         value_item.setBackground(QtGui.QBrush(QtGui.QColor(self.COLOR_OK)))
        cbilling:                     if not value_item.icon().isNull():
        cbilling:                         # logger.info('clearing icon')
        cbilling:                         value_item.setData(None, QtCore.Qt.DecorationRole)
        cbilling:                     tooltip = repr(value)
        cbilling:                 if value_item.toolTip() != tooltip:
        cbilling:                     # logger.info('tooltip_changed')
        cbilling:                     value_item.setToolTip(tooltip)
        cbilling:             if tab_contains_errors:
        cbilling:                 self.set_tab_icon(':qtutils/fugue/exclamation')
        cbilling:             else:
        cbilling:                 self.set_tab_icon(None)
        cbilling:         else:
        cbilling:             # Clear everything:
        cbilling:             self.set_tab_icon(None)
        cbilling:             for row in range(self.globals_model.rowCount()):
        cbilling:                 item = self.globals_model.item(row, self.GLOBALS_COL_VALUE)
        cbilling:                 if item.data(self.GLOBALS_ROLE_IS_DUMMY_ROW):
        cbilling:                     continue
        cbilling:                 item.setData(None, QtCore.Qt.DecorationRole)
        cbilling:                 item.setToolTip('Group inactive')
        cbilling:                 item.setData(None, QtCore.Qt.BackgroundRole)
        cbilling: 
        cbilling: 
     janwerkmann: class RunmanagerMainWindow(QtWidgets.QMainWindow):
        cbilling:     # A signal to show that the window is shown and painted.
        cbilling:     firstPaint = Signal()
        cbilling:     # A signal for when the window manager has created a new window for this widget:
        cbilling:     newWindow = Signal(int)
        cbilling: 
        cbilling:     def __init__(self, *args, **kwargs):
     janwerkmann:         QtWidgets.QMainWindow.__init__(self, *args, **kwargs)
        cbilling:         self._previously_painted = False
        cbilling: 
        cbilling:     def closeEvent(self, event):
        cbilling:         if app.on_close_event():
     janwerkmann:             return QtWidgets.QMainWindow.closeEvent(self, event)
        cbilling:         else:
        cbilling:             event.ignore()
        cbilling: 
        cbilling:     def event(self, event):
     janwerkmann:         result = QtWidgets.QMainWindow.event(self, event)
        cbilling:         if event.type() == QtCore.QEvent.WinIdChange:
        cbilling:             self.newWindow.emit(self.effectiveWinId())
        cbilling:         return result
        cbilling: 
        cbilling:     def paintEvent(self, event):
     janwerkmann:         result = QtWidgets.QMainWindow.paintEvent(self, event)
        cbilling:         if not self._previously_painted:
        cbilling:             self._previously_painted = True
        cbilling:             self.firstPaint.emit()
        cbilling:         return result
        cbilling: 
        cbilling: 
     janwerkmann: class PoppedOutOutputBoxWindow(QtWidgets.QDialog):
        cbilling:     # A signal for when the window manager has created a new window for this widget:
        cbilling:     newWindow = Signal(int)
        cbilling: 
        cbilling:     def closeEvent(self, event):
        cbilling:         app.on_output_popout_button_clicked()
        cbilling: 
        cbilling:     def event(self, event):
     janwerkmann:         result = QtWidgets.QDialog.event(self, event)
        cbilling:         if event.type() == QtCore.QEvent.WinIdChange:
        cbilling:             self.newWindow.emit(self.effectiveWinId())
        cbilling:         return result
        cbilling: 
        cbilling: 
        cbilling: class RunManager(object):
        cbilling: 
        cbilling:     # Constants for the model in the axes tab:
        cbilling:     AXES_COL_NAME = 0
        cbilling:     AXES_COL_LENGTH = 1
        cbilling:     AXES_COL_SHUFFLE = 2
        pstarkey:     AXES_ROLE_NAME = QtCore.Qt.UserRole + 1
        cbilling: 
        cbilling:     # Constants for the model in the groups tab:
        cbilling:     GROUPS_COL_NAME = 0
        cbilling:     GROUPS_COL_ACTIVE = 1
        cbilling:     GROUPS_COL_DELETE = 2
        cbilling:     GROUPS_COL_OPENCLOSE = 3
        cbilling:     GROUPS_ROLE_IS_DUMMY_ROW = QtCore.Qt.UserRole + 1
        cbilling:     GROUPS_ROLE_PREVIOUS_NAME = QtCore.Qt.UserRole + 2
        cbilling:     GROUPS_ROLE_SORT_DATA = QtCore.Qt.UserRole + 3
        cbilling:     GROUPS_ROLE_GROUP_IS_OPEN = QtCore.Qt.UserRole + 4
        cbilling:     GROUPS_DUMMY_ROW_TEXT = '<Click to add group>'
        cbilling: 
        cbilling:     def __init__(self):
        pstarkey:     
        cbilling:         loader = UiLoader()
        cbilling:         loader.registerCustomWidget(FingerTabWidget)
        cbilling:         loader.registerCustomWidget(TreeView)
        cbilling:         self.ui = loader.load('main.ui', RunmanagerMainWindow())
        cbilling: 
        cbilling:         self.output_box = OutputBox(self.ui.verticalLayout_output_tab)
        cbilling: 
        cbilling:         # Add a 'pop-out' button to the output tab:
        cbilling:         output_tab_index = self.ui.tabWidget.indexOf(self.ui.tab_output)
        cbilling:         self.output_popout_button = TabToolButton(self.ui.tabWidget.parent())
        cbilling:         self.output_popout_button.setIcon(QtGui.QIcon(':/qtutils/fugue/arrow-out'))
        cbilling:         self.output_popout_button.setToolTip('Toggle whether the output box is in a separate window')
     janwerkmann:         self.ui.tabWidget.tabBar().setTabButton(output_tab_index, QtWidgets.QTabBar.RightSide, self.output_popout_button)
        cbilling:         # Fix the first three tabs in place:
        cbilling:         for index in range(3):
        cbilling:             self.ui.tabWidget.tabBar().setMovable(False, index=index)
        cbilling:         # Whether or not the output box is currently popped out:
        cbilling:         self.output_box_is_popped_out = False
        cbilling:         # The window it will be moved to when popped out:
        cbilling:         self.output_box_window = PoppedOutOutputBoxWindow(self.ui, QtCore.Qt.WindowSystemMenuHint)
     janwerkmann:         self.output_box_window_verticalLayout = QtWidgets.QVBoxLayout(self.output_box_window)
        cbilling:         self.output_box_window_verticalLayout.setContentsMargins(0, 0, 0, 0)
        cbilling:         self.output_box_window.setWindowTitle('runmanager output')
        cbilling:         self.output_box_window.resize(800, 1000)
        cbilling:         self.setup_config()
        cbilling:         self.setup_axes_tab()
        cbilling:         self.setup_groups_tab()
        cbilling:         self.connect_signals()
        cbilling: 
        cbilling:         # The last location from which a labscript file was selected, defaults
        cbilling:         # to labscriptlib:
        cbilling:         self.last_opened_labscript_folder = self.exp_config.get('paths', 'labscriptlib')
        cbilling:         # The last location from which a globals file was selected, defaults
        cbilling:         # to experiment_shot_storage:
        cbilling:         self.last_opened_globals_folder = self.exp_config.get('paths', 'experiment_shot_storage')
        cbilling:         # The last file to which the user saved or loaded a configuration:
        cbilling:         self.last_save_config_file = None
        cbilling:         # The last manually selected shot output folder, defaults to
        cbilling:         # experiment_shot_storage:
        cbilling:         self.last_selected_shot_output_folder = self.exp_config.get('paths', 'experiment_shot_storage')
        cbilling:         self.shared_drive_prefix = self.exp_config.get('paths', 'shared_drive')
        cbilling:         self.experiment_shot_storage = self.exp_config.get('paths', 'experiment_shot_storage')
        cbilling:         # What the automatically created output folders should be, as an
        cbilling:         # argument to time.strftime():
        cbilling:         try:
        cbilling:             self.output_folder_format = self.exp_config.get('runmanager', 'output_folder_format')
        cbilling:             # Better not start with slashes, irrelevant if it ends with them:
        cbilling:             self.output_folder_format = self.output_folder_format.strip(os.path.sep)
        cbilling:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
        cbilling:             self.output_folder_format = os.path.join('%Y', '%m', '%d')
        cbilling:         # Store the currently open groups as {(globals_filename, group_name): GroupTab}
        cbilling:         self.currently_open_groups = {}
        cbilling: 
        cbilling:         # A thread that will evaluate globals when they change, allowing us to
        cbilling:         # show their values and any errors in the tabs they came from.
        cbilling:         self.preparse_globals_thread = threading.Thread(target=self.preparse_globals_loop)
        cbilling:         self.preparse_globals_thread.daemon = True
        cbilling:         # A threading.Event to inform the preparser thread when globals have
        cbilling:         # changed, and thus need parsing again:
        cbilling:         self.preparse_globals_required = threading.Event()
        cbilling:         self.preparse_globals_thread.start()
        cbilling: 
        cbilling:         # A flag telling the compilation thread to abort:
        cbilling:         self.compilation_aborted = threading.Event()
        cbilling: 
        cbilling:         # A few attributes for self.guess_expansion_modes() to keep track of
        cbilling:         # its state, and thus detect changes:
        cbilling:         self.previous_evaled_globals = {}
        cbilling:         self.previous_global_hierarchy = {}
        cbilling:         self.previous_expansion_types = {}
        cbilling:         self.previous_expansions = {}
        cbilling: 
        cbilling:         # Start the loop that allows compilations to be queued up:
     janwerkmann:         self.compile_queue = queue.Queue()
        cbilling:         self.compile_queue_thread = threading.Thread(target=self.compile_loop)
        cbilling:         self.compile_queue_thread.daemon = True
        cbilling:         self.compile_queue_thread.start()
        cbilling: 
        cbilling:         # Start the compiler subprocess:
        cbilling:         self.to_child, self.from_child, self.child = zprocess.subprocess_with_queues(
        cbilling:             'batch_compiler.py', self.output_box.port)
        cbilling: 
        cbilling:         # Start a thread to monitor the time of day and create new shot output
        cbilling:         # folders for each day:
        cbilling:         self.output_folder_update_required = threading.Event()
        cbilling:         inthread(self.rollover_shot_output_folder)
        cbilling: 
        cbilling:         # The data from the last time we saved the configuration, so we can
        cbilling:         # know if something's changed:
        cbilling:         self.last_save_data = None
        cbilling: 
        cbilling:         # autoload a config file, if labconfig is set to do so:
        cbilling:         try:
        cbilling:             autoload_config_file = self.exp_config.get('runmanager', 'autoload_config_file')
        cbilling:         except (LabConfig.NoOptionError, LabConfig.NoSectionError):
        cbilling:             self.output_box.output('Ready.\n\n')
        cbilling:         else:
        cbilling:             self.ui.setEnabled(False)
        cbilling:             self.output_box.output('Loading default config file %s...' % autoload_config_file)
        cbilling: 
        cbilling:             def load_the_config_file():
        cbilling:                 try:
        cbilling:                     self.load_configuration(autoload_config_file)
        cbilling:                     self.output_box.output('done.\n')
        cbilling:                 except Exception as e:
        cbilling:                     self.output_box.output('\nCould not load config file: %s: %s\n\n' %
        cbilling:                                            (e.__class__.__name__, str(e)), red=True)
        cbilling:                 else:
        cbilling:                     self.output_box.output('Ready.\n\n')
        cbilling:                 finally:
        cbilling:                     self.ui.setEnabled(True)
        cbilling:             # Defer this until 50ms after the window has shown,
        cbilling:             # so that the GUI pops up faster in the meantime
        cbilling:             self.ui.firstPaint.connect(lambda: QtCore.QTimer.singleShot(50, load_the_config_file))
        cbilling: 
        cbilling:         self.ui.show()
        cbilling: 
        cbilling:     def setup_config(self):
        cbilling:         required_config_params = {"DEFAULT": ["experiment_name"],
        cbilling:                                   "programs": ["text_editor",
        cbilling:                                                "text_editor_arguments",
        cbilling:                                                ],
        cbilling:                                   "ports": ['BLACS', 'runviewer'],
        cbilling:                                   "paths": ["shared_drive",
        cbilling:                                             "experiment_shot_storage",
        cbilling:                                             "labscriptlib",
        cbilling:                                             ],
        cbilling:                                   }
     janwerkmann:         self.exp_config = LabConfig(required_params = required_config_params)
        cbilling: 
        cbilling:     def setup_axes_tab(self):
        cbilling:         self.axes_model = QtGui.QStandardItemModel()
        cbilling: 
        cbilling:         # Setup the model columns and link to the treeview
        cbilling:         name_header_item = QtGui.QStandardItem('Name')
        cbilling:         name_header_item.setToolTip('The name of the global or zip group being iterated over')
        cbilling:         self.axes_model.setHorizontalHeaderItem(self.AXES_COL_NAME, name_header_item)
        cbilling: 
        cbilling:         length_header_item = QtGui.QStandardItem('Length')
        cbilling:         length_header_item.setToolTip('The number of elements in the axis of the parameter space')
        cbilling:         self.axes_model.setHorizontalHeaderItem(self.AXES_COL_LENGTH, length_header_item)
        cbilling: 
        cbilling:         shuffle_header_item = QtGui.QStandardItem('Shuffle')
        cbilling:         shuffle_header_item.setToolTip('Whether or not the order of the axis should be randomised')
        cbilling:         shuffle_header_item.setIcon(QtGui.QIcon(':qtutils/fugue/arrow-switch'))
        cbilling:         self.axes_model.setHorizontalHeaderItem(self.AXES_COL_SHUFFLE, shuffle_header_item)
        cbilling: 
        cbilling:         self.ui.treeView_axes.setModel(self.axes_model)
        cbilling: 
        cbilling:         # Setup stuff for a custom context menu:
        cbilling:         self.ui.treeView_axes.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        cbilling: 
        cbilling:         # Make the actions for the context menu:
     janwerkmann:         self.action_axes_check_selected = QtWidgets.QAction(QtGui.QIcon(':qtutils/fugue/ui-check-box'),
        cbilling:                                                         'Check selected', self.ui)
     janwerkmann:         self.action_axes_uncheck_selected = QtWidgets.QAction(QtGui.QIcon(':qtutils/fugue/ui-check-box-uncheck'),
        cbilling:                                                           'Uncheck selected', self.ui)
        pstarkey:                                                           
        pstarkey:         # setup header widths
        pstarkey:         self.ui.treeView_axes.header().setStretchLastSection(False)
        pstarkey:         self.ui.treeView_axes.header().setSectionResizeMode(self.AXES_COL_NAME, QtWidgets.QHeaderView.Stretch)
        pstarkey:                                                           
        cbilling:     def setup_groups_tab(self):
        cbilling:         self.groups_model = QtGui.QStandardItemModel()
        cbilling:         self.groups_model.setHorizontalHeaderLabels(['File/group name', 'Active', 'Delete', 'Open/Close'])
        cbilling:         self.groups_model.setSortRole(self.GROUPS_ROLE_SORT_DATA)
        cbilling:         self.item_delegate = ItemDelegate(self.ui.treeView_groups)
        cbilling:         self.ui.treeView_groups.setModel(self.groups_model)
        cbilling:         for col in range(self.groups_model.columnCount()):
        cbilling:             self.ui.treeView_groups.setItemDelegateForColumn(col, self.item_delegate)
        cbilling:         self.ui.treeView_groups.setAnimated(True)  # Pretty
     janwerkmann:         self.ui.treeView_groups.setSelectionMode(QtWidgets.QTreeView.ExtendedSelection)
        cbilling:         self.ui.treeView_groups.setSortingEnabled(True)
        cbilling:         self.ui.treeView_groups.sortByColumn(self.GROUPS_COL_NAME, QtCore.Qt.AscendingOrder)
        cbilling:         # Set column widths:
        cbilling:         self.ui.treeView_groups.setColumnWidth(self.GROUPS_COL_NAME, 400)
        cbilling:         # Make it so the user can just start typing on an item to edit:
     janwerkmann:         self.ui.treeView_groups.setEditTriggers(QtWidgets.QTreeView.AnyKeyPressed |
     janwerkmann:                                                 QtWidgets.QTreeView.EditKeyPressed |
     janwerkmann:                                                 QtWidgets.QTreeView.SelectedClicked)
        cbilling:         # Ensure the clickable region of the open/close button doesn't extend forever:
        cbilling:         self.ui.treeView_groups.header().setStretchLastSection(False)
        cbilling:         # Shrink columns other than the 'name' column to the size of their headers:
        cbilling:         for column in range(self.groups_model.columnCount()):
        cbilling:             if column != self.GROUPS_COL_NAME:
        cbilling:                 self.ui.treeView_groups.resizeColumnToContents(column)
        cbilling: 
        cbilling:         self.ui.treeView_groups.setTextElideMode(QtCore.Qt.ElideMiddle)
        cbilling:         # Setup stuff for a custom context menu:
        cbilling:         self.ui.treeView_groups.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        cbilling: 
        cbilling:         # Make the actions for the context menu:
     janwerkmann:         self.action_groups_set_selection_active = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box'), 'Set selected group(s) active', self.ui)
     janwerkmann:         self.action_groups_set_selection_inactive = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/ui-check-box-uncheck'), 'Set selected group(s) inactive', self.ui)
     janwerkmann:         self.action_groups_delete_selected = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':qtutils/fugue/minus'), 'Delete selected group(s)', self.ui)
     janwerkmann:         self.action_groups_open_selected = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':/qtutils/fugue/plus'), 'Open selected group(s)', self.ui)
     janwerkmann:         self.action_groups_close_selected_groups = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':/qtutils/fugue/cross'), 'Close selected group(s)', self.ui)
     janwerkmann:         self.action_groups_close_selected_files = QtWidgets.QAction(
        cbilling:             QtGui.QIcon(':/qtutils/fugue/cross'), 'Close selected file(s)', self.ui)
        cbilling: 
        cbilling:         # A counter for keeping track of the recursion depth of
        cbilling:         # self._groups_model_active_changed(). This is used so that some
        cbilling:         # actions can be taken in response to initial data changes, but not to
        cbilling:         # flow-on changes made by the method itself:
        cbilling:         self.on_groups_model_active_changed_recursion_depth = 0
        cbilling: 
        cbilling:     def connect_signals(self):
        cbilling:         # The button that pops the output box in and out:
        cbilling:         self.output_popout_button.clicked.connect(self.on_output_popout_button_clicked)
        cbilling: 
        cbilling:         # The menu items:
        cbilling:         self.ui.actionLoad_configuration.triggered.connect(self.on_load_configuration_triggered)
        cbilling:         self.ui.actionRevert_configuration.triggered.connect(self.on_revert_configuration_triggered)
        cbilling:         self.ui.actionSave_configuration.triggered.connect(self.on_save_configuration_triggered)
        cbilling:         self.ui.actionSave_configuration_as.triggered.connect(self.on_save_configuration_as_triggered)
        cbilling:         self.ui.actionQuit.triggered.connect(self.ui.close)
        cbilling: 
        cbilling:         # labscript file and folder selection stuff:
        cbilling:         self.ui.toolButton_select_labscript_file.clicked.connect(self.on_select_labscript_file_clicked)
        cbilling:         self.ui.toolButton_select_shot_output_folder.clicked.connect(self.on_select_shot_output_folder_clicked)
        cbilling:         self.ui.toolButton_edit_labscript_file.clicked.connect(self.on_edit_labscript_file_clicked)
        cbilling:         self.ui.toolButton_reset_shot_output_folder.clicked.connect(self.on_reset_shot_output_folder_clicked)
        cbilling:         self.ui.lineEdit_labscript_file.textChanged.connect(self.on_labscript_file_text_changed)
        cbilling:         self.ui.lineEdit_shot_output_folder.textChanged.connect(self.on_shot_output_folder_text_changed)
        cbilling: 
        cbilling:         # Control buttons; engage, abort, restart subprocess:
        cbilling:         self.ui.pushButton_engage.clicked.connect(self.on_engage_clicked)
        cbilling:         self.ui.pushButton_abort.clicked.connect(self.on_abort_clicked)
        cbilling:         self.ui.pushButton_restart_subprocess.clicked.connect(self.on_restart_subprocess_clicked)
        pstarkey:         
        pstarkey:         # shuffle master control
        pstarkey:         self.ui.pushButton_shuffle.stateChanged.connect(self.on_master_shuffle_clicked)
        cbilling: 
        cbilling:         # Tab closebutton clicked:
        cbilling:         self.ui.tabWidget.tabCloseRequested.connect(self.on_tabCloseRequested)
        cbilling: 
        cbilling:         # Axes tab; right click menu, menu actions, reordering
        pstarkey:         # self.ui.treeView_axes.customContextMenuRequested.connect(self.on_treeView_axes_context_menu_requested)
        cbilling:         self.action_axes_check_selected.triggered.connect(self.on_axes_check_selected_triggered)
        cbilling:         self.action_axes_uncheck_selected.triggered.connect(self.on_axes_uncheck_selected_triggered)
        cbilling:         self.ui.toolButton_axis_to_top.clicked.connect(self.on_axis_to_top_clicked)
        cbilling:         self.ui.toolButton_axis_up.clicked.connect(self.on_axis_up_clicked)
        cbilling:         self.ui.toolButton_axis_down.clicked.connect(self.on_axis_down_clicked)
        cbilling:         self.ui.toolButton_axis_to_bottom.clicked.connect(self.on_axis_to_bottom_clicked)
        pstarkey:         # axes tab item changed handler
        pstarkey:         self.axes_model.itemChanged.connect(self.on_axes_item_changed)
        pstarkey:         self.axes_model.rowsRemoved.connect(self.update_global_shuffle_state)
        pstarkey:         self.axes_model.rowsInserted.connect(self.update_global_shuffle_state)
        cbilling: 
        cbilling:         # Groups tab; right click menu, menu actions, open globals file, new globals file, diff globals file,
        cbilling:         self.ui.treeView_groups.customContextMenuRequested.connect(self.on_treeView_groups_context_menu_requested)
        cbilling:         self.action_groups_set_selection_active.triggered.connect(
        cbilling:             lambda: self.on_groups_set_selection_active_triggered(QtCore.Qt.Checked))
        cbilling:         self.action_groups_set_selection_inactive.triggered.connect(
        cbilling:             lambda: self.on_groups_set_selection_active_triggered(QtCore.Qt.Unchecked))
        cbilling:         self.action_groups_delete_selected.triggered.connect(self.on_groups_delete_selected_triggered)
        cbilling:         self.action_groups_open_selected.triggered.connect(self.on_groups_open_selected_triggered)
        cbilling:         self.action_groups_close_selected_groups.triggered.connect(self.on_groups_close_selected_groups_triggered)
        cbilling:         self.action_groups_close_selected_files.triggered.connect(self.on_groups_close_selected_files_triggered)
        cbilling: 
        cbilling:         self.ui.pushButton_open_globals_file.clicked.connect(self.on_open_globals_file_clicked)
        cbilling:         self.ui.pushButton_new_globals_file.clicked.connect(self.on_new_globals_file_clicked)
        cbilling:         self.ui.pushButton_diff_globals_file.clicked.connect(self.on_diff_globals_file_clicked)
        cbilling:         self.ui.treeView_groups.leftClicked.connect(self.on_treeView_groups_leftClicked)
        cbilling:         self.ui.treeView_groups.doubleLeftClicked.connect(self.on_treeView_groups_doubleLeftClicked)
        cbilling:         self.groups_model.itemChanged.connect(self.on_groups_model_item_changed)
        cbilling:         # A context manager with which we can temporarily disconnect the above connection.
        cbilling:         self.groups_model_item_changed_disconnected = DisconnectContextManager(
        cbilling:             self.groups_model.itemChanged, self.on_groups_model_item_changed)
        pstarkey:         
chrisjbillington:         # Keyboard shortcuts:
chrisjbillington:         engage_shortcut = QtWidgets.QShortcut('F5', self.ui,
chrisjbillington:             lambda: self.ui.pushButton_engage.clicked.emit(False))
chrisjbillington:         engage_shortcut.setAutoRepeat(False)
chrisjbillington:         QtWidgets.QShortcut('ctrl+W', self.ui, self.close_current_tab)
chrisjbillington:         QtWidgets.QShortcut('ctrl+Tab', self.ui, lambda: self.switch_tabs(+1))
chrisjbillington:         QtWidgets.QShortcut('ctrl+shift+Tab', self.ui, lambda: self.switch_tabs(-1))
chrisjbillington: 
        cbilling:         # Tell Windows how to handle our windows in the the taskbar, making pinning work properly and stuff:
        cbilling:         if os.name == 'nt':
        cbilling:             self.ui.newWindow.connect(set_win_appusermodel)
        cbilling:             self.output_box_window.newWindow.connect(set_win_appusermodel)
        cbilling: 
        cbilling:     def on_close_event(self):
        cbilling:         save_data = self.get_save_data()
        cbilling:         if self.last_save_data is not None and save_data != self.last_save_data:
        cbilling:             message = ('Current configuration (which groups are active/open and other GUI state) '
        cbilling:                        'has changed: save config file \'%s\'?' % self.last_save_config_file)
     janwerkmann:             reply = QtWidgets.QMessageBox.question(self.ui, 'Quit runmanager', message,
     janwerkmann:                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Cancel)
     janwerkmann:             if reply == QtWidgets.QMessageBox.Cancel:
        cbilling:                 return False
     janwerkmann:             if reply == QtWidgets.QMessageBox.Yes:
        cbilling:                 self.save_configuration(self.last_save_config_file)
        cbilling:         self.to_child.put(['quit', None])
        cbilling:         return True
        cbilling: 
chrisjbillington:     def close_current_tab(self):
chrisjbillington:         current_tab_widget = self.ui.tabWidget.currentWidget()
chrisjbillington:         for (globals_file, group_name), tab in self.currently_open_groups.items():
chrisjbillington:             if tab.ui is current_tab_widget:
chrisjbillington:                 self.close_group(globals_file, group_name)
chrisjbillington: 
chrisjbillington:     def switch_tabs(self, change):
chrisjbillington:         current_index = self.ui.tabWidget.currentIndex()
chrisjbillington:         n_tabs = self.ui.tabWidget.count()
chrisjbillington:         new_index = (current_index + change) % n_tabs
chrisjbillington:         self.ui.tabWidget.setCurrentIndex(new_index)
        cbilling: 
        cbilling:     def on_output_popout_button_clicked(self):
        cbilling:         if self.output_box_is_popped_out:
        cbilling:             self.ui.verticalLayout_output_tab.addWidget(self.output_box.output_textedit)
        cbilling:             self.output_box_window.hide()
        cbilling:             self.output_popout_button.setIcon(QtGui.QIcon(':/qtutils/fugue/arrow-out'))
        cbilling:         else:
        cbilling:             # pop it out
        cbilling:             # self.ui.verticalLayout_output_tab.remove(self.output_box)
        cbilling:             self.output_box_window_verticalLayout.addWidget(self.output_box.output_textedit)
        cbilling:             self.output_popout_button.setIcon(QtGui.QIcon(':/qtutils/fugue/arrow-in'))
        cbilling:             self.output_box_window.show()
        cbilling:         self.output_box_is_popped_out = not self.output_box_is_popped_out
        cbilling: 
        cbilling:     def on_select_labscript_file_clicked(self, checked):
     janwerkmann:         labscript_file = QtWidgets.QFileDialog.getOpenFileName(self.ui,
        cbilling:                                                            'Select labscript file',
        cbilling:                                                            self.last_opened_labscript_folder,
        cbilling:                                                            "Python files (*.py)")
     janwerkmann:         if type(labscript_file) is tuple:
     janwerkmann:             labscript_file, _ = labscript_file
     janwerkmann: 
        cbilling:         if not labscript_file:
        cbilling:             # User cancelled selection
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
        cbilling:         labscript_file = os.path.abspath(labscript_file)
        cbilling:         if not os.path.isfile(labscript_file):
        cbilling:             error_dialog("No such file %s." % labscript_file)
        cbilling:             return
        cbilling:         # Save the containing folder for use next time we open the dialog box:
        cbilling:         self.last_opened_labscript_folder = os.path.dirname(labscript_file)
        cbilling:         # Write the file to the lineEdit:
        cbilling:         self.ui.lineEdit_labscript_file.setText(labscript_file)
        cbilling:         # Tell the output folder thread that the output folder might need updating:
        cbilling:         self.output_folder_update_required.set()
        cbilling: 
        cbilling:     def on_edit_labscript_file_clicked(self, checked):
        cbilling:         # get path to text editor
        cbilling:         editor_path = self.exp_config.get('programs', 'text_editor')
        cbilling:         editor_args = self.exp_config.get('programs', 'text_editor_arguments')
        cbilling:         # Get the current labscript file:
        cbilling:         current_labscript_file = self.ui.lineEdit_labscript_file.text()
        cbilling:         # Ignore if no file selected
        cbilling:         if not current_labscript_file:
        cbilling:             return
        cbilling:         if not editor_path:
        cbilling:             error_dialog("No editor specified in the labconfig.")
        cbilling:         if '{file}' in editor_args:
        cbilling:             # Split the args on spaces into a list, replacing {file} with the labscript file
        cbilling:             editor_args = [arg if arg != '{file}' else current_labscript_file for arg in editor_args.split()]
        cbilling:         else:
        cbilling:             # Otherwise if {file} isn't already in there, append it to the other args:
        cbilling:             editor_args = [current_labscript_file] + editor_args.split()
        cbilling:         try:
        cbilling:             subprocess.Popen([editor_path] + editor_args)
        cbilling:         except Exception as e:
        cbilling:             error_dialog("Unable to launch text editor specified in %s. Error was: %s" %
        cbilling:                          (self.exp_config.config_path, str(e)))
        cbilling: 
        cbilling:     def on_select_shot_output_folder_clicked(self, checked):
     janwerkmann:         shot_output_folder = QtWidgets.QFileDialog.getExistingDirectory(self.ui,
        cbilling:                                                                     'Select shot output folder',
        cbilling:                                                                     self.last_selected_shot_output_folder)
     janwerkmann:         if type(shot_output_folder) is tuple:
     janwerkmann:             shot_output_folder, _ = shot_output_folder
     janwerkmann: 
        cbilling:         if not shot_output_folder:
        cbilling:             # User cancelled selection
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
        cbilling:         shot_output_folder = os.path.abspath(shot_output_folder)
        cbilling:         # Save the containing folder for use next time we open the dialog box:
        cbilling:         self.last_selected_shot_output_folder = os.path.dirname(shot_output_folder)
        cbilling:         # Write the file to the lineEdit:
        cbilling:         self.ui.lineEdit_shot_output_folder.setText(shot_output_folder)
        cbilling:         # Tell the output folder rollover thread to run an iteration, so that
        cbilling:         # it notices this change (even though it won't do anything now - this
        cbilling:         # is so it can respond correctly if anything else interesting happens
        cbilling:         # within the next second):
        cbilling:         self.output_folder_update_required.set()
        cbilling: 
        cbilling:     def on_reset_shot_output_folder_clicked(self, checked):
        cbilling:         current_default_output_folder = self.get_default_output_folder()
        cbilling:         if current_default_output_folder is None:
        cbilling:             return
        cbilling:         self.ui.lineEdit_shot_output_folder.setText(current_default_output_folder)
        cbilling:         # Tell the output folder rollover thread to run an iteration, so that
        cbilling:         # it notices this change (even though it won't do anything now - this
        cbilling:         # is so it can respond correctly if anything else interesting happens
        cbilling:         # within the next second):
        cbilling:         self.output_folder_update_required.set()
        cbilling: 
        cbilling:     def on_labscript_file_text_changed(self, text):
        cbilling:         # Blank out the 'edit labscript file' button if no labscript file is
        cbilling:         # selected
        cbilling:         enabled = bool(text)
        cbilling:         self.ui.toolButton_edit_labscript_file.setEnabled(enabled)
        cbilling:         # Blank out the 'select shot output folder' button if no labscript
        cbilling:         # file is selected:
        cbilling:         self.ui.toolButton_select_shot_output_folder.setEnabled(enabled)
        cbilling:         self.ui.lineEdit_labscript_file.setToolTip(text)
        cbilling: 
        cbilling:     def on_shot_output_folder_text_changed(self, text):
        cbilling:         # Blank out the 'reset default output folder' button if the user is
        cbilling:         # already using the default output folder
        cbilling:         if text == self.get_default_output_folder():
        cbilling:             enabled = False
        cbilling:         else:
        cbilling:             enabled = True
        cbilling:         self.ui.toolButton_reset_shot_output_folder.setEnabled(enabled)
        cbilling:         self.ui.lineEdit_shot_output_folder.setToolTip(text)
        cbilling: 
        cbilling:     def on_engage_clicked(self):
        cbilling:         logger.info('Engage')
        cbilling:         try:
        cbilling:             send_to_BLACS = self.ui.checkBox_run_shots.isChecked()
        cbilling:             send_to_runviewer = self.ui.checkBox_view_shots.isChecked()
        cbilling:             labscript_file = self.ui.lineEdit_labscript_file.text()
        pstarkey:             # even though we shuffle on a per global basis, if ALL of the globals are set to shuffle, then we may as well shuffle again. This helps shuffle shots more randomly than just shuffling within each level (because without this, you would still do all shots with the outer most variable the same, etc)
        pstarkey:             shuffle = self.ui.pushButton_shuffle.checkState() == QtCore.Qt.Checked
        cbilling:             if not labscript_file:
        cbilling:                 raise Exception('Error: No labscript file selected')
        cbilling:             output_folder = self.ui.lineEdit_shot_output_folder.text()
        cbilling:             if not output_folder:
        cbilling:                 raise Exception('Error: No output folder selected')
        cbilling:             BLACS_host = self.ui.lineEdit_BLACS_hostname.text()
        cbilling:             logger.info('Parsing globals...')
        cbilling:             active_groups = self.get_active_groups()
        pstarkey:             # Get ordering of expansion globals
        pstarkey:             expansion_order = {}
        pstarkey:             for i in range(self.axes_model.rowCount()):
        pstarkey:                 item = self.axes_model.item(i, self.AXES_COL_NAME)
        pstarkey:                 shuffle_item = self.axes_model.item(i, self.AXES_COL_SHUFFLE)
        pstarkey:                 name = item.data(self.AXES_ROLE_NAME)
        pstarkey:                 expansion_order[name] = {'order':i, 'shuffle':shuffle_item.checkState()}
        pstarkey:             
        cbilling:             try:
        pstarkey:                 sequenceglobals, shots, evaled_globals, global_hierarchy, expansions = self.parse_globals(active_groups, expansion_order=expansion_order)
        cbilling:             except Exception as e:
        cbilling:                 raise Exception('Error parsing globals:\n%s\nCompilation aborted.' % str(e))
           Chris:             logger.info('Making h5 files')
           Chris:             labscript_file, run_files = self.make_h5_files(
           Chris:                 labscript_file, output_folder, sequenceglobals, shots, shuffle)
           Chris:             self.ui.pushButton_abort.setEnabled(True)
           Chris:             self.compile_queue.put([labscript_file, run_files, send_to_BLACS, BLACS_host, send_to_runviewer])
        cbilling:         except Exception as e:
        cbilling:             self.output_box.output('%s\n\n' % str(e), red=True)
        cbilling:         logger.info('end engage')
        cbilling: 
        cbilling:     def on_abort_clicked(self):
        cbilling:         self.compilation_aborted.set()
        cbilling: 
        cbilling:     def on_restart_subprocess_clicked(self):
        cbilling:         # Kill and restart the compilation subprocess
        cbilling:         self.to_child.put(['quit', None])
        cbilling:         self.from_child.put(['done', False])
        cbilling:         time.sleep(0.1)
        cbilling:         self.output_box.output('Asking subprocess to quit...')
        cbilling:         timeout_time = time.time() + 2
        cbilling:         QtCore.QTimer.singleShot(50, lambda: self.check_child_exited(timeout_time, kill=False))
        cbilling: 
        cbilling:     def check_child_exited(self, timeout_time, kill=False):
        cbilling:         self.child.poll()
        cbilling:         if self.child.returncode is None and time.time() < timeout_time:
        cbilling:             QtCore.QTimer.singleShot(50, lambda: self.check_child_exited(timeout_time, kill))
        cbilling:             return
        cbilling:         elif self.child.returncode is None:
        cbilling:             if not kill:
        cbilling:                 self.child.terminate()
        cbilling:                 self.output_box.output('not responding.\n')
        cbilling:                 timeout_time = time.time() + 2
        cbilling:                 QtCore.QTimer.singleShot(50, lambda: self.check_child_exited(timeout_time, kill=True))
        cbilling:                 return
        cbilling:             else:
        cbilling:                 self.child.kill()
        cbilling:                 self.output_box.output('Killed\n', red=True)
        cbilling:         elif kill:
        cbilling:             self.output_box.output('Terminated\n', red=True)
        cbilling:         else:
        cbilling:             self.output_box.output('done.\n')
        cbilling:         self.output_box.output('Spawning new compiler subprocess...')
        cbilling:         self.to_child, self.from_child, self.child = zprocess.subprocess_with_queues(
        cbilling:             'batch_compiler.py', self.output_box.port)
        cbilling:         self.output_box.output('done.\n')
        cbilling:         self.output_box.output('Ready.\n\n')
        cbilling: 
        cbilling:     def on_tabCloseRequested(self, index):
        cbilling:         tab_page = self.ui.tabWidget.widget(index)
        cbilling:         for (globals_file, group_name), group_tab in self.currently_open_groups.items():
        cbilling:             if group_tab.ui is tab_page:
        cbilling:                 self.close_group(globals_file, group_name)
        cbilling:                 break
        cbilling: 
        cbilling:     def on_treeView_axes_context_menu_requested(self, point):
        cbilling:         raise NotImplementedError
     janwerkmann:         # menu = QtWidgets.QMenu(self.ui)
        cbilling:         # menu.addAction(self.action_axes_check_selected)
        cbilling:         # menu.addAction(self.action_axes_uncheck_selected)
        cbilling:         # menu.exec_(QtGui.QCursor.pos())
        cbilling:         pass
        cbilling: 
        cbilling:     def on_axes_check_selected_triggered(self, *args):
        cbilling:         raise NotImplementedError
        cbilling: 
        cbilling:     def on_axes_uncheck_selected_triggered(self, *args):
        cbilling:         raise NotImplementedError
        pstarkey:         
        cbilling:     def on_axis_to_top_clicked(self, checked):
        pstarkey:         # Get the selection model from the treeview
        pstarkey:         selection_model = self.ui.treeView_axes.selectionModel()    
        pstarkey:         # Create a list of select row indices
        pstarkey:         selected_row_list = [index.row() for index in sorted(selection_model.selectedRows())]
        pstarkey:         # For each row selected
        pstarkey:         for i,row in enumerate(selected_row_list):
        pstarkey:             # only move the row while it is not element 0, and the row above it is not selected
        pstarkey:             # (note that while a row above may have been initially selected, it should by now, be one row higher
        pstarkey:             # since we start moving elements of the list upwards starting from the lowest index)
        pstarkey:             while row > 0 and (row-1) not in selected_row_list:
        pstarkey:                 # Remove the selected row
        pstarkey:                 items = self.axes_model.takeRow(row)
        pstarkey:                 # Add the selected row into a position one above
        pstarkey:                 self.axes_model.insertRow(row-1,items)
        pstarkey:                 # Since it is now a newly inserted row, select it again
        pstarkey:                 selection_model.select(self.axes_model.indexFromItem(items[0]),QtCore.QItemSelectionModel.SelectCurrent|QtCore.QItemSelectionModel.Rows)
        pstarkey:                 # reupdate the list of selected indices to reflect this change
        pstarkey:                 selected_row_list[i] -= 1
        pstarkey:                 row -= 1
        pstarkey:                     
        pstarkey:         self.update_axes_indentation()
        cbilling: 
        cbilling:     def on_axis_up_clicked(self, checked):
        pstarkey:         # Get the selection model from the treeview
        pstarkey:         selection_model = self.ui.treeView_axes.selectionModel()    
        pstarkey:         # Create a list of select row indices
        pstarkey:         selected_row_list = [index.row() for index in sorted(selection_model.selectedRows())]
        pstarkey:         # For each row selected
        pstarkey:         for i,row in enumerate(selected_row_list):
        pstarkey:             # only move the row if it is not element 0, and the row above it is not selected
        pstarkey:             # (note that while a row above may have been initially selected, it should by now, be one row higher
        pstarkey:             # since we start moving elements of the list upwards starting from the lowest index)
        pstarkey:             if row > 0 and (row-1) not in selected_row_list:
        pstarkey:                 # Remove the selected row
        pstarkey:                 items = self.axes_model.takeRow(row)
        pstarkey:                 # Add the selected row into a position one above
        pstarkey:                 self.axes_model.insertRow(row-1,items)
        pstarkey:                 # Since it is now a newly inserted row, select it again
        pstarkey:                 selection_model.select(self.axes_model.indexFromItem(items[0]),QtCore.QItemSelectionModel.SelectCurrent|QtCore.QItemSelectionModel.Rows)
        pstarkey:                 # reupdate the list of selected indices to reflect this change
        pstarkey:                 selected_row_list[i] -= 1
        pstarkey:                 
        pstarkey:         self.update_axes_indentation()
        cbilling: 
        cbilling:     def on_axis_down_clicked(self, checked):
        pstarkey:         # Get the selection model from the treeview
        pstarkey:         selection_model = self.ui.treeView_axes.selectionModel()    
        pstarkey:         # Create a list of select row indices
        pstarkey:         selected_row_list = [index.row() for index in reversed(sorted(selection_model.selectedRows()))]
        pstarkey:         # For each row selected
        pstarkey:         for i,row in enumerate(selected_row_list):
        pstarkey:             # only move the row if it is not the last element, and the row above it is not selected
        pstarkey:             # (note that while a row below may have been initially selected, it should by now, be one row lower
        pstarkey:             # since we start moving elements of the list upwards starting from the highest index)
        pstarkey:             if row < self.axes_model.rowCount()-1 and (row+1) not in selected_row_list:
        pstarkey:                 # Remove the selected row
        pstarkey:                 items = self.axes_model.takeRow(row)
        pstarkey:                 # Add the selected row into a position one above
        pstarkey:                 self.axes_model.insertRow(row+1,items)
        pstarkey:                 # Since it is now a newly inserted row, select it again
        pstarkey:                 selection_model.select(self.axes_model.indexFromItem(items[0]),QtCore.QItemSelectionModel.SelectCurrent|QtCore.QItemSelectionModel.Rows)
        pstarkey:                 # reupdate the list of selected indices to reflect this change
        pstarkey:                 selected_row_list[i] += 1
        pstarkey:             
        pstarkey:         self.update_axes_indentation()
        cbilling: 
        cbilling:     def on_axis_to_bottom_clicked(self, checked):
        pstarkey:         selection_model = self.ui.treeView_axes.selectionModel()    
        pstarkey:         # Create a list of select row indices
        pstarkey:         selected_row_list = [index.row() for index in reversed(sorted(selection_model.selectedRows()))]
        pstarkey:         # For each row selected
        pstarkey:         for i,row in enumerate(selected_row_list):
        pstarkey:             # only move the row while it is not the last element, and the row above it is not selected
        pstarkey:             # (note that while a row below may have been initially selected, it should by now, be one row lower
        pstarkey:             # since we start moving elements of the list upwards starting from the highest index)
        pstarkey:             while row < self.axes_model.rowCount()-1 and (row+1) not in selected_row_list:
        pstarkey:                 # Remove the selected row
        pstarkey:                 items = self.axes_model.takeRow(row)
        pstarkey:                 # Add the selected row into a position one above
        pstarkey:                 self.axes_model.insertRow(row+1,items)
        pstarkey:                 # Since it is now a newly inserted row, select it again
        pstarkey:                 selection_model.select(self.axes_model.indexFromItem(items[0]),QtCore.QItemSelectionModel.SelectCurrent|QtCore.QItemSelectionModel.Rows)
        pstarkey:                 # reupdate the list of selected indices to reflect this change
        pstarkey:                 selected_row_list[i] += 1
        pstarkey:                 row += 1
        pstarkey:                 
        pstarkey:         self.update_axes_indentation()
        pstarkey:         
        pstarkey:     def on_axes_item_changed(self, item):
        pstarkey:         if item.column() == self.AXES_COL_SHUFFLE:
        pstarkey:             self.update_global_shuffle_state()
        pstarkey:             
        pstarkey:     def update_global_shuffle_state(self, *args, **kwargs):
        pstarkey:         all_checked = True
        pstarkey:         none_checked = True
        pstarkey:         for i in range(self.axes_model.rowCount()):
        pstarkey:             check_state = self.axes_model.item(i, self.AXES_COL_SHUFFLE).checkState() == QtCore.Qt.Checked
        pstarkey:             all_checked = all_checked and check_state
        pstarkey:             none_checked = none_checked and not check_state
        pstarkey:             
        pstarkey:         if not all_checked and not none_checked:
        pstarkey:             self.ui.pushButton_shuffle.setTristate(True)
        pstarkey:             self.ui.pushButton_shuffle.setCheckState(QtCore.Qt.PartiallyChecked)
        pstarkey:         elif none_checked:
        pstarkey:             self.ui.pushButton_shuffle.setTristate(False)
        pstarkey:             self.ui.pushButton_shuffle.setCheckState(QtCore.Qt.Unchecked)
        pstarkey:         else:
        pstarkey:             self.ui.pushButton_shuffle.setTristate(False)
        pstarkey:             self.ui.pushButton_shuffle.setCheckState(QtCore.Qt.Checked)
        pstarkey:     
        pstarkey:     def on_master_shuffle_clicked(self, state):
        pstarkey:         if state in [QtCore.Qt.Checked, QtCore.Qt.Unchecked]:
        pstarkey:             self.ui.pushButton_shuffle.setTristate(False)
        pstarkey:             for i in range(self.axes_model.rowCount()):
        pstarkey:                 item = self.axes_model.item(i, self.AXES_COL_SHUFFLE)
        pstarkey:                 if item.checkState() != state:
        pstarkey:                     self.axes_model.item(i, self.AXES_COL_SHUFFLE).setCheckState(state)
        cbilling: 
        cbilling:     def on_treeView_groups_context_menu_requested(self, point):
     janwerkmann:         menu = QtWidgets.QMenu(self.ui)
        cbilling:         menu.addAction(self.action_groups_set_selection_active)
        cbilling:         menu.addAction(self.action_groups_set_selection_inactive)
        cbilling:         menu.addAction(self.action_groups_delete_selected)
        cbilling:         menu.addAction(self.action_groups_open_selected)
        cbilling:         menu.addAction(self.action_groups_close_selected_groups)
        cbilling:         menu.addAction(self.action_groups_close_selected_files)
     janwerkmann:         copy_menu = QtWidgets.QMenu('Copy selected group(s) to...', menu)
     janwerkmann:         copy_menu.setIcon(QtGui.QIcon(':/qtutils/fugue/blue-document-copy'))
     janwerkmann:         menu.addMenu(copy_menu)
     janwerkmann:         move_menu = QtWidgets.QMenu('Move selected group(s) to...', menu)
     janwerkmann:         move_menu.setIcon(QtGui.QIcon(':/qtutils/fugue/blue-document--arrow'))
     janwerkmann:         menu.addMenu(move_menu)
     janwerkmann: 
     janwerkmann:         # Create a dict of all filepaths -> filenames
     janwerkmann:         filenames = {}
     janwerkmann:         for index in range(self.groups_model.rowCount()):
     janwerkmann:             filepath = self.groups_model.item(index, self.GROUPS_COL_NAME).text()
     janwerkmann:             filenames[filepath] = filepath.split(os.sep)[-1]
     janwerkmann: 
     janwerkmann:         # expand duplicate filenames until there is nomore duplicates
     janwerkmann:         new_filename = {}
     janwerkmann:         i = 2
     janwerkmann:         while new_filename != filenames:
     janwerkmann:             for filepath, filename in filenames.items():
     janwerkmann:                 if list(filenames.values()).count(filename) > 1:
     janwerkmann:                     new_filename[filepath] = os.sep.join(filepath.split(os.sep)[-i:])
     janwerkmann:                 else:
     janwerkmann:                     new_filename[filepath] = filename
     janwerkmann:             filenames = new_filename
     janwerkmann:             i += 1
     janwerkmann: 
     janwerkmann:         # add all filenames to the copy and move submenu
     janwerkmann:         for filepath, filename in filenames.items():
     janwerkmann:             copy_menu.addAction(filename, lambda filepath=filepath: self.on_groups_copy_selected_groups_triggered(filepath, False))
     janwerkmann:             move_menu.addAction(filename, lambda filepath=filepath: self.on_groups_copy_selected_groups_triggered(filepath, True))
     janwerkmann: 
        cbilling:         menu.exec_(QtGui.QCursor.pos())
        cbilling: 
     janwerkmann:     def on_groups_copy_selected_groups_triggered(self, dest_globals_file=None, delete_source_group=False):
     janwerkmann:         selected_indexes = self.ui.treeView_groups.selectedIndexes()
     janwerkmann:         selected_items = (self.groups_model.itemFromIndex(index) for index in selected_indexes)
     janwerkmann:         name_items = [item for item in selected_items
     janwerkmann:                       if item.column() == self.GROUPS_COL_NAME
     janwerkmann:                       and item.parent() is not None]
     janwerkmann:         for item in name_items:
     janwerkmann:             source_globals_file = item.parent().text()
     janwerkmann:             self.copy_group(source_globals_file, item.text(), dest_globals_file, delete_source_group)
     janwerkmann: 
        cbilling:     def on_groups_set_selection_active_triggered(self, checked_state):
        cbilling:         selected_indexes = self.ui.treeView_groups.selectedIndexes()
        cbilling:         # Filter to only include the 'active' column:
        cbilling:         selected_items = (self.groups_model.itemFromIndex(index) for index in selected_indexes)
        cbilling:         active_items = (item for item in selected_items
        cbilling:                         if item.column() == self.GROUPS_COL_ACTIVE
        cbilling:                         and item.parent() is not None)
        cbilling:         for item in active_items:
        cbilling:             item.setCheckState(checked_state)
        cbilling: 
        cbilling:     def on_groups_delete_selected_triggered(self):
        cbilling:         selected_indexes = self.ui.treeView_groups.selectedIndexes()
        cbilling:         selected_items = (self.groups_model.itemFromIndex(index) for index in selected_indexes)
        cbilling:         name_items = [item for item in selected_items
        cbilling:                       if item.column() == self.GROUPS_COL_NAME
        cbilling:                       and item.parent() is not None]
        cbilling:         # If multiple selected, show 'delete n groups?' message. Otherwise,
        cbilling:         # pass confirm=True to self.delete_group so it can show the regular
        cbilling:         # message.
        cbilling:         confirm_multiple = (len(name_items) > 1)
        cbilling:         if confirm_multiple:
        cbilling:             if not question_dialog("Delete %d groups?" % len(name_items)):
        cbilling:                 return
        cbilling:         for item in name_items:
        cbilling:             globals_file = item.parent().text()
        cbilling:             group_name = item.text()
        cbilling:             self.delete_group(globals_file, group_name, confirm=not confirm_multiple)
        cbilling: 
        cbilling:     def on_groups_open_selected_triggered(self):
        cbilling:         selected_indexes = self.ui.treeView_groups.selectedIndexes()
        cbilling:         selected_items = (self.groups_model.itemFromIndex(index) for index in selected_indexes)
        cbilling:         name_items = [item for item in selected_items
        cbilling:                       if item.column() == self.GROUPS_COL_NAME
        cbilling:                       and item.parent() is not None]
        cbilling:         # Make things a bit faster by acquiring network only locks on all the
        cbilling:         # files we're dealing with.  That way all the open and close
        cbilling:         # operations will be faster.
        cbilling:         filenames = set(item.parent().text() for item in name_items)
        cbilling:         file_locks = [labscript_utils.h5_lock.NetworkOnlyLock(filename) for filename in filenames]
        cbilling:         with nested(*file_locks):
        cbilling:             for item in name_items:
        cbilling:                 globals_file = item.parent().text()
        cbilling:                 group_name = item.text()
        cbilling:                 if (globals_file, group_name) not in self.currently_open_groups:
        cbilling:                     self.open_group(globals_file, group_name, trigger_preparse=False)
        cbilling:         if name_items:
        cbilling:             self.globals_changed()
        cbilling: 
        cbilling:     def on_groups_close_selected_groups_triggered(self):
        cbilling:         selected_indexes = self.ui.treeView_groups.selectedIndexes()
        cbilling:         selected_items = (self.groups_model.itemFromIndex(index) for index in selected_indexes)
        cbilling:         name_items = [item for item in selected_items
        cbilling:                       if item.column() == self.GROUPS_COL_NAME
        cbilling:                       and item.parent() is not None]
        cbilling:         for item in name_items:
        cbilling:             globals_file = item.parent().text()
        cbilling:             group_name = item.text()
        cbilling:             if (globals_file, group_name) in self.currently_open_groups:
        cbilling:                 self.close_group(globals_file, group_name)
        cbilling: 
        cbilling:     def on_groups_close_selected_files_triggered(self):
        cbilling:         selected_indexes = self.ui.treeView_groups.selectedIndexes()
        cbilling:         selected_items = (self.groups_model.itemFromIndex(index) for index in selected_indexes)
        cbilling:         name_items = [item for item in selected_items
        cbilling:                       if item.column() == self.GROUPS_COL_NAME
        cbilling:                       and item.parent() is None]
        cbilling:         child_openclose_items = [item.child(i, self.GROUPS_COL_OPENCLOSE)
        cbilling:                                  for item in name_items
        cbilling:                                  for i in range(item.rowCount())]
        cbilling:         child_is_open = [child_item.data(self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling:                          for child_item in child_openclose_items]
        cbilling:         if any(child_is_open):
        cbilling:             if not question_dialog('Close %d file(s)? This will close %d currently open group(s).' %
        cbilling:                                    (len(name_items), child_is_open.count(True))):
        cbilling:                 return
        cbilling:         for item in name_items:
        cbilling:             globals_file = item.text()
        cbilling:             self.close_globals_file(globals_file, confirm=False)
        cbilling: 
        cbilling:     def on_open_globals_file_clicked(self):
     janwerkmann:         globals_file = QtWidgets.QFileDialog.getOpenFileName(self.ui,
        cbilling:                                                          'Select globals file',
        cbilling:                                                          self.last_opened_globals_folder,
        cbilling:                                                          "HDF5 files (*.h5)")
     janwerkmann:         if type(globals_file) is tuple:
     janwerkmann:             globals_file, _ = globals_file
     janwerkmann: 
        cbilling:         if not globals_file:
        cbilling:             # User cancelled selection
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
        cbilling:         globals_file = os.path.abspath(globals_file)
        cbilling:         if not os.path.isfile(globals_file):
        cbilling:             error_dialog("No such file %s." % globals_file)
        cbilling:             return
        cbilling:         # Save the containing folder for use next time we open the dialog box:
        cbilling:         self.last_opened_globals_folder = os.path.dirname(globals_file)
        cbilling:         # Open the file:
        cbilling:         self.open_globals_file(globals_file)
        cbilling: 
        cbilling:     def on_new_globals_file_clicked(self):
     janwerkmann:         globals_file = QtWidgets.QFileDialog.getSaveFileName(self.ui,
        cbilling:                                                          'Create new globals file',
        cbilling:                                                          self.last_opened_globals_folder,
        cbilling:                                                          "HDF5 files (*.h5)")
     janwerkmann:         if type(globals_file) is tuple:
     janwerkmann:             globals_file, _ = globals_file
     janwerkmann: 
        cbilling:         if not globals_file:
        cbilling:             # User cancelled
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes
        cbilling:         # forward slashes:
        cbilling:         globals_file = os.path.abspath(globals_file)
        cbilling:         # Save the containing folder for use next time we open the dialog box:
        cbilling:         self.last_opened_globals_folder = os.path.dirname(globals_file)
        cbilling:         # Create the new file and open it:
        cbilling:         runmanager.new_globals_file(globals_file)
        cbilling:         self.open_globals_file(globals_file)
        cbilling: 
        cbilling:     def on_diff_globals_file_clicked(self):
     janwerkmann:         globals_file = QtWidgets.QFileDialog.getOpenFileName(self.ui,
        cbilling:                                                          'Select globals file to compare',
        cbilling:                                                          self.last_opened_globals_folder,
        cbilling:                                                          "HDF5 files (*.h5)")
     janwerkmann:         if type(globals_file) is tuple:
     janwerkmann:             globals_file, _ = globals_file
     janwerkmann: 
        cbilling:         if not globals_file:
        cbilling:             # User cancelled
        cbilling:             return
        cbilling: 
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes forward slashes:
        cbilling:         globals_file = os.path.abspath(globals_file)
        cbilling: 
        cbilling:         # Get runmanager's globals
        cbilling:         active_groups = self.get_active_groups()
        cbilling:         if active_groups is None:
        cbilling:             # Invalid group selection
        cbilling:             return
        cbilling: 
          rander:         # Get file's globals groups
        cbilling:         other_groups = runmanager.get_all_groups(globals_file)
        cbilling: 
        cbilling:         # Display the output tab so the user can see the output:
        cbilling:         self.ui.tabWidget.setCurrentWidget(self.ui.tab_output)
          rander:         self.output_box.output('Globals diff with:\n%s\n\n' % globals_file)
        cbilling: 
          rander:         # Do the globals diff
          rander:         globals_diff_table = runmanager.globals_diff_groups(active_groups, other_groups)
           Chris:         self.output_box.output(globals_diff_table)
        cbilling:         self.output_box.output('Ready.\n\n')
        cbilling: 
        cbilling:     def on_treeView_groups_leftClicked(self, index):
        cbilling:         """Here we respond to user clicks on the treeview. We do the following:
        cbilling:         - If the user clicks on the <click to add group> dummy row, we go into
        cbilling:           edit mode on it so they can enter the name of the new group they
        cbilling:           want.
        cbilling:         - If the user clicks on the icon to open or close a globals file or a
        cbilling:           group, we call the appropriate open and close methods and update the
        cbilling:           open/close data role on the model.
        cbilling:         - If the user clicks delete on a globals group, we call a delete
        cbilling:           method, which deletes it after confirmation, and closes it if it was
        cbilling:           open.
        cbilling:           """
        cbilling:         if qapplication.keyboardModifiers() != QtCore.Qt.NoModifier:
        cbilling:             # Only handle mouseclicks with no keyboard modifiers.
        cbilling:             return
        cbilling:         item = self.groups_model.itemFromIndex(index)
        cbilling:         # The 'name' item in the same row:
        cbilling:         name_index = index.sibling(index.row(), self.GROUPS_COL_NAME)
        cbilling:         name_item = self.groups_model.itemFromIndex(name_index)
        cbilling:         # The parent item, None if there is no parent:
        cbilling:         parent_item = item.parent()
        cbilling:         # What kind of row did the user click on?
        cbilling:         # A globals file, a group, or a 'click to add group' row?
        cbilling:         if item.data(self.GROUPS_ROLE_IS_DUMMY_ROW):
        cbilling:             # They clicked on an 'add new group' row. Enter editing
        cbilling:             # mode on the name item so they can enter a name for
        cbilling:             # the new group:
        cbilling:             self.ui.treeView_groups.setCurrentIndex(name_index)
        cbilling:             self.ui.treeView_groups.edit(name_index)
        cbilling:         if item.column() == self.GROUPS_COL_ACTIVE:
        cbilling:             # They clicked on the active column. Toggle the checkbox. We do
        cbilling:             # this manually because setting the item checkable means the model
        cbilling:             # changes before we catch the mouse click. This is a pain because
        cbilling:             # we want the ensuing sorting (if the user is sorting by the
        cbilling:             # enabled column) to keep the the selection. If the user only
        cbilling:             # selected the column by clicking on it, then the sort happens
        cbilling:             # before they selected it, and the resort happens without a visual
        cbilling:             # indication of where the item went, because it never got
        cbilling:             # selected.
        cbilling:             state = item.checkState()
        cbilling:             if state in (QtCore.Qt.Unchecked, QtCore.Qt.PartiallyChecked):
        cbilling:                 item.setCheckState(QtCore.Qt.Checked)
        cbilling:             elif state == QtCore.Qt.Checked:
        cbilling:                 item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:             else:
        cbilling:                 raise AssertionError('Invalid Check state')
        cbilling:             # If this changed the sort order, ensure the item is still visible:
        cbilling:             scroll_treeview_to_row_if_current(self.ui.treeView_groups, item)
        cbilling:         elif parent_item is None:
        cbilling:             # They clicked on a globals file row.
        cbilling:             globals_file = name_item.text()
        cbilling:             # What column did they click on?
        cbilling:             if item.column() == self.GROUPS_COL_OPENCLOSE:
        cbilling:                 # They clicked the close button. Close the file:
        cbilling:                 self.close_globals_file(globals_file)
        cbilling:         else:
        cbilling:             # They clicked on a globals group row.
        cbilling:             globals_file = parent_item.text()
        cbilling:             group_name = name_item.text()
        cbilling:             # What column did they click on?
        cbilling:             if item.column() == self.GROUPS_COL_DELETE:
        cbilling:                 # They clicked the delete button. Delete the group:
        cbilling:                 self.delete_group(globals_file, group_name, confirm=True)
        cbilling:             elif item.column() == self.GROUPS_COL_OPENCLOSE:
        cbilling:                 # They clicked the open/close button. Which is it, open or close?
        cbilling:                 group_is_open = item.data(self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling:                 if group_is_open:
        cbilling:                     self.close_group(globals_file, group_name)
        cbilling:                 else:
        cbilling:                     self.open_group(globals_file, group_name)
        cbilling: 
        cbilling:     def on_treeView_groups_doubleLeftClicked(self, index):
        cbilling:         item = self.groups_model.itemFromIndex(index)
        cbilling:         # The parent item, None if there is no parent:
        cbilling:         parent_item = item.parent()
        cbilling:         if item.data(self.GROUPS_ROLE_IS_DUMMY_ROW):
        cbilling:             return
        cbilling:         elif parent_item and item.column() == self.GROUPS_COL_NAME:
        cbilling:             # it's a group name item. What's the group and file name?
        cbilling:             globals_file = parent_item.text()
        cbilling:             group_name = item.text()
        cbilling:             if (globals_file, group_name) not in self.currently_open_groups:
        cbilling:                 self.open_group(globals_file, group_name)
        cbilling:             # Focus the tab:
        cbilling:             group_tab = self.currently_open_groups[globals_file, group_name]
        cbilling:             for i in range(self.ui.tabWidget.count()):
        cbilling:                 if self.ui.tabWidget.widget(i) is group_tab.ui:
        cbilling:                     self.ui.tabWidget.setCurrentIndex(i)
        cbilling:                     break
        cbilling: 
        cbilling:     def on_groups_model_item_changed(self, item):
        cbilling:         """This function is for responding to data changes in the model. The
        cbilling:         methods for responding to changes different columns do different
        cbilling:         things. Mostly they make other data changes for model consistency, but
        cbilling:         also group creation and renaming is handled in response to changes to
        cbilling:         the 'name' column. When we change things elsewhere, we prefer to only
        cbilling:         change one thing, and the rest of the changes are triggered here. So
        cbilling:         here we do the following:
        cbilling: 
        cbilling:         Be careful not to recurse unsafely into this method - changing
        cbilling:         something that itself triggers further changes is fine so long as they
        cbilling:         peter out and don't get stuck in a loop. If recursion needs to be
        cbilling:         stopped, one can disconnect the signal temporarily with the context
        cbilling:         manager self.groups_model_item_changed_disconnected. But use this
        cbilling:         sparingly, otherwise there's the risk that some required data updates
        cbilling:         will be forgotten about and won't happen.
        cbilling:         """
        cbilling:         if item.column() == self.GROUPS_COL_NAME:
        cbilling:             self.on_groups_model_name_changed(item)
        cbilling:         elif item.column() == self.GROUPS_COL_ACTIVE:
        cbilling:             self.on_groups_model_active_changed(item)
        cbilling:         elif item.column() == self.GROUPS_COL_OPENCLOSE:
        cbilling:             self.on_groups_model_openclose_changed(item)
        cbilling: 
        cbilling:     def on_groups_model_name_changed(self, item):
        cbilling:         """Handles group renaming and creation of new groups due to the user
        cbilling:         editing the <click to add group> item"""
        cbilling:         parent_item = item.parent()
        cbilling:         # File rows are supposed to be uneditable, but just to be sure we have
        cbilling:         # a group row:
        cbilling:         assert parent_item is not None
        cbilling:         if item.data(self.GROUPS_ROLE_IS_DUMMY_ROW):
        cbilling:             item_text = item.text()
        cbilling:             if item_text != self.GROUPS_DUMMY_ROW_TEXT:
        cbilling:                 # The user has made a new globals group by editing the <click
        cbilling:                 # to add group> item.
        cbilling:                 globals_file = parent_item.text()
        cbilling:                 group_name = item_text
        cbilling:                 self.new_group(globals_file, group_name)
        cbilling:         else:
        cbilling:             # User has renamed a globals group.
        cbilling:             new_group_name = item.text()
        cbilling:             previous_group_name = item.data(self.GROUPS_ROLE_PREVIOUS_NAME)
        cbilling:             # Ensure it truly is a name change, and not something else about
        cbilling:             # the item changing:
        cbilling:             if new_group_name != previous_group_name:
        cbilling:                 globals_file = parent_item.text()
        cbilling:                 self.rename_group(globals_file, previous_group_name, new_group_name)
        cbilling: 
        cbilling:     def on_groups_model_active_changed(self, item):
        cbilling:         """Sets the sort data for the item in response to its check state
        cbilling:         changing. Also, if this is the first time this function has been
        cbilling:         called on the stack, that is, the change was initiated externally
        cbilling:         instead of via recursion from this function itself, then set the check
        cbilling:         state of other items for consistency. This entails checking/unchecking
        cbilling:         all group rows in response to the file row's check state changing, or
        cbilling:         changing the file row's check state to reflect the check state of the
        cbilling:         child group rows. That's why we need to keep track of the recursion
        cbilling:         depth - so that those changes we make don't in turn cause further
        cbilling:         changes. But we don't disconnect the on_changed signal altogether,
        cbilling:         because we still want to do the update of the sort data, and anything
        cbilling:         else that might be added in future."""
        cbilling:         self.on_groups_model_active_changed_recursion_depth += 1
        cbilling:         try:
        cbilling:             check_state = item.checkState()
        cbilling:             # Ensure sort data matches active state:
        cbilling:             item.setData(check_state, self.GROUPS_ROLE_SORT_DATA)
        cbilling:             if self.on_groups_model_active_changed_recursion_depth > 1:
        cbilling:                 # Prevent all below code from running in response to data changes
        cbilling:                 # initiated from within this method itself. The code above this
        cbilling:                 # check still runs in response to all changes.
        cbilling:                 return
        cbilling: 
        cbilling:             parent_item = item.parent()
        cbilling:             if parent_item is not None:
        cbilling:                 # A 'group active' checkbox changed due to external action (not from this method itself).
        cbilling:                 # Update the parent file checkbox to reflect the state of its children
        cbilling:                 children = [parent_item.child(i, self.GROUPS_COL_ACTIVE) for i in range(parent_item.rowCount())]
        cbilling:                 child_states = [child.checkState() for child in children
        cbilling:                                 if not child.data(self.GROUPS_ROLE_IS_DUMMY_ROW)]
        cbilling:                 parent_active_index = parent_item.index().sibling(parent_item.index().row(), self.GROUPS_COL_ACTIVE)
        cbilling:                 parent_active_item = self.groups_model.itemFromIndex(parent_active_index)
        cbilling:                 if all(state == QtCore.Qt.Checked for state in child_states):
        cbilling:                     parent_active_item.setCheckState(QtCore.Qt.Checked)
        cbilling:                 elif all(state == QtCore.Qt.Unchecked for state in child_states):
        cbilling:                     parent_active_item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:                 else:
        cbilling:                     parent_active_item.setCheckState(QtCore.Qt.PartiallyChecked)
        cbilling:             else:
        cbilling:                 # A 'file active' checkbox changed due to external action (not from this method itself).
        cbilling:                 # Update the check state of all children to match.
        cbilling:                 name_index = item.index().sibling(item.index().row(), self.GROUPS_COL_NAME)
        cbilling:                 name_item = self.groups_model.itemFromIndex(name_index)
        cbilling:                 checkstate = item.checkState()
        cbilling:                 children = [name_item.child(i, self.GROUPS_COL_ACTIVE) for i in range(name_item.rowCount())]
        cbilling:                 for child in children:
        cbilling:                     if not child.data(self.GROUPS_ROLE_IS_DUMMY_ROW):
        cbilling:                         child.setCheckState(checkstate)
        cbilling:         finally:
        cbilling:             self.on_groups_model_active_changed_recursion_depth -= 1
        cbilling:             if self.on_groups_model_active_changed_recursion_depth == 0:
        cbilling:                 self.do_model_sort()
        cbilling:                 # Trigger a preparse to occur:
        cbilling:                 self.globals_changed()
        cbilling: 
        cbilling:     def on_groups_model_openclose_changed(self, item):
        cbilling:         """Sets item sort data and icon in response to the open/close state of a group
        cbilling:         changing."""
        cbilling:         parent_item = item.parent()
        cbilling:         # The open/close state of a globals group changed. It is definitely a
        cbilling:         # group, not a file, as the open/close state of a file shouldn't be
        cbilling:         # changing.
        cbilling:         assert parent_item is not None  # Just to be sure.
        cbilling:         # Ensure the sort data matches the open/close state:
        cbilling:         group_is_open = item.data(self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling:         item.setData(group_is_open, self.GROUPS_ROLE_SORT_DATA)
        cbilling:         # Set the appropriate icon and tooltip. Changing the icon causes
        cbilling:         # itemChanged to be emitted, even if it the same icon, and even if we
        cbilling:         # were to use the same QIcon instance. So to avoid infinite recursion
        cbilling:         # we temporarily disconnect the signal whilst we set the icons.
        cbilling:         with self.groups_model_item_changed_disconnected:
        cbilling:             if group_is_open:
        cbilling:                 item.setIcon(QtGui.QIcon(':qtutils/fugue/cross'))
        cbilling:                 item.setToolTip('Close globals group.')
        cbilling:             else:
        cbilling:                 item.setIcon(QtGui.QIcon(':qtutils/fugue/plus'))
        cbilling:                 item.setToolTip('Load globals group into runmanager.')
        cbilling:             self.do_model_sort()
        cbilling:             # If this changed the sort order, ensure the item is still visible:
        cbilling:             scroll_treeview_to_row_if_current(self.ui.treeView_groups, item)
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def get_default_output_folder(self):
        cbilling:         """Returns what the default output folder would be right now, based on
        cbilling:         the current date and selected labscript file. Returns empty string if
        cbilling:         no labscript file is selected. Does not create the default output
        cbilling:         folder, does not check if it exists."""
        cbilling:         current_day_folder_suffix = time.strftime(self.output_folder_format)
        cbilling:         current_labscript_file = self.ui.lineEdit_labscript_file.text()
        cbilling:         if not current_labscript_file:
        cbilling:             return ''
        cbilling:         current_labscript_basename = os.path.splitext(os.path.basename(current_labscript_file))[0]
        cbilling:         default_output_folder = os.path.join(self.experiment_shot_storage,
        cbilling:                                              current_labscript_basename, current_day_folder_suffix)
        cbilling:         default_output_folder = os.path.normpath(default_output_folder)
        cbilling:         return default_output_folder
        cbilling: 
        cbilling:     def rollover_shot_output_folder(self):
        cbilling:         """Runs in a thread, checking once a second if it is a new day or the
        cbilling:         labscript file has changed. If it is or has, sets the default folder
        cbilling:         in which compiled shots will be put. Does not create the folder if it
        cbilling:         does not already exists, this will be done at compile-time. Will run
        cbilling:         immediately without waiting a full second if the threading.Event
        cbilling:         self.output_folder_update_required is set() from anywhere."""
        cbilling:         previous_default_output_folder = self.get_default_output_folder()
        cbilling:         while True:
        cbilling:             # Wait up to one second, shorter if the Event() gets set() by someone:
        cbilling:             self.output_folder_update_required.wait(1)
        cbilling:             self.output_folder_update_required.clear()
        cbilling:             previous_default_output_folder = self.check_output_folder_update(previous_default_output_folder)
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def check_output_folder_update(self, previous_default_output_folder):
        cbilling:         """Do a single check of whether the output folder needs updating. This
        cbilling:         is implemented as a separate function to the above loop so that the
        cbilling:         whole check happens at once in the Qt main thread and hence is atomic
        cbilling:         and can't be interfered with by other Qt calls in the program."""
        cbilling:         current_default_output_folder = self.get_default_output_folder()
        cbilling:         if current_default_output_folder is None:
        cbilling:             # No labscript file selected:
        cbilling:             return previous_default_output_folder
        cbilling:         currently_selected_output_folder = self.ui.lineEdit_shot_output_folder.text()
        cbilling:         if current_default_output_folder != previous_default_output_folder:
        cbilling:             # It's a new day, or a new labscript file.
        cbilling:             # Is the user using default folders?
        cbilling:             if currently_selected_output_folder == previous_default_output_folder:
        cbilling:                 # Yes they are. In that case, update to use the new folder:
        cbilling:                 self.ui.lineEdit_shot_output_folder.setText(current_default_output_folder)
        cbilling:             return current_default_output_folder
        cbilling:         return previous_default_output_folder
        cbilling: 
        cbilling:     @inmain_decorator()
        cbilling:     def globals_changed(self):
        cbilling:         """Called from either self or a GroupTab to inform runmanager that
        cbilling:         something about globals has changed, and that they need parsing
        cbilling:         again"""
        cbilling:         self.ui.pushButton_engage.setEnabled(False)
        cbilling:         QtCore.QTimer.singleShot(1,self.preparse_globals_required.set)
        cbilling: 
        pstarkey:     def update_axes_indentation(self):
        pstarkey:         for i in range(self.axes_model.rowCount()):
        pstarkey:             item = self.axes_model.item(i, self.AXES_COL_NAME)
        pstarkey:             text = item.text().lstrip()
        pstarkey:             text = '    '*i + text
        pstarkey:             item.setText(text)
        pstarkey:             
        pstarkey:     @inmain_decorator()  # Is called by preparser thread
        pstarkey:     def update_axes_tab(self, expansions, dimensions):
        pstarkey:         # get set of expansions
        pstarkey:         expansion_list = []
        pstarkey:         for global_name, expansion in expansions.items():
        pstarkey:             if expansion:
        pstarkey:                 if expansion == 'outer':
        pstarkey:                     expansion_list.append('outer '+global_name)
        pstarkey:                 else:
        pstarkey:                     expansion_list.append('zip '+expansion)
        pstarkey:                 
        pstarkey:         expansion_list = set(expansion_list)
        pstarkey:                 
        pstarkey:         # find items to delete
        pstarkey:         for i in reversed(range(self.axes_model.rowCount())):
        pstarkey:             item = self.axes_model.item(i, self.AXES_COL_NAME)
        pstarkey:             name = item.data(self.AXES_ROLE_NAME)
        pstarkey:             if name not in expansion_list:
        pstarkey:                 item = self.axes_model.takeRow(i)
        pstarkey:                 del item
        pstarkey:             else:
        pstarkey:                 length_item = self.axes_model.item(i, self.AXES_COL_LENGTH)
        pstarkey:                 if name in dimensions:
        pstarkey:                     length_item.setText("{}".format(dimensions[name]))
        pstarkey:                 else:
        pstarkey:                     length_item.setText('Unknown')
        pstarkey:                 
        pstarkey:                 # remove from expansions list so we don't add it again
        pstarkey:                 expansion_list.remove(name)
        pstarkey:             
        pstarkey:         # add new rows
        pstarkey:         for expansion_name in expansion_list:
        pstarkey:             shuffle = self.ui.pushButton_shuffle.checkState() != QtCore.Qt.Unchecked
        pstarkey:             self.add_item_to_axes_model(expansion_name, shuffle, dimensions)
        pstarkey:                 
        pstarkey:         self.update_axes_indentation() 
        pstarkey: 
        pstarkey:     def add_item_to_axes_model(self, expansion_name, shuffle, dimensions = None):
        pstarkey:         if dimensions is None:
        pstarkey:             dimensions = {}
        pstarkey:         
        pstarkey:         items = []
        pstarkey:         
        pstarkey:         expansion_type, name = expansion_name.split()
        pstarkey:         name_item = QtGui.QStandardItem(name)
        pstarkey:         name_item.setData(expansion_name, self.AXES_ROLE_NAME)
        pstarkey:         if expansion_type == 'outer':
        pstarkey:             name_item.setIcon(QtGui.QIcon(':qtutils/custom/outer'))
        pstarkey:         else:
        pstarkey:             name_item.setIcon(QtGui.QIcon(':qtutils/custom/zip'))
        pstarkey:         items.append(name_item)
        pstarkey:         
        pstarkey:         length = 'Unknown'
        pstarkey:         if expansion_name in dimensions:
        pstarkey:             length = "{}".format(dimensions[expansion_name])
        pstarkey:         length_item = QtGui.QStandardItem(length)
        pstarkey:         items.append(length_item)
        pstarkey:         
        pstarkey:         shuffle_item = QtGui.QStandardItem()
        pstarkey:         shuffle_item.setCheckable(True)
        pstarkey:         shuffle_item.setCheckState(QtCore.Qt.Checked if shuffle else QtCore.Qt.Unchecked)
        pstarkey:         
        pstarkey:         items.append(shuffle_item)
        pstarkey:         
        pstarkey:         self.axes_model.appendRow(items)
        pstarkey:     
        cbilling:     @inmain_decorator()  # Is called by preparser thread
chrisjbillington:     def update_tabs_parsing_indication(self, active_groups, sequence_globals, evaled_globals, n_shots):
        cbilling:         for group_tab in self.currently_open_groups.values():
        cbilling:             group_tab.update_parse_indication(active_groups, sequence_globals, evaled_globals)
        cbilling:         self.ui.pushButton_engage.setEnabled(True)
chrisjbillington:         if n_shots == 1:
chrisjbillington:             n_shots_string = '(1 shot)'
chrisjbillington:         else:
chrisjbillington:             n_shots_string = '({} shots)'.format(n_shots)
chrisjbillington:         self.ui.pushButton_engage.setText('Engage {}'.format(n_shots_string))
        cbilling: 
        cbilling:     def preparse_globals(self):
        cbilling:         active_groups = self.get_active_groups()
        cbilling:         if active_groups is None:
        cbilling:             # There was an error, get_active_groups has already shown
        cbilling:             # it to the user.
        cbilling:             return
        cbilling:         # Expansion mode is automatically updated when the global's
        cbilling:         # type changes. If this occurs, we will have to parse again to
        cbilling:         # include the change:
        cbilling:         while True:
        pstarkey:             results = self.parse_globals(active_groups, raise_exceptions=False, expand_globals=False, return_dimensions = True)
        pstarkey:             sequence_globals, shots, evaled_globals, global_hierarchy, expansions, dimensions = results
        cbilling:             n_shots = len(shots)
        cbilling:             expansions_changed = self.guess_expansion_modes(
        cbilling:                 active_groups, evaled_globals, global_hierarchy, expansions)
        cbilling:             if not expansions_changed:
        pstarkey:                 # Now expand globals while parsing to calculate the number of shots.
        pstarkey:                 # this must only be done after the expansion type guessing has been updated to avoid exceptions
        pstarkey:                 # when changing a zip group from a list to a single value
        pstarkey:                 results = self.parse_globals(active_groups, raise_exceptions=False, expand_globals=True, return_dimensions = True)
        pstarkey:                 sequence_globals, shots, evaled_globals, global_hierarchy, expansions, dimensions = results
        pstarkey:                 n_shots = len(shots)
        cbilling:                 break
        cbilling:         self.update_tabs_parsing_indication(active_groups, sequence_globals, evaled_globals, n_shots)
        pstarkey:         self.update_axes_tab(expansions, dimensions)
        cbilling: 
     janwerkmann: 
        cbilling:     def preparse_globals_loop(self):
        cbilling:         """Runs in a thread, waiting on a threading.Event that tells us when
        cbilling:         some globals have changed, and calls parse_globals to evaluate them
        cbilling:         all before feeding the results back to the relevant tabs to be
        cbilling:         displayed."""
        cbilling:         while True:
        cbilling:             try:
        cbilling:                 # Wait until we're needed:
        cbilling:                 self.preparse_globals_required.wait()
        cbilling:                 self.preparse_globals_required.clear()
        cbilling:                 # Do some work:
        cbilling:                 self.preparse_globals()
        cbilling:             except Exception:
        cbilling:                 # Raise the error, but keep going so we don't take down the
        cbilling:                 # whole thread if there is a bug.
        cbilling:                 exc_info = sys.exc_info()
        cbilling:                 zprocess.raise_exception_in_thread(exc_info)
        cbilling:                 continue
        cbilling: 
        cbilling:     def get_group_item_by_name(self, globals_file, group_name, column, previous_name=None):
        cbilling:         """Returns an item from the row representing a globals group in the
        cbilling:         groups model. Which item is returned is set by the column argument."""
        cbilling:         parent_item = self.groups_model.findItems(globals_file, column=self.GROUPS_COL_NAME)[0]
        cbilling:         possible_name_items = self.groups_model.findItems(group_name, QtCore.Qt.MatchRecursive,
        cbilling:                                                           column=self.GROUPS_COL_NAME)
        cbilling:         # Don't accidentally match on other groups or files with the same name
        cbilling:         # as this group:
        cbilling:         possible_name_items = [item for item in possible_name_items if item.parent() == parent_item]
        cbilling:         if previous_name is not None:
        cbilling:             # Also filter by previous name, useful for telling rows apart when
        cbilling:             # a rename is in progress and two rows may temporarily contain the
        cbilling:             # same name (though the rename code with throw an error and revert
        cbilling:             # it).
        cbilling:             possible_name_items = [item for item in possible_name_items
        cbilling:                                    if item.data(self.GROUPS_ROLE_PREVIOUS_NAME) == previous_name]
        cbilling:         elif group_name != self.GROUPS_DUMMY_ROW_TEXT:
        cbilling:             # Don't return the dummy item unless they asked for it explicitly
        cbilling:             # - if a new group is being created, its name might be
        cbilling:             # simultaneously present in its own row and the dummy row too.
        cbilling:             possible_name_items = [item for item in possible_name_items
        cbilling:                                    if not item.data(self.GROUPS_ROLE_IS_DUMMY_ROW)]
        cbilling: 
        cbilling:         if len(possible_name_items) > 1:
        cbilling:             raise LookupError('Multiple items found')
        cbilling:         elif not possible_name_items:
        cbilling:             raise LookupError('No item found')
        cbilling:         name_item = possible_name_items[0]
        cbilling:         name_index = name_item.index()
        cbilling:         # Found the name item, get the sibling item for the column requested:
        cbilling:         item_index = name_index.sibling(name_index.row(), column)
        cbilling:         item = self.groups_model.itemFromIndex(item_index)
        cbilling:         return item
        cbilling: 
        cbilling:     def do_model_sort(self):
        cbilling:         header = self.ui.treeView_groups.header()
        cbilling:         sort_column = header.sortIndicatorSection()
        cbilling:         sort_order = header.sortIndicatorOrder()
        cbilling:         self.ui.treeView_groups.sortByColumn(sort_column, sort_order)
        cbilling: 
        cbilling:     @inmain_decorator()  # Can be called from a non-main thread
        cbilling:     def get_active_groups(self):
        cbilling:         """Returns active groups in the format {group_name: globals_file}.
        cbilling:         Displays an error dialog and returns None if multiple groups of the
        cbilling:         same name are selected, this is invalid - selected groups must be
        cbilling:         uniquely named."""
        cbilling:         active_groups = {}
        cbilling:         for i in range(self.groups_model.rowCount()):
        cbilling:             file_name_item = self.groups_model.item(i, self.GROUPS_COL_NAME)
        cbilling:             for j in range(file_name_item.rowCount()):
        cbilling:                 group_name_item = file_name_item.child(j, self.GROUPS_COL_NAME)
        cbilling:                 group_active_item = file_name_item.child(j, self.GROUPS_COL_ACTIVE)
        cbilling:                 if group_active_item.checkState() == QtCore.Qt.Checked:
        cbilling:                     group_name = group_name_item.text()
        cbilling:                     globals_file = file_name_item.text()
        cbilling:                     if group_name in active_groups:
        cbilling:                         error_dialog('There are two active groups named %s. ' % group_name +
        cbilling:                                      'Active groups must have unique names to be used together.')
        cbilling:                         return
        cbilling:                     active_groups[group_name] = globals_file
        cbilling:         return active_groups
        cbilling: 
        cbilling:     def open_globals_file(self, globals_file):
        cbilling:         # Do nothing if this file is already open:
        cbilling:         if self.groups_model.findItems(globals_file, column=self.GROUPS_COL_NAME):
        cbilling:             return
        cbilling: 
        cbilling:         # Get the groups:
        cbilling:         groups = runmanager.get_grouplist(globals_file)
        cbilling:         # Add the parent row:
        cbilling:         file_name_item = QtGui.QStandardItem(globals_file)
        cbilling:         file_name_item.setEditable(False)
        cbilling:         file_name_item.setToolTip(globals_file)
        cbilling:         # Sort column by name:
        cbilling:         file_name_item.setData(globals_file, self.GROUPS_ROLE_SORT_DATA)
        cbilling: 
        cbilling:         file_active_item = QtGui.QStandardItem()
        cbilling:         file_active_item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:         # Sort column by CheckState - must keep this updated when checkstate changes:
        cbilling:         file_active_item.setData(QtCore.Qt.Unchecked, self.GROUPS_ROLE_SORT_DATA)
        cbilling:         file_active_item.setEditable(False)
        cbilling:         file_active_item.setToolTip('Check to set all the file\'s groups as active.')
        cbilling: 
        cbilling:         file_delete_item = QtGui.QStandardItem()  # Blank, only groups have a delete button
        cbilling:         file_delete_item.setEditable(False)
        cbilling:         # Must be set to something so that the dummy row doesn't get sorted first:
        cbilling:         file_delete_item.setData(False, self.GROUPS_ROLE_SORT_DATA)
        cbilling: 
        cbilling:         file_close_item = QtGui.QStandardItem()
        cbilling:         file_close_item.setIcon(QtGui.QIcon(':qtutils/fugue/cross'))
        cbilling:         file_close_item.setEditable(False)
        cbilling:         file_close_item.setToolTip('Close globals file.')
        cbilling: 
        cbilling:         self.groups_model.appendRow([file_name_item, file_active_item, file_delete_item, file_close_item])
        cbilling: 
        cbilling:         # Add the groups as children:
        cbilling:         for group_name in groups:
        cbilling:             row = self.make_group_row(group_name)
        cbilling:             file_name_item.appendRow(row)
        cbilling: 
        cbilling:         # Finally, add the <Click to add group> row at the bottom:
        cbilling:         dummy_name_item = QtGui.QStandardItem(self.GROUPS_DUMMY_ROW_TEXT)
        cbilling:         dummy_name_item.setToolTip('Click to add group')
        cbilling:         # This lets later code know that this row does
        cbilling:         # not correspond to an actual globals group:
        cbilling:         dummy_name_item.setData(True, self.GROUPS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_name_item.setData(self.GROUPS_DUMMY_ROW_TEXT, self.GROUPS_ROLE_PREVIOUS_NAME)
        cbilling:         dummy_name_item.setFlags(QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsEditable)  # Clears the 'selectable' flag
        cbilling: 
        cbilling:         dummy_active_item = QtGui.QStandardItem()
        cbilling:         dummy_active_item.setData(True, self.GROUPS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_active_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling: 
        cbilling:         dummy_delete_item = QtGui.QStandardItem()
        cbilling:         dummy_delete_item.setData(True, self.GROUPS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_delete_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling: 
        cbilling:         dummy_open_close_item = QtGui.QStandardItem()
        cbilling:         dummy_open_close_item.setData(True, self.GROUPS_ROLE_IS_DUMMY_ROW)
        cbilling:         dummy_open_close_item.setFlags(QtCore.Qt.NoItemFlags)
        cbilling: 
        cbilling:         # Not setting anything as the above items' sort role has the effect of
        cbilling:         # ensuring this row is always sorted to the end of the list, without
        cbilling:         # us having to implement any custom sorting methods or subclassing
        cbilling:         # anything, yay.
        cbilling: 
        cbilling:         file_name_item.appendRow([dummy_name_item, dummy_active_item, dummy_delete_item, dummy_open_close_item])
        cbilling:         # Expand the child items to be visible:
        cbilling:         self.ui.treeView_groups.setExpanded(file_name_item.index(), True)
        cbilling:         self.globals_changed()
        cbilling:         self.do_model_sort()
        cbilling:         # If this changed the sort order, ensure the file item is visible:
        cbilling:         scroll_treeview_to_row_if_current(self.ui.treeView_groups, file_name_item)
        cbilling: 
        cbilling:     def make_group_row(self, group_name):
        cbilling:         """Returns a new row representing one group in the groups tab, ready to be
        cbilling:         inserted into the model."""
        cbilling:         group_name_item = QtGui.QStandardItem(group_name)
        cbilling:         # We keep the previous name around so that we can detect what changed:
        cbilling:         group_name_item.setData(group_name, self.GROUPS_ROLE_PREVIOUS_NAME)
        cbilling:         # Sort column by name:
        cbilling:         group_name_item.setData(group_name, self.GROUPS_ROLE_SORT_DATA)
        cbilling: 
        cbilling:         group_active_item = QtGui.QStandardItem()
        cbilling:         group_active_item.setCheckState(QtCore.Qt.Unchecked)
        cbilling:         # Sort column by CheckState - must keep this updated whenever the
        cbilling:         # checkstate changes:
        cbilling:         group_active_item.setData(QtCore.Qt.Unchecked, self.GROUPS_ROLE_SORT_DATA)
        cbilling:         group_active_item.setEditable(False)
        cbilling:         group_active_item.setToolTip(
        cbilling:             'Whether or not the globals within this group should be used by runmanager for compilation.')
        cbilling: 
        cbilling:         group_delete_item = QtGui.QStandardItem()
        cbilling:         group_delete_item.setIcon(QtGui.QIcon(':qtutils/fugue/minus'))
        cbilling:         # Must be set to something so that the dummy row doesn't get sorted first:
        cbilling:         group_delete_item.setData(False, self.GROUPS_ROLE_SORT_DATA)
        cbilling:         group_delete_item.setEditable(False)
        cbilling:         group_delete_item.setToolTip('Delete globals group from file.')
        cbilling: 
        cbilling:         group_open_close_item = QtGui.QStandardItem()
        cbilling:         group_open_close_item.setIcon(QtGui.QIcon(':qtutils/fugue/plus'))
        cbilling:         group_open_close_item.setData(False, self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling:         # Sort column by whether group is open - must keep this manually
        cbilling:         # updated when the state changes:
        cbilling:         group_open_close_item.setData(False, self.GROUPS_ROLE_SORT_DATA)
        cbilling:         group_open_close_item.setEditable(False)
        cbilling:         group_open_close_item.setToolTip('Load globals group into runmananger.')
        cbilling: 
        cbilling:         row = [group_name_item, group_active_item, group_delete_item, group_open_close_item]
        cbilling:         return row
        cbilling: 
        cbilling:     def close_globals_file(self, globals_file, confirm=True):
        cbilling:         item = self.groups_model.findItems(globals_file, column=self.GROUPS_COL_NAME)[0]
        cbilling:         # Close any open groups in this globals file:
        cbilling: 
        cbilling:         child_name_items = [item.child(i, self.GROUPS_COL_NAME) for i in range(item.rowCount())]
        cbilling:         child_openclose_items = [item.child(i, self.GROUPS_COL_OPENCLOSE) for i in range(item.rowCount())]
        cbilling:         child_is_open = [child_item.data(self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling:                          for child_item in child_openclose_items]
        cbilling:         if confirm and any(child_is_open):
        cbilling:             if not question_dialog('Close %s? This will close %d currently open group(s).' %
        cbilling:                                    (globals_file, child_is_open.count(True))):
        cbilling:                 return
        cbilling:         to_close = [name_item for name_item, is_open in zip(child_name_items, child_is_open) if is_open]
        cbilling:         for name_item in to_close:
        cbilling:             group_name = name_item.text()
        cbilling:             self.close_group(globals_file, group_name)
        cbilling: 
        cbilling:         # Remove the globals file from the model:
        cbilling:         self.groups_model.removeRow(item.row())
        cbilling:         self.globals_changed()
        cbilling: 
     janwerkmann:     def copy_group(self, source_globals_file, source_group_name, dest_globals_file=None, delete_source_group=False):
     janwerkmann:         """This function copys a group of globals with the name source_group_name from the file
     janwerkmann:             source_globals_file to a new file dest_globals_file. If delete_source_group is True
     janwerkmann:             the source group is deleted after copying"""
     janwerkmann:         if delete_source_group and source_globals_file == dest_globals_file:
     janwerkmann:             return
     janwerkmann:         try:
     janwerkmann:             dest_group_name = runmanager.copy_group(source_globals_file, source_group_name, dest_globals_file, delete_source_group)
     janwerkmann:         except Exception as e:
     janwerkmann:             error_dialog(str(e))
     janwerkmann:         else:
     janwerkmann:             # Insert the newly created globals group into the model, as a
     janwerkmann:             # child row of the new globals file.
     janwerkmann:             if dest_globals_file is None:
     janwerkmann:                 dest_globals_file = source_globals_file
     janwerkmann: 
     janwerkmann:             # find the new groups parent row by filepath
     janwerkmann:             for index in range(self.groups_model.rowCount()):
     janwerkmann:                 if self.groups_model.item(index, self.GROUPS_COL_NAME).text() == dest_globals_file:
     janwerkmann:                     parent_row = self.groups_model.item(index)
     janwerkmann:                     break
     janwerkmann: 
     janwerkmann:             last_index = parent_row.rowCount()
     janwerkmann:             # Insert it as the row before the last (dummy) row:
     janwerkmann:             group_row = self.make_group_row(dest_group_name)
     janwerkmann:             parent_row.insertRow(last_index - 1, group_row)
     janwerkmann:             self.do_model_sort()
     janwerkmann: 
     janwerkmann:             # Open the group
     janwerkmann:             self.open_group(dest_globals_file, dest_group_name)
     janwerkmann:             name_item = group_row[self.GROUPS_COL_NAME]
     janwerkmann:             self.globals_changed()
     janwerkmann:             self.ui.treeView_groups.setCurrentIndex(name_item.index())
     janwerkmann: 
     janwerkmann:             # delete original
     janwerkmann:             if delete_source_group:
     janwerkmann:                 self.delete_group(source_globals_file, source_group_name, confirm=False)
     janwerkmann: 
     janwerkmann:             # If this changed the sort order, ensure the group item is still visible:
     janwerkmann:             scroll_treeview_to_row_if_current(self.ui.treeView_groups, name_item)
     janwerkmann: 
        cbilling:     def new_group(self, globals_file, group_name):
        cbilling:         item = self.get_group_item_by_name(globals_file, group_name, self.GROUPS_COL_NAME,
        cbilling:                                            previous_name=self.GROUPS_DUMMY_ROW_TEXT)
        cbilling:         try:
        cbilling:             runmanager.new_group(globals_file, group_name)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:         else:
        cbilling:             # Insert the newly created globals group into the model, as a
        cbilling:             # child row of the globals file it belong to.
        cbilling:             group_row = self.make_group_row(group_name)
        cbilling:             last_index = item.parent().rowCount()
        cbilling:             # Insert it as the row before the last (dummy) row:
        cbilling:             item.parent().insertRow(last_index - 1, group_row)
        cbilling:             self.do_model_sort()
        cbilling:             # Open the group and mark it active:
        cbilling:             self.open_group(globals_file, group_name)
        cbilling:             active_item = group_row[self.GROUPS_COL_ACTIVE]
        cbilling:             name_item = group_row[self.GROUPS_COL_NAME]
        cbilling:             active_item.setCheckState(QtCore.Qt.Checked)
        cbilling:             self.globals_changed()
        cbilling:             self.ui.treeView_groups.setCurrentIndex(name_item.index())
        cbilling:             # If this changed the sort order, ensure the group item is still visible:
        cbilling:             scroll_treeview_to_row_if_current(self.ui.treeView_groups, name_item)
        cbilling:         finally:
        cbilling:             # Set the dummy row's text back ready for another group to be created:
        cbilling:             item.setText(self.GROUPS_DUMMY_ROW_TEXT)
        cbilling: 
        cbilling:     def open_group(self, globals_file, group_name, trigger_preparse=True):
        cbilling:         assert (globals_file, group_name) not in self.currently_open_groups  # sanity check
        cbilling:         group_tab = GroupTab(self.ui.tabWidget, globals_file, group_name)
        cbilling:         self.currently_open_groups[globals_file, group_name] = group_tab
        cbilling: 
        cbilling:         # Set the open/close state in the groups_model. itemChanged will be
        cbilling:         # emitted and self.on_groups_model_item_changed will handle updating
        cbilling:         # the other data roles, icons etc:
        cbilling:         openclose_item = self.get_group_item_by_name(globals_file, group_name, self.GROUPS_COL_OPENCLOSE)
        cbilling:         openclose_item.setData(True, self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling:         # Trigger a preparse to occur in light of this. Calling code can
        cbilling:         # disable this so that multiple groups can be opened at once without
        cbilling:         # triggering a preparse. If they do so, they should call
        cbilling:         # self.globals_changed() themselves.
        cbilling:         if trigger_preparse:
        cbilling:             self.globals_changed()
        cbilling: 
        cbilling:     def rename_group(self, globals_file, previous_group_name, new_group_name):
        cbilling:         item = self.get_group_item_by_name(globals_file, new_group_name, self.GROUPS_COL_NAME,
        cbilling:                                            previous_name=previous_group_name)
        cbilling:         try:
        cbilling:             runmanager.rename_group(globals_file, previous_group_name, new_group_name)
        cbilling:         except Exception as e:
        cbilling:             error_dialog(str(e))
        cbilling:             # Set the item text back to the old name, since the rename failed:
        cbilling:             item.setText(previous_group_name)
        cbilling:         else:
        cbilling:             item.setData(new_group_name, self.GROUPS_ROLE_PREVIOUS_NAME)
        cbilling:             item.setData(new_group_name, self.GROUPS_ROLE_SORT_DATA)
        cbilling:             self.do_model_sort()
        cbilling:             # If this changed the sort order, ensure the group item is still visible:
        cbilling:             scroll_treeview_to_row_if_current(self.ui.treeView_groups, item)
        cbilling:             group_tab = self.currently_open_groups.pop((globals_file, previous_group_name), None)
        cbilling:             if group_tab is not None:
        cbilling:                 # Change labels and tooltips appropriately if the group is open:
        cbilling:                 group_tab.set_file_and_group_name(globals_file, new_group_name)
        cbilling:                 # Re-add it to the dictionary under the new name:
        cbilling:                 self.currently_open_groups[globals_file, new_group_name] = group_tab
        cbilling: 
        cbilling:     def close_group(self, globals_file, group_name):
        cbilling:         group_tab = self.currently_open_groups.pop((globals_file, group_name), None)
        cbilling:         assert group_tab is not None  # Just in case
        cbilling:         group_tab.close()
        cbilling:         openclose_item = self.get_group_item_by_name(globals_file, group_name, self.GROUPS_COL_OPENCLOSE)
        cbilling:         openclose_item.setData(False, self.GROUPS_ROLE_GROUP_IS_OPEN)
        cbilling: 
        cbilling:     def delete_group(self, globals_file, group_name, confirm=True):
        cbilling:         if confirm:
        cbilling:             if not question_dialog("Delete the group '%s'?" % group_name):
        cbilling:                 return
        cbilling:         # If the group is open, close it:
        cbilling:         group_tab = self.currently_open_groups.get((globals_file, group_name))
        cbilling:         if group_tab is not None:
        cbilling:             self.close_group(globals_file, group_name)
        cbilling:         runmanager.delete_group(globals_file, group_name)
        cbilling:         # Find the entry for this group in self.groups_model and remove it:
        cbilling:         name_item = self.get_group_item_by_name(globals_file, group_name, self.GROUPS_COL_NAME)
        cbilling:         name_item.parent().removeRow(name_item.row())
        cbilling:         self.globals_changed()
        cbilling: 
        cbilling:     def on_save_configuration_triggered(self):
        cbilling:         if self.last_save_config_file is None:
        cbilling:             self.on_save_configuration_as_triggered()
        cbilling:             self.ui.actionSave_configuration_as.setEnabled(True)
        cbilling:             self.ui.actionRevert_configuration.setEnabled(True)
        cbilling:         else:
        cbilling:             self.save_configuration(self.last_save_config_file)
        cbilling: 
        cbilling:     def on_revert_configuration_triggered(self):
        cbilling:         save_data = self.get_save_data()
        cbilling:         if self.last_save_data is not None and save_data != self.last_save_data:
        cbilling:             message = 'Revert configuration to the last saved state in \'%s\'?' % self.last_save_config_file
     janwerkmann:             reply = QtWidgets.QMessageBox.question(self.ui, 'Load configuration', message,
     janwerkmann:                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.Cancel)
     janwerkmann:             if reply == QtWidgets.QMessageBox.Cancel:
        cbilling:                 return
     janwerkmann:             elif reply == QtWidgets.QMessageBox.Yes:
        cbilling:                 self.load_configuration(self.last_save_config_file)
        cbilling:         else:
        cbilling:             error_dialog('no changes to revert')
        cbilling: 
        cbilling:     def on_save_configuration_as_triggered(self):
        cbilling:         if self.last_save_config_file is not None:
        cbilling:             default = self.last_save_config_file
        cbilling:         else:
        cbilling:             default = os.path.join(self.exp_config.get('paths', 'experiment_shot_storage'), 'runmanager.ini')
     janwerkmann:         save_file = QtWidgets.QFileDialog.getSaveFileName(self.ui,
        cbilling:                                                       'Select  file to save current runmanager configuration',
        cbilling:                                                       default,
        cbilling:                                                       "config files (*.ini)")
     janwerkmann:         if type(save_file) is tuple:
     janwerkmann:             save_file, _ = save_file
     janwerkmann: 
        cbilling:         if not save_file:
        cbilling:             # User cancelled
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes
        cbilling:         # forward slashes:
        cbilling:         save_file = os.path.abspath(save_file)
        cbilling:         self.save_configuration(save_file)
        cbilling: 
        cbilling:     def get_save_data(self):
        cbilling:         # Get the currently open files and active groups:
        cbilling:         h5_files_open = []
        cbilling:         active_groups = []
        cbilling:         for i in range(self.groups_model.rowCount()):
        cbilling:             file_name_item = self.groups_model.item(i, self.GROUPS_COL_NAME)
        cbilling:             globals_file_name = file_name_item.text()
        cbilling:             h5_files_open.append(globals_file_name)
        cbilling:             for j in range(file_name_item.rowCount()):
        cbilling:                 group_name_item = file_name_item.child(j, self.GROUPS_COL_NAME)
        cbilling:                 group_name = group_name_item.text()
        cbilling:                 group_active_item = file_name_item.child(j, self.GROUPS_COL_ACTIVE)
        cbilling:                 if group_active_item.checkState() == QtCore.Qt.Checked:
        cbilling:                     active_groups.append((globals_file_name, group_name))
        cbilling:         # Get the currently open groups:
        cbilling:         groups_open = []
        cbilling:         for i in range(self.ui.tabWidget.count()):
        cbilling:             tab_page = self.ui.tabWidget.widget(i)
        cbilling:             for (globals_file_name, group_name), group_tab in self.currently_open_groups.items():
        cbilling:                 if group_tab.ui is tab_page:
        cbilling:                     groups_open.append((globals_file_name, group_name))
        cbilling:                     break
        cbilling:         # Get the labscript file, output folder, and whether the output folder
        cbilling:         # is default:
        cbilling:         current_labscript_file = self.ui.lineEdit_labscript_file.text()
        cbilling:         shot_output_folder = self.ui.lineEdit_shot_output_folder.text()
        cbilling:         is_using_default_shot_output_folder = (shot_output_folder == self.get_default_output_folder())
        cbilling:         # Only save the shot output folder if not using the default, that way
        cbilling:         # the folder updating as the day rolls over will not be detected as a
        cbilling:         # change to the save data:
        cbilling:         if is_using_default_shot_output_folder:
        cbilling:             shot_output_folder = ''
        cbilling: 
        cbilling:         # Get the server hostnames:
        cbilling:         BLACS_host = self.ui.lineEdit_BLACS_hostname.text()
        cbilling: 
        cbilling:         send_to_runviewer = self.ui.checkBox_view_shots.isChecked()
        cbilling:         send_to_BLACS = self.ui.checkBox_run_shots.isChecked()
        cbilling:         shuffle = self.ui.pushButton_shuffle.isChecked()
        cbilling: 
        pstarkey:         # axes tab information
        pstarkey:         axes = []
        pstarkey:         for i in range(self.axes_model.rowCount()):
        pstarkey:             name_item = self.axes_model.item(i, self.AXES_COL_NAME)
        pstarkey:             shuffle_item = self.axes_model.item(i, self.AXES_COL_SHUFFLE)
        pstarkey:             shuffle_state = shuffle_item.checkState()
        pstarkey:             
        pstarkey:             axes.append((name_item.data(self.AXES_ROLE_NAME), 1 if shuffle_state == QtCore.Qt.Checked else 0))
        pstarkey:         
        cbilling:         save_data = {'h5_files_open': h5_files_open,
        cbilling:                      'active_groups': active_groups,
        cbilling:                      'groups_open': groups_open,
        cbilling:                      'current_labscript_file': current_labscript_file,
        cbilling:                      'shot_output_folder': shot_output_folder,
        cbilling:                      'is_using_default_shot_output_folder': is_using_default_shot_output_folder,
        cbilling:                      'send_to_runviewer': send_to_runviewer,
        cbilling:                      'send_to_BLACS': send_to_BLACS,
        cbilling:                      'shuffle': shuffle,
        pstarkey:                      'axes': axes,
           Chris:                      'BLACS_host': BLACS_host}
        cbilling:         return save_data
        cbilling: 
        cbilling:     def save_configuration(self, save_file):
        cbilling:         runmanager_config = LabConfig(save_file)
        cbilling:         save_data = self.get_save_data()
        cbilling:         self.last_save_config_file = save_file
        cbilling:         self.last_save_data = save_data
        cbilling:         for key, value in save_data.items():
        cbilling:             runmanager_config.set('runmanager_state', key, pprint.pformat(value))
        cbilling: 
        cbilling:     def on_load_configuration_triggered(self):
        cbilling:         save_data = self.get_save_data()
        cbilling:         if self.last_save_data is not None and save_data != self.last_save_data:
        cbilling:             message = ('Current configuration (which groups are active/open and other GUI state) '
        cbilling:                        'has changed: save config file \'%s\'?' % self.last_save_config_file)
     janwerkmann:             reply = QtWidgets.QMessageBox.question(self.ui, 'Load configuration', message,
     janwerkmann:                                                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No | QtWidgets.QMessageBox.Cancel)
     janwerkmann:             if reply == QtWidgets.QMessageBox.Cancel:
        cbilling:                 return
     janwerkmann:             if reply == QtWidgets.QMessageBox.Yes:
        cbilling:                 self.save_configuration(self.last_save_config_file)
        cbilling: 
        cbilling:         if self.last_save_config_file is not None:
        cbilling:             default = self.last_save_config_file
        cbilling:         else:
        cbilling:             default = os.path.join(self.exp_config.get('paths', 'experiment_shot_storage'), 'runmanager.ini')
        cbilling: 
     janwerkmann:         file = QtWidgets.QFileDialog.getOpenFileName(self.ui,
        cbilling:                                                  'Select runmanager configuration file to load',
        cbilling:                                                  default,
        cbilling:                                                  "config files (*.ini)")
     janwerkmann:         if type(file) is tuple:
     janwerkmann:             file, _ = file
     janwerkmann: 
        cbilling:         if not file:
        cbilling:             # User cancelled
        cbilling:             return
        cbilling:         # Convert to standard platform specific path, otherwise Qt likes
        cbilling:         # forward slashes:
        cbilling:         file = os.path.abspath(file)
        cbilling:         self.load_configuration(file)
        cbilling: 
        cbilling:     def load_configuration(self, filename):
        cbilling:         self.last_save_config_file = filename
        cbilling:         self.ui.actionSave_configuration.setText('Save configuration %s'%filename)
        cbilling:         # Close all files:
        cbilling:         save_data = self.get_save_data()
        cbilling:         for globals_file in save_data['h5_files_open']:
        cbilling:             self.close_globals_file(globals_file, confirm=False)
        cbilling:         # Ensure folder exists, if this was opened programmatically we are
        cbilling:         # creating the file, so the directory had better exist!
        cbilling:         mkdir_p(os.path.dirname(filename))
        cbilling:         runmanager_config = LabConfig(filename)
        cbilling: 
        cbilling:         has_been_a_warning = [False]
        cbilling:         def warning(message):
        cbilling:             if not has_been_a_warning[0]:
        cbilling:                 has_been_a_warning[0] = True
        cbilling:                 self.output_box.output('\n')
        cbilling:             self.output_box.output('Warning: %s\n' % message, red=True)
        cbilling: 
        cbilling:         try:
        cbilling:             h5_files_open = ast.literal_eval(runmanager_config.get('runmanager_state', 'h5_files_open'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             for globals_file in h5_files_open:
        cbilling:                 if os.path.exists(globals_file):
        cbilling:                     try:
        cbilling:                         self.open_globals_file(globals_file)
        cbilling:                         self.last_opened_globals_folder = os.path.dirname(globals_file)
        cbilling:                     except Exception:
        cbilling:                         zprocess.raise_exception_in_thread(sys.exc_info())
        cbilling:                         continue
        cbilling:                 else:
        cbilling:                     self.output_box.output('\nWarning: globals file %s no longer exists\n' % globals_file, red=True)
        cbilling:         try:
        cbilling:             active_groups = ast.literal_eval(runmanager_config.get('runmanager_state', 'active_groups'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             for globals_file, group_name in active_groups:
        cbilling:                 try:
        cbilling:                     group_active_item = self.get_group_item_by_name(globals_file, group_name, self.GROUPS_COL_ACTIVE)
        cbilling:                     group_active_item.setCheckState(QtCore.Qt.Checked)
        cbilling:                 except LookupError:
        cbilling:                     warning("previously active group '%s' in %s no longer exists" % (group_name, globals_file))
        cbilling:         try:
        cbilling:             groups_open = ast.literal_eval(runmanager_config.get('runmanager_state', 'groups_open'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             for globals_file, group_name in groups_open:
        cbilling:                 # First check if it exists:
        cbilling:                 try:
        cbilling:                     self.get_group_item_by_name(globals_file, group_name, self.GROUPS_COL_NAME)
        cbilling:                 except LookupError:
        cbilling:                     warning("previously open group '%s' in %s no longer exists" % (group_name, globals_file))
        cbilling:                 else:
        cbilling:                     self.open_group(globals_file, group_name)
        cbilling: 
        cbilling:         try:
        cbilling:             current_labscript_file = ast.literal_eval(
        cbilling:                 runmanager_config.get('runmanager_state', 'current_labscript_file'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             if os.path.exists(current_labscript_file):
        cbilling:                 self.ui.lineEdit_labscript_file.setText(current_labscript_file)
        cbilling:                 self.last_opened_labscript_folder = os.path.dirname(current_labscript_file)
        cbilling:             elif current_labscript_file:
        cbilling:                 warning('previously selected labscript file %s no longer exists' % current_labscript_file)
        cbilling:         try:
        cbilling:             shot_output_folder = ast.literal_eval(runmanager_config.get('runmanager_state', 'shot_output_folder'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             self.ui.lineEdit_shot_output_folder.setText(shot_output_folder)
        cbilling:             self.last_selected_shot_output_folder = os.path.dirname(shot_output_folder)
        cbilling:         try:
        cbilling:             is_using_default_shot_output_folder = ast.literal_eval(
        cbilling:                 runmanager_config.get('runmanager_state', 'is_using_default_shot_output_folder'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             if is_using_default_shot_output_folder:
        cbilling:                 default_output_folder = self.get_default_output_folder()
        cbilling:                 self.ui.lineEdit_shot_output_folder.setText(default_output_folder)
        cbilling:                 self.last_selected_shot_output_folder = os.path.dirname(default_output_folder)
        cbilling:         try:
        cbilling:             send_to_runviewer = ast.literal_eval(runmanager_config.get('runmanager_state', 'send_to_runviewer'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             self.ui.checkBox_view_shots.setChecked(send_to_runviewer)
        cbilling:         try:
        cbilling:             send_to_BLACS = ast.literal_eval(runmanager_config.get('runmanager_state', 'send_to_BLACS'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             self.ui.checkBox_run_shots.setChecked(send_to_BLACS)
        pstarkey:         
        pstarkey:         # clear the axes model first
        pstarkey:         if self.axes_model.rowCount():
        pstarkey:             self.axes_model.removeRows(0, self.axes_model.rowCount())
        pstarkey:         # set the state of the global shuffle button. This ensure that if no axes items get loaded afterwards
        pstarkey:         # (e.g. because the globals in the .ini file are no longer expansion globals), then we still have 
        pstarkey:         # an approximate state for the shuffle button that will apply to whatever globals are to be expanded.
        cbilling:         try:
        cbilling:             shuffle = ast.literal_eval(runmanager_config.get('runmanager_state', 'shuffle'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             if shuffle:
        cbilling:                 self.ui.pushButton_shuffle.setChecked(True)
        pstarkey:         # Now load the axes states (order and shuffle). This will also ensure the shuffle button matches the 
        pstarkey:         # state of these items (since we don't save/restore the tri-state nature of the global shuffle button
        pstarkey:         try:
        pstarkey:             axes = ast.literal_eval(runmanager_config.get('runmanager_state', 'axes'))
        pstarkey:         except Exception:
        pstarkey:             pass
        pstarkey:         else:
        pstarkey:             if isinstance(axes, list):
        pstarkey:                 # clear model
        pstarkey:                 for name, shuffle in axes:
        pstarkey:                     self.add_item_to_axes_model(name, shuffle)
        pstarkey:                 self.update_axes_indentation() 
        cbilling:         try:
        cbilling:             BLACS_host = ast.literal_eval(runmanager_config.get('runmanager_state', 'BLACS_host'))
        cbilling:         except Exception:
        cbilling:             pass
        cbilling:         else:
        cbilling:             self.ui.lineEdit_BLACS_hostname.setText(BLACS_host)
        cbilling:         # Set as self.last_save_data:
        cbilling:         save_data = self.get_save_data()
        cbilling:         self.last_save_data = save_data
        cbilling:         self.ui.actionSave_configuration_as.setEnabled(True)
        cbilling:         self.ui.actionRevert_configuration.setEnabled(True)
        cbilling: 
        cbilling:     def compile_loop(self):
        cbilling:         while True:
        cbilling:             try:
        cbilling:                 labscript_file, run_files, send_to_BLACS, BLACS_host, send_to_runviewer = self.compile_queue.get()
        cbilling:                 run_files = iter(run_files)  # Should already be in iterator but just in case
        cbilling:                 while True:
        cbilling:                     if self.compilation_aborted.is_set():
        cbilling:                         self.output_box.output('Compilation aborted.\n\n', red=True)
        cbilling:                         break
        cbilling:                     try:
        cbilling:                         try:
             jan:                             # We do next() instead of looping over run_files
        cbilling:                             # so that if compilation is aborted we won't
        cbilling:                             # create an extra file unnecessarily.
             jan:                             run_file = next(run_files)
        cbilling:                         except StopIteration:
        cbilling:                             self.output_box.output('Ready.\n\n')
        cbilling:                             break
        cbilling:                         else:
        cbilling:                             self.to_child.put(['compile', [labscript_file, run_file]])
        cbilling:                             signal, success = self.from_child.get()
        cbilling:                             assert signal == 'done'
        cbilling:                             if not success:
        cbilling:                                 self.compilation_aborted.set()
        cbilling:                                 continue
        cbilling:                             if send_to_BLACS:
        cbilling:                                 self.send_to_BLACS(run_file, BLACS_host)
        cbilling:                             if send_to_runviewer:
        cbilling:                                 self.send_to_runviewer(run_file)
        cbilling:                     except Exception as e:
        cbilling:                         self.output_box.output(str(e) + '\n', red=True)
        cbilling:                         self.compilation_aborted.set()
        cbilling:                 inmain(self.ui.pushButton_abort.setEnabled, False)
        cbilling:                 self.compilation_aborted.clear()
        cbilling:             except Exception:
        cbilling:                 # Raise it so whatever bug it is gets seen, but keep going so
        cbilling:                 # the thread keeps functioning:
        cbilling:                 exc_info = sys.exc_info()
        cbilling:                 zprocess.raise_exception_in_thread(exc_info)
        cbilling:                 continue
        cbilling: 
        pstarkey:     def parse_globals(self, active_groups, raise_exceptions=True, expand_globals=True, expansion_order = None, return_dimensions = False):
        cbilling:         sequence_globals = runmanager.get_globals(active_groups)
        cbilling:         #logger.info('got sequence globals')
        cbilling:         evaled_globals, global_hierarchy, expansions = runmanager.evaluate_globals(sequence_globals, raise_exceptions)
        cbilling:         #logger.info('evaluated sequence globals')
        cbilling:         if expand_globals:
        pstarkey:             if return_dimensions:
        pstarkey:                 shots, dimensions = runmanager.expand_globals(sequence_globals, evaled_globals, expansion_order, return_dimensions=return_dimensions)
        pstarkey:             else:
        pstarkey:                 shots = runmanager.expand_globals(sequence_globals, evaled_globals, expansion_order)
        cbilling:         else:
        cbilling:             shots = []
        pstarkey:             dimensions = {}
        cbilling:         #logger.info('expanded sequence globals')
        pstarkey:         if return_dimensions:
        pstarkey:             return sequence_globals, shots, evaled_globals, global_hierarchy, expansions, dimensions
        pstarkey:         else:
        pstarkey:             return sequence_globals, shots, evaled_globals, global_hierarchy, expansions
        cbilling: 
        cbilling:     def guess_expansion_modes(self, active_groups, evaled_globals, global_hierarchy, expansions):
        cbilling:         """This function is designed to be called iteratively. It changes the
        cbilling:         expansion type of globals that reference other globals - such that
        cbilling:         globals referencing an iterable global will be zipped with it, rather
        cbilling:         than outer producted. Each time this method is called,
        cbilling:         self.parse_globals should also be called, so that the globals are
        cbilling:         evaluated with their new expansion modes, if they changed. This should
        cbilling:         be performed repeatedly until there are no more changes. Note that
        cbilling:         this method does not return what expansion types it thinks globals
        cbilling:         should have - it *actually writes them to the globals HDF5 file*. So
        cbilling:         it is up to later code to ensure it re-reads the expansion mode from
        cbilling:         the HDF5 file before proceeding. At present this method is only called
        cbilling:         from self.preparse_globals(), so see there to see how it fits in with
        cbilling:         everything else. This method uses four instance attributes to store
        cbilling:         state: self.previous_evaled_globals, self.previous_global_hierarchy,
        cbilling:         self.previous_expansion_types and self.previous_expansions. This is
        cbilling:         neccesary so that it can detect changes."""
        cbilling: 
        cbilling:         # Do nothing if there were exceptions:
        cbilling:         for group_name in evaled_globals:
        cbilling:             for global_name in evaled_globals[group_name]:
        cbilling:                 value = evaled_globals[group_name][global_name]
        cbilling:                 if isinstance(value, Exception):
        cbilling:                     # Let ExpansionErrors through through, as they occur
        cbilling:                     # when the user has changed the value without changing
        cbilling:                     # the expansion type:
        cbilling:                     if isinstance(value, runmanager.ExpansionError):
        cbilling:                         continue
        cbilling:                     return False
        cbilling:         # Did the guessed expansion type for any of the globals change?
        cbilling:         expansion_types_changed = False
        cbilling:         expansion_types = {}
        cbilling:         for group_name in evaled_globals:
        cbilling:             for global_name in evaled_globals[group_name]:
        cbilling:                 new_value = evaled_globals[group_name][global_name]
        cbilling:                 try:
        cbilling:                     previous_value = self.previous_evaled_globals[group_name][global_name]
        cbilling:                 except KeyError:
        pstarkey:                     # This variable is used to guess the expansion type
        pstarkey:                     # 
        pstarkey:                     # If we already have an expansion specified for this, but
        pstarkey:                     # don't have a previous value, then we should use the 
        pstarkey:                     # new_value for the guess as we are likely loading from HDF5
        pstarkey:                     # file for the first time (and either way, don't want to 
        pstarkey:                     # overwrite what the user has put in the expansion type)
        pstarkey:                     #
        pstarkey:                     # If we don't have an expansion...
        pstarkey:                     # then we set it to '0' which will result in an
        cbilling:                     # expansion type guess of '' (emptys string) This will
        cbilling:                     # either result in nothing being done to the expansion
        cbilling:                     # type or the expansion type being found to be 'outer',
        cbilling:                     # which will then make it go through the machinery below
        pstarkey:                     if global_name in expansions and expansions[global_name]:
        pstarkey:                         previous_value = new_value
        pstarkey:                     else:
        pstarkey:                         previous_value = 0
        cbilling: 
        cbilling:                 new_guess = runmanager.guess_expansion_type(new_value)
        cbilling:                 previous_guess = runmanager.guess_expansion_type(previous_value)
        cbilling: 
        cbilling:                 if new_guess == 'outer':
        cbilling:                     expansion_types[global_name] = {'previous_guess': previous_guess,
        cbilling:                                                     'new_guess': new_guess,
        cbilling:                                                     'group_name': group_name,
        cbilling:                                                     'value': new_value
        cbilling:                                                     }
        cbilling:                 elif new_guess != previous_guess:
        cbilling:                     filename = active_groups[group_name]
        cbilling:                     runmanager.set_expansion(filename, group_name, global_name, new_guess)
        cbilling:                     expansions[global_name] = new_guess
        cbilling:                     expansion_types_changed = True
        cbilling: 
        cbilling:         # recursively find dependencies and add them to a zip group!
        pstarkey:         def find_dependencies(global_name, global_hierarchy, expansion_types):
        cbilling:             results = set()
        cbilling:             for name, dependencies in global_hierarchy.items():
        pstarkey:                 if name in expansion_types and global_name in dependencies:
        cbilling:                     results.add(name)
        pstarkey:                     results = results.union(find_dependencies(name, global_hierarchy, expansion_types))
        cbilling:             return results
        cbilling: 
        cbilling:         def global_depends_on_global_with_outer_product(global_name, global_hierarchy, expansions):
        cbilling:             if global_name not in global_hierarchy:
        cbilling:                 return False
        cbilling:             else:
        cbilling:                 for dependency in global_hierarchy[global_name]:
        cbilling:                     if expansions[dependency]:
        cbilling:                         return True
        cbilling: 
        pstarkey:         def set_expansion_type_guess(expansion_types, expansions, global_name, expansion_to_set, new=True):
        pstarkey:             if new:
        pstarkey:                 key = 'new_guess'
        pstarkey:             else:
        pstarkey:                 key = 'previous_guess'
        pstarkey:                 
        pstarkey:             # debug logging
        pstarkey:             log_if_global(global_name, [], 'setting expansion type for new dependency' if new else 'setting expansion type for old dependencies')
        pstarkey:             
        pstarkey:             
        pstarkey:             # only do this if the expansion is *not* already set to a specific zip group
        pstarkey:             if global_name in expansions and expansions[global_name] != '' and expansions[global_name] != 'outer':
        pstarkey:                 expansion_types[global_name][key] = expansions[global_name]
        pstarkey:                 
        pstarkey:                 # debug logging
        pstarkey:                 log_if_global(global_name, [], 'Using existing expansion %s for %s'%(expansions[global_name], global_name))
        pstarkey:             else:
        pstarkey:                 expansion_types[global_name][key] = expansion_to_set
        pstarkey:                 expansions[global_name] = expansion_to_set
        pstarkey:                 
        pstarkey:                 # debug logging
        pstarkey:                 log_if_global(global_name, [], 'Using existing expansion %s for %s'%(expansion_to_set, global_name))
        pstarkey:             
        pstarkey:         
        cbilling:         for global_name in sorted(expansion_types):
        cbilling:             # we have a global that does not depend on anything that has an
        cbilling:             # expansion type of 'outer'
        cbilling:             if (not global_depends_on_global_with_outer_product(global_name, global_hierarchy, expansions)
        cbilling:                     and not isinstance(expansion_types[global_name]['value'], runmanager.ExpansionError)):
        pstarkey:                 current_dependencies = find_dependencies(global_name, global_hierarchy, expansion_types)
     janwerkmann: 
        cbilling:                 # if this global has other globals that use it, then add them
        cbilling:                 # all to a zip group with the name of this global
        cbilling:                 if current_dependencies:
        pstarkey:                     for dependency in current_dependencies:                        
        pstarkey:                         set_expansion_type_guess(expansion_types, expansions, dependency,  str(global_name))
        pstarkey:                             
        pstarkey:                     set_expansion_type_guess(expansion_types, expansions, global_name,  str(global_name))
        cbilling: 
        cbilling:         for global_name in sorted(self.previous_expansion_types):
        cbilling:             if (not global_depends_on_global_with_outer_product(
        cbilling:                 global_name, self.previous_global_hierarchy, self.previous_expansions)
        cbilling:                     and not isinstance(self.previous_expansion_types[global_name]['value'], runmanager.ExpansionError)):
        pstarkey:                 old_dependencies = find_dependencies(global_name, self.previous_global_hierarchy, self.previous_expansion_types)
        cbilling:                 # if this global has other globals that use it, then add them
        cbilling:                 # all to a zip group with the name of this global
        cbilling:                 if old_dependencies:
        cbilling:                     for dependency in old_dependencies:
        cbilling:                         if dependency in expansion_types:
        pstarkey:                             set_expansion_type_guess(expansion_types, self.previous_expansions, dependency, str(global_name), new=False)
        cbilling:                     if global_name in expansion_types:
        pstarkey:                         set_expansion_type_guess(expansion_types, self.previous_expansions, global_name, str(global_name), new=False)
        cbilling: 
        cbilling:         for global_name, guesses in expansion_types.items():
        cbilling:             if guesses['new_guess'] != guesses['previous_guess']:
        cbilling:                 filename = active_groups[guesses['group_name']]
        cbilling:                 runmanager.set_expansion(
        cbilling:                     filename, str(guesses['group_name']), str(global_name), str(guesses['new_guess']))
        cbilling:                 expansions[global_name] = guesses['new_guess']
        cbilling:                 expansion_types_changed = True
        cbilling: 
        cbilling:         # Now check everything that has an expansion type not equal to outer.
        cbilling:         # If it has one, but is not iteratble, remove it from teh zip group
        cbilling:         for group_name in evaled_globals:
        cbilling:             for global_name in evaled_globals[group_name]:
        cbilling:                 if expansions[global_name] and expansions[global_name] != 'outer':
        cbilling:                     try:
        cbilling:                         iter(evaled_globals[group_name][global_name])
        cbilling:                     except Exception:
        cbilling:                         filename = active_groups[group_name]
        cbilling:                         runmanager.set_expansion(filename, group_name, global_name, '')
        cbilling:                         expansion_types_changed = True
        cbilling: 
        cbilling:         self.previous_evaled_globals = evaled_globals
        cbilling:         self.previous_global_hierarchy = global_hierarchy
        cbilling:         self.previous_expansion_types = expansion_types
        cbilling:         self.previous_expansions = expansions
        cbilling: 
        cbilling:         return expansion_types_changed
        cbilling: 
        cbilling:     def make_h5_files(self, labscript_file, output_folder, sequence_globals, shots, shuffle):
        cbilling:         mkdir_p(output_folder)  # ensure it exists
        cbilling:         sequence_id = runmanager.generate_sequence_id(labscript_file)
        cbilling:         run_files = runmanager.make_run_files(output_folder, sequence_globals, shots, sequence_id, shuffle)
        cbilling:         logger.debug(run_files)
        cbilling:         return labscript_file, run_files
        cbilling: 
        cbilling:     def send_to_BLACS(self, run_file, BLACS_hostname):
        cbilling:         port = int(self.exp_config.get('ports', 'BLACS'))
        cbilling:         agnostic_path = shared_drive.path_to_agnostic(run_file)
        cbilling:         self.output_box.output('Submitting run file %s.\n' % os.path.basename(run_file))
        cbilling:         try:
        cbilling:             response = zprocess.zmq_get(port, BLACS_hostname, data=agnostic_path)
        cbilling:             if 'added successfully' in response:
        cbilling:                 self.output_box.output(response)
        cbilling:             else:
        cbilling:                 raise Exception(response)
        cbilling:         except Exception as e:
        cbilling:             self.output_box.output('Couldn\'t submit job to control server: %s\n' % str(e), red=True)
        cbilling:             self.compilation_aborted.set()
        cbilling: 
        cbilling:     def send_to_runviewer(self, run_file):
        cbilling:         runviewer_port = int(self.exp_config.get('ports', 'runviewer'))
        cbilling:         agnostic_path = shared_drive.path_to_agnostic(run_file)
        cbilling:         try:
        cbilling:             response = zprocess.zmq_get(runviewer_port, 'localhost', data='hello', timeout=1)
        cbilling:             if 'hello' not in response:
        cbilling:                 raise Exception(response)
        cbilling:         except Exception as e:
        cbilling:             logger.info('runviewer not running, attempting to start...')
        cbilling:             # Runviewer not running, start it:
        cbilling:             if os.name == 'nt':
        cbilling:                 creationflags = 0x00000008  # DETACHED_PROCESS from the win32 API
        cbilling:                 subprocess.Popen([sys.executable, '-m', 'runviewer'],
        cbilling:                                  creationflags=creationflags, stdout=None, stderr=None,
        cbilling:                                  close_fds=True)
        cbilling:             else:
        cbilling:                 devnull = open(os.devnull, 'w')
        cbilling:                 if not os.fork():
        cbilling:                     os.setsid()
        cbilling:                     subprocess.Popen([sys.executable, '-m', 'runviewer'],
        cbilling:                                      stdin=devnull, stdout=devnull, stderr=devnull, close_fds=True)
        cbilling:                     os._exit(0)
        cbilling:             try:
        cbilling:                 zprocess.zmq_get(runviewer_port, 'localhost', data='hello', timeout=15)
        cbilling:             except Exception as e:
        cbilling:                 self.output_box.output('Couldn\'t submit shot to runviewer: %s\n\n' % str(e), red=True)
        cbilling: 
        cbilling:         try:
        cbilling:             response = zprocess.zmq_get(runviewer_port, 'localhost', data=agnostic_path, timeout=0.5)
        cbilling:             if 'ok' not in response:
        cbilling:                 raise Exception(response)
        cbilling:             else:
        cbilling:                 self.output_box.output('Shot %s sent to runviewer.\n' % os.path.basename(run_file))
        cbilling:         except Exception as e:
        cbilling:             self.output_box.output('Couldn\'t submit shot to runviewer: %s\n\n' % str(e), red=True)
        cbilling: 
        cbilling: if __name__ == "__main__":
        cbilling:     logger = setup_logging('runmanager')
        cbilling:     labscript_utils.excepthook.set_logger(logger)
        cbilling:     logger.info('\n\n===============starting===============\n')
chrisjbillington:     qapplication = QtWidgets.QApplication(sys.argv)
        cbilling:     qapplication.setAttribute(QtCore.Qt.AA_DontShowIconsInMenus, False)
        cbilling:     app = RunManager()
        cbilling:     sys.exit(qapplication.exec_())
        pstarkey: #####################################################################
        pstarkey: #                                                                   #
        pstarkey: # /batch_compiler.py                                                #
        pstarkey: #                                                                   #
        pstarkey: # Copyright 2013, Monash University                                 #
        pstarkey: #                                                                   #
        pstarkey: # This file is part of the program runmanager, in the labscript     #
        pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
        pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
        pstarkey: # the project for the full license.                                 #
        pstarkey: #                                                                   #
        pstarkey: #####################################################################
     janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
        pstarkey: 
     janwerkmann: import os
        pstarkey: import sys
        pstarkey: import traceback
        cbilling: from zprocess import setup_connection_with_parent
        cbilling: to_parent, from_parent, kill_lock = setup_connection_with_parent(lock = True)
        pstarkey: 
        cbilling: import labscript
        pstarkey: import labscript_utils.excepthook
        pstarkey: from labscript_utils.modulewatcher import ModuleWatcher
        pstarkey: 
        pstarkey: class BatchProcessor(object):
        pstarkey:     def __init__(self, to_parent, from_parent, kill_lock):
        pstarkey:         self.to_parent = to_parent
        pstarkey:         self.from_parent = from_parent
        pstarkey:         self.kill_lock = kill_lock
        pstarkey:         self.mainloop()
        pstarkey:         
        pstarkey:     def mainloop(self):
        pstarkey:         while True:
        pstarkey:             signal, data =  self.from_parent.get()
        pstarkey:             if signal == 'compile':
        pstarkey:                 success = self.compile(*data)
        pstarkey:                 self.to_parent.put(['done',success])
        pstarkey:             elif signal == 'quit':
        pstarkey:                 sys.exit(0)
        pstarkey:             else:
        pstarkey:                 raise ValueError(signal)
        pstarkey:                     
        pstarkey:     def compile(self,labscript_file, run_file):
        pstarkey:         # The namespace the labscript will run in:
        pstarkey:         sandbox = {'__name__':'__main__'}
        pstarkey:         try:
chrisjbillington:             # Do not let the modulewatcher unload any modules whilst we're working:
chrisjbillington:             with kill_lock, module_watcher.lock:
        cbilling:                 labscript.labscript_init(run_file, labscript_file=labscript_file)
     janwerkmann:                 with open(labscript_file) as f:
     janwerkmann:                     code = compile(f.read(), os.path.basename(labscript_file),
     janwerkmann:                                    'exec', dont_inherit=True)
     janwerkmann:                     exec(code, sandbox)
        pstarkey:             return True
        pstarkey:         except:
        pstarkey:             traceback_lines = traceback.format_exception(*sys.exc_info())
        pstarkey:             del traceback_lines[1:2]
        pstarkey:             message = ''.join(traceback_lines)
        pstarkey:             sys.stderr.write(message)
        pstarkey:             return False
        pstarkey:         finally:
        pstarkey:             labscript.labscript_cleanup()
        pstarkey:                    
        pstarkey: if __name__ == '__main__':
        pstarkey:     module_watcher = ModuleWatcher() # Make sure modified modules are reloaded
        pstarkey:     batch_processor = BatchProcessor(to_parent,from_parent,kill_lock)
   pstarkey: #####################################################################
   pstarkey: #                                                                   #
   pstarkey: # /functions.py                                                     #
   pstarkey: #                                                                   #
   pstarkey: # Copyright 2013, Monash University                                 #
   pstarkey: #                                                                   #
   pstarkey: # This file is part of the program runmanager, in the labscript     #
   pstarkey: # suite (see http://labscriptsuite.org), and is licensed under the  #
   pstarkey: # Simplified BSD License. See the license.txt file in the root of   #
   pstarkey: # the project for the full license.                                 #
   pstarkey: #                                                                   #
   pstarkey: #####################################################################
   pstarkey: 
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
   cbilling: from pylab import *
   cbilling: 
   cbilling: ns = 1e-9
   cbilling: us = 1e-6
   cbilling: ms = 1e-3
   cbilling: s = 1
   cbilling: Hz = 1
   cbilling: kHz = 1e3
   cbilling: MHz = 1e6
   cbilling: GHz = 1e9
   cbilling: 
     rander: def quadspace(t_min, t_max, n_points, randomise=False, repeats=1):
     rander:     times = sqrt(linspace(t_min**2, t_max**2, n_points))
     rander:     times = repeat(times, repeats)
   shjohnst:     
   cbilling:     if randomise:
   shjohnst:         return times[argsort(rand(n_points*repeats))]
   cbilling:     else:
     rander:         return times
   cbilling:        
   cbilling: # For backward compatibility:
   cbilling: drop_times = quadspace
   cbilling: 
   cbilling: def first():
   cbilling:     """Infinite iterator. Its first return value is true, subsequent
   cbilling:     return values are False"""
   cbilling:     yield True
   cbilling:     while True:
   cbilling:         yield False
janwerkmann: from __future__ import division, unicode_literals, print_function, absolute_import
janwerkmann: 
     rander: import sys
     rander: from runmanager import globals_diff_shots
     rander: 
janwerkmann: df = globals_diff_shots(sys.argv[1], sys.argv[2])
