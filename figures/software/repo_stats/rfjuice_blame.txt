 vnegnev: # Compilation functions
 vnegnev: import util as u
 vnegnev: import const as c
 vnegnev: import numpy as np
 vnegnev: 
 vnegnev: regData = None
 vnegnev: timlp = None # timing loop counter
 vnegnev: 
 vnegnev: # Timing advance
 vnegnev: def advance_timing(f, trigstr, dt, out_loop_reg, loop_base="tim_loop"):
 vnegnev:     """Increment timer with whatever combo of commands are needed.
 vnegnev: 
 vnegnev:     f: file to write to
 vnegnev:     
 vnegnev:     trigstr: DIR string to write
 vnegnev:     
 vnegnev:     dt: desired timestep, in 13.33333333 ns units
 vnegnev:     
 vnegnev:     out_loop_reg: register to decrement in trigstr, if needed
 vnegnev:     
 vnegnev:     loop_base: base loop name to use if needed (defaults to
 vnegnev:     tim_loop). Program appends X, where X increments each time
 vnegnev:     advance_timing() is called)
 vnegnev:     """
 vnegnev:     
 vnegnev:     if dt > 65535: #limit of 16-bit timing
 vnegnev:         dt -= 65535
 vnegnev:         dt_loop = dt / c.max_stepT
 vnegnev:         dt_rem = dt % c.max_stepT
 vnegnev:         dt = 65535
 vnegnev:         f.write(u.instr(trigstr, dt, reg=out_loop_reg))
 vnegnev:         if dt_loop>0:
 vnegnev:             global timlp # use global loop-index variable
 vnegnev:             loop_name=loop_base + str(timlp)
 vnegnev:             # Write a loop to set the timer arbitrarily high
 vnegnev:             tim_loop_reg, regWritten = set_reg(f,dt_loop,0)
cbilling:             # the loop register value will be zero after the loop
cbilling:             # completes, so we'd better set it to zero in regData so that
cbilling:             # subsequent code doesn't use the register thinking it has
cbilling:             # a nonzero value. No loops can be nested within this one,
cbilling:             # so it is safe to set the register to zero, assuming nothing
cbilling:             # will touch it before the loop completes:
cbilling:             regData[tim_loop_reg,0] = 0
 vnegnev:             f.write(u.instr("addt", c.max_stepT, pre=loop_name+": "))
 vnegnev:             f.write(u.instr("addr", -1, reg=tim_loop_reg)) # decrement loop register
 vnegnev:             f.write(u.instr("jnz (( "+loop_name+" - "+loop_name+"_e) > 2)",reg=tim_loop_reg, pre=loop_name+"_e: "))
cbilling:             timlp += 1
 vnegnev:         f.write(u.instr("addt", dt_rem))
 vnegnev:     else:
 vnegnev:         f.write(u.instr(trigstr, dt, reg=out_loop_reg))
 vnegnev: 
 vnegnev: # Register tricks
 vnegnev: def set_reg(f, val, hold_for, throwaway=False):
 vnegnev:     """Set an available register to hold some relevant data (freq,
 vnegnev:     amp, looping) for a while.
 vnegnev: 
 vnegnev:     If a register already has the needed data, just refer to it and
 vnegnev:     increment its hold time.
 vnegnev: 
 vnegnev:     f: file to write to
 vnegnev:     val: value to write to the register
 vnegnev:     hold_for: number of segments to hold register for (looped segments get held for 1 segment only)
 vnegnev:     regData: numpy array of registers and their properties (passed by reference).
 vnegnev:     Fields: 0 = value, 1 = hold for
 vnegnev:     """
 vnegnev:     regNo = None
 vnegnev:     regFound = False
 vnegnev:     maxHold = np.zeros(2,dtype='i') # [reg number, hold length]
 vnegnev:     
 vnegnev:     for k, reg in enumerate(regData):
 vnegnev:         holdTm = reg[1] # hold time of current reg
 vnegnev:         if reg[0] == val: # data found
 vnegnev:             regFound = True
 vnegnev:             regNo = k
 vnegnev:             regData[k,2] = 1 # leave this register alone for this segment
 vnegnev:             if holdTm < hold_for: # increment hold time, if it'll be needed in future
 vnegnev:                 regData[k,1] = hold_for + 1
 vnegnev:             break # leave the loop
 vnegnev:         elif not reg[2]: # make sure reg isn't needed for *this* segment, otherwise ignore it
 vnegnev:             if reg[1] == 0: # ok to overwrite, zero hold time
 vnegnev:                 regNo = k
 vnegnev:                 if reg[0] == 0:
 vnegnev:                     #contains zero, so write straight away
 vnegnev: #                    regWriteToNonzeroNeeded = False
 vnegnev: #                    if not throwaway:
 vnegnev: #                        regData[k,2] = 1 # leave this register alone for this segment
 vnegnev:                     break
 vnegnev:                 #otherwise, keep looking, but remember that this register can be written to
 vnegnev:             elif holdTm > maxHold[1]: # keep track of how long it'll be needed for
 vnegnev:                 maxHold[0] = k
 vnegnev:                 maxHold[1] = holdTm
 vnegnev:                 
 vnegnev:     if regNo is None:
 vnegnev:         print "Error: no free registers. Somewhere, someone is screaming."
 vnegnev:         print "Current regData: ", regData
 vnegnev:         regNo = maxHold[0]
 vnegnev:         regData[regNo,0] = val
 vnegnev:         regData[regNo,1] = hold_for + 1
 vnegnev:         if not throwaway:
 vnegnev:             regData[regNo,2] = 1
 vnegnev:         print "Overwriting reg ",regNo
 vnegnev:         print "New regData: ", regData
 vnegnev:         f.write(u.instr("setr", val, regNo))
 vnegnev:     elif not regFound:
 vnegnev:         # standard write condition
 vnegnev:         regData[regNo,0] = val
 vnegnev:         regData[regNo,1] = hold_for + 1
 vnegnev:         if not throwaway:
 vnegnev:             regData[regNo,2] = 1
 vnegnev:         f.write(u.instr("setr", val, regNo))
 vnegnev: 
 vnegnev: #    print "Register contents",val," was found? ", regFound, " Using reg ",regNo
 vnegnev:     return regNo, not regFound # register number, and whether it was written
 vnegnev: 
  beclab: def decrement_regs():
 vnegnev:     """Decrement all the register wait times. Once they hit 0, the
 vnegnev:     register can be overwritten without harm.
 vnegnev: 
 vnegnev:     Should only be run at the end of a segment's compilation processing.
 vnegnev:     """
 vnegnev:     regData[:,1] -= np.array((regData[:,1] > 0),dtype="i")
 vnegnev:     regData[:,2] = 0
 vnegnev: 
 vnegnev: def sameDiffD(dList, segsToCheck=10):
 vnegnev:     """Identify future segments where either the freq or amp
  beclab:     parameter is the same as current segment.
  beclab: 
  beclab: 
  beclab:     dList: diff table to be analysed
  beclab: 
  beclab:     segsToCheck: number of segments to look ahead into
  beclab:     """
 vnegnev:     
 vnegnev:     if len(dList) < segsToCheck:
 vnegnev:         print "Error: cannot look ahead ",segsToCheck," values; only ",len(dList)," available!"
 vnegnev:         return np.zeros((len(dList),2),dtype='i')
 vnegnev: 
 vnegnev:     dAList = dList[:,1]
 vnegnev:     dFList = dList[:,2]
 vnegnev: 
 vnegnev:     fSum = np.cumsum(dFList,dtype='i')
 vnegnev:     fSmall = (-c.max_stepF <= dFList) & (dFList <= c.max_stepF)
 vnegnev:     dAFList = np.c_[dAList, dFList*fSmall + (fSum & c.FF_mask)* ~ fSmall]
 vnegnev:     #dAFList = np.c_[dAList,dFList]
 vnegnev:     
 vnegnev:     dAFListP=dAFList
 vnegnev:     futureSegs = np.zeros((len(dList),2),dtype='i')
 vnegnev:     
 vnegnev:     for k in range(1,segsToCheck+1):
 vnegnev:         dAFListP=np.r_[dAFListP[1:],[[0,0]]]
 vnegnev:         sameSegs = dAFList - dAFListP == 0
 vnegnev:         futureSegs *= ~sameSegs
 vnegnev:         futureSegs += sameSegs*k
 vnegnev: 
 vnegnev:     return futureSegs
 vnegnev: 
 vnegnev: def compileD(dList,f,
 vnegnev:              init = True,
 vnegnev:              set_defaults = True,
 vnegnev:              start_trig = True,
 vnegnev:              jump_to_start = True,
 vnegnev:              jump_from_end = True,
 vnegnev:              loop_to_start = 0,
 vnegnev:              loop_from_end = False,
 vnegnev:              avail_regs = 7, # use R0-R6, keep R7 free by default
 vnegnev:              close_end = False,
 vnegnev:              local_loop_pre = '',
 vnegnev:              jump_pre = 'jump',
 vnegnev:              loop_pre = 'lop'
 vnegnev:              ):
 vnegnev:     """Compile a list of differences into a pulse sequence.
 vnegnev:     Difference list follows same standard as the other functions that use it.
  beclab: 
  beclab:     dList: diff table to compile into instructions
  beclab: 
 vnegnev:     init: whether this sequence is the first (i.e. should it write the ASM header?)
 vnegnev: 
 vnegnev:     set_defaults: whether the DDSes are set to default values (i.e. 0
 vnegnev:     amplitude, freq and phase registers) before trigger
 vnegnev: 
  beclab:     start_trig : whether the pulse sequence should be triggered, or
  beclab:     just run as soon as the FSMs start
  beclab: 
 vnegnev:     jump_to_start: whether a later compileD() call will unconditionally jump back to
 vnegnev:     this call or not, if part of a multiple-trigger sequence. If a
 vnegnev:     single-trigger sequence, then should be left True.
 vnegnev: 
 vnegnev:     jump_from_end: whether this compileD() call will unconditionally jump back, or
 vnegnev:     just finish and allow the sequence to proceed.
 vnegnev: 
 vnegnev:     loop_to_start: specify one more than the number of times a later
 vnegnev:     compileD() call will loop back to this call, if part of a
 vnegnev:     multiple-trigger sequence. Eg, to run through a given string of
 vnegnev:     compileD() calls 5 times, you would call the first using
 vnegnev:     loop_to_start = 5, and the last using loop_from_end. Initially
 vnegnev:     will set R7 to the value of loop_to_start, so avail_regs should be
 vnegnev:     at most 7. If a single-trigger sequence, loop_to_start should
 vnegnev:     equal 0.
  beclab: 
 vnegnev:     loop_from_end: whether this compileD() call will conditionally
 vnegnev:     loop back. If it's true, the assembly will decrement R7 at the
 vnegnev:     end, and jump back if it's 0.
 vnegnev: 
 vnegnev:     close_end: include a FIN command at the end. If any unconditional
 vnegnev:     jump commands are used in the assembly, this is irrelevant because
 vnegnev:     the code will never finish.
 vnegnev: 
 vnegnev:     local_loop_pre: prefix for all local loop names
 vnegnev: 
 vnegnev:     jump_pre: prefix for sequence-wide jumps
 vnegnev: 
 vnegnev:     loop_pre: prefix for sequence-wide loops
 vnegnev:     """
 vnegnev: 
 vnegnev:     dListD = sameDiffD(dList,10)
 vnegnev: 
 vnegnev:     ## Initialisation and preparation for trigger
 vnegnev:     if init:
 vnegnev:         f.write(u.init_asm())
 vnegnev: 
 vnegnev:     ## Initial jump point
 vnegnev:     if jump_to_start:
 vnegnev:         f.write("    ;;; Jumpback\n"+jump_pre+":         nop\n")
 vnegnev:         
 vnegnev:     if loop_to_start:
 vnegnev:         f.write("    ;;; Initialise loop reg\n")
 vnegnev:         f.write(u.instr("setr",loop_to_start,7))
 vnegnev:         f.write("    ;;; Loopback\n"+loop_pre+":         nop\n")
  beclab: 
 vnegnev:     # Clear phase (only written if there's a DDSUPD in 'set default
 vnegnev:     # startup values' section below)
 vnegnev:     if set_defaults:
 vnegnev:         f.write("""    ;;; Clear phase and reset timer
 vnegnev:                  setr 0x4108 R0
 vnegnev:                  setcfr 0x00 0x00 0x0e R0
 vnegnev:                  dir (WRDDS|RSTT|TMRADD) 300 0 ; extra delay for register setting
 vnegnev:     """)
 vnegnev: 
 vnegnev:         # Set default startup values
 vnegnev:         f.write("  ;; Set default pre-trigger values\n")
 vnegnev:         f.write(u.instr("seta",0)) # Amp = 0
 vnegnev:         f.write(u.instr("setf",0)) # Freq = 0
 vnegnev:     #    f.write(u.instr("setf",int(c.defaultf*c.fF + 0.5) >> c.FF_shift)) # Freq = 80 MHz default
 vnegnev:     #    f.write(u.instr("addf",int(c.defaultf*c.fF + 0.5) & c.FF_mask)) # Freq = 80 MHz default
 vnegnev:         f.write(u.instr("setp",0)) # Phase = 0
 vnegnev:         f.write(u.instr("dir (WT_TIM|TMRADD|WRDDS|DDSUPD)",c.stepT,0))
 vnegnev:     else: # !set_defaults
 vnegnev:         f.write("""    ;;; Reset timer
 vnegnev:                  dir (RSTT|TMRADD) 300 0
 vnegnev:     """)
 vnegnev: 
 vnegnev:     # Unclear phase
 vnegnev:     f.write("""
 vnegnev:     ;;; Unclear phase
 vnegnev:                  setr 0x4100 R0
 vnegnev:                  setcfr 0x00 0x00 0x0e R0
  beclab:                  dir (WRDDS|WT_TIM|TMRADD|DDSUPD) 150 0
 vnegnev: """)
 vnegnev: 
 vnegnev:     f.write("  ;; Set starting values\n")
 vnegnev:     amp = dList[0,1]
 vnegnev:     freq = dList[0,2]
 vnegnev:     ph = dList[0,3]
 vnegnev:     
 vnegnev:     f.write(u.instr("seta",amp))
 vnegnev:     f.write(u.instr("setf",freq >> c.FF_shift)) # Coarse freq
 vnegnev:     f.write(u.instr("addf",freq & c.FF_mask)) # Fine freq
 vnegnev:     if ph != 0:
 vnegnev:         f.write(u.instr("setp",ph))
 vnegnev: 
 vnegnev:     f.write("  ;; Clear registers\n")
 vnegnev:     for k in range(avail_regs):
 vnegnev:         f.write(u.instr("setr",0,k))
 vnegnev:     
 vnegnev:     f.write("  ;; Set deterministic delays\n")
 vnegnev:     if start_trig:
 vnegnev:         trigstr = "dir (WT_TIM|DDSUPD|WT_TRIG|TMRADD|RSTT)"
 vnegnev:     else:
 vnegnev:         trigstr = "dir (WT_TIM|DDSUPD|TMRADD|RSTT)"
 vnegnev:     startDelay = dList[0,0]
 vnegnev:     if startDelay > 65535: #limit of 16-bit timing
 vnegnev:         startDelay_s = startDelay-65535
 vnegnev:         tim_loops = startDelay_s / c.max_stepT
 vnegnev:         tim_rem = startDelay_s % c.max_stepT
 vnegnev:         
 vnegnev:         f.write(u.instr(trigstr, 65535, c.no_reg))
 vnegnev: 
 vnegnev:         if tim_loops:
 vnegnev:             # Write a loop to set the timer arbitrarily high
 vnegnev:             f.write(u.instr("setr", tim_loops, reg=0))
 vnegnev:             f.write(u.instr("addt", c.max_stepT, pre="tim_loop_"+local_loop_pre+": "))
 vnegnev:             f.write(u.instr("addr", -1, reg=0)) # decrement loop register
 vnegnev:             f.write(u.instr("jnz (( tim_loop - tim_loop_e) > 2)",reg=0, pre="tim_loop_e_"+local_loop_pre+": "))
 vnegnev:         f.write(u.instr("addt", tim_rem - c.externT))
 vnegnev:     else:
 vnegnev:         f.write(u.instr(trigstr, startDelay-c.externT, c.no_reg))
 vnegnev:         f.write(u.instr("dir WRDDS",0,c.no_reg))
 vnegnev: 
 vnegnev:     k = 1 # diff list index
 vnegnev:     kmax = len(dList)
 vnegnev:     m = 0 # loop index
 vnegnev:     global timlp # timing loop index (used for advance_timing() calls)
 vnegnev:     timlp = 0
 vnegnev:     dt = 0
 vnegnev:     damp = 0
 vnegnev:     dfreq = 0
 vnegnev:     dph = 0
 vnegnev:     global regData
 vnegnev:     regData = np.zeros((avail_regs,3),dtype='i')
 vnegnev:     loop_base="loop"+local_loop_pre+"_"
 vnegnev:     tim_lp_base = "tim_"+loop_base
 vnegnev: 
 vnegnev:     while k<kmax:
 vnegnev:         dt = dList[k,0]
 vnegnev:         damp = dList[k,1]
 vnegnev:         dfreq = dList[k,2]
 vnegnev:         dph = dList[k,3]
 vnegnev:         fBig = not -c.max_stepF <= dfreq < c.max_stepF # is frequency step larger than 23 bits?
 vnegnev:         loop = dList[k,4]
 vnegnev:         freg = None
 vnegnev:         areg = None
 vnegnev:         sameA = dListD[k,0] # number of segments ahead where this value is needed
 vnegnev:         sameF = dListD[k,1]
 vnegnev: 
 vnegnev: #       print " FREQ STEP: ",dfreq," IS BIG: ",fBig
 vnegnev:         
 vnegnev:         if not fBig:
 vnegnev:             freq += dfreq*(loop+1) # keep tally of absolute freqs, in case they're needed
 vnegnev:             # f.write("  ; F step within register size\n")
 vnegnev:             # can do optimisations
 vnegnev:             if loop:
 vnegnev:                 # f.write("  ; Loop "+str(m)+"\n")
 vnegnev:                 loop_reg, regWritten = set_reg(f,loop+1,0);
 vnegnev: #                if regWritten: n += 1
 vnegnev: #                if regWritten:
 vnegnev:                     # f.write("  ; ^^ Saved it to R"+str(loop_reg)+"\n")
 vnegnev: #                else:
 vnegnev:                     # f.write("  ; Found it in R"+str(loop_reg)+"\n")
 vnegnev:                     # f.write("  ; Hold time in R"+str(loop_reg)+" is "+str(regData[loop_reg,1])+"\n")
 vnegnev:                 loop_name=loop_base+str(m)
 vnegnev:                 m += 1
 vnegnev:             if sameF:
 vnegnev:                 # f.write("  ; Future freq "+str(dfreq)+" used "+str(sameF)+" steps in future\n")
 vnegnev:                 freg,regWritten = set_reg(f,dfreq,sameF)
 vnegnev: #                if regWritten: n += 1
 vnegnev: #                if regWritten:
 vnegnev:                     # f.write("  ; ^^ Saved it to R"+str(freg)+"\n")
 vnegnev: #                else:
 vnegnev:                     # f.write("  ; Found it in R"+str(freg)+"\n")
 vnegnev:                     # f.write("  ; Hold time in R"+str(freg)+" is "+str(regData[freg,1])+"\n")
 vnegnev:             elif sameA:
 vnegnev:                 # f.write("  ; Future amp "+str(damp)+" used "+str(sameA)+" steps in future\n")
 vnegnev:                 areg, regWritten = set_reg(f,damp,sameA)
 vnegnev: #                if regWritten: n += 1
 vnegnev: #                if regWritten:
 vnegnev:                     # f.write("  ; ^^ Saved it to R"+str(areg)+"\n")
 vnegnev: #                else:
 vnegnev:                     # f.write("  ; Found it in R"+str(areg)+"\n")
 vnegnev:                     # f.write("  ; Hold time in R"+str(areg)+" is "+str(regData[areg,1])+"\n")
 vnegnev:             else:
 vnegnev:                 # f.write("  ; Freq "+str(dfreq)+" not found in future.\n")
 vnegnev:                 freg,regWritten = set_reg(f,dfreq,0)
 vnegnev: #                if regWritten: n += 1
 vnegnev: #                if regWritten:
 vnegnev:                     # f.write("  ; ^^ Saved it to  R"+str(freg)+"\n")
 vnegnev: #                else:
 vnegnev:                     # f.write("  ; Found it in R"+str(freg)+"\n")
 vnegnev:                     # f.write("  ; Hold time in R"+str(freg)+" is "+str(regData[freg,1])+"\n")
 vnegnev:                     
 vnegnev:             if loop:
 vnegnev:                 if freg is not None:
 vnegnev:                     f.write(u.instr("addfr",damp,freg,pre=loop_name + ":"))
 vnegnev: #                    n += 1
 vnegnev:                 else:
 vnegnev:                     f.write(u.instr("addar",dfreq,areg,pre=loop_name+ ":"))
 vnegnev: #                    n += 1
 vnegnev: #                    checkn(k,n); n = 0
 vnegnev:                 
 vnegnev:                 # Increment phase
 vnegnev:                 if dph:
 vnegnev:                     f.write(u.instr("addp",dph))
 vnegnev:                 # Advance timing and do other things
 vnegnev:                 advance_timing(f, "dir (WT_TIM|DDSUPD|WRDDS|TMRADD|REGDEC)", dt, loop_reg, tim_lp_base)
 vnegnev: #                f.write(u.instr("dir (WT_TIM|DDSUPD|WRDDS|TMRADD|REGDEC)",dt,loop_reg)) # dt truncated to 16 bits
 vnegnev:                 f.write(u.instr("jnz ((" + loop_name + " -" + loop_name + "_e) > 2)",
 vnegnev:                           reg = loop_reg, pre = loop_name + "_e:"))
 vnegnev: #                n += 1
 vnegnev:                 # Clear relevant loop reg (since its contents would be
 vnegnev:                 # cleared by the decrements)
 vnegnev:                 regData[loop_reg,0] = 0
 vnegnev:             else: 
 vnegnev:                 if freg is not None:
 vnegnev:                     f.write(u.instr("addfr",damp,freg))
 vnegnev: #                    n += 1
 vnegnev:                 else:
 vnegnev:                     f.write(u.instr("addar",dfreq,areg))
 vnegnev: #                    n += 1
 vnegnev: #                checkn(k,n); n = 0
 vnegnev:                 # Increment phase
 vnegnev:                 if dph:
 vnegnev:                     f.write(u.instr("addp",dph))
 vnegnev:                 # Advance timing and do other things
 vnegnev:                 advance_timing(f, "dir (WT_TIM|DDSUPD|WRDDS|TMRADD)", dt, c.no_reg, tim_lp_base)
 vnegnev: #                f.write(u.instr("dir (WT_TIM|DDSUPD|WRDDS|TMRADD)",dt,c.no_reg))
 vnegnev:         else:
 vnegnev: #            print "Freq is big: ",freq
 vnegnev:             # Error; slope is too high; must unroll loop
 vnegnev:             if loop:
 vnegnev:                 print "Warning: loop slope too high for addf. Unrolling loop..."
 vnegnev:                 f.write("  ;; Unrolling a loop whose freq slope is too high for registers to hold\n")
 vnegnev:             else:
 vnegnev:                 f.write("  ;; Big frequency step\n")
 vnegnev:             for p in range(loop+1):
 vnegnev:                 freq += dfreq # keep tally of absolute freqs updated
 vnegnev:                 f.write("  ; loop = "+str(p)+"\n")
 vnegnev:                 if sameA:
 vnegnev:                     areg, regWritten = set_reg(f,damp,sameA)
 vnegnev: #                    if regWritten: n += 1
 vnegnev: #                    print "SameA; wrote ",areg," with ",damp
 vnegnev:                 else:
 vnegnev:                     freg, regWritten = set_reg(f,freq & c.FF_mask, 0,throwaway=True)
 vnegnev: #                    if regWritten: n += 1
 vnegnev:                 f.write(u.instr("setf",freq >> c.FF_shift))
 vnegnev: #                n += 1
 vnegnev:                 if sameA:
 vnegnev:                     f.write(u.instr("addar",freq & c.FF_mask, areg))
 vnegnev: #                    n += 1
 vnegnev:                 else:
 vnegnev:                     f.write(u.instr("addfr",damp,freg))
 vnegnev: #                    n += 1
 vnegnev: #                checkn(k,n); n = 0
 vnegnev: 
 vnegnev:                 # Increment phase
 vnegnev:                 if dph:
 vnegnev:                     f.write(u.instr("addp",dph))
 vnegnev:                 # Advance timing
 vnegnev:                 advance_timing(f, "dir (WT_TIM|DDSUPD|WRDDS|TMRADD)", dt, c.no_reg, tim_lp_base)
 vnegnev: #                f.write(u.instr("dir (WT_TIM|DDSUPD|WRDDS|TMRADD)",dt,c.no_reg))
 vnegnev: 
 vnegnev:                 
 vnegnev: #        print "regData: ",regData
  beclab:         decrement_regs()
 vnegnev:         k += 1
 vnegnev:         
 vnegnev: #        print "k: ",k
 vnegnev: #        print "regData: ",regData
 vnegnev: #        f.write(u.instr("; k = ",k))
 vnegnev: #        print "------------------------------------------- k = ",k
 vnegnev: 
 vnegnev: 
 vnegnev:     
 vnegnev:     # End sequence
 vnegnev:     if close_end:
 vnegnev:         f.write(u.instr("dir (WT_TIM|DDSUPD|FIN)",0,c.no_reg))
 vnegnev:     else:
  beclab:         f.write(u.instr("dir (WT_TIM|DDSUPD|RSTT)",0,c.no_reg))
 vnegnev: 
 vnegnev:     # Loop-back sequence        
 vnegnev:     if loop_from_end:
 vnegnev:         f.write(u.instr("addr",-1,7))
 vnegnev:         f.write(u.instr("jnz (("+loop_pre+"-"+loop_pre+"_END)>2)",reg=7,pre=loop_pre+"_END: "))
 vnegnev: 
 vnegnev:     # Jump-back sequence
 vnegnev:     if jump_from_end:
 vnegnev:         f.write(u.instr("jump ((" + jump_pre + " - " + jump_pre + "_END)>2)",pre=jump_pre+"_END: "))
 vnegnev: 
 vnegnev: # def checkn(k,n):
 vnegnev: #     if n > max_instr_per_segment:
 vnegnev: #         print "WARNING: ",n," instructions in segment",k, ", which is over ",max_instr_per_segment,". If this warning appears more than once per pulse in your sequence, please do a few trial runs of your desired sequence before using in experiment! Alternatively, try reducing your frequency sweep rate, or disable loops. If in doubt, it's probably fine - but better safe than sorry."
 vnegnev: #         n = 0
 vnegnev: 
 vnegnev: # Function to compile a list of diff tables
 vnegnev: #def compileDseq(
vnegnev: ### CONST.PY
vnegnev: # (c) Vlad Negnevitsky, 2011
vnegnev: #
vnegnev: # All times are expressed in us, frequencies in MHz, amplitudes as [0,1).
vnegnev: 
vnegnev: stept = 2.00 #us
vnegnev: rest = 0.04/3 # 13.3333us, timer resolution (1 tick = this)
vnegnev: tT = 1/rest
vnegnev: stepT = int(stept*tT)
vnegnev: msus = 1000 # ms to us
vnegnev: 
vnegnev: # Tunable parameters
vnegnev: # These must be tuned for each system, since precise timing depends on
vnegnev: # accurate values.
vnegnev: 
 beclab: externT = 16 # total delay due to external trigger - empirically determined (externT * 13.3333 ns)
vnegnev: #ddsupdT = 0 #delay due to DDS update within DDS
vnegnev: max_stepT = 2**24-1 # maximum timer increment
vnegnev: 
vnegnev: bitsF = 32 # bits in freq register
vnegnev: fF = (2 ** bitsF) / 1000. # conversion factor: freq bits per MHz
vnegnev: defaultf = 80 # Default frequency: 80 MHz
vnegnev: 
vnegnev: FF_shift = 8  # bitshift conversion factor between setf and addf
vnegnev: FF_mask = 2**FF_shift - 1 # mask to apply to freq
vnegnev: max_stepF = 2**23-1 # maximum frequency step that addf can do, + 1 (not
vnegnev:                   # 2**24 because 24-bit signed)
vnegnev: 
vnegnev: max_instr_per_segment = 4 # If more instructions than this are run
vnegnev:                           # between IOUPDATEs, there is a risk of
vnegnev:                           # memory contention.
vnegnev: 
vnegnev: bitsA = 14 # bits in amp register
vnegnev: aA = (2 ** bitsA) / 1. # conversion factor: amp bits per 100%
vnegnev: 
vnegnev: bitsP = 16 # bits in phase register
vnegnev: maxP = 2**bitsP
vnegnev: pP = maxP / 360.
vnegnev: 
vnegnev: # lowercase suffix denotes us/MHz/fractions of 1
vnegnev: # uppercase denotes quantised integer equivs
vnegnev: # eg centf = MHz; centF = quantised integer equiv
vnegnev: 
vnegnev: # Niceties for compilation
vnegnev: 
vnegnev: indent = "\t\t"
vnegnev: regdict = {0:"R0",1:"R1",2:"R2",3:"R3",4:"R4",5:"R5",6:"R6",7:"R7",8:"0"}
vnegnev: no_reg = 8
vnegnev: f_inc_reg = 0
vnegnev: a_inc_reg = 1
chrisjbillington: from __future__ import print_function, unicode_literals, division, absolute_import
chrisjbillington: from labscript_utils import PY2, check_version
chrisjbillington: if PY2:
chrisjbillington:     str = unicode
chrisjbillington: import os
        cbilling: 
chrisjbillington: try:
chrisjbillington:     import autocython
chrisjbillington: except ImportError:
chrisjbillington:     msg = ('autocython required, installable via pip')
chrisjbillington:     raise RuntimeError(msg)
chrisjbillington: 
chrisjbillington: check_version('autocython', '1.1.1', '2.0')
chrisjbillington: from autocython import ensure_extensions_compiled, import_extension
chrisjbillington: 
chrisjbillington: ensure_extensions_compiled(os.path.abspath(os.path.dirname(__file__)))
chrisjbillington: make_diff_table = import_extension('rfblaster.rfjuice.cython.make_diff_table')
chrisjbillington: compile = import_extension('rfblaster.rfjuice.cython.compile')
cbilling: # (c) Vlad Negnevitsky, 2011
cbilling: # ported to Cython by Chris Billington
cbilling: 
cbilling: cimport cython
cbilling: import numpy as np
cbilling: cimport numpy as np
cbilling: 
cbilling: cdef int max_stepT, max_stepF, FF_mask, stepT, FF_shift, no_reg, externT
cbilling: from rfblaster.rfjuice.const import max_stepT, max_stepF, FF_mask, stepT, FF_shift, no_reg, externT
cbilling: from rfblaster.rfjuice.const import indent, regdict
cbilling: import rfblaster.rfjuice.util as util
cbilling: 
cbilling: cdef int timlp # timing loop counter
cbilling: 
cbilling: cdef int g_avail_regs # avail_regs argument to compileD, made a global
cbilling: 
cbilling: @cython.nonecheck(False)
cbilling: @cython.wraparound(False)
cbilling: @cython.boundscheck(False)
cbilling: cdef inline str instr(str opcode, par, reg, pre):
cbilling:     """Produce a standard instruction, with optional numeric parameters.
cbilling:     
cbilling:     str: instruction body
cbilling:     para: parameter, when instructions require one
cbilling:     reg: register, when instructions require one
cbilling:     pre: can replace default with, say, 'LOOP1: ' etc.
cbilling:     """
cbilling:     if pre is None:
cbilling:         pre = indent
cbilling:     cdef str wrstr = pre + ' ' +opcode
cbilling:     if par is not None:
cbilling:         if par < 0:
cbilling:             wrstr += ' (0' + str(par) + ')'
cbilling:         else:
cbilling:             wrstr += ' ' + str(par)
cbilling:     if reg is not None and not reg < 0:
cbilling:         wrstr += ' ' + regdict[reg]
cbilling:     wrstr += "\n"
cbilling:     return wrstr    
cbilling:     
cbilling: # Timing advance
cbilling: @cython.nonecheck(False)
cbilling: @cython.wraparound(False)
cbilling: @cython.boundscheck(False)
cbilling: cdef inline advance_timing(f, str trigstr, int dt, int out_loop_reg, 
cbilling:                            str loop_base, np.ndarray[int,ndim=2] regData):
cbilling:     """Increment timer with whatever combo of commands are needed.
cbilling: 
cbilling:     f: file to write to
cbilling:     
cbilling:     trigstr: DIR string to write
cbilling:     
cbilling:     dt: desired timestep, in 13.33333333 ns units
cbilling:     
cbilling:     out_loop_reg: register to decrement in trigstr, if needed
cbilling:     
cbilling:     loop_base: base loop name to use if needed (defaults to
cbilling:     tim_loop). Program appends X, where X increments each time
cbilling:     advance_timing() is called)
cbilling:     """
cbilling:     cdef int dt_loop
cbilling:     cdef int dt_rem
cbilling:     
cbilling:     if dt > 65535: #limit of 16-bit timing
cbilling:         dt -= 65535
cbilling:         dt_loop = dt / max_stepT
cbilling:         dt_rem = dt % max_stepT
cbilling:         dt = 65535
cbilling:         f.write(instr(trigstr, dt, out_loop_reg, None))
cbilling:         if dt_loop>0:
cbilling:             global timlp # use global loop-index variable
cbilling:             loop_name=loop_base + str(timlp)
cbilling:             # Write a loop to set the timer arbitrarily high
cbilling:             tim_loop_reg, regWritten = set_reg(f,dt_loop,0, regData, 0)
cbilling:             # the loop register value will be zero after the loop
cbilling:             # completes, so we'd better set it to zero in regData so that
cbilling:             # subsequent code doesn't use the register thinking it has
cbilling:             # a nonzero value. No loops can be nested within this one,
cbilling:             # so it is safe to set the register to zero, assuming nothing
cbilling:             # will touch it before the loop completes:
cbilling:             regData[tim_loop_reg,0] = 0
cbilling:             f.write(instr("addt", max_stepT, None, loop_name+": "))
cbilling:             f.write(instr("addr", -1, tim_loop_reg, None)) # decrement loop register
cbilling:             f.write(instr("jnz (( "+loop_name+" - "+loop_name+"_e) > 2)", None, tim_loop_reg, loop_name+"_e: "))
cbilling:             timlp += 1
cbilling:         f.write(instr("addt", dt_rem, None, None))
cbilling:     else:
cbilling:         f.write(instr(trigstr, dt, out_loop_reg, None))
cbilling:     
cbilling: # Register tricks
cbilling: @cython.nonecheck(False)
cbilling: @cython.wraparound(False)
cbilling: @cython.boundscheck(False)
cbilling: cdef inline set_reg(f, int val, int hold_for, np.ndarray[int,ndim=2] regData, int throwaway):
cbilling:     """Set an available register to hold some relevant data (freq,
cbilling:     amp, looping) for a while.
cbilling: 
cbilling:     If a register already has the needed data, just refer to it and
cbilling:     increment its hold time.
cbilling: 
cbilling:     f: file to write to
cbilling:     val: value to write to the register
cbilling:     hold_for: number of segments to hold register for (looped segments get held for 1 segment only)
cbilling:     regData: numpy array of registers and their properties (passed by reference).
cbilling:     Fields: 0 = value, 1 = hold for
cbilling:     """
cbilling:     cdef int regNo = -1
cbilling:     cdef int regFound = False
cbilling:     cdef int maxHold_regno = 0
cbilling:     cdef int maxHold_holdlength = 0
cbilling:     cdef int holdTm
cbilling:     
cbilling:     for k in range(g_avail_regs):
cbilling:         holdTm = regData[k,1] # hold time of current reg
cbilling:         if regData[k,0] == val: # data found
cbilling:             regFound = True
cbilling:             regNo = k
cbilling:             regData[k,2] = 1 # leave this register alone for this segment
cbilling:             if holdTm < hold_for: # increment hold time, if it'll be needed in future
cbilling:                 regData[k,1] = hold_for + 1
cbilling:             break # leave the loop
cbilling:         elif not regData[k,2]: # make sure reg isn't needed for *this* segment, otherwise ignore it
cbilling:             if regData[k,1] == 0: # ok to overwrite, zero hold time
cbilling:                 regNo = k
cbilling:                 if regData[k,0] == 0:
cbilling:                     #contains zero, so write straight away
cbilling: #                    regWriteToNonzeroNeeded = False
cbilling: #                    if not throwaway:
cbilling: #                        regData[k,2] = 1 # leave this register alone for this segment
cbilling:                     break
cbilling:                 #otherwise, keep looking, but remember that this register can be written to
cbilling:             elif holdTm > maxHold_holdlength: # keep track of how long it'll be needed for
cbilling:                 maxHold_regno = k
cbilling:                 maxHold_holdlength = holdTm
cbilling:                 
cbilling:     if regNo < 0:
cbilling:         print "Error: no free registers. Somewhere, someone is screaming."
cbilling:         print "Current regData: ", regData
cbilling:         regNo = maxHold_regno
cbilling:         regData[regNo,0] = val
cbilling:         regData[regNo,1] = hold_for + 1
cbilling:         if not throwaway:
cbilling:             regData[regNo,2] = 1
cbilling:         print "Overwriting reg ",regNo
cbilling:         print "New regData: ", regData
cbilling:         f.write(instr("setr", val, regNo, None))
cbilling:     elif not regFound:
cbilling:         # standard write condition
cbilling:         regData[regNo,0] = val
cbilling:         regData[regNo,1] = hold_for + 1
cbilling:         if not throwaway:
cbilling:             regData[regNo,2] = 1
cbilling:         f.write(instr("setr", val, regNo, None))
cbilling: 
cbilling: #    print "Register contents",val," was found? ", regFound, " Using reg ",regNo
cbilling:     return regNo, not regFound # register number, and whether it was written
cbilling: 
cbilling: cdef inline sameDiffD(dList, int segsToCheck=10):
cbilling:     """Identify future segments where either the freq or amp
cbilling:     parameter is the same as current segment.
cbilling: 
cbilling: 
cbilling:     dList: diff table to be analysed
cbilling: 
cbilling:     segsToCheck: number of segments to look ahead into
cbilling:     """
cbilling:     
cbilling:     if len(dList) < segsToCheck:
cbilling:         print "Error: cannot look ahead ",segsToCheck," values; only ",len(dList)," available!"
cbilling:         return np.zeros((len(dList),2),dtype='i')
cbilling: 
cbilling:     dAList = dList[:,1]
cbilling:     dFList = dList[:,2]
cbilling: 
cbilling:     fSum = np.cumsum(dFList,dtype='i')
cbilling:     fSmall = (-max_stepF <= dFList) & (dFList <= max_stepF)
cbilling:     dAFList = np.c_[dAList, dFList*fSmall + (fSum & FF_mask)* ~ fSmall]
cbilling:     #dAFList = np.c_[dAList,dFList]
cbilling:     
cbilling:     dAFListP=dAFList
cbilling:     futureSegs = np.zeros((len(dList),2),dtype='i')
cbilling:     
cbilling:     for k in range(1,segsToCheck+1):
cbilling:         dAFListP=np.r_[dAFListP[1:],[[0,0]]]
cbilling:         sameSegs = dAFList - dAFListP == 0
cbilling:         futureSegs *= ~sameSegs
cbilling:         futureSegs += sameSegs*k
cbilling: 
cbilling:     return futureSegs
cbilling:     
cbilling: @cython.nonecheck(False)
cbilling: @cython.wraparound(False)
cbilling: @cython.boundscheck(False)
cbilling: def compileD(np.ndarray[int, ndim=2] dList,f,
cbilling:              init = True,
cbilling:              set_defaults = True,
cbilling:              start_trig = True,
cbilling:              jump_to_start = True,
cbilling:              jump_from_end = True,
cbilling:              loop_to_start = 0,
cbilling:              loop_from_end = False,
cbilling:              int avail_regs = 7, # use R0-R6, keep R7 free by default
cbilling:              close_end = False,
cbilling:              local_loop_pre = '',
cbilling:              jump_pre = 'jump',
cbilling:              loop_pre = 'lop'
cbilling:              ):
cbilling:     """Compile a list of differences into a pulse sequence.
cbilling:     Difference list follows same standard as the other functions that use it.
cbilling: 
cbilling:     dList: diff table to compile into instructions
cbilling: 
cbilling:     init: whether this sequence is the first (i.e. should it write the ASM header?)
cbilling: 
cbilling:     set_defaults: whether the DDSes are set to default values (i.e. 0
cbilling:     amplitude, freq and phase registers) before trigger
cbilling: 
cbilling:     start_trig : whether the pulse sequence should be triggered, or
cbilling:     just run as soon as the FSMs start
cbilling: 
cbilling:     jump_to_start: whether a later compileD() call will unconditionally jump back to
cbilling:     this call or not, if part of a multiple-trigger sequence. If a
cbilling:     single-trigger sequence, then should be left True.
cbilling: 
cbilling:     jump_from_end: whether this compileD() call will unconditionally jump back, or
cbilling:     just finish and allow the sequence to proceed.
cbilling: 
cbilling:     loop_to_start: specify one more than the number of times a later
cbilling:     compileD() call will loop back to this call, if part of a
cbilling:     multiple-trigger sequence. Eg, to run through a given string of
cbilling:     compileD() calls 5 times, you would call the first using
cbilling:     loop_to_start = 5, and the last using loop_from_end. Initially
cbilling:     will set R7 to the value of loop_to_start, so avail_regs should be
cbilling:     at most 7. If a single-trigger sequence, loop_to_start should
cbilling:     equal 0.
cbilling: 
cbilling:     loop_from_end: whether this compileD() call will conditionally
cbilling:     loop back. If it's true, the assembly will decrement R7 at the
cbilling:     end, and jump back if it's 0.
cbilling: 
cbilling:     close_end: include a FIN command at the end. If any unconditional
cbilling:     jump commands are used in the assembly, this is irrelevant because
cbilling:     the code will never finish.
cbilling: 
cbilling:     local_loop_pre: prefix for all local loop names
cbilling: 
cbilling:     jump_pre: prefix for sequence-wide jumps
cbilling: 
cbilling:     loop_pre: prefix for sequence-wide loops
cbilling:     """
cbilling:     
cbilling:     cdef int k, kmax, m, dt, damp, dfreq, dph
cbilling:     
cbilling:     dListD = sameDiffD(dList,10)
cbilling: 
cbilling:     ## Initialisation and preparation for trigger
cbilling:     if init:
cbilling:         f.write(util.init_asm())
cbilling: 
cbilling:     ## Initial jump point
cbilling:     if jump_to_start:
cbilling:         f.write("    ;;; Jumpback\n"+jump_pre+":         nop\n")
cbilling:         
cbilling:     if loop_to_start:
cbilling:         f.write("    ;;; Initialise loop reg\n")
cbilling:         f.write(instr("setr",loop_to_start,7, None))
cbilling:         f.write("    ;;; Loopback\n"+loop_pre+":         nop\n")
cbilling: 
cbilling:     # Clear phase (only written if there's a DDSUPD in 'set default
cbilling:     # startup values' section below)
cbilling:     if set_defaults:
cbilling:         f.write("""    ;;; Clear phase
cbilling:                      setr 0x4108 R0
cbilling:                      setcfr 0x00 0x00 0x0e R0
cbilling:                      dir (WRDDS|RSTT|TMRADD) 300 0 ; extra delay for register setting
cbilling:     """)
cbilling: 
cbilling:         # Set default startup values
cbilling:         f.write("  ;; Set default pre-trigger values\n")
cbilling:         f.write(instr("seta",0,None,None)) # Amp = 0
cbilling:         f.write(instr("setf",0,None,None)) # Freq = 0
cbilling:     #    f.write(instr("setf",int(c.defaultf*c.fF + 0.5) >> c.FF_shift)) # Freq = 80 MHz default
cbilling:     #    f.write(instr("addf",int(c.defaultf*c.fF + 0.5) & c.FF_mask)) # Freq = 80 MHz default
cbilling:         f.write(instr("setp",0,None,None)) # Phase = 0
cbilling:         f.write(instr("dir (WT_TIM|TMRADD|WRDDS|DDSUPD)",stepT,0,None))
cbilling:     else: # !set_defaults
cbilling:         f.write("""    ;;; Reset timer
cbilling:                  dir (RSTT|TMRADD) 300 0
cbilling:     """)
cbilling:     
cbilling:     # Unclear phase
cbilling:     f.write("""
cbilling:     ;;; Unclear phase
cbilling:                  setr 0x4100 R0
cbilling:                  setcfr 0x00 0x00 0x0e R0
cbilling:                  dir (WRDDS|WT_TIM|TMRADD|DDSUPD) 150 0
cbilling: """)
cbilling: 
cbilling:     f.write("  ;; Set starting values\n")
cbilling:     amp = dList[0,1]
cbilling:     freq = dList[0,2]
cbilling:     ph = dList[0,3]
cbilling:     
cbilling:     f.write(instr("seta",amp,None,None))
cbilling:     f.write(instr("setf",freq >> FF_shift,None,None)) # Coarse freq
cbilling:     f.write(instr("addf",freq & FF_mask,None,None)) # Fine freq
cbilling:     if ph != 0:
cbilling:         f.write(instr("setp",ph,None,None))
cbilling: 
cbilling:     f.write("  ;; Clear registers\n")
cbilling:     for k in range(avail_regs):
cbilling:         f.write(instr("setr",0,k,None))
cbilling:     
cbilling:     f.write("  ;; Set deterministic delays\n")
cbilling:     if start_trig:
cbilling:         trigstr = "dir (WT_TIM|DDSUPD|WT_TRIG|TMRADD|RSTT)"
cbilling:     else:
cbilling:         trigstr = "dir (WT_TIM|DDSUPD|TMRADD|RSTT)"
cbilling:     startDelay = dList[0,0]
cbilling:     if startDelay > 65535: #limit of 16-bit timing
cbilling:         startDelay_s = startDelay-65535
cbilling:         tim_loops = startDelay_s / max_stepT
cbilling:         tim_rem = startDelay_s % max_stepT
cbilling:         
cbilling:         f.write(instr(trigstr, 65535, no_reg,None))
cbilling: 
cbilling:         if tim_loops:
cbilling:             # Write a loop to set the timer arbitrarily high
cbilling:             f.write(instr("setr", tim_loops, 0, None))
cbilling:             f.write(instr("addt", max_stepT, None, "tim_loop_"+local_loop_pre+": "))
cbilling:             f.write(instr("addr", -1, 0, None)) # decrement loop register
cbilling:             f.write(instr("jnz (( tim_loop - tim_loop_e) > 2)", None, 0, "tim_loop_e_"+local_loop_pre+": "))
cbilling:         f.write(instr("addt", tim_rem - externT, None, None))
cbilling:     else:
cbilling:         f.write(instr(trigstr, startDelay-externT, no_reg, None))
cbilling:         f.write(instr("dir WRDDS",0,no_reg, None))
cbilling: 
cbilling:     k = 1 # diff list index
cbilling:     kmax = len(dList)
cbilling:     m = 0 # loop index
cbilling:     global timlp # timing loop index (used for advance_timing() calls)
cbilling:     global g_avail_regs
cbilling:     g_avail_regs = avail_regs
cbilling:     timlp = 0
cbilling:     dt = 0
cbilling:     damp = 0
cbilling:     dfreq = 0
cbilling:     dph = 0
cbilling:     cdef np.ndarray[int, ndim=2] regData
cbilling:     regData = np.zeros((avail_regs,3),dtype='i')
cbilling:     loop_base="loop"+local_loop_pre+"_"
cbilling:     tim_lp_base = "tim_"+loop_base
cbilling: 
cbilling:     cdef int fBig, loop, freg, areg, sameA, sameF
cbilling:     
cbilling:     while k<kmax:
cbilling:         dt = dList[k,0]
cbilling:         damp = dList[k,1]
cbilling:         dfreq = dList[k,2]
cbilling:         dph = dList[k,3]
cbilling:         fBig = not -max_stepF <= dfreq < max_stepF # is frequency step larger than 23 bits?
cbilling:         loop = dList[k,4]
cbilling:         freg = -1
cbilling:         areg = -1
cbilling:         sameA = dListD[k,0] # number of segments ahead where this value is needed
cbilling:         sameF = dListD[k,1]
cbilling: 
cbilling:         if not fBig:
cbilling:             freq += dfreq*(loop+1) # keep tally of absolute freqs, in case they're needed
cbilling:             # f.write("  ; F step within register size\n")
cbilling:             # can do optimisations
cbilling:             if loop:
cbilling:                 # f.write("  ; Loop "+str(m)+"\n")
cbilling:                 loop_reg, regWritten = set_reg(f,loop+1,0,regData,False);
cbilling: #                if regWritten: n += 1
cbilling: #                if regWritten:
cbilling:                     # f.write("  ; ^^ Saved it to R"+str(loop_reg)+"\n")
cbilling: #                else:
cbilling:                     # f.write("  ; Found it in R"+str(loop_reg)+"\n")
cbilling:                     # f.write("  ; Hold time in R"+str(loop_reg)+" is "+str(regData[loop_reg,1])+"\n")
cbilling:                 loop_name=loop_base+str(m)
cbilling:                 m += 1
cbilling:             if sameF:
cbilling:                 # f.write("  ; Future freq "+str(dfreq)+" used "+str(sameF)+" steps in future\n")
cbilling:                 freg,regWritten = set_reg(f,dfreq,sameF,regData,False)
cbilling: #                if regWritten: n += 1
cbilling: #                if regWritten:
cbilling:                     # f.write("  ; ^^ Saved it to R"+str(freg)+"\n")
cbilling: #                else:
cbilling:                     # f.write("  ; Found it in R"+str(freg)+"\n")
cbilling:                     # f.write("  ; Hold time in R"+str(freg)+" is "+str(regData[freg,1])+"\n")
cbilling:             elif sameA:
cbilling:                 # f.write("  ; Future amp "+str(damp)+" used "+str(sameA)+" steps in future\n")
cbilling:                 areg, regWritten = set_reg(f,damp,sameA,regData,False)
cbilling: #                if regWritten: n += 1
cbilling: #                if regWritten:
cbilling:                     # f.write("  ; ^^ Saved it to R"+str(areg)+"\n")
cbilling: #                else:
cbilling:                     # f.write("  ; Found it in R"+str(areg)+"\n")
cbilling:                     # f.write("  ; Hold time in R"+str(areg)+" is "+str(regData[areg,1])+"\n")
cbilling:             else:
cbilling:                 # f.write("  ; Freq "+str(dfreq)+" not found in future.\n")
cbilling:                 freg,regWritten = set_reg(f,dfreq,0,regData,False)
cbilling: #                if regWritten: n += 1
cbilling: #                if regWritten:
cbilling:                     # f.write("  ; ^^ Saved it to  R"+str(freg)+"\n")
cbilling: #                else:
cbilling:                     # f.write("  ; Found it in R"+str(freg)+"\n")
cbilling:                     # f.write("  ; Hold time in R"+str(freg)+" is "+str(regData[freg,1])+"\n")
cbilling:                     
cbilling:             if loop:
cbilling:                 if not freg < 0:
cbilling:                     f.write(instr("addfr",damp,freg,loop_name + ":"))
cbilling: #                    n += 1
cbilling:                 else:
cbilling:                     f.write(instr("addar",dfreq,areg if not areg < 0 else None,loop_name+ ":"))
cbilling: #                    n += 1
cbilling: #                    checkn(k,n); n = 0
cbilling:                 
cbilling:                 # Increment phase
cbilling:                 if dph:
cbilling:                     f.write(instr("addp",dph, None, None))
cbilling:                 # Advance timing and do other things
cbilling:                 advance_timing(f, "dir (WT_TIM|DDSUPD|WRDDS|TMRADD|REGDEC)", dt, loop_reg, tim_lp_base, regData)
cbilling: #                f.write(instr("dir (WT_TIM|DDSUPD|WRDDS|TMRADD|REGDEC)",dt,loop_reg)) # dt truncated to 16 bits
cbilling:                 f.write(instr("jnz ((" + loop_name + " -" + loop_name + "_e) > 2)", None,
cbilling:                           loop_reg, loop_name + "_e:"))
cbilling: #                n += 1
cbilling:                 # Clear relevant loop reg (since its contents would be
cbilling:                 # cleared by the decrements)
cbilling:                 regData[loop_reg,0] = 0
cbilling:             else: 
cbilling:                 if not freg < 0:
cbilling:                     f.write(instr("addfr",damp,freg, None))
cbilling: #                    n += 1
cbilling:                 else:
cbilling:                     f.write(instr("addar",dfreq,areg, None))
cbilling: #                    n += 1
cbilling: #                checkn(k,n); n = 0
cbilling:                 # Increment phase
cbilling:                 if dph:
cbilling:                     f.write(instr("addp",dph, None, None))
cbilling:                 # Advance timing and do other things
cbilling:                 advance_timing(f, "dir (WT_TIM|DDSUPD|WRDDS|TMRADD)", dt, no_reg, tim_lp_base, regData)
cbilling: #                f.write(instr("dir (WT_TIM|DDSUPD|WRDDS|TMRADD)",dt,no_reg))
cbilling:         else:
cbilling: #            print "Freq is big: ",freq
cbilling:             # Error; slope is too high; must unroll loop
cbilling:             if loop:
cbilling:                 print "Warning: loop slope too high for addf. Unrolling loop..."
cbilling:                 f.write("  ;; Unrolling a loop whose freq slope is too high for registers to hold\n")
cbilling:             else:
cbilling:                 f.write("  ;; Big frequency step\n")
cbilling:             for p in range(loop+1):
cbilling:                 freq += dfreq # keep tally of absolute freqs updated
cbilling:                 f.write("  ; loop = "+str(p)+"\n")
cbilling:                 if sameA:
cbilling:                     areg, regWritten = set_reg(f,damp,sameA,regData,False)
cbilling: #                    if regWritten: n += 1
cbilling: #                    print "SameA; wrote ",areg," with ",damp
cbilling:                 else:
cbilling:                     freg, regWritten = set_reg(f,freq & FF_mask, 0,regData,True)
cbilling: #                    if regWritten: n += 1
cbilling:                 f.write(instr("setf",freq >> FF_shift, None, None))
cbilling: #                n += 1
cbilling:                 if sameA:
cbilling:                     f.write(instr("addar",freq & FF_mask, areg, None))
cbilling: #                    n += 1
cbilling:                 else:
cbilling:                     f.write(instr("addfr",damp,freg, None))
cbilling: #                    n += 1
cbilling: #                checkn(k,n); n = 0
cbilling: 
cbilling:                 # Increment phase
cbilling:                 if dph:
cbilling:                     f.write(instr("addp",dph, None, None))
cbilling:                 # Advance timing
cbilling:                 advance_timing(f, "dir (WT_TIM|DDSUPD|WRDDS|TMRADD)", dt, no_reg, tim_lp_base, regData)
cbilling: #                f.write(instr("dir (WT_TIM|DDSUPD|WRDDS|TMRADD)",dt,no_reg))
cbilling: 
cbilling:                 
cbilling: #        print "regData: ",regData
cbilling: #    
cbilling:         # Decrement all the register wait times. Once they hit 0, the
cbilling:         # register can be overwritten without harm.  Should only be run
cbilling:         # at the end of a segment's compilation processing.
cbilling:         for i in range(avail_regs):
cbilling:             if regData[i,1] > 0:
cbilling:                 regData[i,1] -= 1
cbilling:             regData[i,2] = 0
cbilling:         k += 1
cbilling:         
cbilling: #        print "k: ",k
cbilling: #        print "regData: ",regData
cbilling: #        f.write(instr("; k = ",k))
cbilling: #        print "------------------------------------------- k = ",k
cbilling: 
cbilling: 
cbilling:     
cbilling:     # End sequence
cbilling:     if close_end:
cbilling:         f.write(instr("dir (WT_TIM|DDSUPD|FIN)",0,no_reg, None))
cbilling:     else:
cbilling:         f.write(instr("dir (WT_TIM|DDSUPD|RSTT)",0,no_reg, None))
cbilling: 
cbilling:     # Loop-back sequence        
cbilling:     if loop_from_end:
cbilling:         f.write(instr("addr",-1,7, None))
cbilling:         f.write(instr("jnz (("+loop_pre+"-"+loop_pre+"_END)>2)",None, 7, loop_pre+"_END: "))
cbilling: 
cbilling:     # Jump-back sequence
cbilling:     if jump_from_end:
cbilling:         f.write(instr("jump ((" + jump_pre + " - " + jump_pre + "_END)>2)", None, None, jump_pre+"_END: "))
cbilling:     
cbilling:     
cbilling: # (c) Vlad Negnevitsky, 2011
cbilling: # ported to Cython by Chris Billington
cbilling: 
cbilling: cimport cython
cbilling: import numpy as np
cbilling: cimport numpy as np
cbilling: 
cbilling: cdef float tT
cbilling: from rfblaster.rfjuice.const import tT
cbilling: 
cbilling: @cython.nonecheck(False)
cbilling: @cython.wraparound(False)
cbilling: @cython.boundscheck(False)
cbilling: def make_diff_table(np.ndarray[long long,ndim=2] tab):
cbilling: 
cbilling:     cdef int segs = len(tab)
cbilling:     cdef int kmax = segs-1
cbilling:     
cbilling:     startt = 0
cbilling:     totalt = tab[kmax,0] / tT
cbilling:     endt = startt + totalt
cbilling:     centt = (startt+endt)/2
cbilling:     
cbilling:     startA = tab[0,1]            
cbilling:     startF = tab[0,2]
cbilling:     startP = tab[0,3]
cbilling:     
cbilling:     cdef np.ndarray[int,ndim=2] dTAFP = np.zeros((segs,5), dtype='i')
cbilling:     cdef np.ndarray[int,ndim=1] dTAFP_prev = np.zeros(5,dtype='i')
cbilling:     
cbilling:     cdef np.ndarray[int,ndim=1] dTAFP_curr = np.array([ int(round( (centt - totalt/2)*tT)) + tab[0,0],
cbilling:                                                         tab[0,1], tab[0,2], tab[0,3], 0], dtype='i')
cbilling:     for i in range(5):
cbilling:         dTAFP[0,i] = dTAFP_curr[i]
cbilling: 
cbilling:     cdef int m = 0
cbilling:     cdef int k = 0
cbilling: 
cbilling:     cdef int all_same
cbilling:     
cbilling:     while k < kmax:
cbilling:         for i in range(5):
cbilling:             dTAFP_prev[i] = dTAFP_curr[i]
cbilling:         for i in range(4):
cbilling:             dTAFP_curr[i] = tab[k+1,i] - tab[k,i]
cbilling:         dTAFP_curr[4] = 0
cbilling: 
cbilling:         if dTAFP_prev[0] < 0:
cbilling:             raise ValueError("Error: negative timestep. Do you need a dToTab() call?")
cbilling:         
cbilling:         all_same = 1
cbilling:         for i in range(5):
cbilling:             all_same *= (dTAFP_prev[i] == dTAFP_curr[i])
cbilling:         if all_same: # same step, so can loop
cbilling:             dTAFP[m,4] += 1
cbilling:         else:
cbilling:             m += 1
cbilling:             for i in range(5):
cbilling:                 dTAFP[m,i] = dTAFP_curr[i]
cbilling:         k += 1
cbilling:         
cbilling:     return dTAFP[:m+1]
chrisjbillington: # This extension is intended to be built with autocython. To trigger a build on a
chrisjbillington: # new platform, run the code that imports the extension, or run:
chrisjbillington: # python -m autocython
chrisjbillington: # in this directory.
chrisjbillington: from setuptools import setup
chrisjbillington: from setuptools.extension import Extension
        cbilling: from Cython.Distutils import build_ext
        cbilling: import numpy
chrisjbillington: from autocython import PLATFORM_SUFFIX
chrisjbillington: ext_modules = [Extension("compile" + PLATFORM_SUFFIX,
chrisjbillington:                          ["compile.pyx"],
chrisjbillington:                          include_dirs = [numpy.get_include()]),
chrisjbillington:                Extension("make_diff_table" + PLATFORM_SUFFIX,
chrisjbillington:                          ["make_diff_table.pyx"],
chrisjbillington:                          include_dirs = [numpy.get_include()])]
        cbilling: setup(
        cbilling:     name = "compile",
        cbilling:     cmdclass = {"build_ext": build_ext},
        cbilling:     ext_modules = ext_modules
        cbilling: )
 vnegnev: #!/usr/bin/python2
 vnegnev: # (c) Vlad Negnevitsky, 2012
 vnegnev: #
 vnegnev: # Compiles pulse assembly generated by rfjuice (or other), and loads
 vnegnev: # the RfBlaster via HTTP POST request. RfBlaster IP is currently fixed.
 vnegnev: 
 vnegnev: import os
 vnegnev: import urllib
 vnegnev: import urllib2
 vnegnev: import rfjuice
 vnegnev: import sys
 vnegnev: import multipart_form as mpf # Custom class for encoding multipart form data
 vnegnev: 
 vnegnev: print "Doing init..."
 vnegnev: 
 vnegnev: addr = "http://130.194.171.150:8080"
 vnegnev: #addr = "http://130.194.171.211:8080"
 vnegnev: bin_out0 = "output_ch0.bin"
 vnegnev: bin_out1 = "output_ch1.bin"
 vnegnev: 
 vnegnev: # ASM files to write to device
 vnegnev: chlist = "0","1"
 vnegnev: 
 vnegnev: print "Doing rfjuicing..."
 vnegnev: 
 vnegnev: # If phase parameters entered on command line, run a sweep
 vnegnev: if len(sys.argv) >= 5:
 vnegnev:     ph_swp_d = {
 vnegnev:         'start_deg':float(sys.argv[2]),
 vnegnev:         'stop_deg':float(sys.argv[3]),
 vnegnev:         'num':int(sys.argv[4]),
 vnegnev:         'pul_num':sys.argv[1].split(','), # list of strings
 vnegnev:         'print_phases':True,
 vnegnev:         'loops':(len(sys.argv) == 6)}
 vnegnev:     if int(sys.argv[4])<2:
 vnegnev:         print "Error: not enough phases!"
 vnegnev:         exit()
 vnegnev: elif len(sys.argv)>1:
 vnegnev:     print "Error: not enough arguments for phase sweep. Use a comma-separated list of pulse indices, followed by 3 arguments with linspace syntax."
 vnegnev: else:
 vnegnev:     ph_swp_d = None
 vnegnev: 
 vnegnev: # If additional loop quantities entered on command line, do looping    
 vnegnev: if len(sys.argv) == 6:
 vnegnev:     swp_lps,stat_lps = sys.argv[5].split(',')
 vnegnev:     ph_swp_d['swp_loops']=int(swp_lps) # loops of phase sweep
 vnegnev:     ph_swp_d['stat_loops']=int(stat_lps) # loops of stationary phase
 vnegnev:     if int(swp_lps)<1 or int(stat_lps)<1:
 vnegnev:         print "Error: too few loops specified! Need 1 or more for each."
 vnegnev:         exit()
 vnegnev:     
 vnegnev: 
 vnegnev: # Trigger pulse dictionary
 vnegnev: if 0: # set to 0 to enable trigger pulse
 vnegnev:     trig_pulse_d = None
 vnegnev: else:
 vnegnev:     trig_pulse_d = {
 vnegnev:         'time':20, # centre time of trigger, us
 vnegnev:         'amp':0.95,
 vnegnev:         'freq':300 # MHz
 vnegnev:         }
 vnegnev:     
 vnegnev: rfjuice.rfjuice(
 vnegnev:     pulse_in="default.pulse",
 vnegnev:     asm_out0="output_ch0.asm",
 vnegnev:     asm_out1="output_ch1.asm",
 vnegnev:     trig_pulse=trig_pulse_d,
 vnegnev:     ph_swp=ph_swp_d,
 vnegnev:     dwell=False,
cbilling:     plot=True
 vnegnev:     )
 vnegnev: 
 vnegnev: # Import rfjuice.py; runs the main rfjuice function
 vnegnev: print "Doing CASPR..."
 vnegnev: 
 vnegnev: for k in chlist:
  beclab:     if os.environ.has_key("OS"): # only windows has an OS key (I think XP does too)
 vnegnev:         os.system("caspr.exe output_ch"+k+".asm output_ch"+k+".bin")
 vnegnev:     else:
 vnegnev:         os.system("./caspr output_ch"+k+".asm output_ch"+k+".bin")
  beclab: 
 vnegnev: print "Doing encoding..."
 vnegnev:         
  beclab: # Open binary files to encode them
 vnegnev: 
  beclab: bo0 = open(bin_out0,"rb")
 vnegnev: bo1 = open(bin_out1,"rb")
  beclab:         
 vnegnev: #req = urllib2.Request("http://"+ip,data)
 vnegnev: 
 vnegnev: form = mpf.MultiPartForm()
 vnegnev: form.add_file("pulse_ch0",bin_out0,bo0)
 vnegnev: form.add_file("pulse_ch1",bin_out1,bo1)
 vnegnev: form.add_field("upload_and_run","Upload and start")
 vnegnev: 
 vnegnev: # Build the request
 vnegnev: req = urllib2.Request(addr)
 vnegnev: 
 vnegnev: body = str(form)
 vnegnev: req.add_header('Content-type', form.get_content_type())
 vnegnev: req.add_header('Content-length', len(body))
 vnegnev: req.add_data(body)
 vnegnev: 
 vnegnev: print "Doing transfer..."
  beclab: urllib2.urlopen(req)
 vnegnev: 
 vnegnev: bo0.close()
 vnegnev: bo1.close()
vnegnev: import itertools
vnegnev: import mimetools
vnegnev: import mimetypes
vnegnev: #from cStringIO import StringIO
vnegnev: import urllib
vnegnev: import urllib2
vnegnev: 
vnegnev: class MultiPartForm(object):
vnegnev:     """Accumulate the data to be used when posting a form."""
vnegnev: 
vnegnev:     def __init__(self):
vnegnev:         self.form_fields = []
vnegnev:         self.files = []
vnegnev:         self.boundary = mimetools.choose_boundary()
vnegnev:         return
vnegnev:     
vnegnev:     def get_content_type(self):
vnegnev:         return 'multipart/form-data; boundary=%s' % self.boundary
vnegnev: 
vnegnev:     def add_field(self, name, value):
vnegnev:         """Add a simple field to the form data."""
vnegnev:         self.form_fields.append((name, value))
vnegnev:         return
vnegnev: 
vnegnev:     def add_file(self, fieldname, filename, fileHandle, mimetype=None):
vnegnev:         """Add a file to be uploaded."""
vnegnev:         body = fileHandle.read()
vnegnev:         if mimetype is None:
vnegnev:             mimetype = mimetypes.guess_type(filename)[0] or 'application/octet-stream'
vnegnev:         self.files.append((fieldname, filename, mimetype, body))
vnegnev:         return
vnegnev:     
vnegnev:     def __str__(self):
vnegnev:         """Return a string representing the form data, including attached files."""
vnegnev:         # Build a list of lists, each containing "lines" of the
vnegnev:         # request.  Each part is separated by a boundary string.
vnegnev:         # Once the list is built, return a string where each
vnegnev:         # line is separated by '\r\n'.  
vnegnev:         parts = []
vnegnev:         part_boundary = '--' + self.boundary
vnegnev:         
vnegnev:         # Add the form fields
vnegnev:         parts.extend(
vnegnev:             [ part_boundary,
vnegnev:               'Content-Disposition: form-data; name="%s"' % name,
vnegnev:               '',
vnegnev:               value,
vnegnev:               ]
vnegnev:             for name, value in self.form_fields
vnegnev:             )
vnegnev:         
vnegnev:         # Add the files to upload
vnegnev:         parts.extend(
vnegnev:             [ part_boundary, # VN: replaced 'file' with 'form-data'
vnegnev:               'Content-Disposition: form-data; name="%s"; filename="%s"' % \
vnegnev:                   (field_name, filename),
vnegnev:               'Content-Type: %s' % content_type,
vnegnev:               '',
vnegnev:               body,
vnegnev:             ]
vnegnev:             for field_name, filename, content_type, body in self.files
vnegnev:             )
vnegnev:         
vnegnev:         # Flatten the list and add closing boundary marker,
vnegnev:         # then return CR+LF separated data
vnegnev:         flattened = list(itertools.chain(*parts))
vnegnev:         flattened.append('--' + self.boundary + '--')
vnegnev:         flattened.append('')
vnegnev:         return '\r\n'.join(flattened)
vnegnev: 
vnegnev: if __name__ == '__main__':
vnegnev:     # Create the form with simple fields
vnegnev:     form = MultiPartForm()
vnegnev:     form.add_field('firstname', 'Doug')
vnegnev:     form.add_field('lastname', 'Hellmann')
vnegnev: 
vnegnev:     # Add a fake file
vnegnev:     form.add_file('biography', 'bio.txt', 
vnegnev:                   fileHandle=StringIO('Python developer and blogger.'))
vnegnev: 
vnegnev:     # Build the request
vnegnev:     request = urllib2.Request(addr)
vnegnev:     request.add_header('User-agent', 'PyMOTW (http://www.doughellmann.com/PyMOTW/)')
vnegnev:     body = str(form)
vnegnev:     request.add_header('Content-type', form.get_content_type())
vnegnev:     request.add_header('Content-length', len(body))
vnegnev:     request.add_data(body)
vnegnev: 
vnegnev:     print
vnegnev:     print 'OUTGOING DATA:'
vnegnev:     print request.get_data()
vnegnev: 
vnegnev:     print
vnegnev:     print 'SERVER RESPONSE:'
vnegnev:     print urllib2.urlopen(request).read()
vnegnev: ### PULSE.PY
vnegnev: # (c) Vlad Negnevitsky, 2011
vnegnev: #
vnegnev: # Contains pulse objects, including trapezoid and gaussian.
vnegnev: #
vnegnev: # Times are expressed in us, frequencies in MHz, amplitudes as [0,1).
vnegnev: # See const.py for conversion factors.
vnegnev: 
vnegnev: import numpy as np
vnegnev: 
vnegnev: import tables as t
vnegnev: import const as c
vnegnev: import util as u
vnegnev: 
vnegnev: # lowercase suffix denotes us/MHz/fractions of 1
vnegnev: # uppercase denotes integer equivs
vnegnev: 
vnegnev: class Trapezoid:
vnegnev:     def __init__(self, centa, rise, width, centf, slopef, centt, startp=0):
vnegnev:         """Initialisation.
vnegnev: 
vnegnev:         
vnegnev:         centa: amplitude of plateau
vnegnev:         rise: rise/fall time; width of each skirt
vnegnev:         width: width of plateau
vnegnev:         centf: frequency at centt
vnegnev:         slopef: slope of frequency ramp
vnegnev:         centt: centre time
vnegnev:         startp: starting phase offset        
vnegnev:         """
vnegnev: 
vnegnev:         # no of segments for rise (fall) and plateau
vnegnev: 
vnegnev:         self.centt = centt
vnegnev:         self.shape = "Trapezoidal"
vnegnev:         
vnegnev:         self.segs_r = int(rise/c.stept)
vnegnev:         self.segs_p = int(width/c.stept)
vnegnev:         self.segs = 2*self.segs_r + self.segs_p
vnegnev:         remt_r = rise - c.stept * self.segs_r
vnegnev:         remt_p = width - c.stept*self.segs_p
vnegnev: 
vnegnev:         # Duration of rise (fall) and plateau Segment A
vnegnev:         self.stepaT_r = c.stepT + int((remt_r/2) // c.rest)
vnegnev:         self.stepaT_p = c.stepT + int((remt_p/2) // c.rest)
vnegnev:         stepat_r = self.stepaT_r * c.rest
vnegnev:         stepat_p = self.stepaT_p * c.rest
vnegnev: 
vnegnev:         # Duration of rise (fall) and plateau Segment Z
vnegnev:         self.stepzT_r = c.stepT + int((remt_r + c.stept - stepat_r) // c.rest)
vnegnev:         self.stepzT_p = c.stepT + int((remt_p + c.stept - stepat_p) // c.rest)
vnegnev:         stepzt_r = self.stepzT_r * c.rest
vnegnev:         stepzt_p = self.stepzT_p * c.rest
vnegnev: 
vnegnev:         # Total time the pulse will run for (used to calculate
vnegnev:         # residuals)
vnegnev:         totalt_r = (self.segs_r-2)*c.stept + stepat_r + stepzt_r
vnegnev:         totalt_p = (self.segs_p-2)*c.stept + stepat_p + stepzt_p
vnegnev:         self.totalt = 2 * totalt_r + totalt_p
vnegnev: 
vnegnev:         if self.segs_r < 2 or self.segs_p < 2:
vnegnev:             print "Trapezoid error: some durations too short!"
vnegnev: 
vnegnev:         # Amplitude ramp slope
vnegnev:         slopea = centa/rise
vnegnev:         
vnegnev:         # Calculate start-to-1st-midpoint, 1st-midpoint-to-2nd,
vnegnev:         # 2nd-last-to-last, last-to-end amplitude and freq steps
vnegnev:         # labelled a,b,y,z (eg stepyA)
vnegnev: 
vnegnev:         stepaa = slopea*stepat_r/2
vnegnev:         stepba = slopea*(stepat_r + c.stept)/2
vnegnev:         stepa = slopea*c.stept
vnegnev:         stepya = slopea*(stepzt_r + c.stept)/2
vnegnev:         stepza = slopea*stepzt_r/2
vnegnev: 
vnegnev:         half_df = slopef * totalt_p/2
vnegnev:         self.startf = centf - half_df
vnegnev:         self.endf = centf + half_df
vnegnev:         
vnegnev:         stepaf = slopef*stepat_p/2
vnegnev:         stepbf = slopef*(stepat_p + c.stept)/2
vnegnev:         stepf = slopef*c.stept
vnegnev:         stepyf = slopef*(stepzt_p + c.stept)/2
vnegnev:         stepzf = slopef*stepzt_p/2
vnegnev: 
vnegnev:         if bada(centa):
vnegnev:             print "Error: amplitude too high"
vnegnev: 
vnegnev:         if badf(self.startf) or badf(self.endf):
vnegnev:             print "Error: frequency bad"
vnegnev: 
vnegnev:         # Discretisation
vnegnev:         self.stepaA = int(round(stepaa*c.aA))
vnegnev:         self.stepbA = int(round(stepba*c.aA))
vnegnev:         self.stepA = int(round(stepa*c.aA))
vnegnev:         self.stepyA = int(round(stepya*c.aA))
vnegnev:         self.stepzA = int(round(stepza*c.aA))
vnegnev:         self.centA = int(round(centa*c.aA))
vnegnev: 
vnegnev:         self.startA = self.stepaA
vnegnev:         self.startF=int(round(self.startf*c.fF))
vnegnev:         self.endF=int(round(self.endf*c.fF))
vnegnev: 
vnegnev:         self.startP = int(round(startp*c.pP)) % c.maxP
vnegnev:         
vnegnev:         self.stepaF = int(round(stepaf*c.fF))
vnegnev:         self.stepbF = int(round(stepbf*c.fF))
vnegnev:         self.stepF = int(round(stepf*c.fF))
vnegnev:         self.stepyF = int(round(stepyf*c.fF))
vnegnev:         self.stepzF = int(round(stepzf*c.fF))
vnegnev: 
vnegnev:         # Quantisation error: quantised - exact
vnegnev:         self.residt = self.totalt - width - 2*rise
vnegnev:         self.resida = self.centA/c.aA - centa
vnegnev: 
vnegnev: 
vnegnev:     def calcd(self):
vnegnev:         """Produces an array of steps for plotting
vnegnev: 
vnegnev:         Returns a (segs) x 2 array of discretised time, freq and
vnegnev:         amp _steps_ (not absolute values) ready to plot/analyse.
vnegnev:         """
vnegnev:         
vnegnev:         dTAFP = np.zeros((13,5), dtype='i')
vnegnev: 
vnegnev:         # Start
vnegnev:         dTAFP[0] = [int(round(self.centt- self.totalt/2)*c.tT),
vnegnev:                    self.startA, self.startF,self.startP,0]
vnegnev:         
vnegnev:         # Ramp up
vnegnev:         dTAFP[1] = [self.stepaT_r, self.stepbA, 0, 0, 0]
vnegnev:         dTAFP[2] = [c.stepT, self.stepA, 0, 0, self.segs_r-4]
vnegnev:         dTAFP[3] = [c.stepT, self.stepyA, 0, 0, 0]
vnegnev:         dTAFP[4] = [self.stepzT_r, self.stepzA, self.stepaF, 0, 0]
vnegnev: 
vnegnev:         # Level
vnegnev:         
vnegnev:         dTAFP[5] = [self.stepaT_p, 0, self.stepbF, 0, 0]
vnegnev:         dTAFP[6] = [c.stepT, 0, self.stepF, 0, self.segs_p-4]
vnegnev:         dTAFP[7] = [c.stepT, 0, self.stepyF, 0, 0]
vnegnev:         dTAFP[8] = [self.stepzT_p, -self.stepzA, self.stepzF, 0, 0]
vnegnev: 
vnegnev:         # Ramp down
vnegnev:         dTAFP[-4] = [self.stepzT_r, -self.stepyA, 0, 0, 0]
vnegnev:         dTAFP[-3] = [c.stepT, -self.stepA, 0, 0, self.segs_r-4]
vnegnev:         dTAFP[-2] = [c.stepT, -self.stepbA, 0, 0, 0]
vnegnev:         dTAFP[-1] = [self.stepaT_r, -self.stepaA, 0, 0, 0]
vnegnev: 
vnegnev:         return dTAFP
vnegnev: 
vnegnev: class Arbitrary:
vnegnev:     def __init__(self, amp_fn, width, freq_fn, centt, phase_fn=None):
vnegnev:         """Arbitrary pulse segment
vnegnev: 
vnegnev:         amp_fn: function that returns an amplitude value (0 -> 1) when fed a time (in us); 0 time = centre
vnegnev:         width: time from start of pulse to end of pulse
vnegnev:         freq_fn: function that returns a frequency value (0 -> 400) when fed a time; 0 time = centre
vnegnev:         centt: centre time
vnegnev:         phase_fn: function that returns a phase value (0 -> 360) when fed a time; 0 time = centre
vnegnev: 
vnegnev:         NOTE: THERE ARE NO AMP/FREQ CHECKS IN THIS CLASS - MAKE SURE
vnegnev:         amp_fn, freq_fn and phase_fn ARE REASONABLE!
vnegnev:         """
vnegnev: 
vnegnev:         self.centt = centt
vnegnev:         self.shape = "Arbitrary"
vnegnev:         self.amp_fn = amp_fn
vnegnev:         self.freq_fn = freq_fn
vnegnev: 
vnegnev:         self.segs = int(width/c.stept)
vnegnev:         remt = width - c.stept * self.segs # remaining time
vnegnev: 
vnegnev:         # Duration of Segment A
vnegnev:         self.stepaT = c.stepT + int((remt/2 // c.rest))
vnegnev:         stepat = self.stepaT * c.rest
vnegnev: 
vnegnev:         # Duration of Segment Z
vnegnev:         self.stepzT = c.stepT + int((remt + c.stept - stepat) // c.rest)
vnegnev:         stepzt = self.stepzT * c.rest
vnegnev: 
vnegnev:         # Aim is stepaT + stepzT = remT
vnegnev: 
vnegnev:         # Total time the pulse will run for (used to calculate
vnegnev:         # residuals)
vnegnev:         self.totalt = (self.segs-2)*c.stept + stepat + stepzt
vnegnev: 
vnegnev:         if self.segs < 2:
vnegnev:             print "Error: arbitrary duration less than 2 segments!"
vnegnev: 
vnegnev:         # Start and end times to feed into f/a functions
vnegnev:         # (midpoints of relevant segments)
vnegnev:         startt = - ((self.segs-2)*c.stept + stepat)/2
vnegnev:         endt = ((self.segs-2)*c.stept + stepzt)/2
vnegnev:         
vnegnev:         # Precise calculation of amp envelope, freq and phase
vnegnev:         self.vecA = np.zeros(self.segs, dtype='i')
vnegnev:         self.vecF = np.zeros(self.segs, dtype='i')
vnegnev:         self.vecP = np.zeros(self.segs, dtype='i')
vnegnev: 
vnegnev:         # first seg
vnegnev:         self.startF = int(round(freq_fn(startt) * c.fF))
vnegnev:         self.startA = int(round(amp_fn(startt) * c.aA))
vnegnev:         if phase_fn is not None:
vnegnev:             self.startP = int(round(phase_fn(startt) * c.pP)) % c.maxP
vnegnev:         else:
vnegnev:             self.startP = 0
vnegnev:             phase_fn = lambda p:0
vnegnev:         self.vecA[0] = self.startA
vnegnev:         self.vecF[0] = self.startF
vnegnev:         self.vecP[0] = self.startP
vnegnev: 
vnegnev:         # last seg
vnegnev:         self.vecA[-1] = int(round(amp_fn(endt) * c.aA))
vnegnev:         self.vecF[-1] = int(round(freq_fn(endt) * c.fF))
vnegnev:         self.vecP[-1] = int(round(phase_fn(endt) * c.pP))
vnegnev: 
vnegnev:         t = - ((self.segs-3) * c.stept)/2
vnegnev:         for k in range(1,self.segs-1):
vnegnev:             self.vecA[k] = int(round(amp_fn(t) * c.aA))
vnegnev:             self.vecF[k] = int(round(freq_fn(t) * c.fF))
vnegnev:             self.vecP[k] = int(round(phase_fn(t) * c.pP))
vnegnev:             t += c.stept
vnegnev: 
vnegnev:     def calcd(self):
vnegnev:         """returns a diff list of the parent pulse
vnegnev:         """
vnegnev: 
vnegnev:         kmax = self.segs+1
vnegnev:         
vnegnev:         dTAFP = np.zeros((kmax,5), dtype='i')
vnegnev:         dTAFP_prev = np.zeros(5,dtype='i')
vnegnev: #        dTAFP_curr = dTAFP_prev # TODO: check if removing this harms anything
vnegnev:         
vnegnev:         dTAFP[0] = [ int(round( (self.centt- self.totalt/2)*c.tT)),
vnegnev:                     self.startA, self.startF, self.startP, 0]
vnegnev:         dTAFP_curr = np.array([self.stepaT,
vnegnev:                                self.vecA[1]-self.vecA[0],
vnegnev:                                self.vecF[1]-self.vecF[0],
vnegnev:                                self.vecP[1]-self.vecP[0],
vnegnev:                                0],dtype="i")
vnegnev:         dTAFP[1] = dTAFP_curr
vnegnev: 
vnegnev:         m = 1
vnegnev:         
vnegnev:         for k, vA in enumerate(self.vecA[1:-1]):   # range(2,kmax-1):
vnegnev:             dTAFP_prev = dTAFP_curr.copy()
vnegnev:             dTAFP_curr[:]=[c.stepT,
vnegnev:                            self.vecA[k+2]-self.vecA[k+1],
vnegnev:                            self.vecF[k+2] - self.vecF[k+1],
vnegnev:                            self.vecP[k+2] - self.vecP[k+1],
vnegnev:                            0]
vnegnev:             
vnegnev:             if all(dTAFP_prev == dTAFP_curr):
vnegnev:                 dTAFP[m,4] += 1 # increment no of loops
vnegnev:             else:
vnegnev:                 m += 1
vnegnev:                 dTAFP[m] = dTAFP_curr
vnegnev: 
vnegnev:         # end in 0 amp by shifting whatever's left to 0; last remaining freq and phase are left running
vnegnev:         dTAFP[m+1] = [self.stepzT, -self.vecA[-1], 0, 0, 0]
vnegnev: 
vnegnev:         return dTAFP[:m+2] #truncate unused rows
vnegnev:     
vnegnev: class Gaussian:
vnegnev:     def __init__(self, centa, width, centf, slopef, centt, startp=0):
vnegnev:         """Gaussian pulse segment
vnegnev:         
vnegnev:         width: FWHM width of pulse
vnegnev:         centa: amplitude at centt
vnegnev:         centf: frequency at centt
vnegnev:         slopef: slope of frequency ramp (MHz/us)        
vnegnev:         centt: centre time
vnegnev:         startp: starting phase offset
vnegnev:         """
vnegnev: 
vnegnev:         self.centt = centt
vnegnev:         self.shape = "Gaussian"
vnegnev: 
vnegnev:         if slopef != 0:
vnegnev:             self.rampf = True
vnegnev:         else:
vnegnev:             self.rampf = False
vnegnev: 
vnegnev:         # Find point where Gaussian rolls off to 0
vnegnev:         # Uses bisection; quite slow
vnegnev:             
vnegnev:         guess_l = 0.
vnegnev:         guess_h = 10000000. #10 ms
vnegnev: 
vnegnev:         def test_amp(t):
vnegnev:             return u.gaussian(t, centa, width) >= 1/c.aA
vnegnev: 
vnegnev:         # bisect 10ms space 30 times
vnegnev:         bisections = 30
vnegnev: 
vnegnev:         if not test_amp(guess_h) and test_amp(guess_l):
vnegnev:             for k in range(bisections): 
vnegnev:                 guess_c = (guess_l + guess_h)/2
vnegnev:                 if test_amp(guess_c) == test_amp(guess_h):
vnegnev: #                    print "Below ", guess_c
vnegnev:                     guess_h = guess_c
vnegnev:                 else:
vnegnev:                     guess_l = guess_c
vnegnev: #                    print "Above ", guess_c
vnegnev:         else:
vnegnev:             print "Error: something's wrong with Gaussian limits."
vnegnev:                 
vnegnev:             
vnegnev:         # Allow 2 segments either side for leeway. Pulse should have a
vnegnev:         # single segment, whose amplitude is the Gaussian peak and
vnegnev:         # whose centre falls precisely at the peak time.
vnegnev:             
vnegnev:         self.segs = 2*int(guess_h/c.stept) + 1 # Total segments
vnegnev:         segs_wid = (self.segs-1)/2 # segments left of the central one
vnegnev: 
vnegnev:         if segs_wid < 2:
vnegnev:             print "Error: Gaussian duration too short!"
vnegnev: 
vnegnev:         # Total duration of pulse (actual, not asked-for)
vnegnev:         self.totalt = self.segs*c.stept # extra one for final 'zero' pulse
vnegnev: 
vnegnev:         # Half ramp duration
vnegnev: #        self.halft = segs_wid * c.stept
vnegnev:         halft = self.totalt/2
vnegnev: 
vnegnev:         # Precise calculation of amp envelope params
vnegnev:         self.vecA = np.zeros(self.segs, dtype='i')
vnegnev: 
vnegnev:         # Calculate left half
vnegnev:         t = -halft + c.stept/2 # c.stept/2 to ensure midpoint sampling
vnegnev:         
vnegnev:         for k in range(segs_wid+1):
vnegnev:             self.vecA[k] = int(round(u.gaussian(t, centa, width) * c.aA))
vnegnev:             t += c.stept
vnegnev: 
vnegnev:         self.startA = self.vecA[0]
vnegnev: 
vnegnev:         # Copy over to right half
vnegnev:         for k in range(segs_wid):
vnegnev:             self.vecA[k+segs_wid+1] = self.vecA[segs_wid-1-k]
vnegnev: 
vnegnev:         self.startP = int(round(startp*c.pP)) % c.maxP
vnegnev:             
vnegnev:         # Precise calculation of freq params
vnegnev:         if self.rampf:
vnegnev:             half_df = slopef * halft
vnegnev: 
vnegnev:             # Centre freq corrector - initial freq should be slightly
vnegnev:             # shifted forward (if positive ramp) since centre of first
vnegnev:             # segment is half a timestep forward from start of pulse
vnegnev:             # (correction carries through to end freq as well)
vnegnev:             centref_corr = c.stept/2 * slopef
vnegnev:             startf = centf - half_df
vnegnev:             endf = centf + half_df
vnegnev: 
vnegnev:             stepf = slopef * c.stept #freq increment per step
vnegnev: 
vnegnev:             self.startF = int(round( (startf+centref_corr) * c.fF))
vnegnev:             self.endF = int(round( (endf+centref_corr) * c.fF))
vnegnev:             self.stepF = int(round(stepf * c.fF))
vnegnev: 
vnegnev:             # Check freqs
vnegnev:             if badf(startf) or badf(endf):
vnegnev:                 print "Error: freq problem!"
vnegnev: 
vnegnev:         else:
vnegnev:             endf = centf
vnegnev:             self.startF = int(round(centf * c.fF))
vnegnev:             self.endF = self.startF
vnegnev:             self.stepF = 0
vnegnev:         
vnegnev:     def calcd(self):
vnegnev:         """returns a diff list of the parent pulse
vnegnev:         """
vnegnev:         kmax = self.segs+1
vnegnev: 
vnegnev:         
vnegnev:         dTAFP = np.zeros((kmax,5), dtype='i')
vnegnev:         dTAFP[0] = [int(round( (self.centt - self.totalt/2) * c.tT)),
vnegnev:                     self.startA, self.startF, self.startP, 0]
vnegnev:         
vnegnev:         for k in range(1,kmax-1):
vnegnev:             dTAFP[k] = [c.stepT, self.vecA[k] - self.vecA[k-1], self.stepF, 0, 0]
vnegnev: 
vnegnev:         dTAFP[-1] = [c.stepT, -self.vecA[0], self.stepF, 0, 0]
vnegnev: 
vnegnev:         return dTAFP
vnegnev: 
vnegnev: class Table:
vnegnev:     def __init__(self, src, startt=0):
vnegnev:         """Table pulse segment, based on a table of quantised
vnegnev:         times/amps/freqs.
vnegnev: 
vnegnev:         src: Either a pulse object or an absolute table (NOT
vnegnev:         diff). Best used with autogenerated tables, though you can
vnegnev:         roll your own from diff tables using tables.dToTab(). Take
vnegnev:         care you read the code and learn how time zero is treated in
vnegnev:         this case!
vnegnev:         """
vnegnev: 
vnegnev:         self.shape = "Table"
vnegnev: 
vnegnev:         if type(src) is np.ndarray:
vnegnev:             self.tab = src.copy()
vnegnev:             self.totalt = self.tab[-1,0] / c.tT
vnegnev:             endt = startt + self.totalt
vnegnev:             self.centt = (startt+endt)/2
vnegnev:         else:
vnegnev:             # Pulse object passed in as input
vnegnev:             diff = src.calcd()
vnegnev:             self.centt = src.centt
vnegnev:             self.totalt = src.totalt
vnegnev:             diff[0,0] = int(round(-self.totalt/2*c.tT))
vnegnev:             self.tab = t.dToTab(diff)
vnegnev: 
vnegnev:         if len(self.tab) < 2:
vnegnev:             print "Error: table duration less than 2 segments!"
vnegnev: 
vnegnev:         self.startA = self.tab[0,1]            
vnegnev:         self.startF = self.tab[0,2]
vnegnev:         self.startP = self.tab[0,3]
vnegnev: 
vnegnev:     def calcd(self):
vnegnev:         """returns a (segs) x 3 array of discretised time, freq and
vnegnev:         amp _steps_ (not absolute values) ready to plot/analyse.
vnegnev:         """
vnegnev:         segs = len(self.tab)
vnegnev:         
vnegnev:         kmax = segs-1
vnegnev: 
vnegnev:         dTAFP = np.zeros((segs,5), dtype='i')
vnegnev:         dTAFP_prev = np.zeros(5,dtype='i')
vnegnev:         
vnegnev:         dTAFP_curr = np.array([ int(round( (self.centt - self.totalt/2)*c.tT)) + self.tab[0,0],
vnegnev:                     self.tab[0,1], self.tab[0,2], self.tab[0,3], 0],dtype='i')
vnegnev: 
vnegnev:         dTAFP[0] = dTAFP_curr
vnegnev: 
vnegnev:         m = 0
vnegnev:         k = 0
vnegnev: 
vnegnev:         while k < kmax:
vnegnev:             dTAFP_prev = dTAFP_curr.copy()
vnegnev:             dTAFP_curr[:] = [self.tab[k+1,0] - self.tab[k,0],
vnegnev:                             self.tab[k+1,1] - self.tab[k,1],
vnegnev:                             self.tab[k+1,2] - self.tab[k,2],
vnegnev:                             self.tab[k+1,3] - self.tab[k,3], 0]
vnegnev: 
vnegnev:             if dTAFP_prev[0] < 0:
vnegnev:                 print "Error: negative timestep. Do you need a dToTab() call?"
vnegnev:             
vnegnev:             if all(dTAFP_prev == dTAFP_curr): # same step, so can loop
vnegnev:                 dTAFP[m,4] += 1
vnegnev:             else:
vnegnev:                 m += 1
vnegnev:                 dTAFP[m] = dTAFP_curr
vnegnev:             k += 1
vnegnev:             
vnegnev:         return dTAFP[:m+1]
vnegnev:         
vnegnev: 
vnegnev: def bada(amp):
vnegnev:     """Checks if input is [0,1)
vnegnev:     """
vnegnev:     if amp<0 or amp>1:
vnegnev:         return 1
vnegnev:     return 0
vnegnev: 
vnegnev: def badf(freq):
vnegnev:     """Checks if input is between 10kHz and 400MHz, in MHz units
vnegnev:     """
vnegnev:     if freq<0.01 or freq>400: #below 10kHz or above 400MHz
vnegnev:         return 1
vnegnev:     return 0
vnegnev: 
vnegnev: # No badp, because phase wraps around without problems (UNTESTED!).
vnegnev: ### PULSE.PY
vnegnev: # (c) Vlad Negnevitsky, 2011
vnegnev: #
vnegnev: # Contains pulse objects, including trapezoid and gaussian.
vnegnev: #
vnegnev: # All times are expressed in us, frequencies in MHz, amplitudes as [0,1).
vnegnev: 
vnegnev: 
vnegnev: import numpy as np
vnegnev: 
vnegnev: # This project
vnegnev: from const import *
vnegnev: 
vnegnev: class Rect:
vnegnev:     def __init__(self, a, width, centf, slopef):
vnegnev:         # centt: centre time (temporarily not included)
vnegnev:         # width: time from start of rectangular pulse to centt
vnegnev:         # centf: frequency at centt
vnegnev:         # slopef: slope of frequency ramp (MHz/us)
vnegnev: 
vnegnev:         # no of segments
vnegnev:         self.segs = int(2*width / stept)
vnegnev:         remt = 2*width - stept*self.segs
vnegnev:         print "Remt: ",remt
vnegnev: 
vnegnev:         # duration of Segment A
vnegnev:         self.stepaT = stepT + int((remt/2) // rest)
vnegnev:         stepat = self.stepaT*rest
vnegnev:         print "Stepat: ",stepat
vnegnev: 
vnegnev:         # duration of Segment Z
vnegnev:         self.stepzT = stepT + int((remt + stept - stepat) // rest)
vnegnev:         stepzt = self.stepzT*rest
vnegnev:         print "Stepzt: ",stepzt
vnegnev: 
vnegnev:         # Total time the pulse will actually run for (used to
vnegnev:         # calculate residuals)
vnegnev:         self.totalt = (self.segs-2)*stept + stepat + stepzt
vnegnev:         # Precise start and end freqs (using actual duration, not asked-for duration)
vnegnev: 
vnegnev:         half_df = slopef * self.totalt/2
vnegnev:         startf = centf - half_df
vnegnev:         print "Startf: ",startf
vnegnev:         endf = centf + half_df        
vnegnev: 
vnegnev:         # Calculate freq params
vnegnev:         # Two methods. Following, leading the ramp, is commented out.
vnegnev:         stepf = slopef * stept # freq increment per step
vnegnev:         stepaf = slopef * stepat #freq increment at start
vnegnev:         stepzf = slopef * stepzt #freq increment at end
vnegnev: 
vnegnev:         # Following is smoother
vnegnev: #        stepaf = slopef * stepat / 2 #freq increment at start
vnegnev: #        stepzf = slopef * stepzt * 3/2 #freq increment at end      
vnegnev: #        stepf = (2*half_df - stepzf - stepaf) / (self.segs-2) # freq increment per step
vnegnev: 
vnegnev:         print stepf*(self.segs-2)+stepaf+stepzf - 2*half_df
vnegnev:         
vnegnev:         self.startF = int(startf*fF)
vnegnev:         self.endF = int(endf*fF)
vnegnev: 
vnegnev:         self.stepaF = int(stepaf*fF)
vnegnev:         self.stepzF = int(stepzf*fF)
vnegnev:         self.stepF = int(stepf*fF)
vnegnev: 
vnegnev:         # A few checks
vnegnev:         if self.segs < 2:
vnegnev:             print "Error: duration too short!"
vnegnev:         if badf(startf) or badf(endf):
vnegnev:             print "Error: freq problem!"
vnegnev: 
vnegnev:     def calcf(self):
vnegnev:         k = 0
vnegnev:         kmax = (self.segs)*2
vnegnev:         tf = np.zeros((2,kmax+1))
vnegnev:         while k < kmax:
vnegnev:             if k == 0:
vnegnev:                 F = self.startF
vnegnev:                 T = 0
vnegnev:                 incF = self.stepaF
vnegnev:                 incT = self.stepaT
vnegnev:             elif k == (self.segs-1)*2:
vnegnev:                 incF = self.stepzF
vnegnev:                 incT = self.stepzT
vnegnev:             else:
vnegnev:                 incF = self.stepF
vnegnev:                 incT = stepT
vnegnev: 
vnegnev:             tf[0,k] = T
vnegnev:             tf[1,k] = F
vnegnev:             k+=1
vnegnev:             F += incF
vnegnev:             tf[0,k] = T
vnegnev:             tf[1,k] = F
vnegnev:             k+=1
vnegnev:             T += incT
vnegnev: 
vnegnev:             if k == kmax:
vnegnev:                 tf[0,k] = T
vnegnev:                 tf[1,k] = F
vnegnev: 
vnegnev:         return tf
vnegnev: 
vnegnev: def badf(freq):
vnegnev:     if freq<0.01 or freq>400: #below 10kHz or above 400MHz
vnegnev:         return 1
vnegnev:     return 0
vnegnev: 
vnegnev: a=Rect(1,10.499,80,5)
vnegnev: vec=a.calcf();
vnegnev: 
vnegnev: from pylab import *
vnegnev: 
vnegnev: 
vnegnev: plot1=plot(vec[0,:]*rest,vec[1,:]/fF,[0,a.totalt],np.array([a.startF,a.endF])/fF)
vnegnev: 
vnegnev: show()
vnegnev: 
vnegnev: #!/usr/bin/python2
vnegnev: ### pulse_test.py
vnegnev: # (c) Vlad Negnevitsky, 2011
vnegnev: #
vnegnev: # Puts trapezoid through its paces
vnegnev: 
vnegnev: import const as c
vnegnev: import pulse as p
vnegnev: import tables as t
vnegnev: import compile as cp
vnegnev: import pylab as pl
vnegnev: 
vnegnev: #pulses.append(p.Trapezoid(0.9, 21, 21, 62.5, 0.1, 50))
vnegnev: #pulses.append(p.Trapezoid(0.9, 21, 21, 62.5,  -0.1, 150))
vnegnev: #pulses.append(p.Arbitrary(lambda x:0.5-x/25.,21, lambda x:50+x, 250))
vnegnev: #pulses.append(p.Trapezoid(0.9, 21, 21, 62.5,  0.1, 350))
vnegnev: #pulses.append(p.Trapezoid(0.5, 9, 9, 62.5,  0.1, 450))
vnegnev: #pulses.append(p.Gaussian(0.5,21,62.5,0.1,550))
vnegnev: 
vnegnev: pulses = list(p.Gaussian(0.5,22,250,0.1,50+100*k) for k in range(2))
vnegnev: pulses.append(p.Trapezoid(0.9, 21, 21, 250,  0.1, 250))
vnegnev: pulses.append(p.Arbitrary(lambda x:0.5-x/32.,30, lambda x:250+0.244140625*x, 350))
vnegnev: 
vnegnev: vecDAF = t.concatD(pulses)
vnegnev: 
vnegnev: tabPulse = p.Table(t.dToTab(vecDAF))
vnegnev: tabPulse.tab[:,2] = list(int(round((70 + 0.8*k/c.tT)*c.fF)) for k in tabPulse.tab[:,0])
vnegnev: 
vnegnev: tabPulse.tab[:,2] = list(int(round((70 + 0.8*k/c.tT)*c.fF)) for k in tabPulse.tab[:,0])
vnegnev: 
vnegnev: vecDAF2 = tabPulse.calcd()
vnegnev: 
vnegnev: #pulses[2] = p.Table(pulses[2])
vnegnev: #pulses[2].tab[:,1] *= (pulses[2].tab[:,0] > 0)
vnegnev: 
vnegnev: trap = p.Trapezoid(0.9, 21, 21, 62.5,  0.1, 250)
vnegnev: trapT = p.Table(trap)
vnegnev: 
vnegnev: vecDAF3 = t.concatD(pulses)
vnegnev: 
vnegnev: import pdb;pdb.set_trace()
vnegnev: 
vnegnev: 
vnegnev: #vecTAF = t.dToPlot(vecDAF)
vnegnev: 
vnegnev: # Test
vnegnev: dL = pl.array([
vnegnev:         [1000, 100, 200,0],
vnegnev:         [150, 10,-10,1],
vnegnev:         [200,-20,-60,0],
vnegnev:         [190,-20,-5,2],
vnegnev:         [230,-10,-5,0],
vnegnev:         [150,-20,-5,0]]
vnegnev:         )
vnegnev: 
vnegnev: vecTAF=t.dToPlot(vecDAF2)
vnegnev: 
vnegnev: with open("freq_ramp_ch0.asm","w") as testf:
vnegnev: #    cp.compileD(dL, testf)
vnegnev: #    cp.compileD(vecDAF, testf)
vnegnev: 
vnegnev: with open("freq_ramp_ch1.asm","w") as testf:
vnegnev: #    cp.compileD(dL, testf)
vnegnev:     cp.compileD(vecDAF2, testf)
vnegnev: 
vnegnev: import pdb;pdb.set_trace()
vnegnev: 
vnegnev: fig = pl.figure(figsize=(6,4))
vnegnev: ax1 = fig.add_subplot(111)
vnegnev: ax1.plot(vecTAF[:,0]/c.tT, vecTAF[:,1]/c.aA*100,'g')
vnegnev: #ax1.plot(vecTAF[:,0], vecTAF[:,1],'g')
vnegnev: ax1.set_xlabel('Time (us)')
vnegnev: ax1.set_ylabel('Amplitude')
vnegnev: 
vnegnev: ax2 = ax1.twinx()
vnegnev: ax2.plot(vecTAF[:,0]/c.tT, vecTAF[:,2]/c.fF,'b')
vnegnev: #ax2.plot(vecTAF[:,0], vecTAF[:,2],'b')
vnegnev: ax2.set_ylabel('Frequency (MHz)')
vnegnev: 
vnegnev: pl.show()
vnegnev: #!/usr/bin/python2
vnegnev: # Vlad Negnevitsky, 2012
vnegnev: import pulse as p
vnegnev: import tables as t
vnegnev: import compile as cp
vnegnev: import const as c
vnegnev: import math as ma
vnegnev: import numpy as np
vnegnev: 
vnegnev: # Trapezoid args: amplitude, rise time, width of plateau, centre freq,
vnegnev: # freq slope, centre time
vnegnev: #
vnegnev: # Gaussian args: amplitude, width (FWHM; actual total width is
vnegnev: # larger), centre freq, freq slope, centre time
vnegnev: #
vnegnev: # Arbitrary args: amplitide function, width, frequency function,
vnegnev: # centre time
vnegnev: #
vnegnev: # Table args: either a pulse, or a diff table + start time. If a
vnegnev: # pulse, the table reads the essentials and converts the pulse into a
vnegnev: # table. If a diff table + start time, converts into a pulse.
vnegnev: 
vnegnev: 
vnegnev: # Let's initialise a pulse sequence
vnegnev: # pseq = [
vnegnev: # #    p.Trapezoid(0.6, 20, 30, 200, 0.8, 50),
vnegnev: #     p.Gaussian(0.9, 4, 200, -0.8, 10),
vnegnev: #     p.Gaussian(0.4, 25, 200, -0.8, 150),
vnegnev: #     p.Trapezoid(0.3, 20, 30, 200, -0.8, 250),
vnegnev: #     p.Arbitrary(
vnegnev: #         lambda time: 0.5 - 0.5 * (time/40.)**2,
vnegnev: #         80,
vnegnev: #         lambda time: 150 + 100 * (time/40.)**2,
vnegnev: #         350)]
vnegnev: 
vnegnev: pseq = [
vnegnev:     p.Trapezoid(0.1, 100, 200, 78, 0.006, 5000, 0),
vnegnev:     p.Gaussian(0.999, 10, 79, 0, 5500, 0)
vnegnev:     ]
vnegnev: 
vnegnev: # We want to make a copy of the 2nd Gaussian, but halve its amplitude
vnegnev: # past t_gaussian = 0. Here is how:
vnegnev: 
vnegnev: #gTab = p.Table(pseq[1]) # Table pulse reads in Gaussian and creates an
vnegnev:                         # internal list of its times, amps and freqs
vnegnev: 
vnegnev: #gt = gTab.tab[:,0] # extract all the times of the table
vnegnev: #ga = gTab.tab[:,1] # same for amplitudes
vnegnev: #ga *= 0.5*(gt < 0) + 0.5 # multiply amplitudes by a step function
vnegnev:                          # whose value is 1 left of the pulse's
vnegnev:                          # centre, 0 to the right
vnegnev: #gTab.tab[:,1] = ga # write back into the table
vnegnev: #gTab.centt = 450 # update centre time of table pulse
vnegnev: #pseq.append(gTab) # add to pulse sequence
vnegnev: 
vnegnev: # Next, we want to do a frequency sweep
vnegnev: 
vnegnev: # First, we generate a diff table from our existing pulse sequence
vnegnev: dif = t.concatD(pseq)
vnegnev: 
vnegnev: # Next, make a table pulse from the entire sequence's diff
vnegnev: # table. Start time is 0, in which case the times of the original
vnegnev: # pulse sequence are unchanged.
vnegnev: pseqTab = p.Table(t.dToTab(dif), 0)
vnegnev: 
vnegnev: # Parameterise frequency as a function of time
vnegnev: pseqt = pseqTab.tab[:,0]
vnegnev: 
vnegnev: # c.tT and c.fF are quantisation factors
vnegnev: pseqf = (np.round( (50 + (0.008 * pseqt / c.tT)) * c.fF)).astype(int)
vnegnev: pseqTab.tab[:,2] = pseqf
vnegnev: 
vnegnev: # Next, we generate a diff table from the freq-ramping sequence
vnegnev: dif2 = pseqTab.calcd()
vnegnev: 
vnegnev: # Then, can compile the diff tables
vnegnev: with open("test_ch0.asm","w") as test0:
vnegnev:     cp.compileD(dif, test0)
vnegnev: 
vnegnev: with open("test_ch1.asm","w") as test1:
vnegnev:     cp.compileD(dif2, test1)
vnegnev:     
vnegnev: # Can plot just as easily
vnegnev: plot0 = t.dToPlot(dif)
vnegnev: plot1 = t.dToPlot(dif2)
vnegnev: 
vnegnev: import pylab as pl
vnegnev: # Conversions go from discrete values to us/amp percentages/MHz
vnegnev: fig = pl.figure(figsize=(12,10))
vnegnev: 
vnegnev: ax1 = fig.add_subplot(211)
vnegnev: ax1.plot(plot0[:,0]/c.tT, plot0[:,1] / c.aA, 'r') #amps against times
vnegnev: ax2=ax1.twinx()
vnegnev: ax2.plot(plot0[:,0]/c.tT, plot0[:,2] / c.fF, 'g' ) #freqs against times
vnegnev: ax1.set_xlabel('Time (us)')
vnegnev: ax1.set_ylabel('Amplitude (arb)')
vnegnev: ax2.set_ylabel('Freq (MHz)')
vnegnev: 
vnegnev: ax3 = fig.add_subplot(212)
vnegnev: ax3.plot(plot1[:,0]/c.tT, plot1[:,1] / c.aA, 'r') #amps against times
vnegnev: ax4=ax3.twinx()
vnegnev: ax4.plot(plot1[:,0]/c.tT, plot1[:,2] / c.fF, 'g' ) #freqs against times
vnegnev: ax3.set_xlabel('Time (us)')
vnegnev: ax3.set_ylabel('Amplitude (arb)')
vnegnev: ax4.set_ylabel('Freq (MHz)')
vnegnev: 
vnegnev: pl.show()
vnegnev: #!/usr/bin/python2
vnegnev: # Vlad Negnevitsky, 2012
vnegnev: import pulse as p
vnegnev: import tables as t
vnegnev: import compile as cp
vnegnev: import const as c
vnegnev: import math as ma
vnegnev: import numpy as np
vnegnev: 
vnegnev: # Trapezoid args: amplitude, rise time, width of plateau, centre freq,
vnegnev: # freq slope, centre time
vnegnev: #
vnegnev: # Gaussian args: amplitude, width (FWHM; actual total width is
vnegnev: # larger), centre freq, freq slope, centre time
vnegnev: #
vnegnev: # Arbitrary args: amplitide function, width, frequency function,
vnegnev: # centre time
vnegnev: #
vnegnev: # Table args: either a pulse, or a diff table + start time. If a
vnegnev: # pulse, the table reads the essentials and converts the pulse into a
vnegnev: # table. If a diff table + start time, converts into a pulse.
vnegnev: 
vnegnev: 
vnegnev: # Let's initialise a pulse sequence
vnegnev: pseq = [
vnegnev: #    p.Trapezoid(0.6, 20, 30, 200, 0.8, 50),
vnegnev:     p.Gaussian(0.9, 50, 200, -0.8, 200, 0),
vnegnev:     p.Gaussian(0.9, 50, 200, -0.8, 400, 0)
vnegnev: #    p.Gaussian(0.4, 25, 200, -0.8, 150, 0),
vnegnev: #    p.Trapezoid(0.3, 20, 30, 200, -0.8, 250, 0),
vnegnev: #    p.Arbitrary(
vnegnev: #        lambda time: 0.5 - 0.5 * (time/40.)**2,
vnegnev: #        80,
vnegnev: #        lambda time: 150 + 100 * (time/40.)**2,
vnegnev: #        350)]
vnegnev:     ]
vnegnev: 
vnegnev: pseqD = t.concatD(pseq)
vnegnev: 
vnegnev: pseq1 = [    p.Gaussian(0.9, 50, 200, -0.8, 200, 0),
vnegnev:     p.Gaussian(0.9, 50, 200, -0.8, 400, 0)
vnegnev:     ]
vnegnev: 
vnegnev: 
vnegnev: with open("loop_test0.asm", "w") as test0:
vnegnev:     cp.compileD(pseqD, test0)
vnegnev: 
vnegnev: with open("loop_test1.asm","w") as test1:
vnegnev:     pseq1D = t.concatD(pseq1)
vnegnev:     cp.compileD(pseq1D, test1, True, True, False, False, True)
vnegnev: 
vnegnev:     # Flip phase of second Gaussian
vnegnev:     pseq1[1].startP = int(round(180*c.pP))
vnegnev:     pseq1D = t.concatD(pseq1)
vnegnev:     cp.compileD(pseq1D, test1, True, False, True, False, True)
vnegnev:         
vnegnev: # Call caspr
vnegnev: #!/usr/bin/python2
vnegnev: ### RFJUICE.PY
vnegnev: # (c) Vlad Negnevitsky, 2011
vnegnev: #
vnegnev: #
vnegnev: # This project compiles .PULSE pulse sequence descriptions into
vnegnev: # assembly programs ready to run on the RfBlaster.
vnegnev: #
vnegnev: # TODO: insert documentation
vnegnev: 
vnegnev: # parts of this project
vnegnev: import const as c
vnegnev: import tables as t
vnegnev: import util as u
vnegnev: import pulse as p
vnegnev: import compile as cp
vnegnev: import numpy as np
vnegnev: from copy import copy
vnegnev: 
vnegnev: def clr_phases(pulse_list):
vnegnev:     """Return a pulse list with 0 phases"""
vnegnev:     pul_cp = []
vnegnev:     for pul in pulse_list:
vnegnev:         pul.startP = 0
vnegnev: 
vnegnev: def increment_phase(pulse_list,pulse_no, ph):
vnegnev:     """Increment the start phase of a specific pulse in the sequence
vnegnev:     by a given amount (in degrees)"""
vnegnev:     pulse_list[pulse_no].startP += int(round(ph*c.pP))
vnegnev: 
vnegnev: def set_phase(pulse_list,pulse_no, ph):
vnegnev:     """Set the start phase of a specific pulse in the sequence
vnegnev:     to a given value (in degrees)"""
vnegnev:     pulse_list[pulse_no].startP = int(round(ph*c.pP))
vnegnev: 
vnegnev: def add_dwell(pul, enda, endf, dwellt):
vnegnev:     pul.tab = np.r_[pul.tab,
vnegnev:                 [[
vnegnev:                 int(round(dwellt*c.tT)) + pul.tab[-1,0], # Convert dwell delay into an absolute time
vnegnev:                 int(round(enda*c.aA)),
vnegnev:                 int(round(endf*c.fF)),
vnegnev:                 0]]]
vnegnev:     
vnegnev: def rfjuice(pulse_in="default.pulse",asm_out0="output_ch0.asm",asm_out1="output_ch1.asm",trig_pulse=None,ph_swp=None,dwell=False,plot=False):
vnegnev:     """Compiles a pulse file into blast_fsm assembly. Uses a narrow subset of rfjuice capabilities.
vnegnev: 
vnegnev:     pulse_in: file name to read
vnegnev: 
vnegnev:     asm_out[0,1]: assembly files to output
vnegnev: 
vnegnev:     plot: whether to display the sequences or not
vnegnev: 
vnegnev:     If ph_swp is passed, rfjuice compiles a series of pulse
vnegnev:     sequences into Ch 1, separated by triggers. Ch 0 remains
vnegnev:     defaulted.
vnegnev:     
vnegnev:     ph_swp: dictionary with the following keys:
vnegnev:        start_deg: start angle, added to pulse's phase as specified in pulse file
vnegnev:        stop_deg: stop angle, added to pulse's phase as specified in pulse file
vnegnev:        num: number of unique phases
vnegnev:        pul_num : pulse whose phase to sweep (eg 4 will sweep the 5th pulse's phase in the sequence); multiple can be entered using comma
vnegnev:        print_phases: whether to display a list of phases being set
vnegnev:        (optional) swp_loops: times to loop over the sweep
vnegnev:        (optional) stat_loops: times to loop over the stationary phase
vnegnev:     """
vnegnev: 
vnegnev: #    pulse_in = "default.pulse"
vnegnev:     asm_out = [asm_out0,asm_out1]
vnegnev: 
vnegnev:     # Create a pulse sequence from the pulse file
vnegnev:     pulse_params = []
vnegnev:     with open(pulse_in) as pulsef:
vnegnev:         for line in pulsef:
vnegnev:             if line[0] is not '#':
vnegnev:                 pulse_par = line.split(',')
vnegnev:                 pulse_par = map(float,pulse_par)
vnegnev:                 pulse_params.append(pulse_par)
vnegnev: 
vnegnev:     # Process parameters
vnegnev:     dds1_startf = pulse_params[2][0] # start ramp freq, MHz
vnegnev:     dds1_rampf = pulse_params[3][0] / c.msus # ramp rate, MHz/us
vnegnev:     final_dwell = pulse_params[4][0] * c.msus # dwell time at end of sequence, us
vnegnev:     
vnegnev:     dds0_endf = pulse_params[5][0]
vnegnev:     dds0_enda = pulse_params[5][1]
vnegnev:     dds1_endf = pulse_params[5][2]
vnegnev:     dds1_enda = pulse_params[5][3]
vnegnev: 
vnegnev:     # Throw away start of parameters, leaving only genuine pulses
vnegnev:     pulse_params = pulse_params[6:]
vnegnev: 
vnegnev:     # Pulse object list
vnegnev:     pulses0=[]
vnegnev: 
vnegnev:     # if dds_ch == 0:
vnegnev:     #     pulses0.append(pulse.Arbitrary(arb_amp, 7, arb_freq, 50)) # units in us
vnegnev:     #     pulses0.append(pulse.Arbitrary(arb_amp, 7, arb_freq, 150)) # units in us
vnegnev: 
vnegnev:     # Create pulse sequence
vnegnev:     for pulse_cfg in pulse_params:
vnegnev:         if pulse_cfg[0] > 0.5 : # 1 -> Trapezoid
vnegnev:             pulses0.append(p.Trapezoid(
vnegnev:                     pulse_cfg[2], # amp
vnegnev:                     pulse_cfg[4] * c.msus, # rise
vnegnev:                     pulse_cfg[3] * c.msus, # width
vnegnev:                     pulse_cfg[5], # cent freq
vnegnev:                     pulse_cfg[6] / c.msus, # freq slope
vnegnev:                     pulse_cfg[1] * c.msus, #centre time
vnegnev:                     pulse_cfg[7]  # phase offset
vnegnev:                     ) )
vnegnev:         else:
vnegnev:             pulses0.append( p.Gaussian(
vnegnev:                     pulse_cfg[2], # amp
vnegnev:                     pulse_cfg[3] * c.msus, # width
vnegnev:                     pulse_cfg[5], # cent freq
vnegnev:                     pulse_cfg[6] / c.msus, # freq slope
vnegnev:                     pulse_cfg[1] * c.msus, #centre time
vnegnev:                     pulse_cfg[7]  # phase offset
vnegnev:                     ) )
vnegnev: 
vnegnev:     # Add a trigger pulse to Ch0
vnegnev:     pulses1 = copy(pulses0)
vnegnev:     if trig_pulse is not None:
vnegnev:         trp = { # trigger pulse params
vnegnev:             'amp_fn': lambda x:trig_pulse['amp'],
vnegnev:             'width': 2*c.stept, # minimum width
vnegnev:             'freq_fn': lambda x:trig_pulse['freq'],
vnegnev:             'centt': trig_pulse['time']}
vnegnev:         pulses0.insert(0,p.Arbitrary(**trp))
vnegnev:         trp['amp_fn'] = lambda x:0.0 # set to 0 amplitude for Ch1
vnegnev:         pulses1.insert(0,p.Arbitrary(**trp))
vnegnev:             
vnegnev:     # Generate diff table from the pulse sequence for Ch0
vnegnev:     pulsed0    = t.concatD(pulses0)
vnegnev: 
vnegnev:     # Generate diff table for Ch1
vnegnev:     pulsed1 = t.concatD(pulses1)
vnegnev:     
vnegnev:     # Generate a table for Channel 0
vnegnev:     pulseTab0 = p.Table(t.dToTab(pulsed0))
vnegnev: 
vnegnev:     # Generate a table for Channel 1
vnegnev:     pulseTab1 = p.Table(t.dToTab(pulsed1))
vnegnev: 
vnegnev:     # Set all phase steps on Channel 0 to 0
vnegnev:     pulseTab0.tab[:,3] = np.zeros_like(pulseTab0.tab[:,3])
vnegnev:     
vnegnev:     # Implement a frequency sweep on 2nd channel
vnegnev:     # Take time data, multiply by sweep rate, add offset freq (all with conversions)
vnegnev:     pulseTab1.tab[:,2] = (np.round( (dds1_startf + (dds1_rampf * pulseTab1.tab[:,0] / c.tT)) * c.fF)).astype(int)
vnegnev: 
vnegnev:     # Add the final dwell to the end of both sequence tables
vnegnev:     if dwell:
vnegnev:         add_dwell(pulseTab0,dds0_enda,dds0_endf,final_dwell)
vnegnev:         add_dwell(pulseTab1,dds1_enda,dds1_endf,final_dwell)    
vnegnev: 
vnegnev:     # Create diff tables (overwrite earlier pulsed[0,1] with new ones (BAD PRACTICE))
vnegnev:     pulsed0 = pulseTab0.calcd()
vnegnev:     pulsed1 = pulseTab1.calcd()
vnegnev:     if plot:
vnegnev:         pulsed1_plot = pulsed1
vnegnev:         difft = []
vnegnev: 
vnegnev:     with open(asm_out[0],'w') as outf: # write channel 0
vnegnev:         cp.compileD(pulsed0, outf)
vnegnev: 
vnegnev:     if ph_swp is None: # Single phase
vnegnev:         with open(asm_out[1],'w') as outf: # write channel 1
vnegnev:             cp.compileD(pulsed1, outf)
vnegnev:     else: # Repetitive phase increment
vnegnev:         with open(asm_out[1],'w') as outf: # write channel 1
vnegnev:             pul_inds = np.array(ph_swp['pul_num'],dtype=int)+1 # the +1 is to skip the 'trigger pulse'
vnegnev:             startP = int(round( ph_swp['start_deg'] * c.pP))
vnegnev:             endP = int(round( ph_swp['stop_deg'] * c.pP))
vnegnev:             phases = np.round(np.linspace(startP,endP,ph_swp['num'])).astype(int)
vnegnev: 
vnegnev:             #import pdb;pdb.set_trace()
vnegnev:             
vnegnev:             if ph_swp['print_phases']:
vnegnev:                 for k in pul_inds-1:
vnegnev:                     print "Phases for pulse",k,":", np.round( (pulses1[k+1].startP + phases)/c.pP,3) % 360.
vnegnev: 
vnegnev:             orig_pulsesP = list(pul.startP for pul in pulses1)
vnegnev: 
vnegnev:             # Looping section
vnegnev:             for Pstep, P in enumerate(phases):
vnegnev:                 firstP = (Pstep == 0) # first phase
vnegnev:                 lastP = (Pstep == ph_swp['num']-1)
vnegnev:                 for k in pul_inds:
vnegnev:                     pulses1[k].startP = orig_pulsesP[k]+P
vnegnev:                 pd1 = t.concatD(pulses1)
vnegnev:                 pT1 = p.Table(t.dToTab(pd1))
vnegnev:                 pT1.tab[:,2] = (np.round( (dds1_startf + (dds1_rampf * pT1.tab[:,0] / c.tT)) * c.fF)).astype(int)
vnegnev:                 if dwell:
vnegnev:                     add_dwell(pT1,dds1_enda,dds1_endf,final_dwell)
vnegnev:                 pd1 = pT1.calcd()
vnegnev: 
vnegnev:                 if ph_swp['loops']:
vnegnev:                     # Loop over phases; don't unconditionally jump from end
vnegnev:                     compileD_d = {
vnegnev:                         'init':firstP,
vnegnev:                         'start_trig':True,
vnegnev:                         'jump_to_start':firstP,
vnegnev:                         'jump_from_end':False,
vnegnev:                         'loop_to_start':ph_swp['swp_loops']*firstP, # 0 for all but first pulse
vnegnev:                         'loop_from_end':lastP, # if last phase
vnegnev:                         'local_loop_pre':str(Pstep)}
vnegnev:                 else:
vnegnev:                     compileD_d = {
vnegnev:                         'init':firstP,
vnegnev:                         'start_trig':True,
vnegnev:                         'jump_to_start':firstP,
vnegnev:                         'jump_from_end':lastP,
vnegnev:                         'loop_to_start':0,
vnegnev:                         'loop_from_end':False,
vnegnev:                         'local_loop_pre':str(Pstep)}
vnegnev:                     
vnegnev:                 cp.compileD(pd1, outf,**compileD_d)
vnegnev: 
vnegnev:                 if plot:
vnegnev:                     difft.append(pd1)
vnegnev: 
vnegnev:             if ph_swp['loops']:
vnegnev:                 ## Repeat phase sweep for plotting
vnegnev:                 if plot:
vnegnev:                     difft *= ph_swp['swp_loops']
vnegnev: 
vnegnev:                 ## Loop over constant pulse
vnegnev:                 cp.compileD(pulsed1,outf,
vnegnev:                             init=False,
vnegnev:                             start_trig=True,
vnegnev:                             jump_to_start=False,
vnegnev:                             jump_from_end=True,
vnegnev:                             loop_to_start = ph_swp['stat_loops'],
vnegnev:                             loop_from_end = True,
vnegnev:                             local_loop_pre = 'stat',
vnegnev:                             loop_pre = 'lop_stat');
vnegnev: 
vnegnev:                 if plot:
vnegnev:                     for k in xrange(ph_swp['stat_loops']):
vnegnev:                         difft.append(pulsed1)
vnegnev: 
vnegnev:             if plot:
vnegnev:                 pulsed1_plot = t.concatD(difft)
vnegnev:                     
vnegnev:     # Plot (optional)
vnegnev:     if plot:
vnegnev:         import pylab as pl
vnegnev:         # Conversions go from discrete values to us/amp percentages/MHz
vnegnev:         fig = pl.figure(figsize=(12,10))
vnegnev:         plot0 = t.dToPlot(pulsed0)
vnegnev:         plot1 = t.dToPlot(pulsed1_plot)
vnegnev: 
vnegnev:         ax1 = fig.add_subplot(211)
vnegnev:         ax1.plot(plot0[:,0]/c.tT, plot0[:,1] / c.aA, 'r') #amps against times
vnegnev:         ax1.plot(plot0[:,0]/c.tT, (plot0[:,3] / c.pP / 360.)%1, 'b') #phase against times
vnegnev:         ax2=ax1.twinx()
vnegnev:         ax2.plot(plot0[:,0]/c.tT, plot0[:,2] / c.fF, 'g' ) #freqs against times
vnegnev:         ax1.set_xlabel('Time (us)')
vnegnev:         ax1.set_ylabel('Amplitude (arb)')
vnegnev:         ax2.set_ylabel('Freq (MHz)')
vnegnev: 
vnegnev:         ax3 = fig.add_subplot(212)
vnegnev:         ax3.plot(plot1[:,0]/c.tT, plot1[:,1] / c.aA, 'r') #amps against times
vnegnev:         ax3.plot(plot1[:,0]/c.tT, (plot1[:,3] / c.pP / 360.)%1, 'b') #phase against times
vnegnev:         ax4=ax3.twinx()
vnegnev:         ax4.plot(plot1[:,0]/c.tT, plot1[:,2] / c.fF, 'g' ) #freqs against times
vnegnev:         ax3.set_xlabel('Time (us)')
vnegnev:         ax3.set_ylabel('Amplitude (arb)')
vnegnev:         ax4.set_ylabel('Freq (MHz)')
vnegnev: 
vnegnev:         pl.show()
vnegnev: ### TABLES.PY
vnegnev: # (c) Vlad Negnevitsky, 2012
vnegnev: #
vnegnev: # Table operations, including plot concatenation, and conversion from
vnegnev: # absolute to diff
vnegnev: # 
vnegnev: # Plots a given pulse sequence.
vnegnev: 
vnegnev: import numpy as np
vnegnev: 
vnegnev: import const as c
vnegnev: 
vnegnev: def concatPlot(pulselist):
vnegnev:     """Generates a plottable list of times, amps, freqs and phases
vnegnev: 
vnegnev:     The list is in format
vnegnev:     [[time, amp,freq,  ph], 
vnegnev:     [next_time, amp,freq, ph],
vnegnev:     [next_time, next_amp, next_freq, ph],
vnegnev:     [later_time, next_amp, next_freq, ph],
vnegnev:     ...
vnegnev:     ]
vnegnev:     """
vnegnev: 
vnegnev:     # Generate a single vector of differences out of the pulse list
vnegnev:     tot_pts = 2
vnegnev: 
vnegnev:     for pul in pulselist:
vnegnev:         tot_pts += 2 * (pul.segs + 1)
vnegnev:     
vnegnev:     vecTAFP = np.zeros((tot_pts, 4), dtype='i') # vector of absolute times, amps,
vnegnev:                                     # freqs
vnegnev: 
vnegnev:     shiftVals = False # alternate between value and time steps; start
vnegnev:                       # with timestep, then write value
vnegnev:     
vnegnev:     # time, amp, freq step (or initial value, as below)
vnegnev:     TAFP = np.array([0,0,pulselist[0].startF,pulselist[0].startP],dtype="i") # zero time, zero amp, initial freq, initial phase
vnegnev:     vecTAFP[0] = TAFP
vnegnev:     
vnegnev:     m = 1 # row counter
vnegnev:     prevPul = None
vnegnev: 
vnegnev:     for pul in pulselist:
vnegnev:         
vnegnev:         pd = pul.calcd()
vnegnev: 
vnegnev:         # At start of pulse, step time to pulse start
vnegnev:         
vnegnev:         if prevPul is None:
vnegnev:             TAFP[0] += int( (pul.centt- pul.totalt/2)*c.tT)
vnegnev:         else:
vnegnev:             TAFP[0] += int( (pul.centt - prevPul.centt - pul.totalt/2 - prevPul.totalt/2)*c.tT)
vnegnev: 
vnegnev:         vecTAFP[m] = TAFP
vnegnev:         m += 1
vnegnev:         TAFP[1:] = pul.startA, pul.startF, pul.startP
vnegnev:         vecTAFP[m] = TAFP
vnegnev:         m += 1
vnegnev: 
vnegnev:         k = 0
vnegnev:         kmax = pd.shape[0]
vnegnev: 
vnegnev:         while k < kmax:
vnegnev:             if shiftVals:
vnegnev:                 TAFP[1] += pd[k,1]
vnegnev:                 TAFP[2] += pd[k,2]
vnegnev:                 TAFP[3] += pd[k,3]
vnegnev:                 k += 1
vnegnev:             else:
vnegnev:                 TAFP[0] += pd[k,0]
vnegnev:             vecTAFP[m] = TAFP
vnegnev:             m += 1
vnegnev:             shiftVals = not shiftVals
vnegnev: 
vnegnev:         prevPulse = pul
vnegnev:             
vnegnev:     TAFP[0] += c.c.stepT
vnegnev:     vecTAFP[m] = TAFP
vnegnev:                     
vnegnev:     return vecTAFP
vnegnev: 
vnegnev: def concatTab(pulselist):
vnegnev:     """Generates a table of durations, amplitudes and frequencies
vnegnev: 
vnegnev:     Output is in the format:
vnegnev:     [[duration, amp, freq],
vnegnev:     [next_duration, next_amp, next_freq],
vnegnev:     ...
vnegnev:     ]
vnegnev: 
vnegnev:     A 2us pulse, starting at 10us going to 50% amplitude and 250 MHz
vnegnev:     freq, would be something like
vnegnev:     [[750, 0, 0], [150, 2^13, 2^30], [?, 0, 2^30]]
vnegnev: 
vnegnev:     A freq value of 0 means that we don't care about it.
vnegnev:     """
vnegnev: 
vnegnev:     tot_pts = 0
vnegnev: 
vnegnev:     for pul in pulselist:
vnegnev:         tot_pts += (pul.segs + 1) # segments, plus initial silence at
vnegnev:                                   # the start of each
vnegnev: 
vnegnev:     vecDAF = np.zeros((tot_pts,3), dtype='i')
vnegnev: 
vnegnev:     # duration, amp, freq array
vnegnev:     DAF = np.array([0,0,0])
vnegnev: 
vnegnev:     m = 0 # vecDAF row counter
vnegnev: 
vnegnev:     for pul in pulselist:
vnegnev:         pd = pul.calcd() # obtain differences
vnegnev:     
vnegnev:         # Start of pulse
vnegnev:         DAF[:] = pul.startDelay,0,0
vnegnev:         
vnegnev:         vecDAF[m] = DAF
vnegnev:         m += 1
vnegnev: 
vnegnev:         DAF[:] = pd[0,0], pul.startA, pul.startF
vnegnev:         vecDAF[m] = DAF
vnegnev:         m += 1
vnegnev:         
vnegnev:         # Pulse segments
vnegnev:         for k in range(len(pd)-1):
vnegnev:             DAF[0] = pd[k+1,0] # time step
vnegnev:             DAF[1:] += pd[k,1:] # amp/freq
vnegnev: 
vnegnev:             vecDAF[m] = DAF
vnegnev:             m += 1
vnegnev:             
vnegnev:     return vecDAF
vnegnev: 
vnegnev: def concatD(pulseList):
vnegnev:     """Concatenates together a series of pulse-difference lists. Can
vnegnev:     be passed any combination of pulses or diff tables, and makes a
vnegnev:     single long one. Pulse objects must have internal timing
vnegnev:     information (centt, etc)."""
vnegnev: 
vnegnev:     # Write out individual difference lists
vnegnev: 
vnegnev:     dList=None
vnegnev: 
vnegnev:     # Total freq, amp and ph shifts due to current pulse
vnegnev:     ashift = 0
vnegnev:     fshift = 0
vnegnev:     pshift = 0
vnegnev: 
vnegnev:     prevPul = None
vnegnev:     for pul in pulseList:
vnegnev:         if type(pul) is np.ndarray:
vnegnev:             pulIsD = True
vnegnev:             d = pul.copy()
vnegnev:         else:
vnegnev:             pulIsD = False
vnegnev:             d = pul.calcd()
vnegnev: 
vnegnev:         # Loop vector
vnegnev:         loops = 1 + d[:,4]
vnegnev:         # Startup time
vnegnev:         if prevPul is not None:
vnegnev:             if not pulIsD:
vnegnev:                 d[0,0] = int( (pul.centt - prevPul.centt - pul.totalt/2 - prevPul.totalt/2)*c.tT + 0.5)
vnegnev: 
vnegnev:         # Compensate shift of previous pulse, return to 0 reference
vnegnev:         d[0,1] -= ashift 
vnegnev:         d[0,2] -= fshift 
vnegnev:         d[0,3] -= pshift 
vnegnev: 
vnegnev:         if d[0,0] < c.stepT:
vnegnev:             print "Error, segment is too short. Maybe your pulses overlap?"
vnegnev: 
vnegnev:         ashift += sum(d[:,1]*loops)
vnegnev:         fshift += sum(d[:,2]*loops)
vnegnev:         pshift += sum(d[:,3]*loops)
vnegnev:         prevPul = pul
vnegnev:         
vnegnev:         if dList is None:
vnegnev:             dList=d
vnegnev:         else:
vnegnev:             dList=np.r_[dList,d]
vnegnev: 
vnegnev:     return dList
vnegnev: 
vnegnev: def dToTab(dList):
vnegnev:     """ Convert an input list of params + loops into a table-style
vnegnev:     list suitable for the Table pulse.
vnegnev: 
vnegnev:     Table format: time (of each amp/freq change), amp, freq, phase
vnegnev:     """
vnegnev: 
vnegnev:     tot_rows = len(dList) + sum(dList[:,4])
vnegnev:     tabList = np.zeros([tot_rows,4],dtype="i")
vnegnev: 
vnegnev:     time = dList[0,0]
vnegnev:     amp = dList[0,1]
vnegnev:     freq = dList[0,2]
vnegnev:     ph = dList[0,3]
vnegnev: 
vnegnev:     tabList[0] = [time,amp,freq,ph]
vnegnev: 
vnegnev:     # Row counter
vnegnev:     m = 1
vnegnev: 
vnegnev:     # Loop over all rows in diff list
vnegnev:     for pd in dList[1:]:
vnegnev: 
vnegnev:         # Unroll internal loops
vnegnev:         for n in range(pd[4]+1):
vnegnev:             time += pd[0]
vnegnev:             amp += pd[1]
vnegnev:             freq += pd[2]
vnegnev:             ph += pd[3]
vnegnev:             tabList[m] = [time,amp,freq,ph]
vnegnev:             m += 1
vnegnev: 
vnegnev:     return tabList
vnegnev: 
vnegnev: def dToPlot(dList):
vnegnev:     """Convert an input list of params + loops into a plottable list
vnegnev:     of absolute times, amps and freqs.
vnegnev: 
vnegnev:     The input list is in format
vnegnev:     [[first step, first amp, first freq],
vnegnev:     [next step, amp step, freq step],
vnegnev:     [later step, amp step, freq step],
vnegnev:     ...
vnegnev:     ]
vnegnev:     
vnegnev:     The output list is in format
vnegnev:     [[time, freq, amp], 
vnegnev:     [next_time, freq,amp],
vnegnev:     [next_time, next_freq, next_amp],
vnegnev:     [later_time, next_freq, next_amp],
vnegnev:     ...
vnegnev:     ]
vnegnev:     """
vnegnev: 
vnegnev:     # total number of points needed
vnegnev:     tot_pts = 2 + 2*(len(dList) + sum(dList[:,4]))
vnegnev: 
vnegnev:     # list of absolute times, amps, freqs and phases
vnegnev:     plotList = np.zeros((tot_pts,5), dtype="i") #unsigned 32bit ints
vnegnev: 
vnegnev:     # alternate between value and time steps
vnegnev:     stepVals = False
vnegnev: 
vnegnev:     # absolute time, amp and freq: assumed that time and amp start at 0
vnegnev:     TAFP = np.array([0,0,dList[0,2],dList[0,3],dList[0,4]],dtype="i")
vnegnev:     plotList[0] = TAFP
vnegnev: 
vnegnev:     TAFP[0] += dList[0,0]
vnegnev:     plotList[1] = TAFP # First time step
vnegnev:     TAFP[1] += dList[0,1]
vnegnev:     plotList[2] = TAFP # First value step
vnegnev: 
vnegnev:     m = 3 # plotList row index
vnegnev:     k = 1 # dList row index
vnegnev:     kmax = len(dList)
vnegnev:     
vnegnev:     while k < kmax:
vnegnev:         pd = dList[k]
vnegnev:         
vnegnev:         # Unroll internal loops
vnegnev:         n = 0 # loop index
vnegnev:         nmax = pd[4]
vnegnev:         while n <= nmax:
vnegnev:             if stepVals:
vnegnev:                 TAFP[1] += pd[1]
vnegnev:                 TAFP[2] += pd[2]
vnegnev:                 TAFP[3] += pd[3]
vnegnev:                 if n == nmax:
vnegnev:                     k += 1
vnegnev:                 n += 1
vnegnev:             else:
vnegnev:                 TAFP[0] += pd[0]
vnegnev:             plotList[m] = TAFP
vnegnev:             m += 1
vnegnev:             stepVals = not stepVals
vnegnev: 
vnegnev:     # Small step at the end, purely to tail off the plot
vnegnev:     TAFP[0] += c.stepT
vnegnev:     plotList[-1] = TAFP
vnegnev: 
vnegnev:     return plotList
vnegnev: # Utility functions
vnegnev: import math as m
vnegnev: import const as c
vnegnev: 
vnegnev: def instr(opcode, par=None, reg=None, pre=c.indent):
vnegnev:     """Produce a standard instruction, with optional numeric parameters.
vnegnev:     
vnegnev:     str: instruction body
vnegnev:     para: parameter, when instructions require one
vnegnev:     reg: register, when instructions require one
vnegnev:     pre: can replace default with, say, 'LOOP1: ' etc.
vnegnev:     """
vnegnev:     
vnegnev:     wrstr = pre + ' ' +opcode
vnegnev:     if par is not None:
vnegnev:         if par < 0:
vnegnev:             wrstr += ' (0' + str(par) + ')'
vnegnev:         else:
vnegnev:             wrstr += ' ' + str(par)
vnegnev:     if reg is not None:
vnegnev:         wrstr += ' ' + c.regdict[reg]
vnegnev:     wrstr += "\n"
vnegnev: 
vnegnev:     return wrstr    
vnegnev: 
vnegnev: def cfg_dds(ch = 0):
vnegnev:     """DDS initialisation boilerplate.
vnegnev:     
vnegnev:     ch: specifies DDS channel.
vnegnev:     """
vnegnev: 
vnegnev:     dds_ioupdate_rate = 125 #250 MHz / 4 / 125 = 500 kHz (2us updates)
vnegnev:     
vnegnev:     cfr_common_str = """
vnegnev: 
vnegnev:         ;; internal update rate
vnegnev:         setr """ + hex(dds_ioupdate_rate >> 8) + """ R0
vnegnev:         setcfr """ + hex(dds_ioupdate_rate & 0xff) + """ 0x04 0x0e R0
vnegnev: 
vnegnev: 	;; CFR 3 config
vnegnev: 	setr 0x1d3f59 R0
vnegnev: 	setcfr 0x28 0x02 0x0e R0 ; 0x28 for 50 MHz clock; for 10 MHz need 0xc8
vnegnev:         dir (WRDDS|DDSUPD|WT_TIM|TMRADD) 150 0  ; 2us
vnegnev: 
vnegnev: 	;; CFR 2 config, sync err detect off
vnegnev: 	setr 0x014000 R0 
vnegnev: 	setcfr 0xa0 0x01 0x0e R0
vnegnev: 	dir (WRDDS|WT_TIM|TMRADD) 150 0  ; 2us
vnegnev: 
vnegnev: """
vnegnev:     
vnegnev:     if ch:
vnegnev:         return """;;; CHANNEL 1 CONFIGURE DDS
vnegnev: 
vnegnev: """ + cfr_common_str + """
vnegnev:         ;; Multichip sync config; recv only
vnegnev:         setr 0x280000 R0
vnegnev: 	setcfr 0xc8 0x0a 0x0e R0 ;
vnegnev:         dir (WRDDS|DDSUPD|WT_TIM|TMRADD)  150 0 ; 2us
vnegnev: 
vnegnev: 	;; CFR 2 config, sync err detect on
vnegnev: 	setr 0x014000 R0
vnegnev: 	setcfr 0x80 0x01 0x0e R0
vnegnev: 
vnegnev:  START: dir (WRDDS|DDSUPD|WT_TIM|TMRADD) 150 0  ; 2us
vnegnev: 
vnegnev: """
vnegnev:     else:
vnegnev:         return """;;; CHANNEL 0 CONFIGURE DDS
vnegnev: 
vnegnev: """ + cfr_common_str + """
vnegnev:         ;; Multichip sync config; recv + send
vnegnev:         setr 0x2c0000 R0
vnegnev: 	setcfr 0xd0 0x0a 0x0e R0 ;
vnegnev:         dir (WRDDS|DDSUPD|WT_TIM|TMRADD)  150 0 ; 2us
vnegnev: 
vnegnev: 	;; CFR 2 config, sync err detect on
vnegnev: 	setr 0x014000 R0
vnegnev: 	setcfr 0x80 0x01 0x0e R0
vnegnev:         dir (WRDDS|DDSUPD|WT_TIM|TMRADD) 150 0 ; 2us
vnegnev: 
vnegnev:         ;; Clear phase
vnegnev:         setr 0x004108 R0
vnegnev:         setcfr 0x00 0x00 0x0e R0
vnegnev:  START: dir (WRDDS|DDSUPD|WT_TIM|TMRADD) 150 0  ; 2us
vnegnev: 
vnegnev: """
vnegnev: 
vnegnev: def init_asm():
vnegnev:     """ASM file initialisation boilerplate
vnegnev:     
vnegnev:     """
vnegnev:     return """;; Autogenerated by rfjuice.
vnegnev: ;; Please do not edit unless you know what you're doing.
vnegnev: 
vnegnev: .arch blast_fsm
vnegnev: .outfmt bin
vnegnev: 
vnegnev: ;; direct instruction defines
vnegnev: .define WT_TIM 	0x80
vnegnev: .define WT_TRIG 0x40
vnegnev: .define TMRADD 	0x20
vnegnev: .define WRDDS  	0x10
vnegnev: .define REGDEC 	0x08
vnegnev: .define DDSUPD 	0x04
vnegnev: .define RSTT   	0x02
vnegnev: .define FIN    	0x01
vnegnev: 
vnegnev: .define R0 0
vnegnev: .define R1 1
vnegnev: .define R2 2
vnegnev: .define R3 3
vnegnev: .define R4 4
vnegnev: .define R5 5
vnegnev: .define R6 6
vnegnev: .define R7 7
vnegnev: 
vnegnev: """
vnegnev: 
vnegnev: def end_asm(back_to_start):
vnegnev:     if back_to_start:
vnegnev:         return """
vnegnev: 
vnegnev:         dir (WT_TIM|DDSUPD) 0 0
vnegnev: SEQ_END: jump ((TRIGGER - SEQ_END)>2)
vnegnev: """
vnegnev:     else:
vnegnev:         return """
vnegnev:         dir (WT_TIM|DDSUPD|FIN) 0 0
vnegnev: """
vnegnev:     
vnegnev: def clr_dds_ph():
vnegnev:     return """
vnegnev:         dir (WRDDS|WT_TIM|TMRADD) 150 0
vnegnev: 
vnegnev:         ;; CFR 1 clear phase accumulator
vnegnev:         setr 0x000008 R0
vnegnev:         setcfr 0x00 0x00 0x0e R0
vnegnev:         dir (WRDDS|WT_TIM|DDSUPD|TMRADD) 150 0
vnegnev: 
vnegnev:         ;; CFR 1 unclear phase accumulator
vnegnev:         setr 0x000000 R0
vnegnev:         setcfr 0x00 0x00 0x0e R0
vnegnev:         dir (WRDDS|DDSUPD|WT_TIM|TMRADD) 150 0
vnegnev: 
vnegnev: """
vnegnev: 
vnegnev: def unclr_dds_ph():
vnegnev:         return """
vnegnev:         dir (WRDDS|WT_TIM|TMRADD) 150 0
vnegnev: 
vnegnev:         ;; CFR 1 clear phase accumulator
vnegnev:         setr 0x000008 R0
vnegnev:         setcfr 0x00 0x00 0x0e R0
vnegnev:         dir (WRDDS|WT_TIM|DDSUPD|TMRADD) 150 0
vnegnev: 
vnegnev:         ;; CFR 1 unclear phase accumulator
vnegnev:         setr 0x000000 R0
vnegnev:         setcfr 0x00 0x00 0x0e R0
vnegnev:         dir (WRDDS|DDSUPD|WT_TIM|TMRADD) 150 0
vnegnev: 
vnegnev: """
vnegnev:     
vnegnev: def taf_table(taf_vec,separator=' , '):
vnegnev:     """Obsolete
vnegnev:     
vnegnev:     Produce a table of integer times, freqs and amps as sent to DDS; one row for each point in the graph
vnegnev:     """
vnegnev:     
vnegnev:     tbl_str = "Time  ,  Amplitude  , Frequency\n"
vnegnev:     for d in taf_vec:
vnegnev:         tbl_str += str(d[0]) + separator + str(d[1]) + separator + str(d[2]) +'\n'
vnegnev: 
vnegnev:     return tbl_str
vnegnev: 
vnegnev: ## Mathematical
vnegnev: 
vnegnev: def gaussian(t, ampl, width):
vnegnev:     """Gaussian function
vnegnev:     
vnegnev:     t: time (centred on 0)
vnegnev:     ampl: scaling
vnegnev:     width: some kind of FWHM width (I think), maybe 2SD (TODO: find out later)
vnegnev:     """
vnegnev:     return ampl * m.exp(-4*m.log(2)*t**2/(width**2))
