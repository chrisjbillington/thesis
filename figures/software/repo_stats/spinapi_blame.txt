cbilling: #!/usr/bin/env python
cbilling: 
cbilling: # To upload a version to PyPI, run:
cbilling: #
cbilling: #    python setup.py sdist upload
cbilling: #
cbilling: # If the package is not registered with PyPI yet, do so with:
cbilling: #
cbilling: # python setup.py register
cbilling: 
cbilling: from distutils.core import setup
cbilling: import os
cbilling: import platform
cbilling: 
   Chris: VERSION = '3.2.0'
cbilling: 
cbilling: # Auto generate a __version__ package for the package to import
cbilling: with open(os.path.join('spinapi', '__version__.py'), 'w') as f:
cbilling:     f.write("__version__ = '%s'\n"%VERSION)
cbilling: 
cbilling: arch = platform.architecture()
cbilling: 
cbilling: if arch == ('32bit', 'ELF'):
cbilling:     bundled_shared_objects = ['libspinapi.so']
cbilling: elif arch == ('64bit', 'ELF'):
cbilling:     bundled_shared_objects = ['libspinapi64.so']
cbilling: else:
cbilling:     bundled_shared_objects = []
cbilling:     
cbilling: setup(name='spinapi',
cbilling:       version=VERSION,
cbilling:       description='Python wrapper around the Spincore PulseBlaster API using ctypes.',
cbilling:       author='Chris Billington',
cbilling:       author_email='chrisjbillington@gmail.com',
cbilling:       url='https://bitbucket.org/cbillington/spinapi/',
cbilling:       license="BSD",
cbilling:       packages=['spinapi'],
cbilling:       package_data={'spinapi': bundled_shared_objects}
cbilling:      )
   cbilling: try:
      Chris:     from .__version__ import __version__
   cbilling: except ImportError:
   cbilling:     # Version file has not been autogenerated from build process:
   cbilling:     __version__ = None
janwerkmann: 
janwerkmann: from .spinapi import *
   cbilling: #####################################################################
   cbilling: #                                                                   #
   cbilling: # spinapi.py                                                        #
   cbilling: #                                                                   #
   cbilling: # Copyright 2013, Christopher Billington, Philip Starkey            #
   cbilling: #                                                                   #
   cbilling: # This file is part of the spinapi project                          #
   cbilling: # (see https://bitbucket.org/cbillington/spinapi )                  #
   cbilling: # and is licensed under the Simplified BSD License.                 #
   cbilling: # See the LICENSE.txt file in the root of the project               #
   cbilling: # for the full license.                                             #
   cbilling: #                                                                   #
   cbilling: #####################################################################
   cbilling: 
   cbilling: import os
   cbilling: import sys
   cbilling: import platform
   cbilling: import ctypes
   cbilling: import time
      Chris: if sys.version_info[0] == 2:
janwerkmann:     str = unicode
   cbilling: 
   cbilling: # Whether or not to tell the spincore library to write debug logfiles.
   cbilling: # User can set to False before calling any spinapi functions to disable debugging.
   cbilling: debug = False
   cbilling: 
   cbilling: this_folder = os.path.abspath(os.path.realpath(os.path.dirname(__file__)))
   cbilling: def _checkloaded():
   cbilling:     global _spinapi
   cbilling:     try:    
   cbilling:         _spinapi
   cbilling:     except NameError:
   cbilling:         arch = platform.architecture()
   cbilling:         if arch == ('32bit', 'WindowsPE'):
   cbilling:             libname = 'spinapi.dll'
   cbilling:         elif arch == ('64bit', 'WindowsPE'):
   cbilling:             libname = 'spinapi64.dll'
       matt:         elif arch == ('32bit', 'ELF'):
   cbilling:             libname = os.path.join(this_folder, 'libspinapi.so')
       matt:         elif arch == ('64bit', 'ELF'):
   cbilling:             libname = os.path.join(this_folder, 'libspinapi64.so')
       matt: 
   cbilling:         _spinapi = ctypes.cdll.LoadLibrary(libname)
   cbilling:         # enable debugging if it's switched on by the module global:
   cbilling:         pb_set_debug(debug)
   cbilling: 
   cbilling: # Defines for different pb_instr instruction types
   cbilling: CONTINUE = 0
   cbilling: STOP = 1
   cbilling: LOOP = 2
   cbilling: END_LOOP = 3
   cbilling: JSR = 4
   cbilling: RTS = 5
   cbilling: BRANCH = 6
   cbilling: LONG_DELAY = 7
   cbilling: WAIT = 8
   cbilling: RTI = 9
   cbilling: 
   cbilling: # Defines for using different units of time
   cbilling: ns = 1.0
   cbilling: us = 1000.0
   cbilling: ms = 1000000.0
   cbilling: s  = 1000000000.0
   cbilling: 
   cbilling: # Defines for using different units of frequency
   cbilling: MHz = 1.0
   cbilling: kHz = .001
   cbilling: Hz = .000001
   cbilling: 
   cbilling: # Defines for start_programming
   cbilling: PULSE_PROGRAM  = 0
   cbilling: FREQ_REGS = 1
   cbilling: PHASE_REGS = 2
   cbilling: 
   cbilling: # Defines for enabling analog output
   cbilling: ANALOG_ON = 1
   cbilling: ANALOG_OFF = 0
   cbilling: 
   cbilling: # Defines for resetting the phase:
   cbilling: PHASE_RESET = 1
   cbilling: NO_PHASE_RESET = 0
   cbilling: 
   cbilling: def spinpts_get_version():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.spinpts_get_version.restype = ctypes.c_char_p
   cbilling:     return _spinapi.spinpts_get_version()
   cbilling: 
   cbilling: def pb_get_firmware_id():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_get_firmware_id.restype = ctypes.c_uint
   cbilling:     return _spinapi.pb_get_firmware_id()
   cbilling:     
   cbilling: def pb_set_debug(debug):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_set_debug.restype = ctypes.c_int
   cbilling:     return _spinapi.pb_set_debug(ctypes.c_int(debug))
   tbaldwin: 
   tbaldwin: def pb_get_version():
   tbaldwin:     _checkloaded()
   tbaldwin:     _spinapi.pb_get_version.restype = ctypes.c_char_p
   tbaldwin:     return _spinapi.pb_get_version()
   tbaldwin: 
   cbilling: def pb_get_error():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_get_error.restype = ctypes.c_char_p
   cbilling:     return _spinapi.pb_get_error()
   cbilling: 
   cbilling: def pb_status_message():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_status_message.restype = ctypes.c_char_p
   cbilling:     message = _spinapi.pb_status_message()
   cbilling:     return message
   cbilling:   
   cbilling: def pb_read_status():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_read_status.restype = ctypes.c_uint32
   cbilling:     status = _spinapi.pb_read_status()
   cbilling:     
   cbilling:     # convert to reversed binary string
   cbilling:     # convert to binary string, and remove 0b
   cbilling:     status = bin(status)[2:]
   cbilling:     # reverse string
   cbilling:     status = status[::-1]
   cbilling:     # pad to make sure we have enough bits!
   cbilling:     status = status + "0000"
   cbilling:     
   cbilling:     return {"stopped":bool(int(status[0])),"reset":bool(int(status[1])),"running":bool(int(status[2])), "waiting":bool(int(status[3]))}
   cbilling:   
   cbilling: def pb_count_boards():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_count_boards.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_count_boards()
   cbilling:     if result == -1: raise RuntimeError(pb_get_error())  
   cbilling:     return result
   cbilling: 
   cbilling: def pb_select_board(board_num):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_select_board.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_select_board(ctypes.c_int(board_num))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:                                
   cbilling: def pb_init():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_init.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_init()
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_core_clock(clock_freq):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_core_clock.restype = ctypes.c_void_p
   cbilling:     _spinapi.pb_core_clock(ctypes.c_double(clock_freq)) # returns void, so ignore return value.
   cbilling:                 
   cbilling: def pb_start_programming(device):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_start_programming.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_start_programming(ctypes.c_int(device))
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_select_dds(dds):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_select_dds.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_select_dds(ctypes.c_int(dds))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_set_phase(phase):
   cbilling:     _spinapi.pb_set_phase.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_set_phase(ctypes.c_double(phase))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling: 
   cbilling: def pb_set_freq(freq):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_set_freq.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_set_freq(ctypes.c_double(freq))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling: 
   cbilling: def pb_set_amp(amp, register):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_set_amp.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_set_amp(ctypes.c_float(amp),ctypes.c_int(register))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling: 
   cbilling: def pb_inst_pbonly(flags, inst, inst_data, length):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_inst_pbonly.restype = ctypes.c_int
janwerkmann:     if isinstance(flags, str) or isinstance(flags, bytes):
   cbilling:         flags = int(flags[::-1],2)
   cbilling:     result = _spinapi.pb_inst_pbonly(ctypes.c_uint32(flags), ctypes.c_int(inst),
   cbilling:                                      ctypes.c_int(inst_data),ctypes.c_double(length))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_inst_dds2(freq0,phase0,amp0,dds_en0,phase_reset0,
   cbilling:                  freq1,phase1,amp1,dds_en1,phase_reset1,
   cbilling:                  flags, inst, inst_data, length):
   cbilling:     """Gives a full instruction to the pulseblaster, with DDS included. The flags argument can be
   cbilling:        either an int representing the bitfield for the flag states, or a string of ones and zeros.
   cbilling:        Note that if passing in a string for the flag states, the first character represents flag 0.
   cbilling:        Eg.
   cbilling:        If it is a string: 
   cbilling:             flag: 0          12
   cbilling:                  '101100011111'
   cbilling:        
   cbilling:        If it is a binary number (or integer:
   cbilling:             flag:12          0
   cbilling:                 0b111110001101
   cbilling:                 3981    <---- integer representation
   cbilling:        """
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_inst_dds2.restype = ctypes.c_int
janwerkmann:     if isinstance(flags, str) or isinstance(flags, bytes):
   cbilling:         flags = int(flags[::-1],2)
   cbilling:     result = _spinapi.pb_inst_dds2(ctypes.c_int(freq0),ctypes.c_int(phase0),ctypes.c_int(amp0),
   cbilling:                                   ctypes.c_int(dds_en0),ctypes.c_int(phase_reset0),
   cbilling:                                   ctypes.c_int(freq1),ctypes.c_int(phase1),ctypes.c_int(amp1),
   cbilling:                                   ctypes.c_int(dds_en1),ctypes.c_int(phase_reset1),
   cbilling:                                   ctypes.c_int(flags),ctypes.c_int(inst),
   cbilling:                                   ctypes.c_int(inst_data),ctypes.c_double(length))
   cbilling:     if result < 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling: 
   cbilling: # More convenience functions:
   cbilling: def program_freq_regs(*freqs, **kwargs):
   cbilling:     call_stop_programming = kwargs.pop('call_stop_programming', True)
   cbilling:     pb_start_programming(FREQ_REGS)
   cbilling:     for freq in freqs:
   cbilling:         pb_set_freq(freq)
   cbilling:     if call_stop_programming:
   cbilling:         pb_stop_programming()
   cbilling:     if len(freqs) == 1:
   cbilling:         return 0
   cbilling:     else:
   cbilling:         return tuple(range(len(freqs)))
   cbilling: 
   cbilling: def program_phase_regs(*phases, **kwargs):
   cbilling:     call_stop_programming = kwargs.pop('call_stop_programming', True)
   cbilling:     pb_start_programming(PHASE_REGS)
   cbilling:     for phase in phases:
   cbilling:         pb_set_phase(phase)
   cbilling:     if call_stop_programming:
   cbilling:         pb_stop_programming()
   cbilling:     if len(phases) == 1:
   cbilling:         return 0
   cbilling:     else:
   cbilling:         return tuple(range(len(phases)))
   cbilling: 
   cbilling: def program_amp_regs(*amps):
   cbilling:     for i, amp in enumerate(amps):
   cbilling:         pb_set_amp(amp,i)
   cbilling:     if len(amps) == 1:
   cbilling:         return 0
   cbilling:     else:
   cbilling:         return tuple(range(len(amps)))
   cbilling: 
   cbilling: def pb_stop_programming():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_stop_programming.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_stop_programming()
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_start():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_start.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_start()
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_stop():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_stop.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_stop()
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:             
   cbilling: def pb_close():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_close.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_close()
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_reset():
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_reset.restype = ctypes.c_int
   cbilling:     result = _spinapi.pb_reset()
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling:     
   cbilling: def pb_write_default_flag(flags):
   cbilling:     _checkloaded()
   cbilling:     _spinapi.pb_write_register.restype = ctypes.c_int
janwerkmann:     if isinstance(flags, str) or isinstance(flags, bytes):
   cbilling:         flags = int(flags[::-1],2)
   cbilling:     result = _spinapi.pb_write_register(ctypes.c_int(0x40000+0x08), ctypes.c_int(flags))
   cbilling:     if result != 0: raise RuntimeError(pb_get_error())
   cbilling:     return result
   cbilling: 
